pub const __builtin_bswap16 = @import("std").zig.c_builtins.__builtin_bswap16;
pub const __builtin_bswap32 = @import("std").zig.c_builtins.__builtin_bswap32;
pub const __builtin_bswap64 = @import("std").zig.c_builtins.__builtin_bswap64;
pub const __builtin_signbit = @import("std").zig.c_builtins.__builtin_signbit;
pub const __builtin_signbitf = @import("std").zig.c_builtins.__builtin_signbitf;
pub const __builtin_popcount = @import("std").zig.c_builtins.__builtin_popcount;
pub const __builtin_ctz = @import("std").zig.c_builtins.__builtin_ctz;
pub const __builtin_clz = @import("std").zig.c_builtins.__builtin_clz;
pub const __builtin_sqrt = @import("std").zig.c_builtins.__builtin_sqrt;
pub const __builtin_sqrtf = @import("std").zig.c_builtins.__builtin_sqrtf;
pub const __builtin_sin = @import("std").zig.c_builtins.__builtin_sin;
pub const __builtin_sinf = @import("std").zig.c_builtins.__builtin_sinf;
pub const __builtin_cos = @import("std").zig.c_builtins.__builtin_cos;
pub const __builtin_cosf = @import("std").zig.c_builtins.__builtin_cosf;
pub const __builtin_exp = @import("std").zig.c_builtins.__builtin_exp;
pub const __builtin_expf = @import("std").zig.c_builtins.__builtin_expf;
pub const __builtin_exp2 = @import("std").zig.c_builtins.__builtin_exp2;
pub const __builtin_exp2f = @import("std").zig.c_builtins.__builtin_exp2f;
pub const __builtin_log = @import("std").zig.c_builtins.__builtin_log;
pub const __builtin_logf = @import("std").zig.c_builtins.__builtin_logf;
pub const __builtin_log2 = @import("std").zig.c_builtins.__builtin_log2;
pub const __builtin_log2f = @import("std").zig.c_builtins.__builtin_log2f;
pub const __builtin_log10 = @import("std").zig.c_builtins.__builtin_log10;
pub const __builtin_log10f = @import("std").zig.c_builtins.__builtin_log10f;
pub const __builtin_abs = @import("std").zig.c_builtins.__builtin_abs;
pub const __builtin_labs = @import("std").zig.c_builtins.__builtin_labs;
pub const __builtin_llabs = @import("std").zig.c_builtins.__builtin_llabs;
pub const __builtin_fabs = @import("std").zig.c_builtins.__builtin_fabs;
pub const __builtin_fabsf = @import("std").zig.c_builtins.__builtin_fabsf;
pub const __builtin_floor = @import("std").zig.c_builtins.__builtin_floor;
pub const __builtin_floorf = @import("std").zig.c_builtins.__builtin_floorf;
pub const __builtin_ceil = @import("std").zig.c_builtins.__builtin_ceil;
pub const __builtin_ceilf = @import("std").zig.c_builtins.__builtin_ceilf;
pub const __builtin_trunc = @import("std").zig.c_builtins.__builtin_trunc;
pub const __builtin_truncf = @import("std").zig.c_builtins.__builtin_truncf;
pub const __builtin_round = @import("std").zig.c_builtins.__builtin_round;
pub const __builtin_roundf = @import("std").zig.c_builtins.__builtin_roundf;
pub const __builtin_strlen = @import("std").zig.c_builtins.__builtin_strlen;
pub const __builtin_strcmp = @import("std").zig.c_builtins.__builtin_strcmp;
pub const __builtin_object_size = @import("std").zig.c_builtins.__builtin_object_size;
pub const __builtin___memset_chk = @import("std").zig.c_builtins.__builtin___memset_chk;
pub const __builtin_memset = @import("std").zig.c_builtins.__builtin_memset;
pub const __builtin___memcpy_chk = @import("std").zig.c_builtins.__builtin___memcpy_chk;
pub const __builtin_memcpy = @import("std").zig.c_builtins.__builtin_memcpy;
pub const __builtin_expect = @import("std").zig.c_builtins.__builtin_expect;
pub const __builtin_nanf = @import("std").zig.c_builtins.__builtin_nanf;
pub const __builtin_huge_valf = @import("std").zig.c_builtins.__builtin_huge_valf;
pub const __builtin_inff = @import("std").zig.c_builtins.__builtin_inff;
pub const __builtin_isnan = @import("std").zig.c_builtins.__builtin_isnan;
pub const __builtin_isinf = @import("std").zig.c_builtins.__builtin_isinf;
pub const __builtin_isinf_sign = @import("std").zig.c_builtins.__builtin_isinf_sign;
pub const __has_builtin = @import("std").zig.c_builtins.__has_builtin;
pub const __builtin_assume = @import("std").zig.c_builtins.__builtin_assume;
pub const __builtin_unreachable = @import("std").zig.c_builtins.__builtin_unreachable;
pub const __builtin_constant_p = @import("std").zig.c_builtins.__builtin_constant_p;
pub const __builtin_mul_overflow = @import("std").zig.c_builtins.__builtin_mul_overflow;
pub const wchar_t = c_int;
pub const _Float32 = f32;
pub const _Float64 = f64;
pub const _Float32x = f64;
pub const _Float64x = c_longdouble;
pub const div_t = extern struct {
    quot: c_int = @import("std").mem.zeroes(c_int),
    rem: c_int = @import("std").mem.zeroes(c_int),
};
pub const ldiv_t = extern struct {
    quot: c_long = @import("std").mem.zeroes(c_long),
    rem: c_long = @import("std").mem.zeroes(c_long),
};
pub const lldiv_t = extern struct {
    quot: c_longlong = @import("std").mem.zeroes(c_longlong),
    rem: c_longlong = @import("std").mem.zeroes(c_longlong),
};
pub extern fn __ctype_get_mb_cur_max() usize;
pub extern fn atof(__nptr: [*c]const u8) f64;
pub extern fn atoi(__nptr: [*c]const u8) c_int;
pub extern fn atol(__nptr: [*c]const u8) c_long;
pub extern fn atoll(__nptr: [*c]const u8) c_longlong;
pub extern fn strtod(__nptr: [*c]const u8, __endptr: [*c][*c]u8) f64;
pub extern fn strtof(__nptr: [*c]const u8, __endptr: [*c][*c]u8) f32;
pub extern fn strtold(__nptr: [*c]const u8, __endptr: [*c][*c]u8) c_longdouble;
pub extern fn strtol(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_long;
pub extern fn strtoul(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_ulong;
pub extern fn strtoq(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int) c_longlong;
pub extern fn strtouq(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int) c_ulonglong;
pub extern fn strtoll(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_longlong;
pub extern fn strtoull(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_ulonglong;
pub extern fn l64a(__n: c_long) [*c]u8;
pub extern fn a64l(__s: [*c]const u8) c_long;
pub const __u_char = u8;
pub const __u_short = c_ushort;
pub const __u_int = c_uint;
pub const __u_long = c_ulong;
pub const __int8_t = i8;
pub const __uint8_t = u8;
pub const __int16_t = c_short;
pub const __uint16_t = c_ushort;
pub const __int32_t = c_int;
pub const __uint32_t = c_uint;
pub const __int64_t = c_long;
pub const __uint64_t = c_ulong;
pub const __int_least8_t = __int8_t;
pub const __uint_least8_t = __uint8_t;
pub const __int_least16_t = __int16_t;
pub const __uint_least16_t = __uint16_t;
pub const __int_least32_t = __int32_t;
pub const __uint_least32_t = __uint32_t;
pub const __int_least64_t = __int64_t;
pub const __uint_least64_t = __uint64_t;
pub const __quad_t = c_long;
pub const __u_quad_t = c_ulong;
pub const __intmax_t = c_long;
pub const __uintmax_t = c_ulong;
pub const __dev_t = c_ulong;
pub const __uid_t = c_uint;
pub const __gid_t = c_uint;
pub const __ino_t = c_ulong;
pub const __ino64_t = c_ulong;
pub const __mode_t = c_uint;
pub const __nlink_t = c_ulong;
pub const __off_t = c_long;
pub const __off64_t = c_long;
pub const __pid_t = c_int;
pub const __fsid_t = extern struct {
    __val: [2]c_int = @import("std").mem.zeroes([2]c_int),
};
pub const __clock_t = c_long;
pub const __rlim_t = c_ulong;
pub const __rlim64_t = c_ulong;
pub const __id_t = c_uint;
pub const __time_t = c_long;
pub const __useconds_t = c_uint;
pub const __suseconds_t = c_long;
pub const __suseconds64_t = c_long;
pub const __daddr_t = c_int;
pub const __key_t = c_int;
pub const __clockid_t = c_int;
pub const __timer_t = ?*anyopaque;
pub const __blksize_t = c_long;
pub const __blkcnt_t = c_long;
pub const __blkcnt64_t = c_long;
pub const __fsblkcnt_t = c_ulong;
pub const __fsblkcnt64_t = c_ulong;
pub const __fsfilcnt_t = c_ulong;
pub const __fsfilcnt64_t = c_ulong;
pub const __fsword_t = c_long;
pub const __ssize_t = c_long;
pub const __syscall_slong_t = c_long;
pub const __syscall_ulong_t = c_ulong;
pub const __loff_t = __off64_t;
pub const __caddr_t = [*c]u8;
pub const __intptr_t = c_long;
pub const __socklen_t = c_uint;
pub const __sig_atomic_t = c_int;
pub const u_char = __u_char;
pub const u_short = __u_short;
pub const u_int = __u_int;
pub const u_long = __u_long;
pub const quad_t = __quad_t;
pub const u_quad_t = __u_quad_t;
pub const fsid_t = __fsid_t;
pub const loff_t = __loff_t;
pub const ino_t = __ino_t;
pub const dev_t = __dev_t;
pub const gid_t = __gid_t;
pub const mode_t = __mode_t;
pub const nlink_t = __nlink_t;
pub const uid_t = __uid_t;
pub const off_t = __off_t;
pub const pid_t = __pid_t;
pub const id_t = __id_t;
pub const daddr_t = __daddr_t;
pub const caddr_t = __caddr_t;
pub const key_t = __key_t;
pub const clock_t = __clock_t;
pub const clockid_t = __clockid_t;
pub const time_t = __time_t;
pub const timer_t = __timer_t;
pub const ulong = c_ulong;
pub const ushort = c_ushort;
pub const uint = c_uint;
pub const u_int8_t = __uint8_t;
pub const u_int16_t = __uint16_t;
pub const u_int32_t = __uint32_t;
pub const u_int64_t = __uint64_t;
pub const register_t = c_long;
pub fn __bswap_16(arg___bsx: __uint16_t) callconv(.c) __uint16_t {
    var __bsx = arg___bsx;
    _ = &__bsx;
    return @as(__uint16_t, @bitCast(@as(c_short, @truncate(((@as(c_int, @bitCast(@as(c_uint, __bsx))) >> @intCast(8)) & @as(c_int, 255)) | ((@as(c_int, @bitCast(@as(c_uint, __bsx))) & @as(c_int, 255)) << @intCast(8))))));
}
pub fn __bswap_32(arg___bsx: __uint32_t) callconv(.c) __uint32_t {
    var __bsx = arg___bsx;
    _ = &__bsx;
    return ((((__bsx & @as(c_uint, 4278190080)) >> @intCast(24)) | ((__bsx & @as(c_uint, 16711680)) >> @intCast(8))) | ((__bsx & @as(c_uint, 65280)) << @intCast(8))) | ((__bsx & @as(c_uint, 255)) << @intCast(24));
}
pub fn __bswap_64(arg___bsx: __uint64_t) callconv(.c) __uint64_t {
    var __bsx = arg___bsx;
    _ = &__bsx;
    return @as(__uint64_t, @bitCast(@as(c_ulong, @truncate(((((((((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 18374686479671623680)) >> @intCast(56)) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 71776119061217280)) >> @intCast(40))) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 280375465082880)) >> @intCast(24))) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 1095216660480)) >> @intCast(8))) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 4278190080)) << @intCast(8))) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 16711680)) << @intCast(24))) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 65280)) << @intCast(40))) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 255)) << @intCast(56))))));
}
pub fn __uint16_identity(arg___x: __uint16_t) callconv(.c) __uint16_t {
    var __x = arg___x;
    _ = &__x;
    return __x;
}
pub fn __uint32_identity(arg___x: __uint32_t) callconv(.c) __uint32_t {
    var __x = arg___x;
    _ = &__x;
    return __x;
}
pub fn __uint64_identity(arg___x: __uint64_t) callconv(.c) __uint64_t {
    var __x = arg___x;
    _ = &__x;
    return __x;
}
pub const __sigset_t = extern struct {
    __val: [16]c_ulong = @import("std").mem.zeroes([16]c_ulong),
};
pub const sigset_t = __sigset_t;
pub const struct_timeval = extern struct {
    tv_sec: __time_t = @import("std").mem.zeroes(__time_t),
    tv_usec: __suseconds_t = @import("std").mem.zeroes(__suseconds_t),
};
pub const struct_timespec = extern struct {
    tv_sec: __time_t = @import("std").mem.zeroes(__time_t),
    tv_nsec: __syscall_slong_t = @import("std").mem.zeroes(__syscall_slong_t),
};
pub const suseconds_t = __suseconds_t;
pub const __fd_mask = c_long;
pub const fd_set = extern struct {
    __fds_bits: [16]__fd_mask = @import("std").mem.zeroes([16]__fd_mask),
};
pub const fd_mask = __fd_mask;
pub extern fn select(__nfds: c_int, noalias __readfds: [*c]fd_set, noalias __writefds: [*c]fd_set, noalias __exceptfds: [*c]fd_set, noalias __timeout: [*c]struct_timeval) c_int;
pub extern fn pselect(__nfds: c_int, noalias __readfds: [*c]fd_set, noalias __writefds: [*c]fd_set, noalias __exceptfds: [*c]fd_set, noalias __timeout: [*c]const struct_timespec, noalias __sigmask: [*c]const __sigset_t) c_int;
pub const blksize_t = __blksize_t;
pub const blkcnt_t = __blkcnt_t;
pub const fsblkcnt_t = __fsblkcnt_t;
pub const fsfilcnt_t = __fsfilcnt_t;
const struct_unnamed_1 = extern struct {
    __low: c_uint = @import("std").mem.zeroes(c_uint),
    __high: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const __atomic_wide_counter = extern union {
    __value64: c_ulonglong,
    __value32: struct_unnamed_1,
};
pub const struct___pthread_internal_list = extern struct {
    __prev: [*c]struct___pthread_internal_list = @import("std").mem.zeroes([*c]struct___pthread_internal_list),
    __next: [*c]struct___pthread_internal_list = @import("std").mem.zeroes([*c]struct___pthread_internal_list),
};
pub const __pthread_list_t = struct___pthread_internal_list;
pub const struct___pthread_internal_slist = extern struct {
    __next: [*c]struct___pthread_internal_slist = @import("std").mem.zeroes([*c]struct___pthread_internal_slist),
};
pub const __pthread_slist_t = struct___pthread_internal_slist;
pub const struct___pthread_mutex_s = extern struct {
    __lock: c_int = @import("std").mem.zeroes(c_int),
    __count: c_uint = @import("std").mem.zeroes(c_uint),
    __owner: c_int = @import("std").mem.zeroes(c_int),
    __nusers: c_uint = @import("std").mem.zeroes(c_uint),
    __kind: c_int = @import("std").mem.zeroes(c_int),
    __spins: c_short = @import("std").mem.zeroes(c_short),
    __elision: c_short = @import("std").mem.zeroes(c_short),
    __list: __pthread_list_t = @import("std").mem.zeroes(__pthread_list_t),
};
pub const struct___pthread_rwlock_arch_t = extern struct {
    __readers: c_uint = @import("std").mem.zeroes(c_uint),
    __writers: c_uint = @import("std").mem.zeroes(c_uint),
    __wrphase_futex: c_uint = @import("std").mem.zeroes(c_uint),
    __writers_futex: c_uint = @import("std").mem.zeroes(c_uint),
    __pad3: c_uint = @import("std").mem.zeroes(c_uint),
    __pad4: c_uint = @import("std").mem.zeroes(c_uint),
    __cur_writer: c_int = @import("std").mem.zeroes(c_int),
    __shared: c_int = @import("std").mem.zeroes(c_int),
    __rwelision: i8 = @import("std").mem.zeroes(i8),
    __pad1: [7]u8 = @import("std").mem.zeroes([7]u8),
    __pad2: c_ulong = @import("std").mem.zeroes(c_ulong),
    __flags: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const struct___pthread_cond_s = extern struct {
    __wseq: __atomic_wide_counter = @import("std").mem.zeroes(__atomic_wide_counter),
    __g1_start: __atomic_wide_counter = @import("std").mem.zeroes(__atomic_wide_counter),
    __g_refs: [2]c_uint = @import("std").mem.zeroes([2]c_uint),
    __g_size: [2]c_uint = @import("std").mem.zeroes([2]c_uint),
    __g1_orig_size: c_uint = @import("std").mem.zeroes(c_uint),
    __wrefs: c_uint = @import("std").mem.zeroes(c_uint),
    __g_signals: [2]c_uint = @import("std").mem.zeroes([2]c_uint),
};
pub const __tss_t = c_uint;
pub const __thrd_t = c_ulong;
pub const __once_flag = extern struct {
    __data: c_int = @import("std").mem.zeroes(c_int),
};
pub const pthread_t = c_ulong;
pub const pthread_mutexattr_t = extern union {
    __size: [4]u8,
    __align: c_int,
};
pub const pthread_condattr_t = extern union {
    __size: [4]u8,
    __align: c_int,
};
pub const pthread_key_t = c_uint;
pub const pthread_once_t = c_int;
pub const union_pthread_attr_t = extern union {
    __size: [56]u8,
    __align: c_long,
};
pub const pthread_attr_t = union_pthread_attr_t;
pub const pthread_mutex_t = extern union {
    __data: struct___pthread_mutex_s,
    __size: [40]u8,
    __align: c_long,
};
pub const pthread_cond_t = extern union {
    __data: struct___pthread_cond_s,
    __size: [48]u8,
    __align: c_longlong,
};
pub const pthread_rwlock_t = extern union {
    __data: struct___pthread_rwlock_arch_t,
    __size: [56]u8,
    __align: c_long,
};
pub const pthread_rwlockattr_t = extern union {
    __size: [8]u8,
    __align: c_long,
};
pub const pthread_spinlock_t = c_int;
pub const pthread_barrier_t = extern union {
    __size: [32]u8,
    __align: c_long,
};
pub const pthread_barrierattr_t = extern union {
    __size: [4]u8,
    __align: c_int,
};
pub extern fn random() c_long;
pub extern fn srandom(__seed: c_uint) void;
pub extern fn initstate(__seed: c_uint, __statebuf: [*c]u8, __statelen: usize) [*c]u8;
pub extern fn setstate(__statebuf: [*c]u8) [*c]u8;
pub const struct_random_data = extern struct {
    fptr: [*c]i32 = @import("std").mem.zeroes([*c]i32),
    rptr: [*c]i32 = @import("std").mem.zeroes([*c]i32),
    state: [*c]i32 = @import("std").mem.zeroes([*c]i32),
    rand_type: c_int = @import("std").mem.zeroes(c_int),
    rand_deg: c_int = @import("std").mem.zeroes(c_int),
    rand_sep: c_int = @import("std").mem.zeroes(c_int),
    end_ptr: [*c]i32 = @import("std").mem.zeroes([*c]i32),
};
pub extern fn random_r(noalias __buf: [*c]struct_random_data, noalias __result: [*c]i32) c_int;
pub extern fn srandom_r(__seed: c_uint, __buf: [*c]struct_random_data) c_int;
pub extern fn initstate_r(__seed: c_uint, noalias __statebuf: [*c]u8, __statelen: usize, noalias __buf: [*c]struct_random_data) c_int;
pub extern fn setstate_r(noalias __statebuf: [*c]u8, noalias __buf: [*c]struct_random_data) c_int;
pub extern fn rand() c_int;
pub extern fn srand(__seed: c_uint) void;
pub extern fn rand_r(__seed: [*c]c_uint) c_int;
pub extern fn drand48() f64;
pub extern fn erand48(__xsubi: [*c]c_ushort) f64;
pub extern fn lrand48() c_long;
pub extern fn nrand48(__xsubi: [*c]c_ushort) c_long;
pub extern fn mrand48() c_long;
pub extern fn jrand48(__xsubi: [*c]c_ushort) c_long;
pub extern fn srand48(__seedval: c_long) void;
pub extern fn seed48(__seed16v: [*c]c_ushort) [*c]c_ushort;
pub extern fn lcong48(__param: [*c]c_ushort) void;
pub const struct_drand48_data = extern struct {
    __x: [3]c_ushort = @import("std").mem.zeroes([3]c_ushort),
    __old_x: [3]c_ushort = @import("std").mem.zeroes([3]c_ushort),
    __c: c_ushort = @import("std").mem.zeroes(c_ushort),
    __init: c_ushort = @import("std").mem.zeroes(c_ushort),
    __a: c_ulonglong = @import("std").mem.zeroes(c_ulonglong),
};
pub extern fn drand48_r(noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]f64) c_int;
pub extern fn erand48_r(__xsubi: [*c]c_ushort, noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]f64) c_int;
pub extern fn lrand48_r(noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn nrand48_r(__xsubi: [*c]c_ushort, noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn mrand48_r(noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn jrand48_r(__xsubi: [*c]c_ushort, noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn srand48_r(__seedval: c_long, __buffer: [*c]struct_drand48_data) c_int;
pub extern fn seed48_r(__seed16v: [*c]c_ushort, __buffer: [*c]struct_drand48_data) c_int;
pub extern fn lcong48_r(__param: [*c]c_ushort, __buffer: [*c]struct_drand48_data) c_int;
pub extern fn arc4random() __uint32_t;
pub extern fn arc4random_buf(__buf: ?*anyopaque, __size: usize) void;
pub extern fn arc4random_uniform(__upper_bound: __uint32_t) __uint32_t;
pub extern fn malloc(__size: c_ulong) ?*anyopaque;
pub extern fn calloc(__nmemb: c_ulong, __size: c_ulong) ?*anyopaque;
pub extern fn realloc(__ptr: ?*anyopaque, __size: c_ulong) ?*anyopaque;
pub extern fn free(__ptr: ?*anyopaque) void;
pub extern fn reallocarray(__ptr: ?*anyopaque, __nmemb: usize, __size: usize) ?*anyopaque;
pub extern fn alloca(__size: c_ulong) ?*anyopaque;
pub extern fn valloc(__size: usize) ?*anyopaque;
pub extern fn posix_memalign(__memptr: [*c]?*anyopaque, __alignment: usize, __size: usize) c_int;
pub extern fn aligned_alloc(__alignment: c_ulong, __size: c_ulong) ?*anyopaque;
pub extern fn abort() noreturn;
pub extern fn atexit(__func: ?*const fn () callconv(.c) void) c_int;
pub extern fn at_quick_exit(__func: ?*const fn () callconv(.c) void) c_int;
pub extern fn on_exit(__func: ?*const fn (c_int, ?*anyopaque) callconv(.c) void, __arg: ?*anyopaque) c_int;
pub extern fn exit(__status: c_int) noreturn;
pub extern fn quick_exit(__status: c_int) noreturn;
pub extern fn _Exit(__status: c_int) noreturn;
pub extern fn getenv(__name: [*c]const u8) [*c]u8;
pub extern fn putenv(__string: [*c]u8) c_int;
pub extern fn setenv(__name: [*c]const u8, __value: [*c]const u8, __replace: c_int) c_int;
pub extern fn unsetenv(__name: [*c]const u8) c_int;
pub extern fn clearenv() c_int;
pub extern fn mktemp(__template: [*c]u8) [*c]u8;
pub extern fn mkstemp(__template: [*c]u8) c_int;
pub extern fn mkstemps(__template: [*c]u8, __suffixlen: c_int) c_int;
pub extern fn mkdtemp(__template: [*c]u8) [*c]u8;
pub extern fn system(__command: [*c]const u8) c_int;
pub extern fn realpath(noalias __name: [*c]const u8, noalias __resolved: [*c]u8) [*c]u8;
pub const __compar_fn_t = ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.c) c_int;
pub extern fn bsearch(__key: ?*const anyopaque, __base: ?*const anyopaque, __nmemb: usize, __size: usize, __compar: __compar_fn_t) ?*anyopaque;
pub extern fn qsort(__base: ?*anyopaque, __nmemb: usize, __size: usize, __compar: __compar_fn_t) void;
pub extern fn abs(__x: c_int) c_int;
pub extern fn labs(__x: c_long) c_long;
pub extern fn llabs(__x: c_longlong) c_longlong;
pub extern fn div(__numer: c_int, __denom: c_int) div_t;
pub extern fn ldiv(__numer: c_long, __denom: c_long) ldiv_t;
pub extern fn lldiv(__numer: c_longlong, __denom: c_longlong) lldiv_t;
pub extern fn ecvt(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn fcvt(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn gcvt(__value: f64, __ndigit: c_int, __buf: [*c]u8) [*c]u8;
pub extern fn qecvt(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn qfcvt(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn qgcvt(__value: c_longdouble, __ndigit: c_int, __buf: [*c]u8) [*c]u8;
pub extern fn ecvt_r(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn fcvt_r(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn qecvt_r(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn qfcvt_r(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn mblen(__s: [*c]const u8, __n: usize) c_int;
pub extern fn mbtowc(noalias __pwc: [*c]wchar_t, noalias __s: [*c]const u8, __n: usize) c_int;
pub extern fn wctomb(__s: [*c]u8, __wchar: wchar_t) c_int;
pub extern fn mbstowcs(noalias __pwcs: [*c]wchar_t, noalias __s: [*c]const u8, __n: usize) usize;
pub extern fn wcstombs(noalias __s: [*c]u8, noalias __pwcs: [*c]const wchar_t, __n: usize) usize;
pub extern fn rpmatch(__response: [*c]const u8) c_int;
pub extern fn getsubopt(noalias __optionp: [*c][*c]u8, noalias __tokens: [*c]const [*c]u8, noalias __valuep: [*c][*c]u8) c_int;
pub extern fn getloadavg(__loadavg: [*c]f64, __nelem: c_int) c_int;
pub const struct___va_list_tag_2 = extern struct {
    gp_offset: c_uint = @import("std").mem.zeroes(c_uint),
    fp_offset: c_uint = @import("std").mem.zeroes(c_uint),
    overflow_arg_area: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    reg_save_area: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const __builtin_va_list = [1]struct___va_list_tag_2;
pub const __gnuc_va_list = __builtin_va_list;
const union_unnamed_3 = extern union {
    __wch: c_uint,
    __wchb: [4]u8,
};
pub const __mbstate_t = extern struct {
    __count: c_int = @import("std").mem.zeroes(c_int),
    __value: union_unnamed_3 = @import("std").mem.zeroes(union_unnamed_3),
};
pub const struct__G_fpos_t = extern struct {
    __pos: __off_t = @import("std").mem.zeroes(__off_t),
    __state: __mbstate_t = @import("std").mem.zeroes(__mbstate_t),
};
pub const __fpos_t = struct__G_fpos_t;
pub const struct__G_fpos64_t = extern struct {
    __pos: __off64_t = @import("std").mem.zeroes(__off64_t),
    __state: __mbstate_t = @import("std").mem.zeroes(__mbstate_t),
};
pub const __fpos64_t = struct__G_fpos64_t;
pub const struct__IO_marker = opaque {};
pub const _IO_lock_t = anyopaque;
pub const struct__IO_codecvt = opaque {};
pub const struct__IO_wide_data = opaque {};
pub const struct__IO_FILE = extern struct {
    _flags: c_int = @import("std").mem.zeroes(c_int),
    _IO_read_ptr: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_read_end: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_read_base: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_write_base: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_write_ptr: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_write_end: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_buf_base: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_buf_end: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_save_base: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_backup_base: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_save_end: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _markers: ?*struct__IO_marker = @import("std").mem.zeroes(?*struct__IO_marker),
    _chain: [*c]struct__IO_FILE = @import("std").mem.zeroes([*c]struct__IO_FILE),
    _fileno: c_int = @import("std").mem.zeroes(c_int),
    _flags2: c_int = @import("std").mem.zeroes(c_int),
    _old_offset: __off_t = @import("std").mem.zeroes(__off_t),
    _cur_column: c_ushort = @import("std").mem.zeroes(c_ushort),
    _vtable_offset: i8 = @import("std").mem.zeroes(i8),
    _shortbuf: [1]u8 = @import("std").mem.zeroes([1]u8),
    _lock: ?*_IO_lock_t = @import("std").mem.zeroes(?*_IO_lock_t),
    _offset: __off64_t = @import("std").mem.zeroes(__off64_t),
    _codecvt: ?*struct__IO_codecvt = @import("std").mem.zeroes(?*struct__IO_codecvt),
    _wide_data: ?*struct__IO_wide_data = @import("std").mem.zeroes(?*struct__IO_wide_data),
    _freeres_list: [*c]struct__IO_FILE = @import("std").mem.zeroes([*c]struct__IO_FILE),
    _freeres_buf: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    __pad5: usize = @import("std").mem.zeroes(usize),
    _mode: c_int = @import("std").mem.zeroes(c_int),
    _unused2: [20]u8 = @import("std").mem.zeroes([20]u8),
};
pub const __FILE = struct__IO_FILE;
pub const FILE = struct__IO_FILE;
pub const cookie_read_function_t = fn (?*anyopaque, [*c]u8, usize) callconv(.c) __ssize_t;
pub const cookie_write_function_t = fn (?*anyopaque, [*c]const u8, usize) callconv(.c) __ssize_t;
pub const cookie_seek_function_t = fn (?*anyopaque, [*c]__off64_t, c_int) callconv(.c) c_int;
pub const cookie_close_function_t = fn (?*anyopaque) callconv(.c) c_int;
pub const struct__IO_cookie_io_functions_t = extern struct {
    read: ?*const cookie_read_function_t = @import("std").mem.zeroes(?*const cookie_read_function_t),
    write: ?*const cookie_write_function_t = @import("std").mem.zeroes(?*const cookie_write_function_t),
    seek: ?*const cookie_seek_function_t = @import("std").mem.zeroes(?*const cookie_seek_function_t),
    close: ?*const cookie_close_function_t = @import("std").mem.zeroes(?*const cookie_close_function_t),
};
pub const cookie_io_functions_t = struct__IO_cookie_io_functions_t;
pub const va_list = __gnuc_va_list;
pub const fpos_t = __fpos_t;
pub extern var stdin: [*c]FILE;
pub extern var stdout: [*c]FILE;
pub extern var stderr: [*c]FILE;
pub extern fn remove(__filename: [*c]const u8) c_int;
pub extern fn rename(__old: [*c]const u8, __new: [*c]const u8) c_int;
pub extern fn renameat(__oldfd: c_int, __old: [*c]const u8, __newfd: c_int, __new: [*c]const u8) c_int;
pub extern fn fclose(__stream: [*c]FILE) c_int;
pub extern fn tmpfile() [*c]FILE;
pub extern fn tmpnam([*c]u8) [*c]u8;
pub extern fn tmpnam_r(__s: [*c]u8) [*c]u8;
pub extern fn tempnam(__dir: [*c]const u8, __pfx: [*c]const u8) [*c]u8;
pub extern fn fflush(__stream: [*c]FILE) c_int;
pub extern fn fflush_unlocked(__stream: [*c]FILE) c_int;
pub extern fn fopen(__filename: [*c]const u8, __modes: [*c]const u8) [*c]FILE;
pub extern fn freopen(noalias __filename: [*c]const u8, noalias __modes: [*c]const u8, noalias __stream: [*c]FILE) [*c]FILE;
pub extern fn fdopen(__fd: c_int, __modes: [*c]const u8) [*c]FILE;
pub extern fn fopencookie(noalias __magic_cookie: ?*anyopaque, noalias __modes: [*c]const u8, __io_funcs: cookie_io_functions_t) [*c]FILE;
pub extern fn fmemopen(__s: ?*anyopaque, __len: usize, __modes: [*c]const u8) [*c]FILE;
pub extern fn open_memstream(__bufloc: [*c][*c]u8, __sizeloc: [*c]usize) [*c]FILE;
pub extern fn setbuf(noalias __stream: [*c]FILE, noalias __buf: [*c]u8) void;
pub extern fn setvbuf(noalias __stream: [*c]FILE, noalias __buf: [*c]u8, __modes: c_int, __n: usize) c_int;
pub extern fn setbuffer(noalias __stream: [*c]FILE, noalias __buf: [*c]u8, __size: usize) void;
pub extern fn setlinebuf(__stream: [*c]FILE) void;
pub extern fn fprintf(noalias __stream: [*c]FILE, noalias __format: [*c]const u8, ...) c_int;
pub extern fn printf(__format: [*c]const u8, ...) c_int;
pub extern fn sprintf(noalias __s: [*c]u8, noalias __format: [*c]const u8, ...) c_int;
pub extern fn vfprintf(noalias __s: [*c]FILE, noalias __format: [*c]const u8, __arg: [*c]struct___va_list_tag_2) c_int;
pub extern fn vprintf(noalias __format: [*c]const u8, __arg: [*c]struct___va_list_tag_2) c_int;
pub extern fn vsprintf(noalias __s: [*c]u8, noalias __format: [*c]const u8, __arg: [*c]struct___va_list_tag_2) c_int;
pub extern fn snprintf(noalias __s: [*c]u8, __maxlen: c_ulong, noalias __format: [*c]const u8, ...) c_int;
pub extern fn vsnprintf(noalias __s: [*c]u8, __maxlen: c_ulong, noalias __format: [*c]const u8, __arg: [*c]struct___va_list_tag_2) c_int;
pub extern fn vasprintf(noalias __ptr: [*c][*c]u8, noalias __f: [*c]const u8, __arg: [*c]struct___va_list_tag_2) c_int;
pub extern fn __asprintf(noalias __ptr: [*c][*c]u8, noalias __fmt: [*c]const u8, ...) c_int;
pub extern fn asprintf(noalias __ptr: [*c][*c]u8, noalias __fmt: [*c]const u8, ...) c_int;
pub extern fn vdprintf(__fd: c_int, noalias __fmt: [*c]const u8, __arg: [*c]struct___va_list_tag_2) c_int;
pub extern fn dprintf(__fd: c_int, noalias __fmt: [*c]const u8, ...) c_int;
pub extern fn fscanf(noalias __stream: [*c]FILE, noalias __format: [*c]const u8, ...) c_int;
pub extern fn scanf(noalias __format: [*c]const u8, ...) c_int;
pub extern fn sscanf(noalias __s: [*c]const u8, noalias __format: [*c]const u8, ...) c_int;
pub extern fn vfscanf(noalias __s: [*c]FILE, noalias __format: [*c]const u8, __arg: [*c]struct___va_list_tag_2) c_int;
pub extern fn vscanf(noalias __format: [*c]const u8, __arg: [*c]struct___va_list_tag_2) c_int;
pub extern fn vsscanf(noalias __s: [*c]const u8, noalias __format: [*c]const u8, __arg: [*c]struct___va_list_tag_2) c_int;
pub extern fn fgetc(__stream: [*c]FILE) c_int;
pub extern fn getc(__stream: [*c]FILE) c_int;
pub extern fn getchar() c_int;
pub extern fn getc_unlocked(__stream: [*c]FILE) c_int;
pub extern fn getchar_unlocked() c_int;
pub extern fn fgetc_unlocked(__stream: [*c]FILE) c_int;
pub extern fn fputc(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn putc(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn putchar(__c: c_int) c_int;
pub extern fn fputc_unlocked(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn putc_unlocked(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn putchar_unlocked(__c: c_int) c_int;
pub extern fn getw(__stream: [*c]FILE) c_int;
pub extern fn putw(__w: c_int, __stream: [*c]FILE) c_int;
pub extern fn fgets(noalias __s: [*c]u8, __n: c_int, noalias __stream: [*c]FILE) [*c]u8;
pub extern fn __getdelim(noalias __lineptr: [*c][*c]u8, noalias __n: [*c]usize, __delimiter: c_int, noalias __stream: [*c]FILE) __ssize_t;
pub extern fn getdelim(noalias __lineptr: [*c][*c]u8, noalias __n: [*c]usize, __delimiter: c_int, noalias __stream: [*c]FILE) __ssize_t;
pub extern fn getline(noalias __lineptr: [*c][*c]u8, noalias __n: [*c]usize, noalias __stream: [*c]FILE) __ssize_t;
pub extern fn fputs(noalias __s: [*c]const u8, noalias __stream: [*c]FILE) c_int;
pub extern fn puts(__s: [*c]const u8) c_int;
pub extern fn ungetc(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn fread(__ptr: ?*anyopaque, __size: c_ulong, __n: c_ulong, __stream: [*c]FILE) c_ulong;
pub extern fn fwrite(__ptr: ?*const anyopaque, __size: c_ulong, __n: c_ulong, __s: [*c]FILE) c_ulong;
pub extern fn fread_unlocked(noalias __ptr: ?*anyopaque, __size: usize, __n: usize, noalias __stream: [*c]FILE) usize;
pub extern fn fwrite_unlocked(noalias __ptr: ?*const anyopaque, __size: usize, __n: usize, noalias __stream: [*c]FILE) usize;
pub extern fn fseek(__stream: [*c]FILE, __off: c_long, __whence: c_int) c_int;
pub extern fn ftell(__stream: [*c]FILE) c_long;
pub extern fn rewind(__stream: [*c]FILE) void;
pub extern fn fseeko(__stream: [*c]FILE, __off: __off_t, __whence: c_int) c_int;
pub extern fn ftello(__stream: [*c]FILE) __off_t;
pub extern fn fgetpos(noalias __stream: [*c]FILE, noalias __pos: [*c]fpos_t) c_int;
pub extern fn fsetpos(__stream: [*c]FILE, __pos: [*c]const fpos_t) c_int;
pub extern fn clearerr(__stream: [*c]FILE) void;
pub extern fn feof(__stream: [*c]FILE) c_int;
pub extern fn ferror(__stream: [*c]FILE) c_int;
pub extern fn clearerr_unlocked(__stream: [*c]FILE) void;
pub extern fn feof_unlocked(__stream: [*c]FILE) c_int;
pub extern fn ferror_unlocked(__stream: [*c]FILE) c_int;
pub extern fn perror(__s: [*c]const u8) void;
pub extern fn fileno(__stream: [*c]FILE) c_int;
pub extern fn fileno_unlocked(__stream: [*c]FILE) c_int;
pub extern fn pclose(__stream: [*c]FILE) c_int;
pub extern fn popen(__command: [*c]const u8, __modes: [*c]const u8) [*c]FILE;
pub extern fn ctermid(__s: [*c]u8) [*c]u8;
pub extern fn flockfile(__stream: [*c]FILE) void;
pub extern fn ftrylockfile(__stream: [*c]FILE) c_int;
pub extern fn funlockfile(__stream: [*c]FILE) void;
pub extern fn __uflow([*c]FILE) c_int;
pub extern fn __overflow([*c]FILE, c_int) c_int;
pub extern fn memcpy(__dest: ?*anyopaque, __src: ?*const anyopaque, __n: c_ulong) ?*anyopaque;
pub extern fn memmove(__dest: ?*anyopaque, __src: ?*const anyopaque, __n: c_ulong) ?*anyopaque;
pub extern fn memccpy(__dest: ?*anyopaque, __src: ?*const anyopaque, __c: c_int, __n: c_ulong) ?*anyopaque;
pub extern fn memset(__s: ?*anyopaque, __c: c_int, __n: c_ulong) ?*anyopaque;
pub extern fn memcmp(__s1: ?*const anyopaque, __s2: ?*const anyopaque, __n: c_ulong) c_int;
pub extern fn __memcmpeq(__s1: ?*const anyopaque, __s2: ?*const anyopaque, __n: usize) c_int;
pub extern fn memchr(__s: ?*const anyopaque, __c: c_int, __n: c_ulong) ?*anyopaque;
pub extern fn strcpy(__dest: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn strncpy(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strcat(__dest: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn strncat(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strcmp(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strncmp(__s1: [*c]const u8, __s2: [*c]const u8, __n: c_ulong) c_int;
pub extern fn strcoll(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strxfrm(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) c_ulong;
pub const struct___locale_data_4 = opaque {};
pub const struct___locale_struct = extern struct {
    __locales: [13]?*struct___locale_data_4 = @import("std").mem.zeroes([13]?*struct___locale_data_4),
    __ctype_b: [*c]const c_ushort = @import("std").mem.zeroes([*c]const c_ushort),
    __ctype_tolower: [*c]const c_int = @import("std").mem.zeroes([*c]const c_int),
    __ctype_toupper: [*c]const c_int = @import("std").mem.zeroes([*c]const c_int),
    __names: [13][*c]const u8 = @import("std").mem.zeroes([13][*c]const u8),
};
pub const __locale_t = [*c]struct___locale_struct;
pub const locale_t = __locale_t;
pub extern fn strcoll_l(__s1: [*c]const u8, __s2: [*c]const u8, __l: locale_t) c_int;
pub extern fn strxfrm_l(__dest: [*c]u8, __src: [*c]const u8, __n: usize, __l: locale_t) usize;
pub extern fn strdup(__s: [*c]const u8) [*c]u8;
pub extern fn strndup(__string: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strchr(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn strrchr(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn strchrnul(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn strcspn(__s: [*c]const u8, __reject: [*c]const u8) c_ulong;
pub extern fn strspn(__s: [*c]const u8, __accept: [*c]const u8) c_ulong;
pub extern fn strpbrk(__s: [*c]const u8, __accept: [*c]const u8) [*c]u8;
pub extern fn strstr(__haystack: [*c]const u8, __needle: [*c]const u8) [*c]u8;
pub extern fn strtok(__s: [*c]u8, __delim: [*c]const u8) [*c]u8;
pub extern fn __strtok_r(noalias __s: [*c]u8, noalias __delim: [*c]const u8, noalias __save_ptr: [*c][*c]u8) [*c]u8;
pub extern fn strtok_r(noalias __s: [*c]u8, noalias __delim: [*c]const u8, noalias __save_ptr: [*c][*c]u8) [*c]u8;
pub extern fn strcasestr(__haystack: [*c]const u8, __needle: [*c]const u8) [*c]u8;
pub extern fn memmem(__haystack: ?*const anyopaque, __haystacklen: usize, __needle: ?*const anyopaque, __needlelen: usize) ?*anyopaque;
pub extern fn __mempcpy(noalias __dest: ?*anyopaque, noalias __src: ?*const anyopaque, __n: usize) ?*anyopaque;
pub extern fn mempcpy(__dest: ?*anyopaque, __src: ?*const anyopaque, __n: c_ulong) ?*anyopaque;
pub extern fn strlen(__s: [*c]const u8) c_ulong;
pub extern fn strnlen(__string: [*c]const u8, __maxlen: usize) usize;
pub extern fn strerror(__errnum: c_int) [*c]u8;
pub extern fn strerror_r(__errnum: c_int, __buf: [*c]u8, __buflen: usize) c_int;
pub extern fn strerror_l(__errnum: c_int, __l: locale_t) [*c]u8;
pub extern fn bcmp(__s1: ?*const anyopaque, __s2: ?*const anyopaque, __n: c_ulong) c_int;
pub extern fn bcopy(__src: ?*const anyopaque, __dest: ?*anyopaque, __n: c_ulong) void;
pub extern fn bzero(__s: ?*anyopaque, __n: c_ulong) void;
pub extern fn index(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn rindex(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn ffs(__i: c_int) c_int;
pub extern fn ffsl(__l: c_long) c_int;
pub extern fn ffsll(__ll: c_longlong) c_int;
pub extern fn strcasecmp(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strncasecmp(__s1: [*c]const u8, __s2: [*c]const u8, __n: c_ulong) c_int;
pub extern fn strcasecmp_l(__s1: [*c]const u8, __s2: [*c]const u8, __loc: locale_t) c_int;
pub extern fn strncasecmp_l(__s1: [*c]const u8, __s2: [*c]const u8, __n: usize, __loc: locale_t) c_int;
pub extern fn explicit_bzero(__s: ?*anyopaque, __n: usize) void;
pub extern fn strsep(noalias __stringp: [*c][*c]u8, noalias __delim: [*c]const u8) [*c]u8;
pub extern fn strsignal(__sig: c_int) [*c]u8;
pub extern fn __stpcpy(noalias __dest: [*c]u8, noalias __src: [*c]const u8) [*c]u8;
pub extern fn stpcpy(__dest: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn __stpncpy(noalias __dest: [*c]u8, noalias __src: [*c]const u8, __n: usize) [*c]u8;
pub extern fn stpncpy(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strlcpy(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) c_ulong;
pub extern fn strlcat(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) c_ulong;
pub const int_least8_t = __int_least8_t;
pub const int_least16_t = __int_least16_t;
pub const int_least32_t = __int_least32_t;
pub const int_least64_t = __int_least64_t;
pub const uint_least8_t = __uint_least8_t;
pub const uint_least16_t = __uint_least16_t;
pub const uint_least32_t = __uint_least32_t;
pub const uint_least64_t = __uint_least64_t;
pub const int_fast8_t = i8;
pub const int_fast16_t = c_long;
pub const int_fast32_t = c_long;
pub const int_fast64_t = c_long;
pub const uint_fast8_t = u8;
pub const uint_fast16_t = c_ulong;
pub const uint_fast32_t = c_ulong;
pub const uint_fast64_t = c_ulong;
pub const intmax_t = __intmax_t;
pub const uintmax_t = __uintmax_t;
pub const struct_tm = extern struct {
    tm_sec: c_int = @import("std").mem.zeroes(c_int),
    tm_min: c_int = @import("std").mem.zeroes(c_int),
    tm_hour: c_int = @import("std").mem.zeroes(c_int),
    tm_mday: c_int = @import("std").mem.zeroes(c_int),
    tm_mon: c_int = @import("std").mem.zeroes(c_int),
    tm_year: c_int = @import("std").mem.zeroes(c_int),
    tm_wday: c_int = @import("std").mem.zeroes(c_int),
    tm_yday: c_int = @import("std").mem.zeroes(c_int),
    tm_isdst: c_int = @import("std").mem.zeroes(c_int),
    tm_gmtoff: c_long = @import("std").mem.zeroes(c_long),
    tm_zone: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
};
pub const struct_itimerspec = extern struct {
    it_interval: struct_timespec = @import("std").mem.zeroes(struct_timespec),
    it_value: struct_timespec = @import("std").mem.zeroes(struct_timespec),
};
pub const union_sigval = extern union {
    sival_int: c_int,
    sival_ptr: ?*anyopaque,
};
pub const __sigval_t = union_sigval;
const struct_unnamed_6 = extern struct {
    _function: ?*const fn (__sigval_t) callconv(.c) void = @import("std").mem.zeroes(?*const fn (__sigval_t) callconv(.c) void),
    _attribute: [*c]pthread_attr_t = @import("std").mem.zeroes([*c]pthread_attr_t),
};
const union_unnamed_5 = extern union {
    _pad: [12]c_int,
    _tid: __pid_t,
    _sigev_thread: struct_unnamed_6,
};
pub const struct_sigevent = extern struct {
    sigev_value: __sigval_t = @import("std").mem.zeroes(__sigval_t),
    sigev_signo: c_int = @import("std").mem.zeroes(c_int),
    sigev_notify: c_int = @import("std").mem.zeroes(c_int),
    _sigev_un: union_unnamed_5 = @import("std").mem.zeroes(union_unnamed_5),
};
pub extern fn clock() clock_t;
pub extern fn time(__timer: [*c]time_t) time_t;
pub extern fn difftime(__time1: time_t, __time0: time_t) f64;
pub extern fn mktime(__tp: [*c]struct_tm) time_t;
pub extern fn strftime(noalias __s: [*c]u8, __maxsize: usize, noalias __format: [*c]const u8, noalias __tp: [*c]const struct_tm) usize;
pub extern fn strftime_l(noalias __s: [*c]u8, __maxsize: usize, noalias __format: [*c]const u8, noalias __tp: [*c]const struct_tm, __loc: locale_t) usize;
pub extern fn gmtime(__timer: [*c]const time_t) [*c]struct_tm;
pub extern fn localtime(__timer: [*c]const time_t) [*c]struct_tm;
pub extern fn gmtime_r(noalias __timer: [*c]const time_t, noalias __tp: [*c]struct_tm) [*c]struct_tm;
pub extern fn localtime_r(noalias __timer: [*c]const time_t, noalias __tp: [*c]struct_tm) [*c]struct_tm;
pub extern fn asctime(__tp: [*c]const struct_tm) [*c]u8;
pub extern fn ctime(__timer: [*c]const time_t) [*c]u8;
pub extern fn asctime_r(noalias __tp: [*c]const struct_tm, noalias __buf: [*c]u8) [*c]u8;
pub extern fn ctime_r(noalias __timer: [*c]const time_t, noalias __buf: [*c]u8) [*c]u8;
pub extern var __tzname: [2][*c]u8;
pub extern var __daylight: c_int;
pub extern var __timezone: c_long;
pub extern var tzname: [2][*c]u8;
pub extern fn tzset() void;
pub extern var daylight: c_int;
pub extern var timezone: c_long;
pub extern fn timegm(__tp: [*c]struct_tm) time_t;
pub extern fn timelocal(__tp: [*c]struct_tm) time_t;
pub extern fn dysize(__year: c_int) c_int;
pub extern fn nanosleep(__requested_time: [*c]const struct_timespec, __remaining: [*c]struct_timespec) c_int;
pub extern fn clock_getres(__clock_id: clockid_t, __res: [*c]struct_timespec) c_int;
pub extern fn clock_gettime(__clock_id: clockid_t, __tp: [*c]struct_timespec) c_int;
pub extern fn clock_settime(__clock_id: clockid_t, __tp: [*c]const struct_timespec) c_int;
pub extern fn clock_nanosleep(__clock_id: clockid_t, __flags: c_int, __req: [*c]const struct_timespec, __rem: [*c]struct_timespec) c_int;
pub extern fn clock_getcpuclockid(__pid: pid_t, __clock_id: [*c]clockid_t) c_int;
pub extern fn timer_create(__clock_id: clockid_t, noalias __evp: [*c]struct_sigevent, noalias __timerid: [*c]timer_t) c_int;
pub extern fn timer_delete(__timerid: timer_t) c_int;
pub extern fn timer_settime(__timerid: timer_t, __flags: c_int, noalias __value: [*c]const struct_itimerspec, noalias __ovalue: [*c]struct_itimerspec) c_int;
pub extern fn timer_gettime(__timerid: timer_t, __value: [*c]struct_itimerspec) c_int;
pub extern fn timer_getoverrun(__timerid: timer_t) c_int;
pub extern fn timespec_get(__ts: [*c]struct_timespec, __base: c_int) c_int;
pub const struct_iovec = extern struct {
    iov_base: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    iov_len: usize = @import("std").mem.zeroes(usize),
};
pub const socklen_t = __socklen_t;
pub const SOCK_STREAM: c_int = 1;
pub const SOCK_DGRAM: c_int = 2;
pub const SOCK_RAW: c_int = 3;
pub const SOCK_RDM: c_int = 4;
pub const SOCK_SEQPACKET: c_int = 5;
pub const SOCK_DCCP: c_int = 6;
pub const SOCK_PACKET: c_int = 10;
pub const SOCK_CLOEXEC: c_int = 524288;
pub const SOCK_NONBLOCK: c_int = 2048;
pub const enum___socket_type = c_uint;
pub const sa_family_t = c_ushort;
pub const struct_sockaddr = extern struct {
    sa_family: sa_family_t = @import("std").mem.zeroes(sa_family_t),
    sa_data: [14]u8 = @import("std").mem.zeroes([14]u8),
};
pub const struct_sockaddr_storage = extern struct {
    ss_family: sa_family_t = @import("std").mem.zeroes(sa_family_t),
    __ss_padding: [118]u8 = @import("std").mem.zeroes([118]u8),
    __ss_align: c_ulong = @import("std").mem.zeroes(c_ulong),
};
pub const MSG_OOB: c_int = 1;
pub const MSG_PEEK: c_int = 2;
pub const MSG_DONTROUTE: c_int = 4;
pub const MSG_CTRUNC: c_int = 8;
pub const MSG_PROXY: c_int = 16;
pub const MSG_TRUNC: c_int = 32;
pub const MSG_DONTWAIT: c_int = 64;
pub const MSG_EOR: c_int = 128;
pub const MSG_WAITALL: c_int = 256;
pub const MSG_FIN: c_int = 512;
pub const MSG_SYN: c_int = 1024;
pub const MSG_CONFIRM: c_int = 2048;
pub const MSG_RST: c_int = 4096;
pub const MSG_ERRQUEUE: c_int = 8192;
pub const MSG_NOSIGNAL: c_int = 16384;
pub const MSG_MORE: c_int = 32768;
pub const MSG_WAITFORONE: c_int = 65536;
pub const MSG_BATCH: c_int = 262144;
pub const MSG_ZEROCOPY: c_int = 67108864;
pub const MSG_FASTOPEN: c_int = 536870912;
pub const MSG_CMSG_CLOEXEC: c_int = 1073741824;
const enum_unnamed_7 = c_uint;
pub const struct_msghdr = extern struct {
    msg_name: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    msg_namelen: socklen_t = @import("std").mem.zeroes(socklen_t),
    msg_iov: [*c]struct_iovec = @import("std").mem.zeroes([*c]struct_iovec),
    msg_iovlen: usize = @import("std").mem.zeroes(usize),
    msg_control: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    msg_controllen: usize = @import("std").mem.zeroes(usize),
    msg_flags: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct_cmsghdr = extern struct {
    cmsg_len: usize align(8) = @import("std").mem.zeroes(usize),
    cmsg_level: c_int = @import("std").mem.zeroes(c_int),
    cmsg_type: c_int = @import("std").mem.zeroes(c_int),
    pub fn __cmsg_data(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        return @as(ReturnType, @ptrCast(@alignCast(@as(Intermediate, @ptrCast(self)) + 16)));
    }
};
pub extern fn __cmsg_nxthdr(__mhdr: [*c]struct_msghdr, __cmsg: [*c]struct_cmsghdr) [*c]struct_cmsghdr;
pub const SCM_RIGHTS: c_int = 1;
const enum_unnamed_8 = c_uint;
pub const __kernel_fd_set = extern struct {
    fds_bits: [16]c_ulong = @import("std").mem.zeroes([16]c_ulong),
};
pub const __kernel_sighandler_t = ?*const fn (c_int) callconv(.c) void;
pub const __kernel_key_t = c_int;
pub const __kernel_mqd_t = c_int;
pub const __kernel_old_uid_t = c_ushort;
pub const __kernel_old_gid_t = c_ushort;
pub const __kernel_old_dev_t = c_ulong;
pub const __kernel_long_t = c_long;
pub const __kernel_ulong_t = c_ulong;
pub const __kernel_ino_t = __kernel_ulong_t;
pub const __kernel_mode_t = c_uint;
pub const __kernel_pid_t = c_int;
pub const __kernel_ipc_pid_t = c_int;
pub const __kernel_uid_t = c_uint;
pub const __kernel_gid_t = c_uint;
pub const __kernel_suseconds_t = __kernel_long_t;
pub const __kernel_daddr_t = c_int;
pub const __kernel_uid32_t = c_uint;
pub const __kernel_gid32_t = c_uint;
pub const __kernel_size_t = __kernel_ulong_t;
pub const __kernel_ssize_t = __kernel_long_t;
pub const __kernel_ptrdiff_t = __kernel_long_t;
pub const __kernel_fsid_t = extern struct {
    val: [2]c_int = @import("std").mem.zeroes([2]c_int),
};
pub const __kernel_off_t = __kernel_long_t;
pub const __kernel_loff_t = c_longlong;
pub const __kernel_old_time_t = __kernel_long_t;
pub const __kernel_time_t = __kernel_long_t;
pub const __kernel_time64_t = c_longlong;
pub const __kernel_clock_t = __kernel_long_t;
pub const __kernel_timer_t = c_int;
pub const __kernel_clockid_t = c_int;
pub const __kernel_caddr_t = [*c]u8;
pub const __kernel_uid16_t = c_ushort;
pub const __kernel_gid16_t = c_ushort;
pub const struct_linger = extern struct {
    l_onoff: c_int = @import("std").mem.zeroes(c_int),
    l_linger: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct_osockaddr = extern struct {
    sa_family: c_ushort = @import("std").mem.zeroes(c_ushort),
    sa_data: [14]u8 = @import("std").mem.zeroes([14]u8),
};
pub const SHUT_RD: c_int = 0;
pub const SHUT_WR: c_int = 1;
pub const SHUT_RDWR: c_int = 2;
const enum_unnamed_9 = c_uint;
pub extern fn socket(__domain: c_int, __type: c_int, __protocol: c_int) c_int;
pub extern fn socketpair(__domain: c_int, __type: c_int, __protocol: c_int, __fds: [*c]c_int) c_int;
pub extern fn bind(__fd: c_int, __addr: [*c]const struct_sockaddr, __len: socklen_t) c_int;
pub extern fn getsockname(__fd: c_int, noalias __addr: [*c]struct_sockaddr, noalias __len: [*c]socklen_t) c_int;
pub extern fn connect(__fd: c_int, __addr: [*c]const struct_sockaddr, __len: socklen_t) c_int;
pub extern fn getpeername(__fd: c_int, noalias __addr: [*c]struct_sockaddr, noalias __len: [*c]socklen_t) c_int;
pub extern fn send(__fd: c_int, __buf: ?*const anyopaque, __n: usize, __flags: c_int) isize;
pub extern fn recv(__fd: c_int, __buf: ?*anyopaque, __n: usize, __flags: c_int) isize;
pub extern fn sendto(__fd: c_int, __buf: ?*const anyopaque, __n: usize, __flags: c_int, __addr: [*c]const struct_sockaddr, __addr_len: socklen_t) isize;
pub extern fn recvfrom(__fd: c_int, noalias __buf: ?*anyopaque, __n: usize, __flags: c_int, noalias __addr: [*c]struct_sockaddr, noalias __addr_len: [*c]socklen_t) isize;
pub extern fn sendmsg(__fd: c_int, __message: [*c]const struct_msghdr, __flags: c_int) isize;
pub extern fn recvmsg(__fd: c_int, __message: [*c]struct_msghdr, __flags: c_int) isize;
pub extern fn getsockopt(__fd: c_int, __level: c_int, __optname: c_int, noalias __optval: ?*anyopaque, noalias __optlen: [*c]socklen_t) c_int;
pub extern fn setsockopt(__fd: c_int, __level: c_int, __optname: c_int, __optval: ?*const anyopaque, __optlen: socklen_t) c_int;
pub extern fn listen(__fd: c_int, __n: c_int) c_int;
pub extern fn accept(__fd: c_int, noalias __addr: [*c]struct_sockaddr, noalias __addr_len: [*c]socklen_t) c_int;
pub extern fn shutdown(__fd: c_int, __how: c_int) c_int;
pub extern fn sockatmark(__fd: c_int) c_int;
pub extern fn isfdtype(__fd: c_int, __fdtype: c_int) c_int;
pub const in_addr_t = u32;
pub const struct_in_addr = extern struct {
    s_addr: in_addr_t = @import("std").mem.zeroes(in_addr_t),
};
pub const struct_ip_opts = extern struct {
    ip_dst: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    ip_opts: [40]u8 = @import("std").mem.zeroes([40]u8),
};
pub const struct_in_pktinfo = extern struct {
    ipi_ifindex: c_int = @import("std").mem.zeroes(c_int),
    ipi_spec_dst: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    ipi_addr: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
};
pub const IPPROTO_IP: c_int = 0;
pub const IPPROTO_ICMP: c_int = 1;
pub const IPPROTO_IGMP: c_int = 2;
pub const IPPROTO_IPIP: c_int = 4;
pub const IPPROTO_TCP: c_int = 6;
pub const IPPROTO_EGP: c_int = 8;
pub const IPPROTO_PUP: c_int = 12;
pub const IPPROTO_UDP: c_int = 17;
pub const IPPROTO_IDP: c_int = 22;
pub const IPPROTO_TP: c_int = 29;
pub const IPPROTO_DCCP: c_int = 33;
pub const IPPROTO_IPV6: c_int = 41;
pub const IPPROTO_RSVP: c_int = 46;
pub const IPPROTO_GRE: c_int = 47;
pub const IPPROTO_ESP: c_int = 50;
pub const IPPROTO_AH: c_int = 51;
pub const IPPROTO_MTP: c_int = 92;
pub const IPPROTO_BEETPH: c_int = 94;
pub const IPPROTO_ENCAP: c_int = 98;
pub const IPPROTO_PIM: c_int = 103;
pub const IPPROTO_COMP: c_int = 108;
pub const IPPROTO_L2TP: c_int = 115;
pub const IPPROTO_SCTP: c_int = 132;
pub const IPPROTO_UDPLITE: c_int = 136;
pub const IPPROTO_MPLS: c_int = 137;
pub const IPPROTO_ETHERNET: c_int = 143;
pub const IPPROTO_RAW: c_int = 255;
pub const IPPROTO_MPTCP: c_int = 262;
pub const IPPROTO_MAX: c_int = 263;
const enum_unnamed_10 = c_uint;
pub const IPPROTO_HOPOPTS: c_int = 0;
pub const IPPROTO_ROUTING: c_int = 43;
pub const IPPROTO_FRAGMENT: c_int = 44;
pub const IPPROTO_ICMPV6: c_int = 58;
pub const IPPROTO_NONE: c_int = 59;
pub const IPPROTO_DSTOPTS: c_int = 60;
pub const IPPROTO_MH: c_int = 135;
const enum_unnamed_11 = c_uint;
pub const in_port_t = u16;
pub const IPPORT_ECHO: c_int = 7;
pub const IPPORT_DISCARD: c_int = 9;
pub const IPPORT_SYSTAT: c_int = 11;
pub const IPPORT_DAYTIME: c_int = 13;
pub const IPPORT_NETSTAT: c_int = 15;
pub const IPPORT_FTP: c_int = 21;
pub const IPPORT_TELNET: c_int = 23;
pub const IPPORT_SMTP: c_int = 25;
pub const IPPORT_TIMESERVER: c_int = 37;
pub const IPPORT_NAMESERVER: c_int = 42;
pub const IPPORT_WHOIS: c_int = 43;
pub const IPPORT_MTP: c_int = 57;
pub const IPPORT_TFTP: c_int = 69;
pub const IPPORT_RJE: c_int = 77;
pub const IPPORT_FINGER: c_int = 79;
pub const IPPORT_TTYLINK: c_int = 87;
pub const IPPORT_SUPDUP: c_int = 95;
pub const IPPORT_EXECSERVER: c_int = 512;
pub const IPPORT_LOGINSERVER: c_int = 513;
pub const IPPORT_CMDSERVER: c_int = 514;
pub const IPPORT_EFSSERVER: c_int = 520;
pub const IPPORT_BIFFUDP: c_int = 512;
pub const IPPORT_WHOSERVER: c_int = 513;
pub const IPPORT_ROUTESERVER: c_int = 520;
pub const IPPORT_RESERVED: c_int = 1024;
pub const IPPORT_USERRESERVED: c_int = 5000;
const enum_unnamed_12 = c_uint;
const union_unnamed_13 = extern union {
    __u6_addr8: [16]u8,
    __u6_addr16: [8]u16,
    __u6_addr32: [4]u32,
};
pub const struct_in6_addr = extern struct {
    __in6_u: union_unnamed_13 = @import("std").mem.zeroes(union_unnamed_13),
};
pub extern const in6addr_any: struct_in6_addr;
pub extern const in6addr_loopback: struct_in6_addr;
pub const struct_sockaddr_in = extern struct {
    sin_family: sa_family_t = @import("std").mem.zeroes(sa_family_t),
    sin_port: in_port_t = @import("std").mem.zeroes(in_port_t),
    sin_addr: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    sin_zero: [8]u8 = @import("std").mem.zeroes([8]u8),
};
pub const struct_sockaddr_in6 = extern struct {
    sin6_family: sa_family_t = @import("std").mem.zeroes(sa_family_t),
    sin6_port: in_port_t = @import("std").mem.zeroes(in_port_t),
    sin6_flowinfo: u32 = @import("std").mem.zeroes(u32),
    sin6_addr: struct_in6_addr = @import("std").mem.zeroes(struct_in6_addr),
    sin6_scope_id: u32 = @import("std").mem.zeroes(u32),
};
pub const struct_ip_mreq = extern struct {
    imr_multiaddr: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    imr_interface: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
};
pub const struct_ip_mreqn = extern struct {
    imr_multiaddr: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    imr_address: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    imr_ifindex: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct_ip_mreq_source = extern struct {
    imr_multiaddr: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    imr_interface: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    imr_sourceaddr: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
};
pub const struct_ipv6_mreq = extern struct {
    ipv6mr_multiaddr: struct_in6_addr = @import("std").mem.zeroes(struct_in6_addr),
    ipv6mr_interface: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const struct_group_req = extern struct {
    gr_interface: u32 = @import("std").mem.zeroes(u32),
    gr_group: struct_sockaddr_storage = @import("std").mem.zeroes(struct_sockaddr_storage),
};
pub const struct_group_source_req = extern struct {
    gsr_interface: u32 = @import("std").mem.zeroes(u32),
    gsr_group: struct_sockaddr_storage = @import("std").mem.zeroes(struct_sockaddr_storage),
    gsr_source: struct_sockaddr_storage = @import("std").mem.zeroes(struct_sockaddr_storage),
};
pub const struct_ip_msfilter = extern struct {
    imsf_multiaddr: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    imsf_interface: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    imsf_fmode: u32 = @import("std").mem.zeroes(u32),
    imsf_numsrc: u32 = @import("std").mem.zeroes(u32),
    imsf_slist: [1]struct_in_addr = @import("std").mem.zeroes([1]struct_in_addr),
};
pub const struct_group_filter = extern struct {
    gf_interface: u32 = @import("std").mem.zeroes(u32),
    gf_group: struct_sockaddr_storage = @import("std").mem.zeroes(struct_sockaddr_storage),
    gf_fmode: u32 = @import("std").mem.zeroes(u32),
    gf_numsrc: u32 = @import("std").mem.zeroes(u32),
    gf_slist: [1]struct_sockaddr_storage = @import("std").mem.zeroes([1]struct_sockaddr_storage),
};
pub extern fn ntohl(__netlong: u32) u32;
pub extern fn ntohs(__netshort: u16) u16;
pub extern fn htonl(__hostlong: u32) u32;
pub extern fn htons(__hostshort: u16) u16;
pub extern fn bindresvport(__sockfd: c_int, __sock_in: [*c]struct_sockaddr_in) c_int;
pub extern fn bindresvport6(__sockfd: c_int, __sock_in: [*c]struct_sockaddr_in6) c_int;
pub extern fn inet_addr(__cp: [*c]const u8) in_addr_t;
pub extern fn inet_lnaof(__in: struct_in_addr) in_addr_t;
pub extern fn inet_makeaddr(__net: in_addr_t, __host: in_addr_t) struct_in_addr;
pub extern fn inet_netof(__in: struct_in_addr) in_addr_t;
pub extern fn inet_network(__cp: [*c]const u8) in_addr_t;
pub extern fn inet_ntoa(__in: struct_in_addr) [*c]u8;
pub extern fn inet_pton(__af: c_int, noalias __cp: [*c]const u8, noalias __buf: ?*anyopaque) c_int;
pub extern fn inet_ntop(__af: c_int, noalias __cp: ?*const anyopaque, noalias __buf: [*c]u8, __len: socklen_t) [*c]const u8;
pub extern fn inet_aton(__cp: [*c]const u8, __inp: [*c]struct_in_addr) c_int;
pub extern fn inet_neta(__net: in_addr_t, __buf: [*c]u8, __len: usize) [*c]u8;
pub extern fn inet_net_ntop(__af: c_int, __cp: ?*const anyopaque, __bits: c_int, __buf: [*c]u8, __len: usize) [*c]u8;
pub extern fn inet_net_pton(__af: c_int, __cp: [*c]const u8, __buf: ?*anyopaque, __len: usize) c_int;
pub extern fn inet_nsap_addr(__cp: [*c]const u8, __buf: [*c]u8, __len: c_int) c_uint;
pub extern fn inet_nsap_ntoa(__len: c_int, __cp: [*c]const u8, __buf: [*c]u8) [*c]u8;
pub const useconds_t = __useconds_t;
pub extern fn access(__name: [*c]const u8, __type: c_int) c_int;
pub extern fn faccessat(__fd: c_int, __file: [*c]const u8, __type: c_int, __flag: c_int) c_int;
pub extern fn lseek(__fd: c_int, __offset: __off_t, __whence: c_int) __off_t;
pub extern fn close(__fd: c_int) c_int;
pub extern fn closefrom(__lowfd: c_int) void;
pub extern fn read(__fd: c_int, __buf: ?*anyopaque, __nbytes: usize) isize;
pub extern fn write(__fd: c_int, __buf: ?*const anyopaque, __n: usize) isize;
pub extern fn pread(__fd: c_int, __buf: ?*anyopaque, __nbytes: usize, __offset: __off_t) isize;
pub extern fn pwrite(__fd: c_int, __buf: ?*const anyopaque, __n: usize, __offset: __off_t) isize;
pub extern fn pipe(__pipedes: [*c]c_int) c_int;
pub extern fn alarm(__seconds: c_uint) c_uint;
pub extern fn sleep(__seconds: c_uint) c_uint;
pub extern fn ualarm(__value: __useconds_t, __interval: __useconds_t) __useconds_t;
pub extern fn usleep(__useconds: __useconds_t) c_int;
pub extern fn pause() c_int;
pub extern fn chown(__file: [*c]const u8, __owner: __uid_t, __group: __gid_t) c_int;
pub extern fn fchown(__fd: c_int, __owner: __uid_t, __group: __gid_t) c_int;
pub extern fn lchown(__file: [*c]const u8, __owner: __uid_t, __group: __gid_t) c_int;
pub extern fn fchownat(__fd: c_int, __file: [*c]const u8, __owner: __uid_t, __group: __gid_t, __flag: c_int) c_int;
pub extern fn chdir(__path: [*c]const u8) c_int;
pub extern fn fchdir(__fd: c_int) c_int;
pub extern fn getcwd(__buf: [*c]u8, __size: usize) [*c]u8;
pub extern fn getwd(__buf: [*c]u8) [*c]u8;
pub extern fn dup(__fd: c_int) c_int;
pub extern fn dup2(__fd: c_int, __fd2: c_int) c_int;
pub extern var __environ: [*c][*c]u8;
pub extern fn execve(__path: [*c]const u8, __argv: [*c]const [*c]u8, __envp: [*c]const [*c]u8) c_int;
pub extern fn fexecve(__fd: c_int, __argv: [*c]const [*c]u8, __envp: [*c]const [*c]u8) c_int;
pub extern fn execv(__path: [*c]const u8, __argv: [*c]const [*c]u8) c_int;
pub extern fn execle(__path: [*c]const u8, __arg: [*c]const u8, ...) c_int;
pub extern fn execl(__path: [*c]const u8, __arg: [*c]const u8, ...) c_int;
pub extern fn execvp(__file: [*c]const u8, __argv: [*c]const [*c]u8) c_int;
pub extern fn execlp(__file: [*c]const u8, __arg: [*c]const u8, ...) c_int;
pub extern fn nice(__inc: c_int) c_int;
pub extern fn _exit(__status: c_int) noreturn;
pub const _PC_LINK_MAX: c_int = 0;
pub const _PC_MAX_CANON: c_int = 1;
pub const _PC_MAX_INPUT: c_int = 2;
pub const _PC_NAME_MAX: c_int = 3;
pub const _PC_PATH_MAX: c_int = 4;
pub const _PC_PIPE_BUF: c_int = 5;
pub const _PC_CHOWN_RESTRICTED: c_int = 6;
pub const _PC_NO_TRUNC: c_int = 7;
pub const _PC_VDISABLE: c_int = 8;
pub const _PC_SYNC_IO: c_int = 9;
pub const _PC_ASYNC_IO: c_int = 10;
pub const _PC_PRIO_IO: c_int = 11;
pub const _PC_SOCK_MAXBUF: c_int = 12;
pub const _PC_FILESIZEBITS: c_int = 13;
pub const _PC_REC_INCR_XFER_SIZE: c_int = 14;
pub const _PC_REC_MAX_XFER_SIZE: c_int = 15;
pub const _PC_REC_MIN_XFER_SIZE: c_int = 16;
pub const _PC_REC_XFER_ALIGN: c_int = 17;
pub const _PC_ALLOC_SIZE_MIN: c_int = 18;
pub const _PC_SYMLINK_MAX: c_int = 19;
pub const _PC_2_SYMLINKS: c_int = 20;
const enum_unnamed_14 = c_uint;
pub const _SC_ARG_MAX: c_int = 0;
pub const _SC_CHILD_MAX: c_int = 1;
pub const _SC_CLK_TCK: c_int = 2;
pub const _SC_NGROUPS_MAX: c_int = 3;
pub const _SC_OPEN_MAX: c_int = 4;
pub const _SC_STREAM_MAX: c_int = 5;
pub const _SC_TZNAME_MAX: c_int = 6;
pub const _SC_JOB_CONTROL: c_int = 7;
pub const _SC_SAVED_IDS: c_int = 8;
pub const _SC_REALTIME_SIGNALS: c_int = 9;
pub const _SC_PRIORITY_SCHEDULING: c_int = 10;
pub const _SC_TIMERS: c_int = 11;
pub const _SC_ASYNCHRONOUS_IO: c_int = 12;
pub const _SC_PRIORITIZED_IO: c_int = 13;
pub const _SC_SYNCHRONIZED_IO: c_int = 14;
pub const _SC_FSYNC: c_int = 15;
pub const _SC_MAPPED_FILES: c_int = 16;
pub const _SC_MEMLOCK: c_int = 17;
pub const _SC_MEMLOCK_RANGE: c_int = 18;
pub const _SC_MEMORY_PROTECTION: c_int = 19;
pub const _SC_MESSAGE_PASSING: c_int = 20;
pub const _SC_SEMAPHORES: c_int = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: c_int = 22;
pub const _SC_AIO_LISTIO_MAX: c_int = 23;
pub const _SC_AIO_MAX: c_int = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: c_int = 25;
pub const _SC_DELAYTIMER_MAX: c_int = 26;
pub const _SC_MQ_OPEN_MAX: c_int = 27;
pub const _SC_MQ_PRIO_MAX: c_int = 28;
pub const _SC_VERSION: c_int = 29;
pub const _SC_PAGESIZE: c_int = 30;
pub const _SC_RTSIG_MAX: c_int = 31;
pub const _SC_SEM_NSEMS_MAX: c_int = 32;
pub const _SC_SEM_VALUE_MAX: c_int = 33;
pub const _SC_SIGQUEUE_MAX: c_int = 34;
pub const _SC_TIMER_MAX: c_int = 35;
pub const _SC_BC_BASE_MAX: c_int = 36;
pub const _SC_BC_DIM_MAX: c_int = 37;
pub const _SC_BC_SCALE_MAX: c_int = 38;
pub const _SC_BC_STRING_MAX: c_int = 39;
pub const _SC_COLL_WEIGHTS_MAX: c_int = 40;
pub const _SC_EQUIV_CLASS_MAX: c_int = 41;
pub const _SC_EXPR_NEST_MAX: c_int = 42;
pub const _SC_LINE_MAX: c_int = 43;
pub const _SC_RE_DUP_MAX: c_int = 44;
pub const _SC_CHARCLASS_NAME_MAX: c_int = 45;
pub const _SC_2_VERSION: c_int = 46;
pub const _SC_2_C_BIND: c_int = 47;
pub const _SC_2_C_DEV: c_int = 48;
pub const _SC_2_FORT_DEV: c_int = 49;
pub const _SC_2_FORT_RUN: c_int = 50;
pub const _SC_2_SW_DEV: c_int = 51;
pub const _SC_2_LOCALEDEF: c_int = 52;
pub const _SC_PII: c_int = 53;
pub const _SC_PII_XTI: c_int = 54;
pub const _SC_PII_SOCKET: c_int = 55;
pub const _SC_PII_INTERNET: c_int = 56;
pub const _SC_PII_OSI: c_int = 57;
pub const _SC_POLL: c_int = 58;
pub const _SC_SELECT: c_int = 59;
pub const _SC_UIO_MAXIOV: c_int = 60;
pub const _SC_IOV_MAX: c_int = 60;
pub const _SC_PII_INTERNET_STREAM: c_int = 61;
pub const _SC_PII_INTERNET_DGRAM: c_int = 62;
pub const _SC_PII_OSI_COTS: c_int = 63;
pub const _SC_PII_OSI_CLTS: c_int = 64;
pub const _SC_PII_OSI_M: c_int = 65;
pub const _SC_T_IOV_MAX: c_int = 66;
pub const _SC_THREADS: c_int = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: c_int = 68;
pub const _SC_GETGR_R_SIZE_MAX: c_int = 69;
pub const _SC_GETPW_R_SIZE_MAX: c_int = 70;
pub const _SC_LOGIN_NAME_MAX: c_int = 71;
pub const _SC_TTY_NAME_MAX: c_int = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: c_int = 73;
pub const _SC_THREAD_KEYS_MAX: c_int = 74;
pub const _SC_THREAD_STACK_MIN: c_int = 75;
pub const _SC_THREAD_THREADS_MAX: c_int = 76;
pub const _SC_THREAD_ATTR_STACKADDR: c_int = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: c_int = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: c_int = 79;
pub const _SC_THREAD_PRIO_INHERIT: c_int = 80;
pub const _SC_THREAD_PRIO_PROTECT: c_int = 81;
pub const _SC_THREAD_PROCESS_SHARED: c_int = 82;
pub const _SC_NPROCESSORS_CONF: c_int = 83;
pub const _SC_NPROCESSORS_ONLN: c_int = 84;
pub const _SC_PHYS_PAGES: c_int = 85;
pub const _SC_AVPHYS_PAGES: c_int = 86;
pub const _SC_ATEXIT_MAX: c_int = 87;
pub const _SC_PASS_MAX: c_int = 88;
pub const _SC_XOPEN_VERSION: c_int = 89;
pub const _SC_XOPEN_XCU_VERSION: c_int = 90;
pub const _SC_XOPEN_UNIX: c_int = 91;
pub const _SC_XOPEN_CRYPT: c_int = 92;
pub const _SC_XOPEN_ENH_I18N: c_int = 93;
pub const _SC_XOPEN_SHM: c_int = 94;
pub const _SC_2_CHAR_TERM: c_int = 95;
pub const _SC_2_C_VERSION: c_int = 96;
pub const _SC_2_UPE: c_int = 97;
pub const _SC_XOPEN_XPG2: c_int = 98;
pub const _SC_XOPEN_XPG3: c_int = 99;
pub const _SC_XOPEN_XPG4: c_int = 100;
pub const _SC_CHAR_BIT: c_int = 101;
pub const _SC_CHAR_MAX: c_int = 102;
pub const _SC_CHAR_MIN: c_int = 103;
pub const _SC_INT_MAX: c_int = 104;
pub const _SC_INT_MIN: c_int = 105;
pub const _SC_LONG_BIT: c_int = 106;
pub const _SC_WORD_BIT: c_int = 107;
pub const _SC_MB_LEN_MAX: c_int = 108;
pub const _SC_NZERO: c_int = 109;
pub const _SC_SSIZE_MAX: c_int = 110;
pub const _SC_SCHAR_MAX: c_int = 111;
pub const _SC_SCHAR_MIN: c_int = 112;
pub const _SC_SHRT_MAX: c_int = 113;
pub const _SC_SHRT_MIN: c_int = 114;
pub const _SC_UCHAR_MAX: c_int = 115;
pub const _SC_UINT_MAX: c_int = 116;
pub const _SC_ULONG_MAX: c_int = 117;
pub const _SC_USHRT_MAX: c_int = 118;
pub const _SC_NL_ARGMAX: c_int = 119;
pub const _SC_NL_LANGMAX: c_int = 120;
pub const _SC_NL_MSGMAX: c_int = 121;
pub const _SC_NL_NMAX: c_int = 122;
pub const _SC_NL_SETMAX: c_int = 123;
pub const _SC_NL_TEXTMAX: c_int = 124;
pub const _SC_XBS5_ILP32_OFF32: c_int = 125;
pub const _SC_XBS5_ILP32_OFFBIG: c_int = 126;
pub const _SC_XBS5_LP64_OFF64: c_int = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: c_int = 128;
pub const _SC_XOPEN_LEGACY: c_int = 129;
pub const _SC_XOPEN_REALTIME: c_int = 130;
pub const _SC_XOPEN_REALTIME_THREADS: c_int = 131;
pub const _SC_ADVISORY_INFO: c_int = 132;
pub const _SC_BARRIERS: c_int = 133;
pub const _SC_BASE: c_int = 134;
pub const _SC_C_LANG_SUPPORT: c_int = 135;
pub const _SC_C_LANG_SUPPORT_R: c_int = 136;
pub const _SC_CLOCK_SELECTION: c_int = 137;
pub const _SC_CPUTIME: c_int = 138;
pub const _SC_THREAD_CPUTIME: c_int = 139;
pub const _SC_DEVICE_IO: c_int = 140;
pub const _SC_DEVICE_SPECIFIC: c_int = 141;
pub const _SC_DEVICE_SPECIFIC_R: c_int = 142;
pub const _SC_FD_MGMT: c_int = 143;
pub const _SC_FIFO: c_int = 144;
pub const _SC_PIPE: c_int = 145;
pub const _SC_FILE_ATTRIBUTES: c_int = 146;
pub const _SC_FILE_LOCKING: c_int = 147;
pub const _SC_FILE_SYSTEM: c_int = 148;
pub const _SC_MONOTONIC_CLOCK: c_int = 149;
pub const _SC_MULTI_PROCESS: c_int = 150;
pub const _SC_SINGLE_PROCESS: c_int = 151;
pub const _SC_NETWORKING: c_int = 152;
pub const _SC_READER_WRITER_LOCKS: c_int = 153;
pub const _SC_SPIN_LOCKS: c_int = 154;
pub const _SC_REGEXP: c_int = 155;
pub const _SC_REGEX_VERSION: c_int = 156;
pub const _SC_SHELL: c_int = 157;
pub const _SC_SIGNALS: c_int = 158;
pub const _SC_SPAWN: c_int = 159;
pub const _SC_SPORADIC_SERVER: c_int = 160;
pub const _SC_THREAD_SPORADIC_SERVER: c_int = 161;
pub const _SC_SYSTEM_DATABASE: c_int = 162;
pub const _SC_SYSTEM_DATABASE_R: c_int = 163;
pub const _SC_TIMEOUTS: c_int = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: c_int = 165;
pub const _SC_USER_GROUPS: c_int = 166;
pub const _SC_USER_GROUPS_R: c_int = 167;
pub const _SC_2_PBS: c_int = 168;
pub const _SC_2_PBS_ACCOUNTING: c_int = 169;
pub const _SC_2_PBS_LOCATE: c_int = 170;
pub const _SC_2_PBS_MESSAGE: c_int = 171;
pub const _SC_2_PBS_TRACK: c_int = 172;
pub const _SC_SYMLOOP_MAX: c_int = 173;
pub const _SC_STREAMS: c_int = 174;
pub const _SC_2_PBS_CHECKPOINT: c_int = 175;
pub const _SC_V6_ILP32_OFF32: c_int = 176;
pub const _SC_V6_ILP32_OFFBIG: c_int = 177;
pub const _SC_V6_LP64_OFF64: c_int = 178;
pub const _SC_V6_LPBIG_OFFBIG: c_int = 179;
pub const _SC_HOST_NAME_MAX: c_int = 180;
pub const _SC_TRACE: c_int = 181;
pub const _SC_TRACE_EVENT_FILTER: c_int = 182;
pub const _SC_TRACE_INHERIT: c_int = 183;
pub const _SC_TRACE_LOG: c_int = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: c_int = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: c_int = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: c_int = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: c_int = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: c_int = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: c_int = 190;
pub const _SC_LEVEL2_CACHE_SIZE: c_int = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: c_int = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: c_int = 193;
pub const _SC_LEVEL3_CACHE_SIZE: c_int = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: c_int = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: c_int = 196;
pub const _SC_LEVEL4_CACHE_SIZE: c_int = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: c_int = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: c_int = 199;
pub const _SC_IPV6: c_int = 235;
pub const _SC_RAW_SOCKETS: c_int = 236;
pub const _SC_V7_ILP32_OFF32: c_int = 237;
pub const _SC_V7_ILP32_OFFBIG: c_int = 238;
pub const _SC_V7_LP64_OFF64: c_int = 239;
pub const _SC_V7_LPBIG_OFFBIG: c_int = 240;
pub const _SC_SS_REPL_MAX: c_int = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: c_int = 242;
pub const _SC_TRACE_NAME_MAX: c_int = 243;
pub const _SC_TRACE_SYS_MAX: c_int = 244;
pub const _SC_TRACE_USER_EVENT_MAX: c_int = 245;
pub const _SC_XOPEN_STREAMS: c_int = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: c_int = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: c_int = 248;
pub const _SC_MINSIGSTKSZ: c_int = 249;
pub const _SC_SIGSTKSZ: c_int = 250;
const enum_unnamed_15 = c_uint;
pub const _CS_PATH: c_int = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: c_int = 1;
pub const _CS_GNU_LIBC_VERSION: c_int = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: c_int = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: c_int = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: c_int = 5;
pub const _CS_LFS_CFLAGS: c_int = 1000;
pub const _CS_LFS_LDFLAGS: c_int = 1001;
pub const _CS_LFS_LIBS: c_int = 1002;
pub const _CS_LFS_LINTFLAGS: c_int = 1003;
pub const _CS_LFS64_CFLAGS: c_int = 1004;
pub const _CS_LFS64_LDFLAGS: c_int = 1005;
pub const _CS_LFS64_LIBS: c_int = 1006;
pub const _CS_LFS64_LINTFLAGS: c_int = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: c_int = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: c_int = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: c_int = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: c_int = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: c_int = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: c_int = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: c_int = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: c_int = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: c_int = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: c_int = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: c_int = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: c_int = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: c_int = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: c_int = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: c_int = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: c_int = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: c_int = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: c_int = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: c_int = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: c_int = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: c_int = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: c_int = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: c_int = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: c_int = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: c_int = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: c_int = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: c_int = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: c_int = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: c_int = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: c_int = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: c_int = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: c_int = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: c_int = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: c_int = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: c_int = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: c_int = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: c_int = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: c_int = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: c_int = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: c_int = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: c_int = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: c_int = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: c_int = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: c_int = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: c_int = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: c_int = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: c_int = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: c_int = 1147;
pub const _CS_V6_ENV: c_int = 1148;
pub const _CS_V7_ENV: c_int = 1149;
const enum_unnamed_16 = c_uint;
pub extern fn pathconf(__path: [*c]const u8, __name: c_int) c_long;
pub extern fn fpathconf(__fd: c_int, __name: c_int) c_long;
pub extern fn sysconf(__name: c_int) c_long;
pub extern fn confstr(__name: c_int, __buf: [*c]u8, __len: usize) usize;
pub extern fn getpid() __pid_t;
pub extern fn getppid() __pid_t;
pub extern fn getpgrp() __pid_t;
pub extern fn __getpgid(__pid: __pid_t) __pid_t;
pub extern fn getpgid(__pid: __pid_t) __pid_t;
pub extern fn setpgid(__pid: __pid_t, __pgid: __pid_t) c_int;
pub extern fn setpgrp() c_int;
pub extern fn setsid() __pid_t;
pub extern fn getsid(__pid: __pid_t) __pid_t;
pub extern fn getuid() __uid_t;
pub extern fn geteuid() __uid_t;
pub extern fn getgid() __gid_t;
pub extern fn getegid() __gid_t;
pub extern fn getgroups(__size: c_int, __list: [*c]__gid_t) c_int;
pub extern fn setuid(__uid: __uid_t) c_int;
pub extern fn setreuid(__ruid: __uid_t, __euid: __uid_t) c_int;
pub extern fn seteuid(__uid: __uid_t) c_int;
pub extern fn setgid(__gid: __gid_t) c_int;
pub extern fn setregid(__rgid: __gid_t, __egid: __gid_t) c_int;
pub extern fn setegid(__gid: __gid_t) c_int;
pub extern fn fork() __pid_t;
pub extern fn vfork() c_int;
pub extern fn ttyname(__fd: c_int) [*c]u8;
pub extern fn ttyname_r(__fd: c_int, __buf: [*c]u8, __buflen: usize) c_int;
pub extern fn isatty(__fd: c_int) c_int;
pub extern fn ttyslot() c_int;
pub extern fn link(__from: [*c]const u8, __to: [*c]const u8) c_int;
pub extern fn linkat(__fromfd: c_int, __from: [*c]const u8, __tofd: c_int, __to: [*c]const u8, __flags: c_int) c_int;
pub extern fn symlink(__from: [*c]const u8, __to: [*c]const u8) c_int;
pub extern fn readlink(noalias __path: [*c]const u8, noalias __buf: [*c]u8, __len: usize) isize;
pub extern fn symlinkat(__from: [*c]const u8, __tofd: c_int, __to: [*c]const u8) c_int;
pub extern fn readlinkat(__fd: c_int, noalias __path: [*c]const u8, noalias __buf: [*c]u8, __len: usize) isize;
pub extern fn unlink(__name: [*c]const u8) c_int;
pub extern fn unlinkat(__fd: c_int, __name: [*c]const u8, __flag: c_int) c_int;
pub extern fn rmdir(__path: [*c]const u8) c_int;
pub extern fn tcgetpgrp(__fd: c_int) __pid_t;
pub extern fn tcsetpgrp(__fd: c_int, __pgrp_id: __pid_t) c_int;
pub extern fn getlogin() [*c]u8;
pub extern fn getlogin_r(__name: [*c]u8, __name_len: usize) c_int;
pub extern fn setlogin(__name: [*c]const u8) c_int;
pub extern var optarg: [*c]u8;
pub extern var optind: c_int;
pub extern var opterr: c_int;
pub extern var optopt: c_int;
pub extern fn getopt(___argc: c_int, ___argv: [*c]const [*c]u8, __shortopts: [*c]const u8) c_int;
pub extern fn gethostname(__name: [*c]u8, __len: usize) c_int;
pub extern fn sethostname(__name: [*c]const u8, __len: usize) c_int;
pub extern fn sethostid(__id: c_long) c_int;
pub extern fn getdomainname(__name: [*c]u8, __len: usize) c_int;
pub extern fn setdomainname(__name: [*c]const u8, __len: usize) c_int;
pub extern fn vhangup() c_int;
pub extern fn revoke(__file: [*c]const u8) c_int;
pub extern fn profil(__sample_buffer: [*c]c_ushort, __size: usize, __offset: usize, __scale: c_uint) c_int;
pub extern fn acct(__name: [*c]const u8) c_int;
pub extern fn getusershell() [*c]u8;
pub extern fn endusershell() void;
pub extern fn setusershell() void;
pub extern fn daemon(__nochdir: c_int, __noclose: c_int) c_int;
pub extern fn chroot(__path: [*c]const u8) c_int;
pub extern fn getpass(__prompt: [*c]const u8) [*c]u8;
pub extern fn fsync(__fd: c_int) c_int;
pub extern fn gethostid() c_long;
pub extern fn sync() void;
pub extern fn getpagesize() c_int;
pub extern fn getdtablesize() c_int;
pub extern fn truncate(__file: [*c]const u8, __length: __off_t) c_int;
pub extern fn ftruncate(__fd: c_int, __length: __off_t) c_int;
pub extern fn brk(__addr: ?*anyopaque) c_int;
pub extern fn sbrk(__delta: isize) ?*anyopaque;
pub extern fn syscall(__sysno: c_long, ...) c_long;
pub extern fn lockf(__fd: c_int, __cmd: c_int, __len: __off_t) c_int;
pub extern fn fdatasync(__fildes: c_int) c_int;
pub extern fn crypt(__key: [*c]const u8, __salt: [*c]const u8) [*c]u8;
pub extern fn getentropy(__buffer: ?*anyopaque, __length: usize) c_int;
pub extern fn __errno_location() [*c]c_int;
pub const mp_digit = u64;
pub const mp_word = u128;
pub const mp_min_u32 = mp_digit;
pub const mp_err = c_int;
pub extern var KARATSUBA_MUL_CUTOFF: c_int;
pub extern var KARATSUBA_SQR_CUTOFF: c_int;
pub extern var TOOM_MUL_CUTOFF: c_int;
pub extern var TOOM_SQR_CUTOFF: c_int;
pub const mp_int = extern struct {
    used: c_int = @import("std").mem.zeroes(c_int),
    alloc: c_int = @import("std").mem.zeroes(c_int),
    sign: c_int = @import("std").mem.zeroes(c_int),
    dp: [*c]mp_digit = @import("std").mem.zeroes([*c]mp_digit),
};
pub const ltm_prime_callback = fn ([*c]u8, c_int, ?*anyopaque) callconv(.c) c_int;
pub extern fn mp_error_to_string(code: c_int) [*c]const u8;
pub export fn mp_init(arg_a: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var i: c_int = undefined;
    _ = &i;
    a.*.dp = @as([*c]mp_digit, @ptrCast(@alignCast(malloc(@sizeOf(mp_digit) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32))))))));
    if (a.*.dp == @as([*c]mp_digit, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        return -@as(c_int, 2);
    }
    {
        i = 0;
        while (i < @as(c_int, 32)) : (i += 1) {
            (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = 0;
        }
    }
    a.*.used = 0;
    a.*.alloc = 32;
    a.*.sign = 0;
    return 0;
}
pub export fn mp_clear(arg_a: [*c]mp_int) void {
    var a = arg_a;
    _ = &a;
    var i: c_int = undefined;
    _ = &i;
    if (a.*.dp != @as([*c]mp_digit, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        {
            i = 0;
            while (i < a.*.used) : (i += 1) {
                (blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).* = 0;
            }
        }
        free(@as(?*anyopaque, @ptrCast(a.*.dp)));
        a.*.dp = null;
        a.*.alloc = blk: {
            const tmp = @as(c_int, 0);
            a.*.used = tmp;
            break :blk tmp;
        };
        a.*.sign = 0;
    }
}
// ./libtomcrypt.c:6572:5: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn mp_init_multi(mp: [*c]mp_int, ...) c_int;
// ./libtomcrypt.c:4004:6: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn mp_clear_multi(mp: [*c]mp_int, ...) void;
pub export fn mp_exch(arg_a: [*c]mp_int, arg_b: [*c]mp_int) void {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var t: mp_int = undefined;
    _ = &t;
    t = a.*;
    a.* = b.*;
    b.* = t;
}
pub export fn mp_shrink(arg_a: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var tmp: [*c]mp_digit = undefined;
    _ = &tmp;
    var used: c_int = 1;
    _ = &used;
    if (a.*.used > @as(c_int, 0)) {
        used = a.*.used;
    }
    if (a.*.alloc != used) {
        if ((blk: {
            const tmp_1 = @as([*c]mp_digit, @ptrCast(@alignCast(realloc(@as(?*anyopaque, @ptrCast(a.*.dp)), @sizeOf(mp_digit) *% @as(c_ulong, @bitCast(@as(c_long, used)))))));
            tmp = tmp_1;
            break :blk tmp_1;
        }) == @as([*c]mp_digit, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
            return -@as(c_int, 2);
        }
        a.*.dp = tmp;
        a.*.alloc = used;
    }
    return 0;
}
pub export fn mp_grow(arg_a: [*c]mp_int, arg_size: c_int) c_int {
    var a = arg_a;
    _ = &a;
    var size = arg_size;
    _ = &size;
    var i: c_int = undefined;
    _ = &i;
    var tmp: [*c]mp_digit = undefined;
    _ = &tmp;
    if (a.*.alloc < size) {
        size += (@as(c_int, 32) * @as(c_int, 2)) - @import("std").zig.c_translation.signedRemainder(size, @as(c_int, 32));
        tmp = @as([*c]mp_digit, @ptrCast(@alignCast(realloc(@as(?*anyopaque, @ptrCast(a.*.dp)), @sizeOf(mp_digit) *% @as(c_ulong, @bitCast(@as(c_long, size)))))));
        if (tmp == @as([*c]mp_digit, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
            return -@as(c_int, 2);
        }
        a.*.dp = tmp;
        i = a.*.alloc;
        a.*.alloc = size;
        while (i < a.*.alloc) : (i += 1) {
            (blk: {
                const tmp_1 = i;
                if (tmp_1 >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp_1)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp_1)) +% -1));
            }).* = 0;
        }
    }
    return 0;
}
pub export fn mp_init_size(arg_a: [*c]mp_int, arg_size: c_int) c_int {
    var a = arg_a;
    _ = &a;
    var size = arg_size;
    _ = &size;
    var x: c_int = undefined;
    _ = &x;
    size += (@as(c_int, 32) * @as(c_int, 2)) - @import("std").zig.c_translation.signedRemainder(size, @as(c_int, 32));
    a.*.dp = @as([*c]mp_digit, @ptrCast(@alignCast(malloc(@sizeOf(mp_digit) *% @as(c_ulong, @bitCast(@as(c_long, size)))))));
    if (a.*.dp == @as([*c]mp_digit, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        return -@as(c_int, 2);
    }
    a.*.used = 0;
    a.*.alloc = size;
    a.*.sign = 0;
    {
        x = 0;
        while (x < size) : (x += 1) {
            (blk: {
                const tmp = x;
                if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = 0;
        }
    }
    return 0;
}
pub export fn mp_zero(arg_a: [*c]mp_int) void {
    var a = arg_a;
    _ = &a;
    var n: c_int = undefined;
    _ = &n;
    var tmp: [*c]mp_digit = undefined;
    _ = &tmp;
    a.*.sign = 0;
    a.*.used = 0;
    tmp = a.*.dp;
    {
        n = 0;
        while (n < a.*.alloc) : (n += 1) {
            (blk: {
                const ref = &tmp;
                const tmp_1 = ref.*;
                ref.* += 1;
                break :blk tmp_1;
            }).* = 0;
        }
    }
}
pub export fn mp_set(arg_a: [*c]mp_int, arg_b: mp_digit) void {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    mp_zero(a);
    a.*.dp[@as(c_uint, @intCast(@as(c_int, 0)))] = b & ((@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))));
    a.*.used = if (a.*.dp[@as(c_uint, @intCast(@as(c_int, 0)))] != @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0))))) @as(c_int, 1) else @as(c_int, 0);
}
pub export fn mp_set_int(arg_a: [*c]mp_int, arg_b: c_ulong) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var x: c_int = undefined;
    _ = &x;
    var res: c_int = undefined;
    _ = &res;
    mp_zero(a);
    {
        x = 0;
        while (x < @as(c_int, 8)) : (x += 1) {
            if ((blk: {
                const tmp = mp_mul_2d(a, @as(c_int, 4), a);
                res = tmp;
                break :blk tmp;
            }) != @as(c_int, 0)) {
                return res;
            }
            a.*.dp[@as(c_uint, @intCast(@as(c_int, 0)))] |= @as(mp_digit, @bitCast((b >> @intCast(28)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 15))))));
            b <<= @intCast(@as(c_int, 4));
            a.*.used += @as(c_int, 1);
        }
    }
    mp_clamp(a);
    return 0;
}
pub export fn mp_set_long(arg_a: [*c]mp_int, arg_b: c_ulong) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var x: c_uint = undefined;
    _ = &x;
    var res: c_int = undefined;
    _ = &res;
    mp_zero(a);
    {
        x = 0;
        while (@as(c_ulong, @bitCast(@as(c_ulong, x))) < (@sizeOf(c_ulong) *% @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, 2)))))) : (x +%= 1) {
            if ((blk: {
                const tmp = mp_mul_2d(a, @as(c_int, 4), a);
                res = tmp;
                break :blk tmp;
            }) != @as(c_int, 0)) {
                return res;
            }
            a.*.dp[@as(c_uint, @intCast(@as(c_int, 0)))] |= @as(mp_digit, @bitCast((b >> @intCast((@sizeOf(c_ulong) *% @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, 8))))) -% @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, 4)))))) & @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, 15))))));
            b <<= @intCast(@as(c_int, 4));
            a.*.used += @as(c_int, 1);
        }
    }
    mp_clamp(a);
    return 0;
}
pub export fn mp_set_long_long(arg_a: [*c]mp_int, arg_b: c_ulonglong) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var x: c_uint = undefined;
    _ = &x;
    var res: c_int = undefined;
    _ = &res;
    mp_zero(a);
    {
        x = 0;
        while (@as(c_ulong, @bitCast(@as(c_ulong, x))) < (@sizeOf(c_ulonglong) *% @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, 2)))))) : (x +%= 1) {
            if ((blk: {
                const tmp = mp_mul_2d(a, @as(c_int, 4), a);
                res = tmp;
                break :blk tmp;
            }) != @as(c_int, 0)) {
                return res;
            }
            a.*.dp[@as(c_uint, @intCast(@as(c_int, 0)))] |= @as(mp_digit, @bitCast(@as(c_ulong, @truncate((b >> @intCast((@sizeOf(c_ulonglong) *% @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, 8))))) -% @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, 4)))))) & @as(c_ulonglong, @bitCast(@as(c_ulonglong, @as(c_uint, 15))))))));
            b <<= @intCast(@as(c_int, 4));
            a.*.used += @as(c_int, 1);
        }
    }
    mp_clamp(a);
    return 0;
}
pub export fn mp_get_int(arg_a: [*c]mp_int) c_ulong {
    var a = arg_a;
    _ = &a;
    var i: c_int = undefined;
    _ = &i;
    var res: mp_min_u32 = undefined;
    _ = &res;
    if (a.*.used == @as(c_int, 0)) {
        return 0;
    }
    i = (if (a.*.used < @as(c_int, @bitCast(@as(c_uint, @truncate((((@sizeOf(c_ulong) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))) +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 60))))) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))) / @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 60))))))))) a.*.used else @as(c_int, @bitCast(@as(c_uint, @truncate((((@sizeOf(c_ulong) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))) +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 60))))) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))) / @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 60))))))))) - @as(c_int, 1);
    res = (blk: {
        const tmp = i;
        if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    while ((blk: {
        const ref = &i;
        ref.* -= 1;
        break :blk ref.*;
    }) >= @as(c_int, 0)) {
        res = (res << @intCast(60)) | (blk: {
            const tmp = i;
            if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*;
    }
    return res & @as(c_ulong, 4294967295);
}
pub export fn mp_get_long(arg_a: [*c]mp_int) c_ulong {
    var a = arg_a;
    _ = &a;
    var i: c_int = undefined;
    _ = &i;
    var res: c_ulong = undefined;
    _ = &res;
    if (a.*.used == @as(c_int, 0)) {
        return 0;
    }
    i = (if (a.*.used < @as(c_int, @bitCast(@as(c_uint, @truncate((((@sizeOf(c_ulong) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))) +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 60))))) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))) / @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 60))))))))) a.*.used else @as(c_int, @bitCast(@as(c_uint, @truncate((((@sizeOf(c_ulong) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))) +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 60))))) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))) / @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 60))))))))) - @as(c_int, 1);
    res = (blk: {
        const tmp = i;
        if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    while ((blk: {
        const ref = &i;
        ref.* -= 1;
        break :blk ref.*;
    }) >= @as(c_int, 0)) {
        res = (res << @intCast(60)) | (blk: {
            const tmp = i;
            if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*;
    }
    return res;
}
pub export fn mp_get_long_long(arg_a: [*c]mp_int) c_ulonglong {
    var a = arg_a;
    _ = &a;
    var i: c_int = undefined;
    _ = &i;
    var res: c_ulonglong = undefined;
    _ = &res;
    if (a.*.used == @as(c_int, 0)) {
        return 0;
    }
    i = (if (a.*.used < @as(c_int, @bitCast(@as(c_uint, @truncate((((@sizeOf(c_ulonglong) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))) +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 60))))) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))) / @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 60))))))))) a.*.used else @as(c_int, @bitCast(@as(c_uint, @truncate((((@sizeOf(c_ulonglong) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))) +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 60))))) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))) / @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 60))))))))) - @as(c_int, 1);
    res = @as(c_ulonglong, @bitCast(@as(c_ulonglong, (blk: {
        const tmp = i;
        if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*)));
    while ((blk: {
        const ref = &i;
        ref.* -= 1;
        break :blk ref.*;
    }) >= @as(c_int, 0)) {
        res = (res << @intCast(60)) | @as(c_ulonglong, @bitCast(@as(c_ulonglong, (blk: {
            const tmp = i;
            if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*)));
    }
    return res;
}
pub export fn mp_init_set(arg_a: [*c]mp_int, arg_b: mp_digit) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var err: c_int = undefined;
    _ = &err;
    if ((blk: {
        const tmp = mp_init(a);
        err = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return err;
    }
    mp_set(a, b);
    return err;
}
pub export fn mp_init_set_int(arg_a: [*c]mp_int, arg_b: c_ulong) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var err: c_int = undefined;
    _ = &err;
    if ((blk: {
        const tmp = mp_init(a);
        err = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return err;
    }
    return mp_set_int(a, b);
}
pub export fn mp_copy(arg_a: [*c]mp_int, arg_b: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var res: c_int = undefined;
    _ = &res;
    var n: c_int = undefined;
    _ = &n;
    if (a == b) {
        return 0;
    }
    if (b.*.alloc < a.*.used) {
        if ((blk: {
            const tmp = mp_grow(b, a.*.used);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    {
        var tmpa: [*c]mp_digit = undefined;
        _ = &tmpa;
        var tmpb: [*c]mp_digit = undefined;
        _ = &tmpb;
        tmpa = a.*.dp;
        tmpb = b.*.dp;
        {
            n = 0;
            while (n < a.*.used) : (n += 1) {
                (blk: {
                    const ref = &tmpb;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* = (blk: {
                    const ref = &tmpa;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).*;
            }
        }
        while (n < b.*.used) : (n += 1) {
            (blk: {
                const ref = &tmpb;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = 0;
        }
    }
    b.*.used = a.*.used;
    b.*.sign = a.*.sign;
    return 0;
}
pub export fn mp_init_copy(arg_a: [*c]mp_int, arg_b: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var res: c_int = undefined;
    _ = &res;
    if ((blk: {
        const tmp = mp_init_size(a, b.*.used);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    return mp_copy(b, a);
}
pub export fn mp_clamp(arg_a: [*c]mp_int) void {
    var a = arg_a;
    _ = &a;
    while ((a.*.used > @as(c_int, 0)) and ((blk: {
        const tmp = a.*.used - @as(c_int, 1);
        if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* == @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0)))))) {
        a.*.used -= 1;
    }
    if (a.*.used == @as(c_int, 0)) {
        a.*.sign = 0;
    }
}
pub export fn mp_import(arg_rop: [*c]mp_int, arg_count: usize, arg_order: c_int, arg_size: usize, arg_endian: c_int, arg_nails: usize, arg_op: ?*const anyopaque) c_int {
    var rop = arg_rop;
    _ = &rop;
    var count = arg_count;
    _ = &count;
    var order = arg_order;
    _ = &order;
    var size = arg_size;
    _ = &size;
    var endian = arg_endian;
    _ = &endian;
    var nails = arg_nails;
    _ = &nails;
    var op = arg_op;
    _ = &op;
    var result: c_int = undefined;
    _ = &result;
    var odd_nails: usize = undefined;
    _ = &odd_nails;
    var nail_bytes: usize = undefined;
    _ = &nail_bytes;
    var i: usize = undefined;
    _ = &i;
    var j: usize = undefined;
    _ = &j;
    var odd_nail_mask: u8 = undefined;
    _ = &odd_nail_mask;
    mp_zero(rop);
    if (endian == @as(c_int, 0)) {
        const union_unnamed_17 = extern union {
            i: c_uint,
            c: [4]u8,
        };
        _ = &union_unnamed_17;
        var lint: union_unnamed_17 = undefined;
        _ = &lint;
        lint.i = @as(c_uint, @bitCast(@as(c_int, 16909060)));
        endian = if (@as(c_int, @bitCast(@as(c_uint, lint.c[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 4)) -@as(c_int, 1) else @as(c_int, 1);
    }
    odd_nails = nails % @as(usize, @bitCast(@as(c_long, @as(c_int, 8))));
    odd_nail_mask = 255;
    {
        i = 0;
        while (i < odd_nails) : (i +%= 1) {
            odd_nail_mask ^= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1) << @intCast(@as(usize, @bitCast(@as(c_long, @as(c_int, 7)))) -% i)))));
        }
    }
    nail_bytes = nails / @as(usize, @bitCast(@as(c_long, @as(c_int, 8))));
    {
        i = 0;
        while (i < count) : (i +%= 1) {
            {
                j = 0;
                while (j < (size -% nail_bytes)) : (j +%= 1) {
                    var byte_1: u8 = ((@as([*c]u8, @ptrCast(@volatileCast(@constCast(op)))) + ((if (order == @as(c_int, 1)) i else (count -% @as(usize, @bitCast(@as(c_long, @as(c_int, 1))))) -% i) *% size)) + (if (endian == @as(c_int, 1)) j +% nail_bytes else ((size -% @as(usize, @bitCast(@as(c_long, @as(c_int, 1))))) -% j) -% nail_bytes)).*;
                    _ = &byte_1;
                    if ((blk: {
                        const tmp = mp_mul_2d(rop, @as(c_int, @bitCast(@as(c_uint, @truncate(if (j == @as(usize, @bitCast(@as(c_long, @as(c_int, 0))))) @as(usize, @bitCast(@as(c_long, @as(c_int, 8)))) -% odd_nails else @as(usize, @bitCast(@as(c_long, @as(c_int, 8)))))))), rop);
                        result = tmp;
                        break :blk tmp;
                    }) != @as(c_int, 0)) {
                        return result;
                    }
                    rop.*.dp[@as(c_uint, @intCast(@as(c_int, 0)))] |= @as(mp_digit, @bitCast(@as(c_long, if (j == @as(usize, @bitCast(@as(c_long, @as(c_int, 0))))) @as(c_int, @bitCast(@as(c_uint, byte_1))) & @as(c_int, @bitCast(@as(c_uint, odd_nail_mask))) else @as(c_int, @bitCast(@as(c_uint, byte_1))))));
                    rop.*.used += @as(c_int, 1);
                }
            }
        }
    }
    mp_clamp(rop);
    return 0;
}
pub export fn mp_export(arg_rop: ?*anyopaque, arg_countp: [*c]usize, arg_order: c_int, arg_size: usize, arg_endian: c_int, arg_nails: usize, arg_op: [*c]mp_int) c_int {
    var rop = arg_rop;
    _ = &rop;
    var countp = arg_countp;
    _ = &countp;
    var order = arg_order;
    _ = &order;
    var size = arg_size;
    _ = &size;
    var endian = arg_endian;
    _ = &endian;
    var nails = arg_nails;
    _ = &nails;
    var op = arg_op;
    _ = &op;
    var result: c_int = undefined;
    _ = &result;
    var odd_nails: usize = undefined;
    _ = &odd_nails;
    var nail_bytes: usize = undefined;
    _ = &nail_bytes;
    var i: usize = undefined;
    _ = &i;
    var j: usize = undefined;
    _ = &j;
    var bits: usize = undefined;
    _ = &bits;
    var count: usize = undefined;
    _ = &count;
    var odd_nail_mask: u8 = undefined;
    _ = &odd_nail_mask;
    var t: mp_int = undefined;
    _ = &t;
    if ((blk: {
        const tmp = mp_init_copy(&t, op);
        result = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return result;
    }
    if (endian == @as(c_int, 0)) {
        const union_unnamed_18 = extern union {
            i: c_uint,
            c: [4]u8,
        };
        _ = &union_unnamed_18;
        var lint: union_unnamed_18 = undefined;
        _ = &lint;
        lint.i = @as(c_uint, @bitCast(@as(c_int, 16909060)));
        endian = if (@as(c_int, @bitCast(@as(c_uint, lint.c[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 4)) -@as(c_int, 1) else @as(c_int, 1);
    }
    odd_nails = nails % @as(usize, @bitCast(@as(c_long, @as(c_int, 8))));
    odd_nail_mask = 255;
    {
        i = 0;
        while (i < odd_nails) : (i +%= 1) {
            odd_nail_mask ^= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1) << @intCast(@as(usize, @bitCast(@as(c_long, @as(c_int, 7)))) -% i)))));
        }
    }
    nail_bytes = nails / @as(usize, @bitCast(@as(c_long, @as(c_int, 8))));
    bits = @as(usize, @bitCast(@as(c_long, mp_count_bits(&t))));
    count = (bits / ((size *% @as(usize, @bitCast(@as(c_long, @as(c_int, 8))))) -% nails)) +% @as(usize, @bitCast(@as(c_long, if ((bits % ((size *% @as(usize, @bitCast(@as(c_long, @as(c_int, 8))))) -% nails)) != @as(usize, @bitCast(@as(c_long, @as(c_int, 0))))) @as(c_int, 1) else @as(c_int, 0))));
    {
        i = 0;
        while (i < count) : (i +%= 1) {
            {
                j = 0;
                while (j < size) : (j +%= 1) {
                    var byte_1: [*c]u8 = (@as([*c]u8, @ptrCast(@alignCast(rop))) + ((if (order == -@as(c_int, 1)) i else (count -% @as(usize, @bitCast(@as(c_long, @as(c_int, 1))))) -% i) *% size)) + (if (endian == -@as(c_int, 1)) j else (size -% @as(usize, @bitCast(@as(c_long, @as(c_int, 1))))) -% j);
                    _ = &byte_1;
                    if (j >= (size -% nail_bytes)) {
                        byte_1.* = 0;
                        continue;
                    }
                    byte_1.* = @as(u8, @bitCast(@as(u8, @truncate(if (j == ((size -% nail_bytes) -% @as(usize, @bitCast(@as(c_long, @as(c_int, 1)))))) t.dp[@as(c_uint, @intCast(@as(c_int, 0)))] & @as(mp_digit, @bitCast(@as(c_ulong, odd_nail_mask))) else t.dp[@as(c_uint, @intCast(@as(c_int, 0)))] & @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 255))))))));
                    if ((blk: {
                        const tmp = mp_div_2d(&t, @as(c_int, @bitCast(@as(c_uint, @truncate(if (j == ((size -% nail_bytes) -% @as(usize, @bitCast(@as(c_long, @as(c_int, 1)))))) @as(usize, @bitCast(@as(c_long, @as(c_int, 8)))) -% odd_nails else @as(usize, @bitCast(@as(c_long, @as(c_int, 8)))))))), &t, null);
                        result = tmp;
                        break :blk tmp;
                    }) != @as(c_int, 0)) {
                        mp_clear(&t);
                        return result;
                    }
                }
            }
        }
    }
    mp_clear(&t);
    if (countp != @as([*c]usize, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        countp.* = count;
    }
    return 0;
}
pub export fn mp_rshd(arg_a: [*c]mp_int, arg_b: c_int) void {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var x: c_int = undefined;
    _ = &x;
    if (b <= @as(c_int, 0)) {
        return;
    }
    if (a.*.used <= b) {
        mp_zero(a);
        return;
    }
    {
        var bottom: [*c]mp_digit = undefined;
        _ = &bottom;
        var top: [*c]mp_digit = undefined;
        _ = &top;
        bottom = a.*.dp;
        top = a.*.dp + @as(usize, @bitCast(@as(isize, @intCast(b))));
        {
            x = 0;
            while (x < (a.*.used - b)) : (x += 1) {
                (blk: {
                    const ref = &bottom;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* = (blk: {
                    const ref = &top;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).*;
            }
        }
        while (x < a.*.used) : (x += 1) {
            (blk: {
                const ref = &bottom;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = 0;
        }
    }
    a.*.used -= b;
}
pub export fn mp_lshd(arg_a: [*c]mp_int, arg_b: c_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var x: c_int = undefined;
    _ = &x;
    var res: c_int = undefined;
    _ = &res;
    if (b <= @as(c_int, 0)) {
        return 0;
    }
    if (a.*.alloc < (a.*.used + b)) {
        if ((blk: {
            const tmp = mp_grow(a, a.*.used + b);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    {
        var top: [*c]mp_digit = undefined;
        _ = &top;
        var bottom: [*c]mp_digit = undefined;
        _ = &bottom;
        a.*.used += b;
        top = (a.*.dp + @as(usize, @bitCast(@as(isize, @intCast(a.*.used))))) - @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1)))));
        bottom = ((a.*.dp + @as(usize, @bitCast(@as(isize, @intCast(a.*.used))))) - @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1)))))) - @as(usize, @bitCast(@as(isize, @intCast(b))));
        {
            x = a.*.used - @as(c_int, 1);
            while (x >= b) : (x -= 1) {
                (blk: {
                    const ref = &top;
                    const tmp = ref.*;
                    ref.* -= 1;
                    break :blk tmp;
                }).* = (blk: {
                    const ref = &bottom;
                    const tmp = ref.*;
                    ref.* -= 1;
                    break :blk tmp;
                }).*;
            }
        }
        top = a.*.dp;
        {
            x = 0;
            while (x < b) : (x += 1) {
                (blk: {
                    const ref = &top;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* = 0;
            }
        }
    }
    return 0;
}
pub export fn mp_div_2d(arg_a: [*c]mp_int, arg_b: c_int, arg_c: [*c]mp_int, arg_d: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var d = arg_d;
    _ = &d;
    var D_1: mp_digit = undefined;
    _ = &D_1;
    var r: mp_digit = undefined;
    _ = &r;
    var rr: mp_digit = undefined;
    _ = &rr;
    var x: c_int = undefined;
    _ = &x;
    var res: c_int = undefined;
    _ = &res;
    var t: mp_int = undefined;
    _ = &t;
    if (b <= @as(c_int, 0)) {
        res = mp_copy(a, c);
        if (d != @as([*c]mp_int, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
            mp_zero(d);
        }
        return res;
    }
    if ((blk: {
        const tmp = mp_init(&t);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    if (d != @as([*c]mp_int, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        if ((blk: {
            const tmp = mp_mod_2d(a, b, &t);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            mp_clear(&t);
            return res;
        }
    }
    if ((blk: {
        const tmp = mp_copy(a, c);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        mp_clear(&t);
        return res;
    }
    if (b >= @as(c_int, 60)) {
        mp_rshd(c, @divTrunc(b, @as(c_int, 60)));
    }
    D_1 = @as(mp_digit, @bitCast(@as(c_long, @import("std").zig.c_translation.signedRemainder(b, @as(c_int, 60)))));
    if (D_1 != @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0))))) {
        var tmpc: [*c]mp_digit = undefined;
        _ = &tmpc;
        var mask: mp_digit = undefined;
        _ = &mask;
        var shift: mp_digit = undefined;
        _ = &shift;
        mask = (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(D_1)) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1))));
        shift = @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))) -% D_1;
        tmpc = c.*.dp + @as(usize, @bitCast(@as(isize, @intCast(c.*.used - @as(c_int, 1)))));
        r = 0;
        {
            x = c.*.used - @as(c_int, 1);
            while (x >= @as(c_int, 0)) : (x -= 1) {
                rr = tmpc.* & mask;
                tmpc.* = (tmpc.* >> @intCast(D_1)) | (r << @intCast(shift));
                tmpc -= 1;
                r = rr;
            }
        }
    }
    mp_clamp(c);
    if (d != @as([*c]mp_int, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        mp_exch(&t, d);
    }
    mp_clear(&t);
    return 0;
}
pub export fn mp_div_2(arg_a: [*c]mp_int, arg_b: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var x: c_int = undefined;
    _ = &x;
    var res: c_int = undefined;
    _ = &res;
    var oldused: c_int = undefined;
    _ = &oldused;
    if (b.*.alloc < a.*.used) {
        if ((blk: {
            const tmp = mp_grow(b, a.*.used);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    oldused = b.*.used;
    b.*.used = a.*.used;
    {
        var r: mp_digit = undefined;
        _ = &r;
        var rr: mp_digit = undefined;
        _ = &rr;
        var tmpa: [*c]mp_digit = undefined;
        _ = &tmpa;
        var tmpb: [*c]mp_digit = undefined;
        _ = &tmpb;
        tmpa = (a.*.dp + @as(usize, @bitCast(@as(isize, @intCast(b.*.used))))) - @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1)))));
        tmpb = (b.*.dp + @as(usize, @bitCast(@as(isize, @intCast(b.*.used))))) - @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1)))));
        r = 0;
        {
            x = b.*.used - @as(c_int, 1);
            while (x >= @as(c_int, 0)) : (x -= 1) {
                rr = tmpa.* & @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1))));
                (blk: {
                    const ref = &tmpb;
                    const tmp = ref.*;
                    ref.* -= 1;
                    break :blk tmp;
                }).* = ((blk: {
                    const ref = &tmpa;
                    const tmp = ref.*;
                    ref.* -= 1;
                    break :blk tmp;
                }).* >> @intCast(1)) | (r << @intCast(@as(c_int, 60) - @as(c_int, 1)));
                r = rr;
            }
        }
        tmpb = b.*.dp + @as(usize, @bitCast(@as(isize, @intCast(b.*.used))));
        {
            x = b.*.used;
            while (x < oldused) : (x += 1) {
                (blk: {
                    const ref = &tmpb;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* = 0;
            }
        }
    }
    b.*.sign = a.*.sign;
    mp_clamp(b);
    return 0;
}
pub export fn mp_mul_2d(arg_a: [*c]mp_int, arg_b: c_int, arg_c: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var d: mp_digit = undefined;
    _ = &d;
    var res: c_int = undefined;
    _ = &res;
    if (a != c) {
        if ((blk: {
            const tmp = mp_copy(a, c);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    if (c.*.alloc < ((c.*.used + @divTrunc(b, @as(c_int, 60))) + @as(c_int, 1))) {
        if ((blk: {
            const tmp = mp_grow(c, (c.*.used + @divTrunc(b, @as(c_int, 60))) + @as(c_int, 1));
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    if (b >= @as(c_int, 60)) {
        if ((blk: {
            const tmp = mp_lshd(c, @divTrunc(b, @as(c_int, 60)));
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    d = @as(mp_digit, @bitCast(@as(c_long, @import("std").zig.c_translation.signedRemainder(b, @as(c_int, 60)))));
    if (d != @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0))))) {
        var tmpc: [*c]mp_digit = undefined;
        _ = &tmpc;
        var shift: mp_digit = undefined;
        _ = &shift;
        var mask: mp_digit = undefined;
        _ = &mask;
        var r: mp_digit = undefined;
        _ = &r;
        var rr: mp_digit = undefined;
        _ = &rr;
        var x: c_int = undefined;
        _ = &x;
        mask = (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(d)) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1))));
        shift = @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))) -% d;
        tmpc = c.*.dp;
        r = 0;
        {
            x = 0;
            while (x < c.*.used) : (x += 1) {
                rr = (tmpc.* >> @intCast(shift)) & mask;
                tmpc.* = ((tmpc.* << @intCast(d)) | r) & ((@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))));
                tmpc += 1;
                r = rr;
            }
        }
        if (r != @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0))))) {
            (blk: {
                const tmp = blk_1: {
                    const ref = &c.*.used;
                    const tmp_2 = ref.*;
                    ref.* += 1;
                    break :blk_1 tmp_2;
                };
                if (tmp >= 0) break :blk c.*.dp + @as(usize, @intCast(tmp)) else break :blk c.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = r;
        }
    }
    mp_clamp(c);
    return 0;
}
pub export fn mp_mul_2(arg_a: [*c]mp_int, arg_b: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var x: c_int = undefined;
    _ = &x;
    var res: c_int = undefined;
    _ = &res;
    var oldused: c_int = undefined;
    _ = &oldused;
    if (b.*.alloc < (a.*.used + @as(c_int, 1))) {
        if ((blk: {
            const tmp = mp_grow(b, a.*.used + @as(c_int, 1));
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    oldused = b.*.used;
    b.*.used = a.*.used;
    {
        var r: mp_digit = undefined;
        _ = &r;
        var rr: mp_digit = undefined;
        _ = &rr;
        var tmpa: [*c]mp_digit = undefined;
        _ = &tmpa;
        var tmpb: [*c]mp_digit = undefined;
        _ = &tmpb;
        tmpa = a.*.dp;
        tmpb = b.*.dp;
        r = 0;
        {
            x = 0;
            while (x < a.*.used) : (x += 1) {
                rr = tmpa.* >> @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60) - @as(c_int, 1)))));
                (blk: {
                    const ref = &tmpb;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* = (((blk: {
                    const ref = &tmpa;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))))) | r) & ((@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))));
                r = rr;
            }
        }
        if (r != @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0))))) {
            tmpb.* = 1;
            b.*.used += 1;
        }
        tmpb = b.*.dp + @as(usize, @bitCast(@as(isize, @intCast(b.*.used))));
        {
            x = b.*.used;
            while (x < oldused) : (x += 1) {
                (blk: {
                    const ref = &tmpb;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* = 0;
            }
        }
    }
    b.*.sign = a.*.sign;
    return 0;
}
pub export fn mp_mod_2d(arg_a: [*c]mp_int, arg_b: c_int, arg_c: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var x: c_int = undefined;
    _ = &x;
    var res: c_int = undefined;
    _ = &res;
    if (b <= @as(c_int, 0)) {
        mp_zero(c);
        return 0;
    }
    if (b >= (a.*.used * @as(c_int, 60))) {
        res = mp_copy(a, c);
        return res;
    }
    if ((blk: {
        const tmp = mp_copy(a, c);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    {
        x = @divTrunc(b, @as(c_int, 60)) + (if (@import("std").zig.c_translation.signedRemainder(b, @as(c_int, 60)) == @as(c_int, 0)) @as(c_int, 0) else @as(c_int, 1));
        while (x < c.*.used) : (x += 1) {
            (blk: {
                const tmp = x;
                if (tmp >= 0) break :blk c.*.dp + @as(usize, @intCast(tmp)) else break :blk c.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = 0;
        }
    }
    (blk: {
        const tmp = @divTrunc(b, @as(c_int, 60));
        if (tmp >= 0) break :blk c.*.dp + @as(usize, @intCast(tmp)) else break :blk c.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* &= (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, b))) % @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1))));
    mp_clamp(c);
    return 0;
}
pub export fn mp_2expt(arg_a: [*c]mp_int, arg_b: c_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var res: c_int = undefined;
    _ = &res;
    mp_zero(a);
    if ((blk: {
        const tmp = mp_grow(a, @divTrunc(b, @as(c_int, 60)) + @as(c_int, 1));
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    a.*.used = @divTrunc(b, @as(c_int, 60)) + @as(c_int, 1);
    (blk: {
        const tmp = @divTrunc(b, @as(c_int, 60));
        if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* = @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@import("std").zig.c_translation.signedRemainder(b, @as(c_int, 60)));
    return 0;
}
pub export fn mp_cnt_lsb(arg_a: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var x: c_int = undefined;
    _ = &x;
    var q: mp_digit = undefined;
    _ = &q;
    var qq: mp_digit = undefined;
    _ = &qq;
    if ((if (a.*.used == @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0)) == @as(c_int, 1)) {
        return 0;
    }
    {
        x = 0;
        while ((x < a.*.used) and ((blk: {
            const tmp = x;
            if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* == @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0)))))) : (x += 1) {}
    }
    q = (blk: {
        const tmp = x;
        if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    x *= @as(c_int, 60);
    if ((q & @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1))))) == @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0))))) {
        while (true) {
            qq = q & @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 15))));
            x += lnz[qq];
            q >>= @intCast(@as(c_int, 4));
            if (!(qq == @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0)))))) break;
        }
    }
    return x;
}
pub export fn mp_rand(arg_a: [*c]mp_int, arg_digits: c_int) c_int {
    var a = arg_a;
    _ = &a;
    var digits = arg_digits;
    _ = &digits;
    var res: c_int = undefined;
    _ = &res;
    var d: mp_digit = undefined;
    _ = &d;
    mp_zero(a);
    if (digits <= @as(c_int, 0)) {
        return 0;
    }
    while (true) {
        d = @as(mp_digit, @bitCast(@as(c_long, abs(rand())))) & ((@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))));
        if (!(d == @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0)))))) break;
    }
    if ((blk: {
        const tmp = mp_add_d(a, d, a);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    while ((blk: {
        const ref = &digits;
        ref.* -= 1;
        break :blk ref.*;
    }) > @as(c_int, 0)) {
        if ((blk: {
            const tmp = mp_lshd(a, @as(c_int, 1));
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
        if ((blk: {
            const tmp = mp_add_d(a, @as(mp_digit, @bitCast(@as(c_long, abs(rand())))), a);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    return 0;
}
pub export fn mp_xor(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var res: c_int = undefined;
    _ = &res;
    var ix: c_int = undefined;
    _ = &ix;
    var px: c_int = undefined;
    _ = &px;
    var t: mp_int = undefined;
    _ = &t;
    var x: [*c]mp_int = undefined;
    _ = &x;
    if (a.*.used > b.*.used) {
        if ((blk: {
            const tmp = mp_init_copy(&t, a);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
        px = b.*.used;
        x = b;
    } else {
        if ((blk: {
            const tmp = mp_init_copy(&t, b);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
        px = a.*.used;
        x = a;
    }
    {
        ix = 0;
        while (ix < px) : (ix += 1) {
            (blk: {
                const tmp = ix;
                if (tmp >= 0) break :blk t.dp + @as(usize, @intCast(tmp)) else break :blk t.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* ^= (blk: {
                const tmp = ix;
                if (tmp >= 0) break :blk x.*.dp + @as(usize, @intCast(tmp)) else break :blk x.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
        }
    }
    mp_clamp(&t);
    mp_exch(c, &t);
    mp_clear(&t);
    return 0;
}
pub export fn mp_or(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var res: c_int = undefined;
    _ = &res;
    var ix: c_int = undefined;
    _ = &ix;
    var px: c_int = undefined;
    _ = &px;
    var t: mp_int = undefined;
    _ = &t;
    var x: [*c]mp_int = undefined;
    _ = &x;
    if (a.*.used > b.*.used) {
        if ((blk: {
            const tmp = mp_init_copy(&t, a);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
        px = b.*.used;
        x = b;
    } else {
        if ((blk: {
            const tmp = mp_init_copy(&t, b);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
        px = a.*.used;
        x = a;
    }
    {
        ix = 0;
        while (ix < px) : (ix += 1) {
            (blk: {
                const tmp = ix;
                if (tmp >= 0) break :blk t.dp + @as(usize, @intCast(tmp)) else break :blk t.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* |= (blk: {
                const tmp = ix;
                if (tmp >= 0) break :blk x.*.dp + @as(usize, @intCast(tmp)) else break :blk x.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
        }
    }
    mp_clamp(&t);
    mp_exch(c, &t);
    mp_clear(&t);
    return 0;
}
pub export fn mp_and(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var res: c_int = undefined;
    _ = &res;
    var ix: c_int = undefined;
    _ = &ix;
    var px: c_int = undefined;
    _ = &px;
    var t: mp_int = undefined;
    _ = &t;
    var x: [*c]mp_int = undefined;
    _ = &x;
    if (a.*.used > b.*.used) {
        if ((blk: {
            const tmp = mp_init_copy(&t, a);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
        px = b.*.used;
        x = b;
    } else {
        if ((blk: {
            const tmp = mp_init_copy(&t, b);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
        px = a.*.used;
        x = a;
    }
    {
        ix = 0;
        while (ix < px) : (ix += 1) {
            (blk: {
                const tmp = ix;
                if (tmp >= 0) break :blk t.dp + @as(usize, @intCast(tmp)) else break :blk t.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* &= (blk: {
                const tmp = ix;
                if (tmp >= 0) break :blk x.*.dp + @as(usize, @intCast(tmp)) else break :blk x.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
        }
    }
    while (ix < t.used) : (ix += 1) {
        (blk: {
            const tmp = ix;
            if (tmp >= 0) break :blk t.dp + @as(usize, @intCast(tmp)) else break :blk t.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = 0;
    }
    mp_clamp(&t);
    mp_exch(c, &t);
    mp_clear(&t);
    return 0;
}
pub export fn mp_neg(arg_a: [*c]mp_int, arg_b: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var res: c_int = undefined;
    _ = &res;
    if (a != b) {
        if ((blk: {
            const tmp = mp_copy(a, b);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    if ((if (b.*.used == @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0)) != @as(c_int, 1)) {
        b.*.sign = if (a.*.sign == @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0);
    } else {
        b.*.sign = 0;
    }
    return 0;
}
pub export fn mp_abs(arg_a: [*c]mp_int, arg_b: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var res: c_int = undefined;
    _ = &res;
    if (a != b) {
        if ((blk: {
            const tmp = mp_copy(a, b);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    b.*.sign = 0;
    return 0;
}
pub export fn mp_cmp(arg_a: [*c]mp_int, arg_b: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    if (a.*.sign != b.*.sign) {
        if (a.*.sign == @as(c_int, 1)) {
            return -@as(c_int, 1);
        } else {
            return 1;
        }
    }
    if (a.*.sign == @as(c_int, 1)) {
        return mp_cmp_mag(b, a);
    } else {
        return mp_cmp_mag(a, b);
    }
    return 0;
}
pub export fn mp_cmp_mag(arg_a: [*c]mp_int, arg_b: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var n: c_int = undefined;
    _ = &n;
    var tmpa: [*c]mp_digit = undefined;
    _ = &tmpa;
    var tmpb: [*c]mp_digit = undefined;
    _ = &tmpb;
    if (a.*.used > b.*.used) {
        return 1;
    }
    if (a.*.used < b.*.used) {
        return -@as(c_int, 1);
    }
    tmpa = a.*.dp + @as(usize, @bitCast(@as(isize, @intCast(a.*.used - @as(c_int, 1)))));
    tmpb = b.*.dp + @as(usize, @bitCast(@as(isize, @intCast(a.*.used - @as(c_int, 1)))));
    {
        n = 0;
        while (n < a.*.used) : (_ = blk: {
            _ = blk_1: {
                n += 1;
                break :blk_1 blk_2: {
                    const ref = &tmpa;
                    ref.* -= 1;
                    break :blk_2 ref.*;
                };
            };
            break :blk blk_1: {
                const ref = &tmpb;
                ref.* -= 1;
                break :blk_1 ref.*;
            };
        }) {
            if (tmpa.* > tmpb.*) {
                return 1;
            }
            if (tmpa.* < tmpb.*) {
                return -@as(c_int, 1);
            }
        }
    }
    return 0;
}
pub export fn mp_add(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var sa: c_int = undefined;
    _ = &sa;
    var sb: c_int = undefined;
    _ = &sb;
    var res: c_int = undefined;
    _ = &res;
    sa = a.*.sign;
    sb = b.*.sign;
    if (sa == sb) {
        c.*.sign = sa;
        res = s_mp_add(a, b, c);
    } else {
        if (mp_cmp_mag(a, b) == -@as(c_int, 1)) {
            c.*.sign = sb;
            res = s_mp_sub(b, a, c);
        } else {
            c.*.sign = sa;
            res = s_mp_sub(a, b, c);
        }
    }
    return res;
}
pub export fn mp_sub(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var sa: c_int = undefined;
    _ = &sa;
    var sb: c_int = undefined;
    _ = &sb;
    var res: c_int = undefined;
    _ = &res;
    sa = a.*.sign;
    sb = b.*.sign;
    if (sa != sb) {
        c.*.sign = sa;
        res = s_mp_add(a, b, c);
    } else {
        if (mp_cmp_mag(a, b) != -@as(c_int, 1)) {
            c.*.sign = sa;
            res = s_mp_sub(a, b, c);
        } else {
            c.*.sign = if (sa == @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0);
            res = s_mp_sub(b, a, c);
        }
    }
    return res;
}
pub export fn mp_mul(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var res: c_int = undefined;
    _ = &res;
    var neg_1: c_int = undefined;
    _ = &neg_1;
    neg_1 = if (a.*.sign == b.*.sign) @as(c_int, 0) else @as(c_int, 1);
    if ((if (a.*.used < b.*.used) a.*.used else b.*.used) >= TOOM_MUL_CUTOFF) {
        res = mp_toom_mul(a, b, c);
    } else if ((if (a.*.used < b.*.used) a.*.used else b.*.used) >= KARATSUBA_MUL_CUTOFF) {
        res = mp_karatsuba_mul(a, b, c);
    } else {
        var digs: c_int = (a.*.used + b.*.used) + @as(c_int, 1);
        _ = &digs;
        if ((digs < (@as(c_int, 1) << @intCast(((@sizeOf(mp_word) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2) * @as(c_int, 60))))) +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))))) and ((if (a.*.used < b.*.used) a.*.used else b.*.used) <= (@as(c_int, 1) << @intCast((@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))) *% @sizeOf(mp_word)) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2) * @as(c_int, 60)))))))) {
            res = fast_s_mp_mul_digs(a, b, c, digs);
        } else {
            res = s_mp_mul_digs(a, b, c, (a.*.used + b.*.used) + @as(c_int, 1));
        }
    }
    c.*.sign = if (c.*.used > @as(c_int, 0)) neg_1 else @as(c_int, 0);
    return res;
}
pub export fn mp_sqr(arg_a: [*c]mp_int, arg_b: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var res: c_int = undefined;
    _ = &res;
    if (a.*.used >= TOOM_SQR_CUTOFF) {
        res = mp_toom_sqr(a, b);
    } else if (a.*.used >= KARATSUBA_SQR_CUTOFF) {
        res = mp_karatsuba_sqr(a, b);
    } else {
        if ((((a.*.used * @as(c_int, 2)) + @as(c_int, 1)) < (@as(c_int, 1) << @intCast(((@sizeOf(mp_word) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2) * @as(c_int, 60))))) +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))))) and (a.*.used < (@as(c_int, 1) << @intCast(((@sizeOf(mp_word) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2) * @as(c_int, 60))))) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))))))) {
            res = fast_s_mp_sqr(a, b);
        } else {
            res = s_mp_sqr(a, b);
        }
    }
    b.*.sign = 0;
    return res;
}
// ./libtomcrypt.c:4472:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:4444:5: warning: unable to translate function, demoted to extern
pub extern fn mp_div(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int, arg_d: [*c]mp_int) c_int;
pub export fn mp_mod(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var t: mp_int = undefined;
    _ = &t;
    var res: c_int = undefined;
    _ = &res;
    if ((blk: {
        const tmp = mp_init(&t);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    if ((blk: {
        const tmp = mp_div(a, b, null, &t);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        mp_clear(&t);
        return res;
    }
    if (((if ((&t).*.used == @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0)) != @as(c_int, 0)) or (t.sign == b.*.sign)) {
        res = 0;
        mp_exch(&t, c);
    } else {
        res = mp_add(b, &t, c);
    }
    mp_clear(&t);
    return res;
}
pub export fn mp_cmp_d(arg_a: [*c]mp_int, arg_b: mp_digit) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    if (a.*.sign == @as(c_int, 1)) {
        return -@as(c_int, 1);
    }
    if (a.*.used > @as(c_int, 1)) {
        return 1;
    }
    if (a.*.dp[@as(c_uint, @intCast(@as(c_int, 0)))] > b) {
        return 1;
    } else if (a.*.dp[@as(c_uint, @intCast(@as(c_int, 0)))] < b) {
        return -@as(c_int, 1);
    } else {
        return 0;
    }
    return 0;
}
pub export fn mp_add_d(arg_a: [*c]mp_int, arg_b: mp_digit, arg_c: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var res: c_int = undefined;
    _ = &res;
    var ix: c_int = undefined;
    _ = &ix;
    var oldused: c_int = undefined;
    _ = &oldused;
    var tmpa: [*c]mp_digit = undefined;
    _ = &tmpa;
    var tmpc: [*c]mp_digit = undefined;
    _ = &tmpc;
    var mu: mp_digit = undefined;
    _ = &mu;
    if (c.*.alloc < (a.*.used + @as(c_int, 1))) {
        if ((blk: {
            const tmp = mp_grow(c, a.*.used + @as(c_int, 1));
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    if ((a.*.sign == @as(c_int, 1)) and ((a.*.used > @as(c_int, 1)) or (a.*.dp[@as(c_uint, @intCast(@as(c_int, 0)))] >= b))) {
        a.*.sign = 0;
        res = mp_sub_d(a, b, c);
        a.*.sign = blk: {
            const tmp = @as(c_int, 1);
            c.*.sign = tmp;
            break :blk tmp;
        };
        mp_clamp(c);
        return res;
    }
    oldused = c.*.used;
    c.*.sign = 0;
    tmpa = a.*.dp;
    tmpc = c.*.dp;
    if (a.*.sign == @as(c_int, 0)) {
        tmpc.* = (blk: {
            const ref = &tmpa;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* +% b;
        mu = tmpc.* >> @intCast(60);
        (blk: {
            const ref = &tmpc;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* &= (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1))));
        {
            ix = 1;
            while (ix < a.*.used) : (ix += 1) {
                tmpc.* = (blk: {
                    const ref = &tmpa;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* +% mu;
                mu = tmpc.* >> @intCast(60);
                (blk: {
                    const ref = &tmpc;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* &= (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1))));
            }
        }
        ix += 1;
        (blk: {
            const ref = &tmpc;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = mu;
        c.*.used = a.*.used + @as(c_int, 1);
    } else {
        c.*.used = 1;
        if (a.*.used == @as(c_int, 1)) {
            (blk: {
                const ref = &tmpc;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = b -% a.*.dp[@as(c_uint, @intCast(@as(c_int, 0)))];
        } else {
            (blk: {
                const ref = &tmpc;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = b;
        }
        ix = 1;
    }
    while ((blk: {
        const ref = &ix;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }) < oldused) {
        (blk: {
            const ref = &tmpc;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = 0;
    }
    mp_clamp(c);
    return 0;
}
pub export fn mp_sub_d(arg_a: [*c]mp_int, arg_b: mp_digit, arg_c: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var tmpa: [*c]mp_digit = undefined;
    _ = &tmpa;
    var tmpc: [*c]mp_digit = undefined;
    _ = &tmpc;
    var mu: mp_digit = undefined;
    _ = &mu;
    var res: c_int = undefined;
    _ = &res;
    var ix: c_int = undefined;
    _ = &ix;
    var oldused: c_int = undefined;
    _ = &oldused;
    if (c.*.alloc < (a.*.used + @as(c_int, 1))) {
        if ((blk: {
            const tmp = mp_grow(c, a.*.used + @as(c_int, 1));
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    if (a.*.sign == @as(c_int, 1)) {
        a.*.sign = 0;
        res = mp_add_d(a, b, c);
        a.*.sign = blk: {
            const tmp = @as(c_int, 1);
            c.*.sign = tmp;
            break :blk tmp;
        };
        mp_clamp(c);
        return res;
    }
    oldused = c.*.used;
    tmpa = a.*.dp;
    tmpc = c.*.dp;
    if (((a.*.used == @as(c_int, 1)) and (a.*.dp[@as(c_uint, @intCast(@as(c_int, 0)))] <= b)) or (a.*.used == @as(c_int, 0))) {
        if (a.*.used == @as(c_int, 1)) {
            (blk: {
                const ref = &tmpc;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = b -% tmpa.*;
        } else {
            (blk: {
                const ref = &tmpc;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = b;
        }
        ix = 1;
        c.*.sign = 1;
        c.*.used = 1;
    } else {
        c.*.sign = 0;
        c.*.used = a.*.used;
        tmpc.* = (blk: {
            const ref = &tmpa;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* -% b;
        mu = tmpc.* >> @intCast((@sizeOf(mp_digit) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))));
        (blk: {
            const ref = &tmpc;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* &= (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1))));
        {
            ix = 1;
            while (ix < a.*.used) : (ix += 1) {
                tmpc.* = (blk: {
                    const ref = &tmpa;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* -% mu;
                mu = tmpc.* >> @intCast((@sizeOf(mp_digit) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))));
                (blk: {
                    const ref = &tmpc;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* &= (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1))));
            }
        }
    }
    while ((blk: {
        const ref = &ix;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }) < oldused) {
        (blk: {
            const ref = &tmpc;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = 0;
    }
    mp_clamp(c);
    return 0;
}
pub export fn mp_mul_d(arg_a: [*c]mp_int, arg_b: mp_digit, arg_c: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var u: mp_digit = undefined;
    _ = &u;
    var tmpa: [*c]mp_digit = undefined;
    _ = &tmpa;
    var tmpc: [*c]mp_digit = undefined;
    _ = &tmpc;
    var r: mp_word = undefined;
    _ = &r;
    var ix: c_int = undefined;
    _ = &ix;
    var res: c_int = undefined;
    _ = &res;
    var olduse: c_int = undefined;
    _ = &olduse;
    if (c.*.alloc < (a.*.used + @as(c_int, 1))) {
        if ((blk: {
            const tmp = mp_grow(c, a.*.used + @as(c_int, 1));
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    olduse = c.*.used;
    c.*.sign = a.*.sign;
    tmpa = a.*.dp;
    tmpc = c.*.dp;
    u = 0;
    {
        ix = 0;
        while (ix < a.*.used) : (ix += 1) {
            r = @as(mp_word, @bitCast(@as(u128, u))) +% (@as(mp_word, @bitCast(@as(u128, (blk: {
                const ref = &tmpa;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).*))) *% @as(mp_word, @bitCast(@as(u128, b))));
            (blk: {
                const ref = &tmpc;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(r & @as(mp_word, @bitCast(@as(u128, (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))))))))));
            u = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(r >> @intCast(@as(mp_word, @bitCast(@as(i128, @as(c_int, 60)))))))));
        }
    }
    (blk: {
        const ref = &tmpc;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }).* = u;
    ix += 1;
    while ((blk: {
        const ref = &ix;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }) < olduse) {
        (blk: {
            const ref = &tmpc;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = 0;
    }
    c.*.used = a.*.used + @as(c_int, 1);
    mp_clamp(c);
    return 0;
}
pub export fn mp_div_d(arg_a: [*c]mp_int, arg_b: mp_digit, arg_c: [*c]mp_int, arg_d: [*c]mp_digit) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var d = arg_d;
    _ = &d;
    var q: mp_int = undefined;
    _ = &q;
    var w: mp_word = undefined;
    _ = &w;
    var t: mp_digit = undefined;
    _ = &t;
    var res: c_int = undefined;
    _ = &res;
    var ix: c_int = undefined;
    _ = &ix;
    if (b == @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0))))) {
        return -@as(c_int, 3);
    }
    if ((b == @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1))))) or ((if (a.*.used == @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0)) == @as(c_int, 1))) {
        if (d != @as([*c]mp_digit, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
            d.* = 0;
        }
        if (c != @as([*c]mp_int, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
            return mp_copy(a, c);
        }
        return 0;
    }
    if (s_is_power_of_two(b, &ix) == @as(c_int, 1)) {
        if (d != @as([*c]mp_digit, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
            d.* = a.*.dp[@as(c_uint, @intCast(@as(c_int, 0)))] & ((@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(ix)) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))));
        }
        if (c != @as([*c]mp_int, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
            return mp_div_2d(a, ix, c, null);
        }
        return 0;
    }
    if (b == @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 3))))) {
        return mp_div_3(a, c, d);
    }
    if ((blk: {
        const tmp = mp_init_size(&q, a.*.used);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    q.used = a.*.used;
    q.sign = a.*.sign;
    w = 0;
    {
        ix = a.*.used - @as(c_int, 1);
        while (ix >= @as(c_int, 0)) : (ix -= 1) {
            w = (w << @intCast(@as(mp_word, @bitCast(@as(i128, @as(c_int, 60)))))) | @as(mp_word, @bitCast(@as(u128, (blk: {
                const tmp = ix;
                if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*)));
            if (w >= @as(mp_word, @bitCast(@as(u128, b)))) {
                t = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(w / @as(mp_word, @bitCast(@as(u128, b)))))));
                w -%= @as(mp_word, @bitCast(@as(u128, t))) *% @as(mp_word, @bitCast(@as(u128, b)));
            } else {
                t = 0;
            }
            (blk: {
                const tmp = ix;
                if (tmp >= 0) break :blk q.dp + @as(usize, @intCast(tmp)) else break :blk q.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = t;
        }
    }
    if (d != @as([*c]mp_digit, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        d.* = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(w))));
    }
    if (c != @as([*c]mp_int, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        mp_clamp(&q);
        mp_exch(&q, c);
    }
    mp_clear(&q);
    return res;
}
pub export fn mp_div_3(arg_a: [*c]mp_int, arg_c: [*c]mp_int, arg_d: [*c]mp_digit) c_int {
    var a = arg_a;
    _ = &a;
    var c = arg_c;
    _ = &c;
    var d = arg_d;
    _ = &d;
    var q: mp_int = undefined;
    _ = &q;
    var w: mp_word = undefined;
    _ = &w;
    var t: mp_word = undefined;
    _ = &t;
    var b: mp_digit = undefined;
    _ = &b;
    var res: c_int = undefined;
    _ = &res;
    var ix: c_int = undefined;
    _ = &ix;
    b = @as(mp_digit, @bitCast(@as(c_ulong, @truncate((@as(mp_word, @bitCast(@as(i128, @as(c_int, 1)))) << @intCast(@as(mp_word, @bitCast(@as(i128, @as(c_int, 60)))))) / @as(mp_word, @bitCast(@as(i128, @as(c_int, 3))))))));
    if ((blk: {
        const tmp = mp_init_size(&q, a.*.used);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    q.used = a.*.used;
    q.sign = a.*.sign;
    w = 0;
    {
        ix = a.*.used - @as(c_int, 1);
        while (ix >= @as(c_int, 0)) : (ix -= 1) {
            w = (w << @intCast(@as(mp_word, @bitCast(@as(i128, @as(c_int, 60)))))) | @as(mp_word, @bitCast(@as(u128, (blk: {
                const tmp = ix;
                if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*)));
            if (w >= @as(mp_word, @bitCast(@as(i128, @as(c_int, 3))))) {
                t = (w *% @as(mp_word, @bitCast(@as(u128, b)))) >> @intCast(@as(mp_word, @bitCast(@as(i128, @as(c_int, 60)))));
                w -%= (t +% t) +% t;
                while (w >= @as(mp_word, @bitCast(@as(i128, @as(c_int, 3))))) {
                    t +%= @as(mp_word, @bitCast(@as(i128, @as(c_int, 1))));
                    w -%= @as(mp_word, @bitCast(@as(i128, @as(c_int, 3))));
                }
            } else {
                t = 0;
            }
            (blk: {
                const tmp = ix;
                if (tmp >= 0) break :blk q.dp + @as(usize, @intCast(tmp)) else break :blk q.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(t))));
        }
    }
    if (d != @as([*c]mp_digit, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        d.* = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(w))));
    }
    if (c != @as([*c]mp_int, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        mp_clamp(&q);
        mp_exch(&q, c);
    }
    mp_clear(&q);
    return res;
}
pub export fn mp_expt_d(arg_a: [*c]mp_int, arg_b: mp_digit, arg_c: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    return mp_expt_d_ex(a, b, c, @as(c_int, 0));
}
pub export fn mp_expt_d_ex(arg_a: [*c]mp_int, arg_b: mp_digit, arg_c: [*c]mp_int, arg_fast: c_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var fast = arg_fast;
    _ = &fast;
    var res: c_int = undefined;
    _ = &res;
    var x: c_uint = undefined;
    _ = &x;
    var g: mp_int = undefined;
    _ = &g;
    if ((blk: {
        const tmp = mp_init_copy(&g, a);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    mp_set(c, @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))));
    if (fast != @as(c_int, 0)) {
        while (b > @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0))))) {
            if ((b & @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1))))) != @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0))))) {
                if ((blk: {
                    const tmp = mp_mul(c, &g, c);
                    res = tmp;
                    break :blk tmp;
                }) != @as(c_int, 0)) {
                    mp_clear(&g);
                    return res;
                }
            }
            if (b > @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1))))) {
                if ((blk: {
                    const tmp = mp_sqr(&g, &g);
                    res = tmp;
                    break :blk tmp;
                }) != @as(c_int, 0)) {
                    mp_clear(&g);
                    return res;
                }
            }
            b >>= @intCast(@as(c_int, 1));
        }
    } else {
        {
            x = 0;
            while (x < @as(c_uint, @bitCast(@as(c_int, 60)))) : (x +%= 1) {
                if ((blk: {
                    const tmp = mp_sqr(c, c);
                    res = tmp;
                    break :blk tmp;
                }) != @as(c_int, 0)) {
                    mp_clear(&g);
                    return res;
                }
                if ((b & (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(c_int, 60) - @as(c_int, 1)))) != @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0))))) {
                    if ((blk: {
                        const tmp = mp_mul(c, &g, c);
                        res = tmp;
                        break :blk tmp;
                    }) != @as(c_int, 0)) {
                        mp_clear(&g);
                        return res;
                    }
                }
                b <<= @intCast(@as(c_int, 1));
            }
        }
    }
    mp_clear(&g);
    return 0;
}
pub export fn mp_mod_d(arg_a: [*c]mp_int, arg_b: mp_digit, arg_c: [*c]mp_digit) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    return mp_div_d(a, b, null, c);
}
pub export fn mp_addmod(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int, arg_d: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var d = arg_d;
    _ = &d;
    var res: c_int = undefined;
    _ = &res;
    var t: mp_int = undefined;
    _ = &t;
    if ((blk: {
        const tmp = mp_init(&t);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    if ((blk: {
        const tmp = mp_add(a, b, &t);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        mp_clear(&t);
        return res;
    }
    res = mp_mod(&t, c, d);
    mp_clear(&t);
    return res;
}
pub export fn mp_submod(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int, arg_d: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var d = arg_d;
    _ = &d;
    var res: c_int = undefined;
    _ = &res;
    var t: mp_int = undefined;
    _ = &t;
    if ((blk: {
        const tmp = mp_init(&t);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    if ((blk: {
        const tmp = mp_sub(a, b, &t);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        mp_clear(&t);
        return res;
    }
    res = mp_mod(&t, c, d);
    mp_clear(&t);
    return res;
}
pub export fn mp_mulmod(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int, arg_d: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var d = arg_d;
    _ = &d;
    var res: c_int = undefined;
    _ = &res;
    var t: mp_int = undefined;
    _ = &t;
    if ((blk: {
        const tmp = mp_init(&t);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    if ((blk: {
        const tmp = mp_mul(a, b, &t);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        mp_clear(&t);
        return res;
    }
    res = mp_mod(&t, c, d);
    mp_clear(&t);
    return res;
}
pub export fn mp_sqrmod(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var res: c_int = undefined;
    _ = &res;
    var t: mp_int = undefined;
    _ = &t;
    if ((blk: {
        const tmp = mp_init(&t);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    if ((blk: {
        const tmp = mp_sqr(a, &t);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        mp_clear(&t);
        return res;
    }
    res = mp_mod(&t, b, c);
    mp_clear(&t);
    return res;
}
pub export fn mp_invmod(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    if ((b.*.sign == @as(c_int, 1)) or ((if (b.*.used == @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0)) == @as(c_int, 1))) {
        return -@as(c_int, 3);
    }
    if ((if ((b.*.used > @as(c_int, 0)) and ((b.*.dp[@as(c_uint, @intCast(@as(c_int, 0)))] & @as(mp_digit, @bitCast(@as(c_ulong, @as(c_uint, 1))))) == @as(mp_digit, @bitCast(@as(c_ulong, @as(c_uint, 1)))))) @as(c_int, 1) else @as(c_int, 0)) == @as(c_int, 1)) {
        return fast_mp_invmod(a, b, c);
    }
    return mp_invmod_slow(a, b, c);
}
// ./libtomcrypt.c:6134:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:6116:5: warning: unable to translate function, demoted to extern
pub extern fn mp_gcd(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int) c_int;
// ./libtomcrypt.c:5882:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:5871:5: warning: unable to translate function, demoted to extern
pub extern fn mp_exteuclid(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_U1: [*c]mp_int, arg_U2: [*c]mp_int, arg_U3: [*c]mp_int) c_int;
// ./libtomcrypt.c:7502:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:7491:5: warning: unable to translate function, demoted to extern
pub extern fn mp_lcm(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int) c_int;
pub export fn mp_n_root(arg_a: [*c]mp_int, arg_b: mp_digit, arg_c: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    return mp_n_root_ex(a, b, c, @as(c_int, 0));
}
// ./libtomcrypt.c:8417:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:8403:5: warning: unable to translate function, demoted to extern
pub extern fn mp_n_root_ex(arg_a: [*c]mp_int, arg_b: mp_digit, arg_c: [*c]mp_int, arg_fast: c_int) c_int;
// ./libtomcrypt.c:10507:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:10487:5: warning: unable to translate function, demoted to extern
pub extern fn mp_sqrt(arg_arg: [*c]mp_int, arg_ret: [*c]mp_int) c_int;
// ./libtomcrypt.c:10590:52: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:10568:5: warning: unable to translate function, demoted to extern
pub extern fn mp_sqrtmod_prime(arg_n: [*c]mp_int, arg_prime: [*c]mp_int, arg_ret: [*c]mp_int) c_int;
// ./libtomcrypt.c:7031:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:6995:5: warning: unable to translate function, demoted to extern
pub extern fn mp_is_square(arg_arg: [*c]mp_int, arg_ret: [*c]c_int) c_int;
// ./libtomcrypt.c:7125:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:7089:5: warning: unable to translate function, demoted to extern
pub extern fn mp_jacobi(arg_a: [*c]mp_int, arg_n: [*c]mp_int, arg_c: [*c]c_int) c_int;
pub export fn mp_reduce_setup(arg_a: [*c]mp_int, arg_b: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var res: c_int = undefined;
    _ = &res;
    if ((blk: {
        const tmp = mp_2expt(a, (b.*.used * @as(c_int, 2)) * @as(c_int, 60));
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    return mp_div(a, b, a, null);
}
// ./libtomcrypt.c:9660:13: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:9645:5: warning: unable to translate function, demoted to extern
pub extern fn mp_reduce(arg_x: [*c]mp_int, arg_m: [*c]mp_int, arg_mu: [*c]mp_int) c_int;
pub export fn mp_montgomery_setup(arg_n: [*c]mp_int, arg_rho: [*c]mp_digit) c_int {
    var n = arg_n;
    _ = &n;
    var rho = arg_rho;
    _ = &rho;
    var x: mp_digit = undefined;
    _ = &x;
    var b: mp_digit = undefined;
    _ = &b;
    b = n.*.dp[@as(c_uint, @intCast(@as(c_int, 0)))];
    if ((b & @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1))))) == @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0))))) {
        return -@as(c_int, 3);
    }
    x = (((b +% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 2))))) & @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 4))))) << @intCast(1)) +% b;
    x *%= @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 2)))) -% (b *% x);
    x *%= @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 2)))) -% (b *% x);
    x *%= @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 2)))) -% (b *% x);
    x *%= @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 2)))) -% (b *% x);
    rho.* = @as(mp_digit, @bitCast(@as(c_ulong, @truncate((@as(mp_word, @bitCast(@as(i128, @as(c_int, 1)))) << @intCast(@as(mp_word, @bitCast(@as(i128, @as(c_int, 60)))))) -% @as(mp_word, @bitCast(@as(u128, x))))))) & ((@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))));
    return 0;
}
pub export fn mp_montgomery_calc_normalization(arg_a: [*c]mp_int, arg_b: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var x: c_int = undefined;
    _ = &x;
    var bits: c_int = undefined;
    _ = &bits;
    var res: c_int = undefined;
    _ = &res;
    bits = @import("std").zig.c_translation.signedRemainder(mp_count_bits(b), @as(c_int, 60));
    if (b.*.used > @as(c_int, 1)) {
        if ((blk: {
            const tmp = mp_2expt(a, (((b.*.used - @as(c_int, 1)) * @as(c_int, 60)) + bits) - @as(c_int, 1));
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    } else {
        mp_set(a, @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))));
        bits = 1;
    }
    {
        x = bits - @as(c_int, 1);
        while (x < @as(c_int, 60)) : (x += 1) {
            if ((blk: {
                const tmp = mp_mul_2(a, a);
                res = tmp;
                break :blk tmp;
            }) != @as(c_int, 0)) {
                return res;
            }
            if (mp_cmp_mag(a, b) != -@as(c_int, 1)) {
                if ((blk: {
                    const tmp = s_mp_sub(a, b, a);
                    res = tmp;
                    break :blk tmp;
                }) != @as(c_int, 0)) {
                    return res;
                }
            }
        }
    }
    return 0;
}
pub export fn mp_montgomery_reduce(arg_x: [*c]mp_int, arg_n: [*c]mp_int, arg_rho: mp_digit) c_int {
    var x = arg_x;
    _ = &x;
    var n = arg_n;
    _ = &n;
    var rho = arg_rho;
    _ = &rho;
    var ix: c_int = undefined;
    _ = &ix;
    var res: c_int = undefined;
    _ = &res;
    var digs: c_int = undefined;
    _ = &digs;
    var mu: mp_digit = undefined;
    _ = &mu;
    digs = (n.*.used * @as(c_int, 2)) + @as(c_int, 1);
    if ((digs < (@as(c_int, 1) << @intCast(((@sizeOf(mp_word) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2) * @as(c_int, 60))))) +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))))) and (n.*.used < (@as(c_int, 1) << @intCast((@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))) *% @sizeOf(mp_word)) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2) * @as(c_int, 60)))))))) {
        return fast_mp_montgomery_reduce(x, n, rho);
    }
    if (x.*.alloc < digs) {
        if ((blk: {
            const tmp = mp_grow(x, digs);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    x.*.used = digs;
    {
        ix = 0;
        while (ix < n.*.used) : (ix += 1) {
            mu = @as(mp_digit, @bitCast(@as(c_ulong, @truncate((@as(mp_word, @bitCast(@as(u128, (blk: {
                const tmp = ix;
                if (tmp >= 0) break :blk x.*.dp + @as(usize, @intCast(tmp)) else break :blk x.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))) *% @as(mp_word, @bitCast(@as(u128, rho)))) & @as(mp_word, @bitCast(@as(u128, (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))))))))));
            {
                var iy: c_int = undefined;
                _ = &iy;
                var tmpn: [*c]mp_digit = undefined;
                _ = &tmpn;
                var tmpx: [*c]mp_digit = undefined;
                _ = &tmpx;
                var u: mp_digit = undefined;
                _ = &u;
                var r: mp_word = undefined;
                _ = &r;
                tmpn = n.*.dp;
                tmpx = x.*.dp + @as(usize, @bitCast(@as(isize, @intCast(ix))));
                u = 0;
                {
                    iy = 0;
                    while (iy < n.*.used) : (iy += 1) {
                        r = ((@as(mp_word, @bitCast(@as(u128, mu))) *% @as(mp_word, @bitCast(@as(u128, (blk: {
                            const ref = &tmpn;
                            const tmp = ref.*;
                            ref.* += 1;
                            break :blk tmp;
                        }).*)))) +% @as(mp_word, @bitCast(@as(u128, u)))) +% @as(mp_word, @bitCast(@as(u128, tmpx.*)));
                        u = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(r >> @intCast(@as(mp_word, @bitCast(@as(i128, @as(c_int, 60)))))))));
                        (blk: {
                            const ref = &tmpx;
                            const tmp = ref.*;
                            ref.* += 1;
                            break :blk tmp;
                        }).* = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(r & @as(mp_word, @bitCast(@as(u128, (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))))))))));
                    }
                }
                while (u != @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0))))) {
                    tmpx.* +%= u;
                    u = tmpx.* >> @intCast(60);
                    (blk: {
                        const ref = &tmpx;
                        const tmp = ref.*;
                        ref.* += 1;
                        break :blk tmp;
                    }).* &= (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1))));
                }
            }
        }
    }
    mp_clamp(x);
    mp_rshd(x, n.*.used);
    if (mp_cmp_mag(x, n) != -@as(c_int, 1)) {
        return s_mp_sub(x, n, x);
    }
    return 0;
}
pub export fn mp_dr_is_modulus(arg_a: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var ix: c_int = undefined;
    _ = &ix;
    if (a.*.used < @as(c_int, 2)) {
        return 0;
    }
    {
        ix = 1;
        while (ix < a.*.used) : (ix += 1) {
            if ((blk: {
                const tmp = ix;
                if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* != ((@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))))) {
                return 0;
            }
        }
    }
    return 1;
}
pub export fn mp_dr_setup(arg_a: [*c]mp_int, arg_d: [*c]mp_digit) void {
    var a = arg_a;
    _ = &a;
    var d = arg_d;
    _ = &d;
    d.* = @as(mp_digit, @bitCast(@as(c_ulong, @truncate((@as(mp_word, @bitCast(@as(i128, @as(c_int, 1)))) << @intCast(@as(mp_word, @bitCast(@as(i128, @as(c_int, 60)))))) -% @as(mp_word, @bitCast(@as(u128, a.*.dp[@as(c_uint, @intCast(@as(c_int, 0)))])))))));
}
// ./libtomcrypt.c:5095:1: warning: TODO implement translation of stmt class LabelStmtClass

// ./libtomcrypt.c:5077:1: warning: unable to translate function, demoted to extern
pub extern fn mp_dr_reduce(arg_x: [*c]mp_int, arg_n: [*c]mp_int, arg_k: mp_digit) c_int;
pub export fn mp_reduce_is_2k(arg_a: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var ix: c_int = undefined;
    _ = &ix;
    var iy: c_int = undefined;
    _ = &iy;
    var iw: c_int = undefined;
    _ = &iw;
    var iz: mp_digit = undefined;
    _ = &iz;
    if (a.*.used == @as(c_int, 0)) {
        return 0;
    } else if (a.*.used == @as(c_int, 1)) {
        return 1;
    } else if (a.*.used > @as(c_int, 1)) {
        iy = mp_count_bits(a);
        iz = 1;
        iw = 1;
        {
            ix = 60;
            while (ix < iy) : (ix += 1) {
                if (((blk: {
                    const tmp = iw;
                    if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).* & iz) == @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0))))) {
                    return 0;
                }
                iz <<= @intCast(@as(c_int, 1));
                if (iz > ((@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))))) {
                    iw += 1;
                    iz = 1;
                }
            }
        }
    }
    return 1;
}
pub export fn mp_reduce_2k_setup(arg_a: [*c]mp_int, arg_d: [*c]mp_digit) c_int {
    var a = arg_a;
    _ = &a;
    var d = arg_d;
    _ = &d;
    var res: c_int = undefined;
    _ = &res;
    var p: c_int = undefined;
    _ = &p;
    var tmp: mp_int = undefined;
    _ = &tmp;
    if ((blk: {
        const tmp_1 = mp_init(&tmp);
        res = tmp_1;
        break :blk tmp_1;
    }) != @as(c_int, 0)) {
        return res;
    }
    p = mp_count_bits(a);
    if ((blk: {
        const tmp_1 = mp_2expt(&tmp, p);
        res = tmp_1;
        break :blk tmp_1;
    }) != @as(c_int, 0)) {
        mp_clear(&tmp);
        return res;
    }
    if ((blk: {
        const tmp_1 = s_mp_sub(&tmp, a, &tmp);
        res = tmp_1;
        break :blk tmp_1;
    }) != @as(c_int, 0)) {
        mp_clear(&tmp);
        return res;
    }
    d.* = tmp.dp[@as(c_uint, @intCast(@as(c_int, 0)))];
    mp_clear(&tmp);
    return 0;
}
// ./libtomcrypt.c:9753:1: warning: TODO implement translation of stmt class LabelStmtClass

// ./libtomcrypt.c:9744:5: warning: unable to translate function, demoted to extern
pub extern fn mp_reduce_2k(arg_a: [*c]mp_int, arg_n: [*c]mp_int, arg_d: mp_digit) c_int;
pub export fn mp_reduce_is_2k_l(arg_a: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var ix: c_int = undefined;
    _ = &ix;
    var iy: c_int = undefined;
    _ = &iy;
    if (a.*.used == @as(c_int, 0)) {
        return 0;
    } else if (a.*.used == @as(c_int, 1)) {
        return 1;
    } else if (a.*.used > @as(c_int, 1)) {
        {
            iy = blk: {
                const tmp = @as(c_int, 0);
                ix = tmp;
                break :blk tmp;
            };
            while (ix < a.*.used) : (ix += 1) {
                if ((blk: {
                    const tmp = ix;
                    if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).* == ((@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))))) {
                    iy += 1;
                }
            }
        }
        return if (iy >= @divTrunc(a.*.used, @as(c_int, 2))) @as(c_int, 1) else @as(c_int, 0);
    }
    return 0;
}
// ./libtomcrypt.c:9931:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:9922:5: warning: unable to translate function, demoted to extern
pub extern fn mp_reduce_2k_setup_l(arg_a: [*c]mp_int, arg_d: [*c]mp_int) c_int;
// ./libtomcrypt.c:9820:1: warning: TODO implement translation of stmt class LabelStmtClass

// ./libtomcrypt.c:9811:5: warning: unable to translate function, demoted to extern
pub extern fn mp_reduce_2k_l(arg_a: [*c]mp_int, arg_n: [*c]mp_int, arg_d: [*c]mp_int) c_int;
pub export fn mp_exptmod(arg_G_1: [*c]mp_int, arg_X_2: [*c]mp_int, arg_P: [*c]mp_int, arg_Y_3: [*c]mp_int) c_int {
    var G_1 = arg_G_1;
    _ = &G_1;
    var X_2 = arg_X_2;
    _ = &X_2;
    var P = arg_P;
    _ = &P;
    var Y_3 = arg_Y_3;
    _ = &Y_3;
    var dr: c_int = undefined;
    _ = &dr;
    if (P.*.sign == @as(c_int, 1)) {
        return -@as(c_int, 3);
    }
    if (X_2.*.sign == @as(c_int, 1)) {
        var tmpG: mp_int = undefined;
        _ = &tmpG;
        var tmpX: mp_int = undefined;
        _ = &tmpX;
        var err: c_int = undefined;
        _ = &err;
        if ((blk: {
            const tmp = mp_init(&tmpG);
            err = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return err;
        }
        if ((blk: {
            const tmp = mp_invmod(G_1, P, &tmpG);
            err = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            mp_clear(&tmpG);
            return err;
        }
        if ((blk: {
            const tmp = mp_init(&tmpX);
            err = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            mp_clear(&tmpG);
            return err;
        }
        if ((blk: {
            const tmp = mp_abs(X_2, &tmpX);
            err = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            mp_clear_multi(&tmpG, &tmpX, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
            return err;
        }
        err = mp_exptmod(&tmpG, &tmpX, P, Y_3);
        mp_clear_multi(&tmpG, &tmpX, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
        return err;
    }
    if (mp_reduce_is_2k_l(P) == @as(c_int, 1)) {
        return s_mp_exptmod(G_1, X_2, P, Y_3, @as(c_int, 1));
    }
    dr = mp_dr_is_modulus(P);
    if (dr == @as(c_int, 0)) {
        dr = mp_reduce_is_2k(P) << @intCast(1);
    }
    if (((if ((P.*.used > @as(c_int, 0)) and ((P.*.dp[@as(c_uint, @intCast(@as(c_int, 0)))] & @as(mp_digit, @bitCast(@as(c_ulong, @as(c_uint, 1))))) == @as(mp_digit, @bitCast(@as(c_ulong, @as(c_uint, 1)))))) @as(c_int, 1) else @as(c_int, 0)) == @as(c_int, 1)) or (dr != @as(c_int, 0))) {
        return mp_exptmod_fast(G_1, X_2, P, Y_3, dr);
    } else {
        return s_mp_exptmod(G_1, X_2, P, Y_3, @as(c_int, 0));
    }
    return 0;
}
pub extern const ltm_prime_tab: [256]mp_digit;
pub export fn mp_prime_is_divisible(arg_a: [*c]mp_int, arg_result: [*c]c_int) c_int {
    var a = arg_a;
    _ = &a;
    var result = arg_result;
    _ = &result;
    var err: c_int = undefined;
    _ = &err;
    var ix: c_int = undefined;
    _ = &ix;
    var res: mp_digit = undefined;
    _ = &res;
    result.* = 0;
    {
        ix = 0;
        while (ix < @as(c_int, 256)) : (ix += 1) {
            if ((blk: {
                const tmp = mp_mod_d(a, ltm_prime_tab[@as(c_uint, @intCast(ix))], &res);
                err = tmp;
                break :blk tmp;
            }) != @as(c_int, 0)) {
                return err;
            }
            if (res == @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0))))) {
                result.* = 1;
                return 0;
            }
        }
    }
    return 0;
}
// ./libtomcrypt.c:8649:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:8630:5: warning: unable to translate function, demoted to extern
pub extern fn mp_prime_fermat(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_result: [*c]c_int) c_int;
// ./libtomcrypt.c:8847:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:8830:5: warning: unable to translate function, demoted to extern
pub extern fn mp_prime_miller_rabin(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_result: [*c]c_int) c_int;
const struct_unnamed_19 = extern struct {
    k: c_int = @import("std").mem.zeroes(c_int),
    t: c_int = @import("std").mem.zeroes(c_int),
};
pub export fn mp_prime_rabin_miller_trials(arg_size: c_int) c_int {
    var size = arg_size;
    _ = &size;
    var x: c_int = undefined;
    _ = &x;
    {
        x = 0;
        while (x < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([8]struct_unnamed_19) / @sizeOf(struct_unnamed_19)))))) : (x += 1) {
            if (sizes[@as(c_uint, @intCast(x))].k == size) {
                return sizes[@as(c_uint, @intCast(x))].t;
            } else if (sizes[@as(c_uint, @intCast(x))].k > size) {
                return if (x == @as(c_int, 0)) sizes[@as(c_uint, @intCast(@as(c_int, 0)))].t else sizes[@as(c_uint, @intCast(x - @as(c_int, 1)))].t;
            }
        }
    }
    return sizes[@as(c_uint, @intCast(x - @as(c_int, 1)))].t + @as(c_int, 1);
}
// ./libtomcrypt.c:8785:13: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:8745:5: warning: unable to translate function, demoted to extern
pub extern fn mp_prime_is_prime(arg_a: [*c]mp_int, arg_t: c_int, arg_result: [*c]c_int) c_int;
// ./libtomcrypt.c:9047:13: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:8933:5: warning: unable to translate function, demoted to extern
pub extern fn mp_prime_next_prime(arg_a: [*c]mp_int, arg_t: c_int, arg_bbs_style: c_int) c_int;
// ./libtomcrypt.c:9211:13: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:9168:5: warning: unable to translate function, demoted to extern
pub extern fn mp_prime_random_ex(arg_a: [*c]mp_int, arg_t: c_int, arg_size: c_int, arg_flags: c_int, arg_cb: ?*const ltm_prime_callback, arg_dat: ?*anyopaque) c_int;
pub export fn mp_count_bits(arg_a: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var r: c_int = undefined;
    _ = &r;
    var q: mp_digit = undefined;
    _ = &q;
    if (a.*.used == @as(c_int, 0)) {
        return 0;
    }
    r = (a.*.used - @as(c_int, 1)) * @as(c_int, 60);
    q = (blk: {
        const tmp = a.*.used - @as(c_int, 1);
        if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    while (q > @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0))))) {
        r += 1;
        q >>= @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))));
    }
    return r;
}
pub export fn mp_unsigned_bin_size(arg_a: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var size: c_int = mp_count_bits(a);
    _ = &size;
    return @divTrunc(size, @as(c_int, 8)) + (if ((size & @as(c_int, 7)) != @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0));
}
pub export fn mp_read_unsigned_bin(arg_a: [*c]mp_int, arg_b: [*c]const u8, arg_c: c_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var res: c_int = undefined;
    _ = &res;
    if (a.*.alloc < @as(c_int, 2)) {
        if ((blk: {
            const tmp = mp_grow(a, @as(c_int, 2));
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    mp_zero(a);
    while ((blk: {
        const ref = &c;
        const tmp = ref.*;
        ref.* -= 1;
        break :blk tmp;
    }) > @as(c_int, 0)) {
        if ((blk: {
            const tmp = mp_mul_2d(a, @as(c_int, 8), a);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
        a.*.dp[@as(c_uint, @intCast(@as(c_int, 0)))] |= @as(mp_digit, @bitCast(@as(c_ulong, (blk: {
            const ref = &b;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).*)));
        a.*.used += @as(c_int, 1);
    }
    mp_clamp(a);
    return 0;
}
pub export fn mp_to_unsigned_bin(arg_a: [*c]mp_int, arg_b: [*c]u8) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var x: c_int = undefined;
    _ = &x;
    var res: c_int = undefined;
    _ = &res;
    var t: mp_int = undefined;
    _ = &t;
    if ((blk: {
        const tmp = mp_init_copy(&t, a);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    x = 0;
    while ((if ((&t).*.used == @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0)) == @as(c_int, 0)) {
        (blk: {
            const tmp = blk_1: {
                const ref = &x;
                const tmp_2 = ref.*;
                ref.* += 1;
                break :blk_1 tmp_2;
            };
            if (tmp >= 0) break :blk b + @as(usize, @intCast(tmp)) else break :blk b - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = @as(u8, @bitCast(@as(u8, @truncate(t.dp[@as(c_uint, @intCast(@as(c_int, 0)))] & @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 255))))))));
        if ((blk: {
            const tmp = mp_div_2d(&t, @as(c_int, 8), &t, null);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            mp_clear(&t);
            return res;
        }
    }
    bn_reverse(b, x);
    mp_clear(&t);
    return 0;
}
pub extern fn mp_to_unsigned_bin_n(a: [*c]mp_int, b: [*c]u8, outlen: [*c]c_ulong) c_int;
pub export fn mp_signed_bin_size(arg_a: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    return @as(c_int, 1) + mp_unsigned_bin_size(a);
}
pub export fn mp_read_signed_bin(arg_a: [*c]mp_int, arg_b: [*c]const u8, arg_c: c_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var res: c_int = undefined;
    _ = &res;
    if ((blk: {
        const tmp = mp_read_unsigned_bin(a, b + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))), c - @as(c_int, 1));
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    if (@as(c_int, @bitCast(@as(c_uint, b[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 0)) {
        a.*.sign = 0;
    } else {
        a.*.sign = 1;
    }
    return 0;
}
pub export fn mp_to_signed_bin(arg_a: [*c]mp_int, arg_b: [*c]u8) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var res: c_int = undefined;
    _ = &res;
    if ((blk: {
        const tmp = mp_to_unsigned_bin(a, b + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))));
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    b[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(i8, @truncate(if (a.*.sign == @as(c_int, 0)) @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0)))))))) else @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))))))))));
    return 0;
}
pub export fn mp_to_signed_bin_n(arg_a: [*c]mp_int, arg_b: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var outlen = arg_outlen;
    _ = &outlen;
    if (outlen.* < @as(c_ulong, @bitCast(@as(c_long, mp_signed_bin_size(a))))) {
        return -@as(c_int, 3);
    }
    outlen.* = @as(c_ulong, @bitCast(@as(c_long, mp_signed_bin_size(a))));
    return mp_to_signed_bin(a, b);
}
pub export fn mp_read_radix(arg_a: [*c]mp_int, arg_str: [*c]const u8, arg_radix: c_int) c_int {
    var a = arg_a;
    _ = &a;
    var str = arg_str;
    _ = &str;
    var radix = arg_radix;
    _ = &radix;
    var y: c_int = undefined;
    _ = &y;
    var res: c_int = undefined;
    _ = &res;
    var neg_1: c_int = undefined;
    _ = &neg_1;
    var ch: u8 = undefined;
    _ = &ch;
    mp_zero(a);
    if ((radix < @as(c_int, 2)) or (radix > @as(c_int, 64))) {
        return -@as(c_int, 3);
    }
    if (@as(c_int, @bitCast(@as(c_uint, str.*))) == @as(c_int, '-')) {
        str += 1;
        neg_1 = 1;
    } else {
        neg_1 = 0;
    }
    mp_zero(a);
    while (@as(c_int, @bitCast(@as(c_uint, str.*))) != @as(c_int, '\x00')) {
        ch = @as(u8, @bitCast(@as(i8, @truncate(if (radix <= @as(c_int, 36)) @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(toupper(@as(c_int, @bitCast(@as(c_uint, str.*))))))))))) else @as(c_int, @bitCast(@as(c_uint, str.*)))))));
        {
            y = 0;
            while (y < @as(c_int, 64)) : (y += 1) {
                if (@as(c_int, @bitCast(@as(c_uint, ch))) == @as(c_int, @bitCast(@as(c_uint, (blk: {
                    const tmp = y;
                    if (tmp >= 0) break :blk mp_s_rmap + @as(usize, @intCast(tmp)) else break :blk mp_s_rmap - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*)))) {
                    break;
                }
            }
        }
        if (y < radix) {
            if ((blk: {
                const tmp = mp_mul_d(a, @as(mp_digit, @bitCast(@as(c_long, radix))), a);
                res = tmp;
                break :blk tmp;
            }) != @as(c_int, 0)) {
                return res;
            }
            if ((blk: {
                const tmp = mp_add_d(a, @as(mp_digit, @bitCast(@as(c_long, y))), a);
                res = tmp;
                break :blk tmp;
            }) != @as(c_int, 0)) {
                return res;
            }
        } else {
            break;
        }
        str += 1;
    }
    if ((if (a.*.used == @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0)) != @as(c_int, 1)) {
        a.*.sign = neg_1;
    }
    return 0;
}
pub export fn mp_toradix(arg_a: [*c]mp_int, arg_str: [*c]u8, arg_radix: c_int) c_int {
    var a = arg_a;
    _ = &a;
    var str = arg_str;
    _ = &str;
    var radix = arg_radix;
    _ = &radix;
    var res: c_int = undefined;
    _ = &res;
    var digs: c_int = undefined;
    _ = &digs;
    var t: mp_int = undefined;
    _ = &t;
    var d: mp_digit = undefined;
    _ = &d;
    var _s: [*c]u8 = str;
    _ = &_s;
    if ((radix < @as(c_int, 2)) or (radix > @as(c_int, 64))) {
        return -@as(c_int, 3);
    }
    if ((if (a.*.used == @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0)) == @as(c_int, 1)) {
        (blk: {
            const ref = &str;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = '0';
        str.* = '\x00';
        return 0;
    }
    if ((blk: {
        const tmp = mp_init_copy(&t, a);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    if (t.sign == @as(c_int, 1)) {
        _s += 1;
        (blk: {
            const ref = &str;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = '-';
        t.sign = 0;
    }
    digs = 0;
    while ((if ((&t).*.used == @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0)) == @as(c_int, 0)) {
        if ((blk: {
            const tmp = mp_div_d(&t, @as(mp_digit, @bitCast(@as(c_long, radix))), &t, &d);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            mp_clear(&t);
            return res;
        }
        (blk: {
            const ref = &str;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = mp_s_rmap[d];
        digs += 1;
    }
    bn_reverse(@as([*c]u8, @ptrCast(@alignCast(_s))), digs);
    str.* = '\x00';
    mp_clear(&t);
    return 0;
}
pub extern fn mp_toradix_n(a: [*c]mp_int, str: [*c]u8, radix: c_int, maxlen: c_int) c_int;
pub export fn mp_radix_size(arg_a: [*c]mp_int, arg_radix: c_int, arg_size: [*c]c_int) c_int {
    var a = arg_a;
    _ = &a;
    var radix = arg_radix;
    _ = &radix;
    var size = arg_size;
    _ = &size;
    var res: c_int = undefined;
    _ = &res;
    var digs: c_int = undefined;
    _ = &digs;
    var t: mp_int = undefined;
    _ = &t;
    var d: mp_digit = undefined;
    _ = &d;
    size.* = 0;
    if ((radix < @as(c_int, 2)) or (radix > @as(c_int, 64))) {
        return -@as(c_int, 3);
    }
    if ((if (a.*.used == @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0)) == @as(c_int, 1)) {
        size.* = 2;
        return 0;
    }
    if (radix == @as(c_int, 2)) {
        size.* = (mp_count_bits(a) + (if (a.*.sign == @as(c_int, 1)) @as(c_int, 1) else @as(c_int, 0))) + @as(c_int, 1);
        return 0;
    }
    digs = 0;
    if (a.*.sign == @as(c_int, 1)) {
        digs += 1;
    }
    if ((blk: {
        const tmp = mp_init_copy(&t, a);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    t.sign = 0;
    while ((if ((&t).*.used == @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0)) == @as(c_int, 0)) {
        if ((blk: {
            const tmp = mp_div_d(&t, @as(mp_digit, @bitCast(@as(c_long, radix))), &t, &d);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            mp_clear(&t);
            return res;
        }
        digs += 1;
    }
    mp_clear(&t);
    size.* = digs + @as(c_int, 1);
    return 0;
}
pub export fn mp_fread(arg_a: [*c]mp_int, arg_radix: c_int, arg_stream: [*c]FILE) c_int {
    var a = arg_a;
    _ = &a;
    var radix = arg_radix;
    _ = &radix;
    var stream = arg_stream;
    _ = &stream;
    var err: c_int = undefined;
    _ = &err;
    var ch: c_int = undefined;
    _ = &ch;
    var neg_1: c_int = undefined;
    _ = &neg_1;
    var y: c_int = undefined;
    _ = &y;
    mp_zero(a);
    ch = fgetc(stream);
    if (ch == @as(c_int, '-')) {
        neg_1 = 1;
        ch = fgetc(stream);
    } else {
        neg_1 = 0;
    }
    while (true) {
        {
            y = 0;
            while (y < radix) : (y += 1) {
                if (@as(c_int, @bitCast(@as(c_uint, (blk: {
                    const tmp = y;
                    if (tmp >= 0) break :blk mp_s_rmap + @as(usize, @intCast(tmp)) else break :blk mp_s_rmap - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*))) == ch) {
                    break;
                }
            }
        }
        if (y == radix) {
            break;
        }
        if ((blk: {
            const tmp = mp_mul_d(a, @as(mp_digit, @bitCast(@as(c_long, radix))), a);
            err = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return err;
        }
        if ((blk: {
            const tmp = mp_add_d(a, @as(mp_digit, @bitCast(@as(c_long, y))), a);
            err = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return err;
        }
        ch = fgetc(stream);
    }
    if (mp_cmp_d(a, @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0))))) != @as(c_int, 0)) {
        a.*.sign = neg_1;
    }
    return 0;
}
pub export fn mp_fwrite(arg_a: [*c]mp_int, arg_radix: c_int, arg_stream: [*c]FILE) c_int {
    var a = arg_a;
    _ = &a;
    var radix = arg_radix;
    _ = &radix;
    var stream = arg_stream;
    _ = &stream;
    var buf: [*c]u8 = undefined;
    _ = &buf;
    var err: c_int = undefined;
    _ = &err;
    var len: c_int = undefined;
    _ = &len;
    var x: c_int = undefined;
    _ = &x;
    if ((blk: {
        const tmp = mp_radix_size(a, radix, &len);
        err = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return err;
    }
    buf = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, len)))))));
    if (buf == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        return -@as(c_int, 2);
    }
    if ((blk: {
        const tmp = mp_toradix(a, buf, radix);
        err = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        free(@as(?*anyopaque, @ptrCast(buf)));
        return err;
    }
    {
        x = 0;
        while (x < len) : (x += 1) {
            if (fputc(@as(c_int, @bitCast(@as(c_uint, (blk: {
                const tmp = x;
                if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))), stream) == -@as(c_int, 1)) {
                free(@as(?*anyopaque, @ptrCast(buf)));
                return -@as(c_int, 3);
            }
        }
    }
    free(@as(?*anyopaque, @ptrCast(buf)));
    return 0;
}
pub const _ISupper: c_int = 256;
pub const _ISlower: c_int = 512;
pub const _ISalpha: c_int = 1024;
pub const _ISdigit: c_int = 2048;
pub const _ISxdigit: c_int = 4096;
pub const _ISspace: c_int = 8192;
pub const _ISprint: c_int = 16384;
pub const _ISgraph: c_int = 32768;
pub const _ISblank: c_int = 1;
pub const _IScntrl: c_int = 2;
pub const _ISpunct: c_int = 4;
pub const _ISalnum: c_int = 8;
const enum_unnamed_20 = c_uint;
pub extern fn __ctype_b_loc() [*c][*c]const c_ushort;
pub extern fn __ctype_tolower_loc() [*c][*c]const __int32_t;
pub extern fn __ctype_toupper_loc() [*c][*c]const __int32_t;
pub extern fn isalnum(c_int) c_int;
pub extern fn isalpha(c_int) c_int;
pub extern fn iscntrl(c_int) c_int;
pub extern fn isdigit(c_int) c_int;
pub extern fn islower(c_int) c_int;
pub extern fn isgraph(c_int) c_int;
pub extern fn isprint(c_int) c_int;
pub extern fn ispunct(c_int) c_int;
pub extern fn isspace(c_int) c_int;
pub extern fn isupper(c_int) c_int;
pub extern fn isxdigit(c_int) c_int;
pub extern fn tolower(__c: c_int) c_int;
pub extern fn toupper(__c: c_int) c_int;
pub extern fn isblank(c_int) c_int;
pub extern fn isascii(__c: c_int) c_int;
pub extern fn toascii(__c: c_int) c_int;
pub extern fn _toupper(c_int) c_int;
pub extern fn _tolower(c_int) c_int;
pub extern fn isalnum_l(c_int, locale_t) c_int;
pub extern fn isalpha_l(c_int, locale_t) c_int;
pub extern fn iscntrl_l(c_int, locale_t) c_int;
pub extern fn isdigit_l(c_int, locale_t) c_int;
pub extern fn islower_l(c_int, locale_t) c_int;
pub extern fn isgraph_l(c_int, locale_t) c_int;
pub extern fn isprint_l(c_int, locale_t) c_int;
pub extern fn ispunct_l(c_int, locale_t) c_int;
pub extern fn isspace_l(c_int, locale_t) c_int;
pub extern fn isupper_l(c_int, locale_t) c_int;
pub extern fn isxdigit_l(c_int, locale_t) c_int;
pub extern fn isblank_l(c_int, locale_t) c_int;
pub extern fn __tolower_l(__c: c_int, __l: locale_t) c_int;
pub extern fn tolower_l(__c: c_int, __l: locale_t) c_int;
pub extern fn __toupper_l(__c: c_int, __l: locale_t) c_int;
pub extern fn toupper_l(__c: c_int, __l: locale_t) c_int;
pub export fn s_mp_add(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var x: [*c]mp_int = undefined;
    _ = &x;
    var olduse: c_int = undefined;
    _ = &olduse;
    var res: c_int = undefined;
    _ = &res;
    var min: c_int = undefined;
    _ = &min;
    var max: c_int = undefined;
    _ = &max;
    if (a.*.used > b.*.used) {
        min = b.*.used;
        max = a.*.used;
        x = a;
    } else {
        min = a.*.used;
        max = b.*.used;
        x = b;
    }
    if (c.*.alloc < (max + @as(c_int, 1))) {
        if ((blk: {
            const tmp = mp_grow(c, max + @as(c_int, 1));
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    olduse = c.*.used;
    c.*.used = max + @as(c_int, 1);
    {
        var u: mp_digit = undefined;
        _ = &u;
        var tmpa: [*c]mp_digit = undefined;
        _ = &tmpa;
        var tmpb: [*c]mp_digit = undefined;
        _ = &tmpb;
        var tmpc: [*c]mp_digit = undefined;
        _ = &tmpc;
        var i: c_int = undefined;
        _ = &i;
        tmpa = a.*.dp;
        tmpb = b.*.dp;
        tmpc = c.*.dp;
        u = 0;
        {
            i = 0;
            while (i < min) : (i += 1) {
                tmpc.* = ((blk: {
                    const ref = &tmpa;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* +% (blk: {
                    const ref = &tmpb;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).*) +% u;
                u = tmpc.* >> @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))));
                (blk: {
                    const ref = &tmpc;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* &= (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1))));
            }
        }
        if (min != max) {
            while (i < max) : (i += 1) {
                tmpc.* = (blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk x.*.dp + @as(usize, @intCast(tmp)) else break :blk x.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).* +% u;
                u = tmpc.* >> @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))));
                (blk: {
                    const ref = &tmpc;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* &= (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1))));
            }
        }
        (blk: {
            const ref = &tmpc;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = u;
        {
            i = c.*.used;
            while (i < olduse) : (i += 1) {
                (blk: {
                    const ref = &tmpc;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* = 0;
            }
        }
    }
    mp_clamp(c);
    return 0;
}
pub export fn s_mp_sub(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var olduse: c_int = undefined;
    _ = &olduse;
    var res: c_int = undefined;
    _ = &res;
    var min: c_int = undefined;
    _ = &min;
    var max: c_int = undefined;
    _ = &max;
    min = b.*.used;
    max = a.*.used;
    if (c.*.alloc < max) {
        if ((blk: {
            const tmp = mp_grow(c, max);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    olduse = c.*.used;
    c.*.used = max;
    {
        var u: mp_digit = undefined;
        _ = &u;
        var tmpa: [*c]mp_digit = undefined;
        _ = &tmpa;
        var tmpb: [*c]mp_digit = undefined;
        _ = &tmpb;
        var tmpc: [*c]mp_digit = undefined;
        _ = &tmpc;
        var i: c_int = undefined;
        _ = &i;
        tmpa = a.*.dp;
        tmpb = b.*.dp;
        tmpc = c.*.dp;
        u = 0;
        {
            i = 0;
            while (i < min) : (i += 1) {
                tmpc.* = ((blk: {
                    const ref = &tmpa;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* -% (blk: {
                    const ref = &tmpb;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).*) -% u;
                u = tmpc.* >> @intCast(@as(mp_digit, @bitCast((@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))) *% @sizeOf(mp_digit)) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))))));
                (blk: {
                    const ref = &tmpc;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* &= (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1))));
            }
        }
        while (i < max) : (i += 1) {
            tmpc.* = (blk: {
                const ref = &tmpa;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* -% u;
            u = tmpc.* >> @intCast(@as(mp_digit, @bitCast((@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))) *% @sizeOf(mp_digit)) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))))));
            (blk: {
                const ref = &tmpc;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* &= (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1))));
        }
        {
            i = c.*.used;
            while (i < olduse) : (i += 1) {
                (blk: {
                    const ref = &tmpc;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* = 0;
            }
        }
    }
    mp_clamp(c);
    return 0;
}
pub export fn fast_s_mp_mul_digs(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int, arg_digs: c_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var digs = arg_digs;
    _ = &digs;
    var olduse: c_int = undefined;
    _ = &olduse;
    var res: c_int = undefined;
    _ = &res;
    var pa: c_int = undefined;
    _ = &pa;
    var ix: c_int = undefined;
    _ = &ix;
    var iz: c_int = undefined;
    _ = &iz;
    var W: [512]mp_digit = undefined;
    _ = &W;
    var _W: mp_word = undefined;
    _ = &_W;
    if (c.*.alloc < digs) {
        if ((blk: {
            const tmp = mp_grow(c, digs);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    pa = if (digs < (a.*.used + b.*.used)) digs else a.*.used + b.*.used;
    _W = 0;
    {
        ix = 0;
        while (ix < pa) : (ix += 1) {
            var tx: c_int = undefined;
            _ = &tx;
            var ty: c_int = undefined;
            _ = &ty;
            var iy: c_int = undefined;
            _ = &iy;
            var tmpx: [*c]mp_digit = undefined;
            _ = &tmpx;
            var tmpy: [*c]mp_digit = undefined;
            _ = &tmpy;
            ty = if ((b.*.used - @as(c_int, 1)) < ix) b.*.used - @as(c_int, 1) else ix;
            tx = ix - ty;
            tmpx = a.*.dp + @as(usize, @bitCast(@as(isize, @intCast(tx))));
            tmpy = b.*.dp + @as(usize, @bitCast(@as(isize, @intCast(ty))));
            iy = if ((a.*.used - tx) < (ty + @as(c_int, 1))) a.*.used - tx else ty + @as(c_int, 1);
            {
                iz = 0;
                while (iz < iy) : (iz += 1) {
                    _W +%= @as(mp_word, @bitCast(@as(u128, (blk: {
                        const ref = &tmpx;
                        const tmp = ref.*;
                        ref.* += 1;
                        break :blk tmp;
                    }).*))) *% @as(mp_word, @bitCast(@as(u128, (blk: {
                        const ref = &tmpy;
                        const tmp = ref.*;
                        ref.* -= 1;
                        break :blk tmp;
                    }).*)));
                }
            }
            W[@as(c_uint, @intCast(ix))] = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(_W)))) & ((@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))));
            _W = _W >> @intCast(@as(mp_word, @bitCast(@as(i128, @as(c_int, 60)))));
        }
    }
    olduse = c.*.used;
    c.*.used = pa;
    {
        var tmpc: [*c]mp_digit = undefined;
        _ = &tmpc;
        tmpc = c.*.dp;
        {
            ix = 0;
            while (ix < (pa + @as(c_int, 1))) : (ix += 1) {
                (blk: {
                    const ref = &tmpc;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* = W[@as(c_uint, @intCast(ix))];
            }
        }
        while (ix < olduse) : (ix += 1) {
            (blk: {
                const ref = &tmpc;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = 0;
        }
    }
    mp_clamp(c);
    return 0;
}
pub export fn s_mp_mul_digs(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int, arg_digs: c_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var digs = arg_digs;
    _ = &digs;
    var t: mp_int = undefined;
    _ = &t;
    var res: c_int = undefined;
    _ = &res;
    var pa: c_int = undefined;
    _ = &pa;
    var pb: c_int = undefined;
    _ = &pb;
    var ix: c_int = undefined;
    _ = &ix;
    var iy: c_int = undefined;
    _ = &iy;
    var u: mp_digit = undefined;
    _ = &u;
    var r: mp_word = undefined;
    _ = &r;
    var tmpx: mp_digit = undefined;
    _ = &tmpx;
    var tmpt: [*c]mp_digit = undefined;
    _ = &tmpt;
    var tmpy: [*c]mp_digit = undefined;
    _ = &tmpy;
    if ((digs < (@as(c_int, 1) << @intCast(((@sizeOf(mp_word) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2) * @as(c_int, 60))))) +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))))) and ((if (a.*.used < b.*.used) a.*.used else b.*.used) < (@as(c_int, 1) << @intCast((@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))) *% @sizeOf(mp_word)) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2) * @as(c_int, 60)))))))) {
        return fast_s_mp_mul_digs(a, b, c, digs);
    }
    if ((blk: {
        const tmp = mp_init_size(&t, digs);
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    t.used = digs;
    pa = a.*.used;
    {
        ix = 0;
        while (ix < pa) : (ix += 1) {
            u = 0;
            pb = if (b.*.used < (digs - ix)) b.*.used else digs - ix;
            tmpx = (blk: {
                const tmp = ix;
                if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
            tmpt = t.dp + @as(usize, @bitCast(@as(isize, @intCast(ix))));
            tmpy = b.*.dp;
            {
                iy = 0;
                while (iy < pb) : (iy += 1) {
                    r = (@as(mp_word, @bitCast(@as(u128, tmpt.*))) +% (@as(mp_word, @bitCast(@as(u128, tmpx))) *% @as(mp_word, @bitCast(@as(u128, (blk: {
                        const ref = &tmpy;
                        const tmp = ref.*;
                        ref.* += 1;
                        break :blk tmp;
                    }).*))))) +% @as(mp_word, @bitCast(@as(u128, u)));
                    (blk: {
                        const ref = &tmpt;
                        const tmp = ref.*;
                        ref.* += 1;
                        break :blk tmp;
                    }).* = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(r & @as(mp_word, @bitCast(@as(u128, (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))))))))));
                    u = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(r >> @intCast(@as(mp_word, @bitCast(@as(i128, @as(c_int, 60)))))))));
                }
            }
            if ((ix + iy) < digs) {
                tmpt.* = u;
            }
        }
    }
    mp_clamp(&t);
    mp_exch(&t, c);
    mp_clear(&t);
    return 0;
}
pub export fn fast_s_mp_mul_high_digs(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int, arg_digs: c_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var digs = arg_digs;
    _ = &digs;
    var olduse: c_int = undefined;
    _ = &olduse;
    var res: c_int = undefined;
    _ = &res;
    var pa: c_int = undefined;
    _ = &pa;
    var ix: c_int = undefined;
    _ = &ix;
    var iz: c_int = undefined;
    _ = &iz;
    var W: [512]mp_digit = undefined;
    _ = &W;
    var _W: mp_word = undefined;
    _ = &_W;
    pa = a.*.used + b.*.used;
    if (c.*.alloc < pa) {
        if ((blk: {
            const tmp = mp_grow(c, pa);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    pa = a.*.used + b.*.used;
    _W = 0;
    {
        ix = digs;
        while (ix < pa) : (ix += 1) {
            var tx: c_int = undefined;
            _ = &tx;
            var ty: c_int = undefined;
            _ = &ty;
            var iy: c_int = undefined;
            _ = &iy;
            var tmpx: [*c]mp_digit = undefined;
            _ = &tmpx;
            var tmpy: [*c]mp_digit = undefined;
            _ = &tmpy;
            ty = if ((b.*.used - @as(c_int, 1)) < ix) b.*.used - @as(c_int, 1) else ix;
            tx = ix - ty;
            tmpx = a.*.dp + @as(usize, @bitCast(@as(isize, @intCast(tx))));
            tmpy = b.*.dp + @as(usize, @bitCast(@as(isize, @intCast(ty))));
            iy = if ((a.*.used - tx) < (ty + @as(c_int, 1))) a.*.used - tx else ty + @as(c_int, 1);
            {
                iz = 0;
                while (iz < iy) : (iz += 1) {
                    _W +%= @as(mp_word, @bitCast(@as(u128, (blk: {
                        const ref = &tmpx;
                        const tmp = ref.*;
                        ref.* += 1;
                        break :blk tmp;
                    }).*))) *% @as(mp_word, @bitCast(@as(u128, (blk: {
                        const ref = &tmpy;
                        const tmp = ref.*;
                        ref.* -= 1;
                        break :blk tmp;
                    }).*)));
                }
            }
            W[@as(c_uint, @intCast(ix))] = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(_W)))) & ((@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))));
            _W = _W >> @intCast(@as(mp_word, @bitCast(@as(i128, @as(c_int, 60)))));
        }
    }
    olduse = c.*.used;
    c.*.used = pa;
    {
        var tmpc: [*c]mp_digit = undefined;
        _ = &tmpc;
        tmpc = c.*.dp + @as(usize, @bitCast(@as(isize, @intCast(digs))));
        {
            ix = digs;
            while (ix < pa) : (ix += 1) {
                (blk: {
                    const ref = &tmpc;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* = W[@as(c_uint, @intCast(ix))];
            }
        }
        while (ix < olduse) : (ix += 1) {
            (blk: {
                const ref = &tmpc;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = 0;
        }
    }
    mp_clamp(c);
    return 0;
}
pub export fn s_mp_mul_high_digs(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int, arg_digs: c_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var digs = arg_digs;
    _ = &digs;
    var t: mp_int = undefined;
    _ = &t;
    var res: c_int = undefined;
    _ = &res;
    var pa: c_int = undefined;
    _ = &pa;
    var pb: c_int = undefined;
    _ = &pb;
    var ix: c_int = undefined;
    _ = &ix;
    var iy: c_int = undefined;
    _ = &iy;
    var u: mp_digit = undefined;
    _ = &u;
    var r: mp_word = undefined;
    _ = &r;
    var tmpx: mp_digit = undefined;
    _ = &tmpx;
    var tmpt: [*c]mp_digit = undefined;
    _ = &tmpt;
    var tmpy: [*c]mp_digit = undefined;
    _ = &tmpy;
    if ((((a.*.used + b.*.used) + @as(c_int, 1)) < (@as(c_int, 1) << @intCast(((@sizeOf(mp_word) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2) * @as(c_int, 60))))) +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))))) and ((if (a.*.used < b.*.used) a.*.used else b.*.used) < (@as(c_int, 1) << @intCast((@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))) *% @sizeOf(mp_word)) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2) * @as(c_int, 60)))))))) {
        return fast_s_mp_mul_high_digs(a, b, c, digs);
    }
    if ((blk: {
        const tmp = mp_init_size(&t, (a.*.used + b.*.used) + @as(c_int, 1));
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    t.used = (a.*.used + b.*.used) + @as(c_int, 1);
    pa = a.*.used;
    pb = b.*.used;
    {
        ix = 0;
        while (ix < pa) : (ix += 1) {
            u = 0;
            tmpx = (blk: {
                const tmp = ix;
                if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
            tmpt = &(blk: {
                const tmp = digs;
                if (tmp >= 0) break :blk t.dp + @as(usize, @intCast(tmp)) else break :blk t.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
            tmpy = b.*.dp + @as(usize, @bitCast(@as(isize, @intCast(digs - ix))));
            {
                iy = digs - ix;
                while (iy < pb) : (iy += 1) {
                    r = (@as(mp_word, @bitCast(@as(u128, tmpt.*))) +% (@as(mp_word, @bitCast(@as(u128, tmpx))) *% @as(mp_word, @bitCast(@as(u128, (blk: {
                        const ref = &tmpy;
                        const tmp = ref.*;
                        ref.* += 1;
                        break :blk tmp;
                    }).*))))) +% @as(mp_word, @bitCast(@as(u128, u)));
                    (blk: {
                        const ref = &tmpt;
                        const tmp = ref.*;
                        ref.* += 1;
                        break :blk tmp;
                    }).* = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(r & @as(mp_word, @bitCast(@as(u128, (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))))))))));
                    u = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(r >> @intCast(@as(mp_word, @bitCast(@as(i128, @as(c_int, 60)))))))));
                }
            }
            tmpt.* = u;
        }
    }
    mp_clamp(&t);
    mp_exch(&t, c);
    mp_clear(&t);
    return 0;
}
pub export fn fast_s_mp_sqr(arg_a: [*c]mp_int, arg_b: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var olduse: c_int = undefined;
    _ = &olduse;
    var res: c_int = undefined;
    _ = &res;
    var pa: c_int = undefined;
    _ = &pa;
    var ix: c_int = undefined;
    _ = &ix;
    var iz: c_int = undefined;
    _ = &iz;
    var W: [512]mp_digit = undefined;
    _ = &W;
    var tmpx: [*c]mp_digit = undefined;
    _ = &tmpx;
    var W1: mp_word = undefined;
    _ = &W1;
    pa = a.*.used + a.*.used;
    if (b.*.alloc < pa) {
        if ((blk: {
            const tmp = mp_grow(b, pa);
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    W1 = 0;
    {
        ix = 0;
        while (ix < pa) : (ix += 1) {
            var tx: c_int = undefined;
            _ = &tx;
            var ty: c_int = undefined;
            _ = &ty;
            var iy: c_int = undefined;
            _ = &iy;
            var _W: mp_word = undefined;
            _ = &_W;
            var tmpy: [*c]mp_digit = undefined;
            _ = &tmpy;
            _W = 0;
            ty = if ((a.*.used - @as(c_int, 1)) < ix) a.*.used - @as(c_int, 1) else ix;
            tx = ix - ty;
            tmpx = a.*.dp + @as(usize, @bitCast(@as(isize, @intCast(tx))));
            tmpy = a.*.dp + @as(usize, @bitCast(@as(isize, @intCast(ty))));
            iy = if ((a.*.used - tx) < (ty + @as(c_int, 1))) a.*.used - tx else ty + @as(c_int, 1);
            iy = if (iy < (((ty - tx) + @as(c_int, 1)) >> @intCast(1))) iy else ((ty - tx) + @as(c_int, 1)) >> @intCast(1);
            {
                iz = 0;
                while (iz < iy) : (iz += 1) {
                    _W +%= @as(mp_word, @bitCast(@as(u128, (blk: {
                        const ref = &tmpx;
                        const tmp = ref.*;
                        ref.* += 1;
                        break :blk tmp;
                    }).*))) *% @as(mp_word, @bitCast(@as(u128, (blk: {
                        const ref = &tmpy;
                        const tmp = ref.*;
                        ref.* -= 1;
                        break :blk tmp;
                    }).*)));
                }
            }
            _W = (_W +% _W) +% W1;
            if ((ix & @as(c_int, 1)) == @as(c_int, 0)) {
                _W +%= @as(mp_word, @bitCast(@as(u128, (blk: {
                    const tmp = ix >> @intCast(1);
                    if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*))) *% @as(mp_word, @bitCast(@as(u128, (blk: {
                    const tmp = ix >> @intCast(1);
                    if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*)));
            }
            W[@as(c_uint, @intCast(ix))] = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(_W & @as(mp_word, @bitCast(@as(u128, (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))))))))));
            W1 = _W >> @intCast(@as(mp_word, @bitCast(@as(i128, @as(c_int, 60)))));
        }
    }
    olduse = b.*.used;
    b.*.used = a.*.used + a.*.used;
    {
        var tmpb: [*c]mp_digit = undefined;
        _ = &tmpb;
        tmpb = b.*.dp;
        {
            ix = 0;
            while (ix < pa) : (ix += 1) {
                (blk: {
                    const ref = &tmpb;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* = W[@as(c_uint, @intCast(ix))] & ((@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))));
            }
        }
        while (ix < olduse) : (ix += 1) {
            (blk: {
                const ref = &tmpb;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = 0;
        }
    }
    mp_clamp(b);
    return 0;
}
pub export fn s_mp_sqr(arg_a: [*c]mp_int, arg_b: [*c]mp_int) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var t: mp_int = undefined;
    _ = &t;
    var res: c_int = undefined;
    _ = &res;
    var ix: c_int = undefined;
    _ = &ix;
    var iy: c_int = undefined;
    _ = &iy;
    var pa: c_int = undefined;
    _ = &pa;
    var r: mp_word = undefined;
    _ = &r;
    var u: mp_digit = undefined;
    _ = &u;
    var tmpx: mp_digit = undefined;
    _ = &tmpx;
    var tmpt: [*c]mp_digit = undefined;
    _ = &tmpt;
    pa = a.*.used;
    if ((blk: {
        const tmp = mp_init_size(&t, (@as(c_int, 2) * pa) + @as(c_int, 1));
        res = tmp;
        break :blk tmp;
    }) != @as(c_int, 0)) {
        return res;
    }
    t.used = (@as(c_int, 2) * pa) + @as(c_int, 1);
    {
        ix = 0;
        while (ix < pa) : (ix += 1) {
            r = @as(mp_word, @bitCast(@as(u128, (blk: {
                const tmp = @as(c_int, 2) * ix;
                if (tmp >= 0) break :blk t.dp + @as(usize, @intCast(tmp)) else break :blk t.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))) +% (@as(mp_word, @bitCast(@as(u128, (blk: {
                const tmp = ix;
                if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))) *% @as(mp_word, @bitCast(@as(u128, (blk: {
                const tmp = ix;
                if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))));
            (blk: {
                const tmp = ix + ix;
                if (tmp >= 0) break :blk t.dp + @as(usize, @intCast(tmp)) else break :blk t.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(r & @as(mp_word, @bitCast(@as(u128, (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))))))))));
            u = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(r >> @intCast(@as(mp_word, @bitCast(@as(i128, @as(c_int, 60)))))))));
            tmpx = (blk: {
                const tmp = ix;
                if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
            tmpt = t.dp + @as(usize, @bitCast(@as(isize, @intCast((@as(c_int, 2) * ix) + @as(c_int, 1)))));
            {
                iy = ix + @as(c_int, 1);
                while (iy < pa) : (iy += 1) {
                    r = @as(mp_word, @bitCast(@as(u128, tmpx))) *% @as(mp_word, @bitCast(@as(u128, (blk: {
                        const tmp = iy;
                        if (tmp >= 0) break :blk a.*.dp + @as(usize, @intCast(tmp)) else break :blk a.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).*)));
                    r = ((@as(mp_word, @bitCast(@as(u128, tmpt.*))) +% r) +% r) +% @as(mp_word, @bitCast(@as(u128, u)));
                    (blk: {
                        const ref = &tmpt;
                        const tmp = ref.*;
                        ref.* += 1;
                        break :blk tmp;
                    }).* = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(r & @as(mp_word, @bitCast(@as(u128, (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))))))))));
                    u = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(r >> @intCast(@as(mp_word, @bitCast(@as(i128, @as(c_int, 60)))))))));
                }
            }
            while (u != @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0))))) {
                r = @as(mp_word, @bitCast(@as(u128, tmpt.*))) +% @as(mp_word, @bitCast(@as(u128, u)));
                (blk: {
                    const ref = &tmpt;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(r & @as(mp_word, @bitCast(@as(u128, (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))))))))));
                u = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(r >> @intCast(@as(mp_word, @bitCast(@as(i128, @as(c_int, 60)))))))));
            }
        }
    }
    mp_clamp(&t);
    mp_exch(&t, b);
    mp_clear(&t);
    return 0;
}
// ./libtomcrypt.c:7242:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:7227:5: warning: unable to translate function, demoted to extern
pub extern fn mp_karatsuba_mul(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int) c_int;
// ./libtomcrypt.c:11032:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:11016:5: warning: unable to translate function, demoted to extern
pub extern fn mp_toom_mul(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int) c_int;
// ./libtomcrypt.c:7388:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:7374:5: warning: unable to translate function, demoted to extern
pub extern fn mp_karatsuba_sqr(arg_a: [*c]mp_int, arg_b: [*c]mp_int) c_int;
// ./libtomcrypt.c:11312:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:11298:1: warning: unable to translate function, demoted to extern
pub extern fn mp_toom_sqr(arg_a: [*c]mp_int, arg_b: [*c]mp_int) c_int;
// ./libtomcrypt.c:2921:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:2905:5: warning: unable to translate function, demoted to extern
pub extern fn fast_mp_invmod(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int) c_int;
// ./libtomcrypt.c:6813:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:6796:5: warning: unable to translate function, demoted to extern
pub extern fn mp_invmod_slow(arg_a: [*c]mp_int, arg_b: [*c]mp_int, arg_c: [*c]mp_int) c_int;
pub export fn fast_mp_montgomery_reduce(arg_x: [*c]mp_int, arg_n: [*c]mp_int, arg_rho: mp_digit) c_int {
    var x = arg_x;
    _ = &x;
    var n = arg_n;
    _ = &n;
    var rho = arg_rho;
    _ = &rho;
    var ix: c_int = undefined;
    _ = &ix;
    var res: c_int = undefined;
    _ = &res;
    var olduse: c_int = undefined;
    _ = &olduse;
    var W: [512]mp_word = undefined;
    _ = &W;
    olduse = x.*.used;
    if (x.*.alloc < (n.*.used + @as(c_int, 1))) {
        if ((blk: {
            const tmp = mp_grow(x, n.*.used + @as(c_int, 1));
            res = tmp;
            break :blk tmp;
        }) != @as(c_int, 0)) {
            return res;
        }
    }
    {
        var _W: [*c]mp_word = undefined;
        _ = &_W;
        var tmpx: [*c]mp_digit = undefined;
        _ = &tmpx;
        _W = @as([*c]mp_word, @ptrCast(@alignCast(&W)));
        tmpx = x.*.dp;
        {
            ix = 0;
            while (ix < x.*.used) : (ix += 1) {
                (blk: {
                    const ref = &_W;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* = @as(mp_word, @bitCast(@as(u128, (blk: {
                    const ref = &tmpx;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).*)));
            }
        }
        while (ix < ((n.*.used * @as(c_int, 2)) + @as(c_int, 1))) : (ix += 1) {
            (blk: {
                const ref = &_W;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = 0;
        }
    }
    {
        ix = 0;
        while (ix < n.*.used) : (ix += 1) {
            var mu: mp_digit = undefined;
            _ = &mu;
            mu = @as(mp_digit, @bitCast(@as(c_ulong, @truncate(((W[@as(c_uint, @intCast(ix))] & @as(mp_word, @bitCast(@as(u128, (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))))))) *% @as(mp_word, @bitCast(@as(u128, rho)))) & @as(mp_word, @bitCast(@as(u128, (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))))))))));
            {
                var iy: c_int = undefined;
                _ = &iy;
                var tmpn: [*c]mp_digit = undefined;
                _ = &tmpn;
                var _W: [*c]mp_word = undefined;
                _ = &_W;
                tmpn = n.*.dp;
                _W = @as([*c]mp_word, @ptrCast(@alignCast(&W))) + @as(usize, @bitCast(@as(isize, @intCast(ix))));
                {
                    iy = 0;
                    while (iy < n.*.used) : (iy += 1) {
                        (blk: {
                            const ref = &_W;
                            const tmp = ref.*;
                            ref.* += 1;
                            break :blk tmp;
                        }).* +%= @as(mp_word, @bitCast(@as(u128, mu))) *% @as(mp_word, @bitCast(@as(u128, (blk: {
                            const ref = &tmpn;
                            const tmp = ref.*;
                            ref.* += 1;
                            break :blk tmp;
                        }).*)));
                    }
                }
            }
            W[@as(c_uint, @intCast(ix + @as(c_int, 1)))] +%= W[@as(c_uint, @intCast(ix))] >> @intCast(@as(mp_word, @bitCast(@as(i128, @as(c_int, 60)))));
        }
    }
    {
        var tmpx: [*c]mp_digit = undefined;
        _ = &tmpx;
        var _W: [*c]mp_word = undefined;
        _ = &_W;
        var _W1: [*c]mp_word = undefined;
        _ = &_W1;
        _W1 = @as([*c]mp_word, @ptrCast(@alignCast(&W))) + @as(usize, @bitCast(@as(isize, @intCast(ix))));
        _W = @as([*c]mp_word, @ptrCast(@alignCast(&W))) + @as(usize, @bitCast(@as(isize, @intCast(blk: {
            const ref = &ix;
            ref.* += 1;
            break :blk ref.*;
        }))));
        while (ix <= ((n.*.used * @as(c_int, 2)) + @as(c_int, 1))) : (ix += 1) {
            (blk: {
                const ref = &_W;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* +%= (blk: {
                const ref = &_W1;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* >> @intCast(@as(mp_word, @bitCast(@as(i128, @as(c_int, 60)))));
        }
        tmpx = x.*.dp;
        _W = @as([*c]mp_word, @ptrCast(@alignCast(&W))) + @as(usize, @bitCast(@as(isize, @intCast(n.*.used))));
        {
            ix = 0;
            while (ix < (n.*.used + @as(c_int, 1))) : (ix += 1) {
                (blk: {
                    const ref = &tmpx;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* = @as(mp_digit, @bitCast(@as(c_ulong, @truncate((blk: {
                    const ref = &_W;
                    const tmp = ref.*;
                    ref.* += 1;
                    break :blk tmp;
                }).* & @as(mp_word, @bitCast(@as(u128, (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 60)))))) -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))))))))));
            }
        }
        while (ix < olduse) : (ix += 1) {
            (blk: {
                const ref = &tmpx;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = 0;
        }
    }
    x.*.used = n.*.used + @as(c_int, 1);
    mp_clamp(x);
    if (mp_cmp_mag(x, n) != -@as(c_int, 1)) {
        return s_mp_sub(x, n, x);
    }
    return 0;
}
// ./libtomcrypt.c:5616:13: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:5559:5: warning: unable to translate function, demoted to extern
pub extern fn mp_exptmod_fast(arg_G_1: [*c]mp_int, arg_X_2: [*c]mp_int, arg_P: [*c]mp_int, arg_Y_3: [*c]mp_int, arg_redmode: c_int) c_int;
// ./libtomcrypt.c:11989:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:11939:5: warning: unable to translate function, demoted to extern
pub extern fn s_mp_exptmod(arg_G_1: [*c]mp_int, arg_X_2: [*c]mp_int, arg_P: [*c]mp_int, arg_Y_3: [*c]mp_int, arg_redmode: c_int) c_int;
pub export fn bn_reverse(arg_s: [*c]u8, arg_len: c_int) void {
    var s = arg_s;
    _ = &s;
    var len = arg_len;
    _ = &len;
    var ix: c_int = undefined;
    _ = &ix;
    var iy: c_int = undefined;
    _ = &iy;
    var t: u8 = undefined;
    _ = &t;
    ix = 0;
    iy = len - @as(c_int, 1);
    while (ix < iy) {
        t = (blk: {
            const tmp = ix;
            if (tmp >= 0) break :blk s + @as(usize, @intCast(tmp)) else break :blk s - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*;
        (blk: {
            const tmp = ix;
            if (tmp >= 0) break :blk s + @as(usize, @intCast(tmp)) else break :blk s - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = (blk: {
            const tmp = iy;
            if (tmp >= 0) break :blk s + @as(usize, @intCast(tmp)) else break :blk s - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*;
        (blk: {
            const tmp = iy;
            if (tmp >= 0) break :blk s + @as(usize, @intCast(tmp)) else break :blk s - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = t;
        ix += 1;
        iy -= 1;
    }
}
pub extern var mp_s_rmap: [*c]const u8;
pub const lnz: [16]c_int = [16]c_int{
    4,
    0,
    1,
    0,
    2,
    0,
    1,
    0,
    3,
    0,
    1,
    0,
    2,
    0,
    1,
    0,
};
pub fn s_is_power_of_two(arg_b: mp_digit, arg_p: [*c]c_int) callconv(.c) c_int {
    var b = arg_b;
    _ = &b;
    var p = arg_p;
    _ = &p;
    var x: c_int = undefined;
    _ = &x;
    if ((b == @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0))))) or ((b & (b -% @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))))) != @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0)))))) {
        return 0;
    }
    {
        x = 0;
        while (x < @as(c_int, 60)) : (x += 1) {
            if (b == (@as(mp_digit, @bitCast(@as(c_long, @as(c_int, 1)))) << @intCast(x))) {
                p.* = x;
                return 1;
            }
        }
    }
    return 0;
}
pub const rem_128: [128]u8 = [128]u8{
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
};
pub const rem_105: [105]u8 = [105]u8{
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    1,
};
pub const sizes: [8]struct_unnamed_19 = [8]struct_unnamed_19{
    struct_unnamed_19{
        .k = @as(c_int, 128),
        .t = @as(c_int, 28),
    },
    struct_unnamed_19{
        .k = @as(c_int, 256),
        .t = @as(c_int, 16),
    },
    struct_unnamed_19{
        .k = @as(c_int, 384),
        .t = @as(c_int, 10),
    },
    struct_unnamed_19{
        .k = @as(c_int, 512),
        .t = @as(c_int, 7),
    },
    struct_unnamed_19{
        .k = @as(c_int, 640),
        .t = @as(c_int, 6),
    },
    struct_unnamed_19{
        .k = @as(c_int, 768),
        .t = @as(c_int, 5),
    },
    struct_unnamed_19{
        .k = @as(c_int, 896),
        .t = @as(c_int, 4),
    },
    struct_unnamed_19{
        .k = @as(c_int, 1024),
        .t = @as(c_int, 4),
    },
};
pub export var crypt_build_settings: [*c]const u8 = "LibTomCrypt 1.17 (Tom St Denis, tomstdenis@gmail.com)\nLibTomCrypt is public domain software.\nBuilt on Mar 23 2025 at 11:56:09\n\n\nEndianess: Clean stack: disabled\nCiphers built-in:\n\n\nHashes built-in:\n\nBlock Chaining Modes:\n\n\nMACs:\n\nENC + AUTH modes:\n\n\nPRNG:\n\nPK Algs:\n\nCompiler:\n   GCC compiler detected.\n   x86-64 detected.\n\nVarious others: \n\n\n\n";
pub const sig_atomic_t = __sig_atomic_t;
const struct_unnamed_22 = extern struct {
    si_pid: __pid_t = @import("std").mem.zeroes(__pid_t),
    si_uid: __uid_t = @import("std").mem.zeroes(__uid_t),
};
const struct_unnamed_23 = extern struct {
    si_tid: c_int = @import("std").mem.zeroes(c_int),
    si_overrun: c_int = @import("std").mem.zeroes(c_int),
    si_sigval: __sigval_t = @import("std").mem.zeroes(__sigval_t),
};
const struct_unnamed_24 = extern struct {
    si_pid: __pid_t = @import("std").mem.zeroes(__pid_t),
    si_uid: __uid_t = @import("std").mem.zeroes(__uid_t),
    si_sigval: __sigval_t = @import("std").mem.zeroes(__sigval_t),
};
const struct_unnamed_25 = extern struct {
    si_pid: __pid_t = @import("std").mem.zeroes(__pid_t),
    si_uid: __uid_t = @import("std").mem.zeroes(__uid_t),
    si_status: c_int = @import("std").mem.zeroes(c_int),
    si_utime: __clock_t = @import("std").mem.zeroes(__clock_t),
    si_stime: __clock_t = @import("std").mem.zeroes(__clock_t),
};
const struct_unnamed_28 = extern struct {
    _lower: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    _upper: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
const union_unnamed_27 = extern union {
    _addr_bnd: struct_unnamed_28,
    _pkey: __uint32_t,
};
const struct_unnamed_26 = extern struct {
    si_addr: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    si_addr_lsb: c_short = @import("std").mem.zeroes(c_short),
    _bounds: union_unnamed_27 = @import("std").mem.zeroes(union_unnamed_27),
};
const struct_unnamed_29 = extern struct {
    si_band: c_long = @import("std").mem.zeroes(c_long),
    si_fd: c_int = @import("std").mem.zeroes(c_int),
};
const struct_unnamed_30 = extern struct {
    _call_addr: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    _syscall: c_int = @import("std").mem.zeroes(c_int),
    _arch: c_uint = @import("std").mem.zeroes(c_uint),
};
const union_unnamed_21 = extern union {
    _pad: [28]c_int,
    _kill: struct_unnamed_22,
    _timer: struct_unnamed_23,
    _rt: struct_unnamed_24,
    _sigchld: struct_unnamed_25,
    _sigfault: struct_unnamed_26,
    _sigpoll: struct_unnamed_29,
    _sigsys: struct_unnamed_30,
};
pub const siginfo_t = extern struct {
    si_signo: c_int = @import("std").mem.zeroes(c_int),
    si_errno: c_int = @import("std").mem.zeroes(c_int),
    si_code: c_int = @import("std").mem.zeroes(c_int),
    __pad0: c_int = @import("std").mem.zeroes(c_int),
    _sifields: union_unnamed_21 = @import("std").mem.zeroes(union_unnamed_21),
};
pub const SI_ASYNCNL: c_int = -60;
pub const SI_DETHREAD: c_int = -7;
pub const SI_TKILL: c_int = -6;
pub const SI_SIGIO: c_int = -5;
pub const SI_ASYNCIO: c_int = -4;
pub const SI_MESGQ: c_int = -3;
pub const SI_TIMER: c_int = -2;
pub const SI_QUEUE: c_int = -1;
pub const SI_USER: c_int = 0;
pub const SI_KERNEL: c_int = 128;
const enum_unnamed_31 = c_int;
pub const ILL_ILLOPC: c_int = 1;
pub const ILL_ILLOPN: c_int = 2;
pub const ILL_ILLADR: c_int = 3;
pub const ILL_ILLTRP: c_int = 4;
pub const ILL_PRVOPC: c_int = 5;
pub const ILL_PRVREG: c_int = 6;
pub const ILL_COPROC: c_int = 7;
pub const ILL_BADSTK: c_int = 8;
pub const ILL_BADIADDR: c_int = 9;
const enum_unnamed_32 = c_uint;
pub const FPE_INTDIV: c_int = 1;
pub const FPE_INTOVF: c_int = 2;
pub const FPE_FLTDIV: c_int = 3;
pub const FPE_FLTOVF: c_int = 4;
pub const FPE_FLTUND: c_int = 5;
pub const FPE_FLTRES: c_int = 6;
pub const FPE_FLTINV: c_int = 7;
pub const FPE_FLTSUB: c_int = 8;
pub const FPE_FLTUNK: c_int = 14;
pub const FPE_CONDTRAP: c_int = 15;
const enum_unnamed_33 = c_uint;
pub const SEGV_MAPERR: c_int = 1;
pub const SEGV_ACCERR: c_int = 2;
pub const SEGV_BNDERR: c_int = 3;
pub const SEGV_PKUERR: c_int = 4;
pub const SEGV_ACCADI: c_int = 5;
pub const SEGV_ADIDERR: c_int = 6;
pub const SEGV_ADIPERR: c_int = 7;
pub const SEGV_MTEAERR: c_int = 8;
pub const SEGV_MTESERR: c_int = 9;
pub const SEGV_CPERR: c_int = 10;
const enum_unnamed_34 = c_uint;
pub const BUS_ADRALN: c_int = 1;
pub const BUS_ADRERR: c_int = 2;
pub const BUS_OBJERR: c_int = 3;
pub const BUS_MCEERR_AR: c_int = 4;
pub const BUS_MCEERR_AO: c_int = 5;
const enum_unnamed_35 = c_uint;
pub const CLD_EXITED: c_int = 1;
pub const CLD_KILLED: c_int = 2;
pub const CLD_DUMPED: c_int = 3;
pub const CLD_TRAPPED: c_int = 4;
pub const CLD_STOPPED: c_int = 5;
pub const CLD_CONTINUED: c_int = 6;
const enum_unnamed_36 = c_uint;
pub const POLL_IN: c_int = 1;
pub const POLL_OUT: c_int = 2;
pub const POLL_MSG: c_int = 3;
pub const POLL_ERR: c_int = 4;
pub const POLL_PRI: c_int = 5;
pub const POLL_HUP: c_int = 6;
const enum_unnamed_37 = c_uint;
pub const sigval_t = __sigval_t;
pub const sigevent_t = struct_sigevent;
pub const SIGEV_SIGNAL: c_int = 0;
pub const SIGEV_NONE: c_int = 1;
pub const SIGEV_THREAD: c_int = 2;
pub const SIGEV_THREAD_ID: c_int = 4;
const enum_unnamed_38 = c_uint;
pub const __sighandler_t = ?*const fn (c_int) callconv(.c) void;
pub extern fn __sysv_signal(__sig: c_int, __handler: __sighandler_t) __sighandler_t;
pub extern fn signal(__sig: c_int, __handler: __sighandler_t) __sighandler_t;
pub extern fn kill(__pid: __pid_t, __sig: c_int) c_int;
pub extern fn killpg(__pgrp: __pid_t, __sig: c_int) c_int;
pub extern fn raise(__sig: c_int) c_int;
pub extern fn ssignal(__sig: c_int, __handler: __sighandler_t) __sighandler_t;
pub extern fn gsignal(__sig: c_int) c_int;
pub extern fn psignal(__sig: c_int, __s: [*c]const u8) void;
pub extern fn psiginfo(__pinfo: [*c]const siginfo_t, __s: [*c]const u8) void;
pub extern fn sigblock(__mask: c_int) c_int;
pub extern fn sigsetmask(__mask: c_int) c_int;
pub extern fn siggetmask() c_int;
pub const sig_t = __sighandler_t;
pub extern fn sigemptyset(__set: [*c]sigset_t) c_int;
pub extern fn sigfillset(__set: [*c]sigset_t) c_int;
pub extern fn sigaddset(__set: [*c]sigset_t, __signo: c_int) c_int;
pub extern fn sigdelset(__set: [*c]sigset_t, __signo: c_int) c_int;
pub extern fn sigismember(__set: [*c]const sigset_t, __signo: c_int) c_int;
const union_unnamed_39 = extern union {
    sa_handler: __sighandler_t,
    sa_sigaction: ?*const fn (c_int, [*c]siginfo_t, ?*anyopaque) callconv(.c) void,
};
pub const struct_sigaction = extern struct {
    __sigaction_handler: union_unnamed_39 = @import("std").mem.zeroes(union_unnamed_39),
    sa_mask: __sigset_t = @import("std").mem.zeroes(__sigset_t),
    sa_flags: c_int = @import("std").mem.zeroes(c_int),
    sa_restorer: ?*const fn () callconv(.c) void = @import("std").mem.zeroes(?*const fn () callconv(.c) void),
};
pub extern fn sigprocmask(__how: c_int, noalias __set: [*c]const sigset_t, noalias __oset: [*c]sigset_t) c_int;
pub extern fn sigsuspend(__set: [*c]const sigset_t) c_int;
pub extern fn sigaction(__sig: c_int, noalias __act: [*c]const struct_sigaction, noalias __oact: [*c]struct_sigaction) c_int;
pub extern fn sigpending(__set: [*c]sigset_t) c_int;
pub extern fn sigwait(noalias __set: [*c]const sigset_t, noalias __sig: [*c]c_int) c_int;
pub extern fn sigwaitinfo(noalias __set: [*c]const sigset_t, noalias __info: [*c]siginfo_t) c_int;
pub extern fn sigtimedwait(noalias __set: [*c]const sigset_t, noalias __info: [*c]siginfo_t, noalias __timeout: [*c]const struct_timespec) c_int;
pub extern fn sigqueue(__pid: __pid_t, __sig: c_int, __val: union_sigval) c_int;
pub const struct__fpx_sw_bytes = extern struct {
    magic1: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    extended_size: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    xstate_bv: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    xstate_size: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    __glibc_reserved1: [7]__uint32_t = @import("std").mem.zeroes([7]__uint32_t),
};
pub const struct__fpreg = extern struct {
    significand: [4]c_ushort = @import("std").mem.zeroes([4]c_ushort),
    exponent: c_ushort = @import("std").mem.zeroes(c_ushort),
};
pub const struct__fpxreg = extern struct {
    significand: [4]c_ushort = @import("std").mem.zeroes([4]c_ushort),
    exponent: c_ushort = @import("std").mem.zeroes(c_ushort),
    __glibc_reserved1: [3]c_ushort = @import("std").mem.zeroes([3]c_ushort),
};
pub const struct__xmmreg = extern struct {
    element: [4]__uint32_t = @import("std").mem.zeroes([4]__uint32_t),
};
pub const struct__fpstate = extern struct {
    cwd: __uint16_t = @import("std").mem.zeroes(__uint16_t),
    swd: __uint16_t = @import("std").mem.zeroes(__uint16_t),
    ftw: __uint16_t = @import("std").mem.zeroes(__uint16_t),
    fop: __uint16_t = @import("std").mem.zeroes(__uint16_t),
    rip: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rdp: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    mxcsr: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    mxcr_mask: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    _st: [8]struct__fpxreg = @import("std").mem.zeroes([8]struct__fpxreg),
    _xmm: [16]struct__xmmreg = @import("std").mem.zeroes([16]struct__xmmreg),
    __glibc_reserved1: [24]__uint32_t = @import("std").mem.zeroes([24]__uint32_t),
};
const union_unnamed_40 = extern union {
    fpstate: [*c]struct__fpstate,
    __fpstate_word: __uint64_t,
};
pub const struct_sigcontext = extern struct {
    r8: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    r9: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    r10: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    r11: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    r12: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    r13: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    r14: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    r15: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rdi: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rsi: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rbp: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rbx: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rdx: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rax: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rcx: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rsp: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rip: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    eflags: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    cs: c_ushort = @import("std").mem.zeroes(c_ushort),
    gs: c_ushort = @import("std").mem.zeroes(c_ushort),
    fs: c_ushort = @import("std").mem.zeroes(c_ushort),
    __pad0: c_ushort = @import("std").mem.zeroes(c_ushort),
    err: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    trapno: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    oldmask: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    cr2: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    unnamed_0: union_unnamed_40 = @import("std").mem.zeroes(union_unnamed_40),
    __reserved1: [8]__uint64_t = @import("std").mem.zeroes([8]__uint64_t),
};
pub const struct__xsave_hdr = extern struct {
    xstate_bv: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    __glibc_reserved1: [2]__uint64_t = @import("std").mem.zeroes([2]__uint64_t),
    __glibc_reserved2: [5]__uint64_t = @import("std").mem.zeroes([5]__uint64_t),
};
pub const struct__ymmh_state = extern struct {
    ymmh_space: [64]__uint32_t = @import("std").mem.zeroes([64]__uint32_t),
};
pub const struct__xstate = extern struct {
    fpstate: struct__fpstate = @import("std").mem.zeroes(struct__fpstate),
    xstate_hdr: struct__xsave_hdr = @import("std").mem.zeroes(struct__xsave_hdr),
    ymmh: struct__ymmh_state = @import("std").mem.zeroes(struct__ymmh_state),
};
pub extern fn sigreturn(__scp: [*c]struct_sigcontext) c_int;
pub const stack_t = extern struct {
    ss_sp: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    ss_flags: c_int = @import("std").mem.zeroes(c_int),
    ss_size: usize = @import("std").mem.zeroes(usize),
};
pub const greg_t = c_longlong;
pub const gregset_t = [23]greg_t;
pub const struct__libc_fpxreg = extern struct {
    significand: [4]c_ushort = @import("std").mem.zeroes([4]c_ushort),
    exponent: c_ushort = @import("std").mem.zeroes(c_ushort),
    __glibc_reserved1: [3]c_ushort = @import("std").mem.zeroes([3]c_ushort),
};
pub const struct__libc_xmmreg = extern struct {
    element: [4]__uint32_t = @import("std").mem.zeroes([4]__uint32_t),
};
pub const struct__libc_fpstate = extern struct {
    cwd: __uint16_t = @import("std").mem.zeroes(__uint16_t),
    swd: __uint16_t = @import("std").mem.zeroes(__uint16_t),
    ftw: __uint16_t = @import("std").mem.zeroes(__uint16_t),
    fop: __uint16_t = @import("std").mem.zeroes(__uint16_t),
    rip: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rdp: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    mxcsr: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    mxcr_mask: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    _st: [8]struct__libc_fpxreg = @import("std").mem.zeroes([8]struct__libc_fpxreg),
    _xmm: [16]struct__libc_xmmreg = @import("std").mem.zeroes([16]struct__libc_xmmreg),
    __glibc_reserved1: [24]__uint32_t = @import("std").mem.zeroes([24]__uint32_t),
};
pub const fpregset_t = [*c]struct__libc_fpstate;
pub const mcontext_t = extern struct {
    gregs: gregset_t = @import("std").mem.zeroes(gregset_t),
    fpregs: fpregset_t = @import("std").mem.zeroes(fpregset_t),
    __reserved1: [8]c_ulonglong = @import("std").mem.zeroes([8]c_ulonglong),
};
pub const struct_ucontext_t = extern struct {
    uc_flags: c_ulong = @import("std").mem.zeroes(c_ulong),
    uc_link: [*c]struct_ucontext_t = @import("std").mem.zeroes([*c]struct_ucontext_t),
    uc_stack: stack_t = @import("std").mem.zeroes(stack_t),
    uc_mcontext: mcontext_t = @import("std").mem.zeroes(mcontext_t),
    uc_sigmask: sigset_t = @import("std").mem.zeroes(sigset_t),
    __fpregs_mem: struct__libc_fpstate = @import("std").mem.zeroes(struct__libc_fpstate),
    __ssp: [4]c_ulonglong = @import("std").mem.zeroes([4]c_ulonglong),
};
pub const ucontext_t = struct_ucontext_t;
pub extern fn siginterrupt(__sig: c_int, __interrupt: c_int) c_int;
pub const SS_ONSTACK: c_int = 1;
pub const SS_DISABLE: c_int = 2;
const enum_unnamed_41 = c_uint;
pub extern fn sigaltstack(noalias __ss: [*c]const stack_t, noalias __oss: [*c]stack_t) c_int;
pub const struct_sigstack = extern struct {
    ss_sp: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    ss_onstack: c_int = @import("std").mem.zeroes(c_int),
};
pub extern fn sigstack(__ss: [*c]struct_sigstack, __oss: [*c]struct_sigstack) c_int;
pub extern fn pthread_sigmask(__how: c_int, noalias __newmask: [*c]const __sigset_t, noalias __oldmask: [*c]__sigset_t) c_int;
pub extern fn pthread_kill(__threadid: pthread_t, __signo: c_int) c_int;
pub extern fn __libc_current_sigrtmin() c_int;
pub extern fn __libc_current_sigrtmax() c_int;
pub export fn crypt_argchk(arg_v: [*c]u8, arg_s: [*c]u8, arg_d: c_int) void {
    var v = arg_v;
    _ = &v;
    var s = arg_s;
    _ = &s;
    var d = arg_d;
    _ = &d;
    _ = fprintf(stderr, "LTC_ARGCHK '%s' failure on line %d of file %s\n", v, d, s);
    _ = raise(@as(c_int, 6));
}
pub extern fn __assert_fail(__assertion: [*c]const u8, __file: [*c]const u8, __line: c_uint, __function: [*c]const u8) noreturn;
pub extern fn __assert_perror_fail(__errnum: c_int, __file: [*c]const u8, __line: c_uint, __function: [*c]const u8) noreturn;
pub extern fn __assert(__assertion: [*c]const u8, __file: [*c]const u8, __line: c_int) noreturn;
pub const CRYPT_OK: c_int = 0;
pub const CRYPT_ERROR: c_int = 1;
pub const CRYPT_NOP: c_int = 2;
pub const CRYPT_INVALID_KEYSIZE: c_int = 3;
pub const CRYPT_INVALID_ROUNDS: c_int = 4;
pub const CRYPT_FAIL_TESTVECTOR: c_int = 5;
pub const CRYPT_BUFFER_OVERFLOW: c_int = 6;
pub const CRYPT_INVALID_PACKET: c_int = 7;
pub const CRYPT_INVALID_PRNGSIZE: c_int = 8;
pub const CRYPT_ERROR_READPRNG: c_int = 9;
pub const CRYPT_INVALID_CIPHER: c_int = 10;
pub const CRYPT_INVALID_HASH: c_int = 11;
pub const CRYPT_INVALID_PRNG: c_int = 12;
pub const CRYPT_MEM: c_int = 13;
pub const CRYPT_PK_TYPE_MISMATCH: c_int = 14;
pub const CRYPT_PK_NOT_PRIVATE: c_int = 15;
pub const CRYPT_INVALID_ARG: c_int = 16;
pub const CRYPT_FILE_NOTFOUND: c_int = 17;
pub const CRYPT_PK_INVALID_TYPE: c_int = 18;
pub const CRYPT_OVERFLOW: c_int = 19;
pub const CRYPT_PK_ASN1_ERROR: c_int = 20;
pub const CRYPT_INPUT_TOO_LONG: c_int = 21;
pub const CRYPT_PK_INVALID_SIZE: c_int = 22;
pub const CRYPT_INVALID_PRIME_SIZE: c_int = 23;
pub const CRYPT_PK_INVALID_PADDING: c_int = 24;
pub const CRYPT_HASH_OVERFLOW: c_int = 25;
pub const CRYPT_PW_CTX_MISSING: c_int = 26;
pub const CRYPT_UNKNOWN_PEM: c_int = 27;
const enum_unnamed_42 = c_uint;
pub const ulong64 = c_ulonglong;
pub const long64 = c_longlong;
pub const ulong32 = c_uint;
// ./libtomcrypt.c:13831:5: warning: TODO implement translation of stmt class GCCAsmStmtClass

// ./libtomcrypt.c:13830:24: warning: unable to translate function, demoted to extern
pub extern fn ROL(arg_word: c_uint, arg_i: c_int) callconv(.c) c_uint;
// ./libtomcrypt.c:13838:5: warning: TODO implement translation of stmt class GCCAsmStmtClass

// ./libtomcrypt.c:13837:24: warning: unable to translate function, demoted to extern
pub extern fn ROR(arg_word: c_uint, arg_i: c_int) callconv(.c) c_uint;
// ./libtomcrypt.c:13919:5: warning: TODO implement translation of stmt class GCCAsmStmtClass

// ./libtomcrypt.c:13918:29: warning: unable to translate function, demoted to extern
pub extern fn ROL64(arg_word: c_ulong, arg_i: c_int) callconv(.c) c_ulong;
// ./libtomcrypt.c:13926:5: warning: TODO implement translation of stmt class GCCAsmStmtClass

// ./libtomcrypt.c:13925:29: warning: unable to translate function, demoted to extern
pub extern fn ROR64(arg_word: c_ulong, arg_i: c_int) callconv(.c) c_ulong;
pub const struct_blowfish_key = extern struct {
    S: [4][256]ulong32 = @import("std").mem.zeroes([4][256]ulong32),
    K: [18]ulong32 = @import("std").mem.zeroes([18]ulong32),
};
pub const struct_rc5_key = extern struct {
    rounds: c_int = @import("std").mem.zeroes(c_int),
    K: [50]ulong32 = @import("std").mem.zeroes([50]ulong32),
};
pub const struct_rc6_key = extern struct {
    K: [44]ulong32 = @import("std").mem.zeroes([44]ulong32),
};
pub const struct_saferp_key = extern struct {
    K: [33][16]u8 = @import("std").mem.zeroes([33][16]u8),
    rounds: c_long = @import("std").mem.zeroes(c_long),
};
pub const struct_rijndael_key = extern struct {
    eK: [60]ulong32 = @import("std").mem.zeroes([60]ulong32),
    dK: [60]ulong32 = @import("std").mem.zeroes([60]ulong32),
    Nr: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct_kseed_key = extern struct {
    K: [32]ulong32 = @import("std").mem.zeroes([32]ulong32),
    dK: [32]ulong32 = @import("std").mem.zeroes([32]ulong32),
};
pub const struct_kasumi_key = extern struct {
    KLi1: [8]ulong32 = @import("std").mem.zeroes([8]ulong32),
    KLi2: [8]ulong32 = @import("std").mem.zeroes([8]ulong32),
    KOi1: [8]ulong32 = @import("std").mem.zeroes([8]ulong32),
    KOi2: [8]ulong32 = @import("std").mem.zeroes([8]ulong32),
    KOi3: [8]ulong32 = @import("std").mem.zeroes([8]ulong32),
    KIi1: [8]ulong32 = @import("std").mem.zeroes([8]ulong32),
    KIi2: [8]ulong32 = @import("std").mem.zeroes([8]ulong32),
    KIi3: [8]ulong32 = @import("std").mem.zeroes([8]ulong32),
};
pub const struct_xtea_key = extern struct {
    A: [32]c_ulong = @import("std").mem.zeroes([32]c_ulong),
    B: [32]c_ulong = @import("std").mem.zeroes([32]c_ulong),
};
pub const struct_twofish_key = extern struct {
    S: [4][256]ulong32 = @import("std").mem.zeroes([4][256]ulong32),
    K: [40]ulong32 = @import("std").mem.zeroes([40]ulong32),
};
pub const safer_block_t = [8]u8;
pub const safer_key_t = [217]u8;
pub const struct_safer_key = extern struct {
    key: safer_key_t = @import("std").mem.zeroes(safer_key_t),
};
pub const struct_rc2_key = extern struct {
    xkey: [64]c_uint = @import("std").mem.zeroes([64]c_uint),
};
pub const struct_des_key = extern struct {
    ek: [32]ulong32 = @import("std").mem.zeroes([32]ulong32),
    dk: [32]ulong32 = @import("std").mem.zeroes([32]ulong32),
};
pub const struct_des3_key = extern struct {
    ek: [3][32]ulong32 = @import("std").mem.zeroes([3][32]ulong32),
    dk: [3][32]ulong32 = @import("std").mem.zeroes([3][32]ulong32),
};
pub const struct_cast5_key = extern struct {
    K: [32]ulong32 = @import("std").mem.zeroes([32]ulong32),
    keylen: ulong32 = @import("std").mem.zeroes(ulong32),
};
pub const struct_noekeon_key = extern struct {
    K: [4]ulong32 = @import("std").mem.zeroes([4]ulong32),
    dK: [4]ulong32 = @import("std").mem.zeroes([4]ulong32),
};
pub const struct_skipjack_key = extern struct {
    key: [10]u8 = @import("std").mem.zeroes([10]u8),
};
pub const struct_khazad_key = extern struct {
    roundKeyEnc: [9]ulong64 = @import("std").mem.zeroes([9]ulong64),
    roundKeyDec: [9]ulong64 = @import("std").mem.zeroes([9]ulong64),
};
pub const struct_anubis_key = extern struct {
    keyBits: c_int = @import("std").mem.zeroes(c_int),
    R: c_int = @import("std").mem.zeroes(c_int),
    roundKeyEnc: [19][4]ulong32 = @import("std").mem.zeroes([19][4]ulong32),
    roundKeyDec: [19][4]ulong32 = @import("std").mem.zeroes([19][4]ulong32),
};
pub const union_Symmetric_key = extern union {
    des: struct_des_key,
    des3: struct_des3_key,
    rc2: struct_rc2_key,
    safer: struct_safer_key,
    twofish: struct_twofish_key,
    blowfish: struct_blowfish_key,
    rc5: struct_rc5_key,
    rc6: struct_rc6_key,
    saferp: struct_saferp_key,
    rijndael: struct_rijndael_key,
    xtea: struct_xtea_key,
    cast5: struct_cast5_key,
    noekeon: struct_noekeon_key,
    skipjack: struct_skipjack_key,
    khazad: struct_khazad_key,
    anubis: struct_anubis_key,
    kseed: struct_kseed_key,
    kasumi: struct_kasumi_key,
    data: ?*anyopaque,
};
pub const symmetric_key = union_Symmetric_key;
pub const symmetric_ECB = extern struct {
    cipher: c_int = @import("std").mem.zeroes(c_int),
    blocklen: c_int = @import("std").mem.zeroes(c_int),
    key: symmetric_key = @import("std").mem.zeroes(symmetric_key),
};
pub const symmetric_CFB = extern struct {
    cipher: c_int = @import("std").mem.zeroes(c_int),
    blocklen: c_int = @import("std").mem.zeroes(c_int),
    padlen: c_int = @import("std").mem.zeroes(c_int),
    IV: [128]u8 = @import("std").mem.zeroes([128]u8),
    pad: [128]u8 = @import("std").mem.zeroes([128]u8),
    key: symmetric_key = @import("std").mem.zeroes(symmetric_key),
};
pub const symmetric_OFB = extern struct {
    cipher: c_int = @import("std").mem.zeroes(c_int),
    blocklen: c_int = @import("std").mem.zeroes(c_int),
    padlen: c_int = @import("std").mem.zeroes(c_int),
    IV: [128]u8 = @import("std").mem.zeroes([128]u8),
    key: symmetric_key = @import("std").mem.zeroes(symmetric_key),
};
pub const symmetric_CBC = extern struct {
    cipher: c_int = @import("std").mem.zeroes(c_int),
    blocklen: c_int = @import("std").mem.zeroes(c_int),
    IV: [128]u8 = @import("std").mem.zeroes([128]u8),
    key: symmetric_key = @import("std").mem.zeroes(symmetric_key),
};
pub const symmetric_CTR = extern struct {
    cipher: c_int = @import("std").mem.zeroes(c_int),
    blocklen: c_int = @import("std").mem.zeroes(c_int),
    padlen: c_int = @import("std").mem.zeroes(c_int),
    mode: c_int = @import("std").mem.zeroes(c_int),
    ctrlen: c_int = @import("std").mem.zeroes(c_int),
    ctr: [128]u8 = @import("std").mem.zeroes([128]u8),
    pad: [128]u8 = @import("std").mem.zeroes([128]u8),
    key: symmetric_key = @import("std").mem.zeroes(symmetric_key),
};
pub const symmetric_LRW = extern struct {
    cipher: c_int = @import("std").mem.zeroes(c_int),
    IV: [16]u8 = @import("std").mem.zeroes([16]u8),
    tweak: [16]u8 = @import("std").mem.zeroes([16]u8),
    pad: [16]u8 = @import("std").mem.zeroes([16]u8),
    key: symmetric_key = @import("std").mem.zeroes(symmetric_key),
    PC: [16][256][16]u8 = @import("std").mem.zeroes([16][256][16]u8),
};
pub const symmetric_F8 = extern struct {
    cipher: c_int = @import("std").mem.zeroes(c_int),
    blocklen: c_int = @import("std").mem.zeroes(c_int),
    padlen: c_int = @import("std").mem.zeroes(c_int),
    IV: [128]u8 = @import("std").mem.zeroes([128]u8),
    MIV: [128]u8 = @import("std").mem.zeroes([128]u8),
    blockcnt: ulong32 = @import("std").mem.zeroes(ulong32),
    key: symmetric_key = @import("std").mem.zeroes(symmetric_key),
};
pub const struct_ltc_cipher_descriptor = extern struct {
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    ID: u8 = @import("std").mem.zeroes(u8),
    min_key_length: c_int = @import("std").mem.zeroes(c_int),
    max_key_length: c_int = @import("std").mem.zeroes(c_int),
    block_length: c_int = @import("std").mem.zeroes(c_int),
    default_rounds: c_int = @import("std").mem.zeroes(c_int),
    setup: ?*const fn ([*c]const u8, c_int, c_int, [*c]symmetric_key) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, c_int, c_int, [*c]symmetric_key) callconv(.c) c_int),
    ecb_encrypt: ?*const fn ([*c]const u8, [*c]u8, [*c]symmetric_key) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, [*c]u8, [*c]symmetric_key) callconv(.c) c_int),
    ecb_decrypt: ?*const fn ([*c]const u8, [*c]u8, [*c]symmetric_key) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, [*c]u8, [*c]symmetric_key) callconv(.c) c_int),
    @"test": ?*const fn () callconv(.c) c_int = @import("std").mem.zeroes(?*const fn () callconv(.c) c_int),
    done: ?*const fn ([*c]symmetric_key) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]symmetric_key) callconv(.c) void),
    keysize: ?*const fn ([*c]c_int) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]c_int) callconv(.c) c_int),
    accel_ecb_encrypt: ?*const fn ([*c]const u8, [*c]u8, c_ulong, [*c]symmetric_key) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, [*c]u8, c_ulong, [*c]symmetric_key) callconv(.c) c_int),
    accel_ecb_decrypt: ?*const fn ([*c]const u8, [*c]u8, c_ulong, [*c]symmetric_key) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, [*c]u8, c_ulong, [*c]symmetric_key) callconv(.c) c_int),
    accel_cbc_encrypt: ?*const fn ([*c]const u8, [*c]u8, c_ulong, [*c]u8, [*c]symmetric_key) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, [*c]u8, c_ulong, [*c]u8, [*c]symmetric_key) callconv(.c) c_int),
    accel_cbc_decrypt: ?*const fn ([*c]const u8, [*c]u8, c_ulong, [*c]u8, [*c]symmetric_key) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, [*c]u8, c_ulong, [*c]u8, [*c]symmetric_key) callconv(.c) c_int),
    accel_ctr_encrypt: ?*const fn ([*c]const u8, [*c]u8, c_ulong, [*c]u8, c_int, [*c]symmetric_key) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, [*c]u8, c_ulong, [*c]u8, c_int, [*c]symmetric_key) callconv(.c) c_int),
    accel_lrw_encrypt: ?*const fn ([*c]const u8, [*c]u8, c_ulong, [*c]u8, [*c]const u8, [*c]symmetric_key) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, [*c]u8, c_ulong, [*c]u8, [*c]const u8, [*c]symmetric_key) callconv(.c) c_int),
    accel_lrw_decrypt: ?*const fn ([*c]const u8, [*c]u8, c_ulong, [*c]u8, [*c]const u8, [*c]symmetric_key) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, [*c]u8, c_ulong, [*c]u8, [*c]const u8, [*c]symmetric_key) callconv(.c) c_int),
    accel_ccm_memory: ?*const fn ([*c]const u8, c_ulong, [*c]symmetric_key, [*c]const u8, c_ulong, [*c]const u8, c_ulong, [*c]u8, c_ulong, [*c]u8, [*c]u8, [*c]c_ulong, c_int) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, c_ulong, [*c]symmetric_key, [*c]const u8, c_ulong, [*c]const u8, c_ulong, [*c]u8, c_ulong, [*c]u8, [*c]u8, [*c]c_ulong, c_int) callconv(.c) c_int),
    accel_gcm_memory: ?*const fn ([*c]const u8, c_ulong, [*c]const u8, c_ulong, [*c]const u8, c_ulong, [*c]u8, c_ulong, [*c]u8, [*c]u8, [*c]c_ulong, c_int) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, c_ulong, [*c]const u8, c_ulong, [*c]const u8, c_ulong, [*c]u8, c_ulong, [*c]u8, [*c]u8, [*c]c_ulong, c_int) callconv(.c) c_int),
    omac_memory: ?*const fn ([*c]const u8, c_ulong, [*c]const u8, c_ulong, [*c]u8, [*c]c_ulong) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, c_ulong, [*c]const u8, c_ulong, [*c]u8, [*c]c_ulong) callconv(.c) c_int),
    xcbc_memory: ?*const fn ([*c]const u8, c_ulong, [*c]const u8, c_ulong, [*c]u8, [*c]c_ulong) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, c_ulong, [*c]const u8, c_ulong, [*c]u8, [*c]c_ulong) callconv(.c) c_int),
    f9_memory: ?*const fn ([*c]const u8, c_ulong, [*c]const u8, c_ulong, [*c]u8, [*c]c_ulong) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, c_ulong, [*c]const u8, c_ulong, [*c]u8, [*c]c_ulong) callconv(.c) c_int),
};
pub const cipher_descriptor: [*c]struct_ltc_cipher_descriptor = @extern([*c]struct_ltc_cipher_descriptor, .{
    .name = "cipher_descriptor",
});
pub extern fn blowfish_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn blowfish_ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn blowfish_ecb_decrypt(ct: [*c]const u8, pt: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn blowfish_test() c_int;
pub extern fn blowfish_done(skey: [*c]symmetric_key) void;
pub extern fn blowfish_keysize(keysize: [*c]c_int) c_int;
pub extern const blowfish_desc: struct_ltc_cipher_descriptor;
pub extern fn rc5_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn rc5_ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn rc5_ecb_decrypt(ct: [*c]const u8, pt: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn rc5_test() c_int;
pub extern fn rc5_done(skey: [*c]symmetric_key) void;
pub extern fn rc5_keysize(keysize: [*c]c_int) c_int;
pub extern const rc5_desc: struct_ltc_cipher_descriptor;
pub extern fn rc6_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn rc6_ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn rc6_ecb_decrypt(ct: [*c]const u8, pt: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn rc6_test() c_int;
pub extern fn rc6_done(skey: [*c]symmetric_key) void;
pub extern fn rc6_keysize(keysize: [*c]c_int) c_int;
pub extern const rc6_desc: struct_ltc_cipher_descriptor;
pub extern fn rc2_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn rc2_ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn rc2_ecb_decrypt(ct: [*c]const u8, pt: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn rc2_test() c_int;
pub extern fn rc2_done(skey: [*c]symmetric_key) void;
pub extern fn rc2_keysize(keysize: [*c]c_int) c_int;
pub extern const rc2_desc: struct_ltc_cipher_descriptor;
pub extern fn saferp_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn saferp_ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn saferp_ecb_decrypt(ct: [*c]const u8, pt: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn saferp_test() c_int;
pub extern fn saferp_done(skey: [*c]symmetric_key) void;
pub extern fn saferp_keysize(keysize: [*c]c_int) c_int;
pub extern const saferp_desc: struct_ltc_cipher_descriptor;
pub extern fn safer_k64_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn safer_sk64_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn safer_k128_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn safer_sk128_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn safer_ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, key: [*c]symmetric_key) c_int;
pub extern fn safer_ecb_decrypt(ct: [*c]const u8, pt: [*c]u8, key: [*c]symmetric_key) c_int;
pub extern fn safer_k64_test() c_int;
pub extern fn safer_sk64_test() c_int;
pub extern fn safer_sk128_test() c_int;
pub extern fn safer_done(skey: [*c]symmetric_key) void;
pub extern fn safer_64_keysize(keysize: [*c]c_int) c_int;
pub extern fn safer_128_keysize(keysize: [*c]c_int) c_int;
pub extern const safer_k64_desc: struct_ltc_cipher_descriptor;
pub extern const safer_k128_desc: struct_ltc_cipher_descriptor;
pub extern const safer_sk64_desc: struct_ltc_cipher_descriptor;
pub extern const safer_sk128_desc: struct_ltc_cipher_descriptor;
// ./libtomcrypt.c:13667:5: warning: TODO implement translation of stmt class GCCAsmStmtClass

// ./libtomcrypt.c:32159:18: warning: unable to translate function, demoted to extern
pub extern fn rijndael_setup(arg_key: [*c]const u8, arg_keylen: c_int, arg_num_rounds: c_int, arg_skey: [*c]symmetric_key) c_int;
// ./libtomcrypt.c:13667:5: warning: TODO implement translation of stmt class GCCAsmStmtClass

// ./libtomcrypt.c:32160:18: warning: unable to translate function, demoted to extern
pub extern fn rijndael_ecb_encrypt(arg_pt: [*c]const u8, arg_ct: [*c]u8, arg_skey: [*c]symmetric_key) c_int;
// ./libtomcrypt.c:13667:5: warning: TODO implement translation of stmt class GCCAsmStmtClass

// ./libtomcrypt.c:32161:18: warning: unable to translate function, demoted to extern
pub extern fn rijndael_ecb_decrypt(arg_ct: [*c]const u8, arg_pt: [*c]u8, arg_skey: [*c]symmetric_key) c_int;
pub export fn rijndael_test() c_int {
    var err: c_int = undefined;
    _ = &err;
    const struct_unnamed_43 = extern struct {
        keylen: c_int = @import("std").mem.zeroes(c_int),
        key: [32]u8 = @import("std").mem.zeroes([32]u8),
        pt: [16]u8 = @import("std").mem.zeroes([16]u8),
        ct: [16]u8 = @import("std").mem.zeroes([16]u8),
    };
    _ = &struct_unnamed_43;
    const tests = struct {
        const static: [3]struct_unnamed_43 = [3]struct_unnamed_43{
            struct_unnamed_43{
                .keylen = @as(c_int, 16),
                .key = [16]u8{
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                } ++ [1]u8{0} ** 16,
                .pt = [16]u8{
                    0,
                    17,
                    34,
                    51,
                    68,
                    85,
                    102,
                    119,
                    136,
                    153,
                    170,
                    187,
                    204,
                    221,
                    238,
                    255,
                },
                .ct = [16]u8{
                    105,
                    196,
                    224,
                    216,
                    106,
                    123,
                    4,
                    48,
                    216,
                    205,
                    183,
                    128,
                    112,
                    180,
                    197,
                    90,
                },
            },
            struct_unnamed_43{
                .keylen = @as(c_int, 24),
                .key = [24]u8{
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                } ++ [1]u8{0} ** 8,
                .pt = [16]u8{
                    0,
                    17,
                    34,
                    51,
                    68,
                    85,
                    102,
                    119,
                    136,
                    153,
                    170,
                    187,
                    204,
                    221,
                    238,
                    255,
                },
                .ct = [16]u8{
                    221,
                    169,
                    124,
                    164,
                    134,
                    76,
                    223,
                    224,
                    110,
                    175,
                    112,
                    160,
                    236,
                    13,
                    113,
                    145,
                },
            },
            struct_unnamed_43{
                .keylen = @as(c_int, 32),
                .key = [32]u8{
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                    30,
                    31,
                },
                .pt = [16]u8{
                    0,
                    17,
                    34,
                    51,
                    68,
                    85,
                    102,
                    119,
                    136,
                    153,
                    170,
                    187,
                    204,
                    221,
                    238,
                    255,
                },
                .ct = [16]u8{
                    142,
                    162,
                    183,
                    202,
                    81,
                    103,
                    69,
                    191,
                    234,
                    252,
                    73,
                    144,
                    75,
                    73,
                    96,
                    137,
                },
            },
        };
    };
    _ = &tests;
    var key: symmetric_key = undefined;
    _ = &key;
    var tmp: [2][16]u8 = undefined;
    _ = &tmp;
    var i: c_int = undefined;
    _ = &i;
    var y: c_int = undefined;
    _ = &y;
    {
        i = 0;
        while (i < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([3]struct_unnamed_43) / @sizeOf(struct_unnamed_43)))))) : (i += 1) {
            zeromem(@as(?*anyopaque, @ptrCast(&key)), @sizeOf(symmetric_key));
            if ((blk: {
                const tmp_1 = rijndael_setup(@as([*c]const u8, @ptrCast(@alignCast(&tests.static[@as(c_uint, @intCast(i))].key))), tests.static[@as(c_uint, @intCast(i))].keylen, @as(c_int, 0), &key);
                err = tmp_1;
                break :blk tmp_1;
            }) != CRYPT_OK) {
                return err;
            }
            _ = rijndael_ecb_encrypt(@as([*c]const u8, @ptrCast(@alignCast(&tests.static[@as(c_uint, @intCast(i))].pt))), @as([*c]u8, @ptrCast(@alignCast(&tmp[@as(c_uint, @intCast(@as(c_int, 0)))]))), &key);
            _ = rijndael_ecb_decrypt(@as([*c]u8, @ptrCast(@alignCast(&tmp[@as(c_uint, @intCast(@as(c_int, 0)))]))), @as([*c]u8, @ptrCast(@alignCast(&tmp[@as(c_uint, @intCast(@as(c_int, 1)))]))), &key);
            if ((memcmp(@as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&tmp[@as(c_uint, @intCast(@as(c_int, 0)))]))))), @as(?*const anyopaque, @ptrCast(@as([*c]const u8, @ptrCast(@alignCast(&tests.static[@as(c_uint, @intCast(i))].ct))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16))))) != 0) or (memcmp(@as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&tmp[@as(c_uint, @intCast(@as(c_int, 1)))]))))), @as(?*const anyopaque, @ptrCast(@as([*c]const u8, @ptrCast(@alignCast(&tests.static[@as(c_uint, @intCast(i))].pt))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16))))) != 0)) {
                return CRYPT_FAIL_TESTVECTOR;
            }
            {
                y = 0;
                while (y < @as(c_int, 16)) : (y += 1) {
                    tmp[@as(c_uint, @intCast(@as(c_int, 0)))][@as(c_uint, @intCast(y))] = 0;
                }
            }
            {
                y = 0;
                while (y < @as(c_int, 1000)) : (y += 1) {
                    _ = rijndael_ecb_encrypt(@as([*c]u8, @ptrCast(@alignCast(&tmp[@as(c_uint, @intCast(@as(c_int, 0)))]))), @as([*c]u8, @ptrCast(@alignCast(&tmp[@as(c_uint, @intCast(@as(c_int, 0)))]))), &key);
                }
            }
            {
                y = 0;
                while (y < @as(c_int, 1000)) : (y += 1) {
                    _ = rijndael_ecb_decrypt(@as([*c]u8, @ptrCast(@alignCast(&tmp[@as(c_uint, @intCast(@as(c_int, 0)))]))), @as([*c]u8, @ptrCast(@alignCast(&tmp[@as(c_uint, @intCast(@as(c_int, 0)))]))), &key);
                }
            }
            {
                y = 0;
                while (y < @as(c_int, 16)) : (y += 1) if (@as(c_int, @bitCast(@as(c_uint, tmp[@as(c_uint, @intCast(@as(c_int, 0)))][@as(c_uint, @intCast(y))]))) != @as(c_int, 0)) return CRYPT_FAIL_TESTVECTOR;
            }
        }
    }
    return CRYPT_OK;
}
pub export fn rijndael_done(arg_skey: [*c]symmetric_key) void {
    var skey = arg_skey;
    _ = &skey;
}
pub export fn rijndael_keysize(arg_keysize: [*c]c_int) c_int {
    var keysize = arg_keysize;
    _ = &keysize;
    if (!(keysize != @as([*c]c_int, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("keysize != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 32859));
    }
    if (keysize.* < @as(c_int, 16)) return CRYPT_INVALID_KEYSIZE;
    if (keysize.* < @as(c_int, 24)) {
        keysize.* = 16;
        return CRYPT_OK;
    } else if (keysize.* < @as(c_int, 32)) {
        keysize.* = 24;
        return CRYPT_OK;
    } else {
        keysize.* = 32;
        return CRYPT_OK;
    }
    return 0;
}
pub extern fn rijndael_enc_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn rijndael_enc_ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn rijndael_enc_done(skey: [*c]symmetric_key) void;
pub extern fn rijndael_enc_keysize(keysize: [*c]c_int) c_int;
pub extern const rijndael_desc: struct_ltc_cipher_descriptor;
pub extern const aes_desc: struct_ltc_cipher_descriptor;
pub extern const rijndael_enc_desc: struct_ltc_cipher_descriptor;
pub extern const aes_enc_desc: struct_ltc_cipher_descriptor;
pub extern fn xtea_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn xtea_ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn xtea_ecb_decrypt(ct: [*c]const u8, pt: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn xtea_test() c_int;
pub extern fn xtea_done(skey: [*c]symmetric_key) void;
pub extern fn xtea_keysize(keysize: [*c]c_int) c_int;
pub extern const xtea_desc: struct_ltc_cipher_descriptor;
pub extern fn twofish_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn twofish_ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn twofish_ecb_decrypt(ct: [*c]const u8, pt: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn twofish_test() c_int;
pub extern fn twofish_done(skey: [*c]symmetric_key) void;
pub extern fn twofish_keysize(keysize: [*c]c_int) c_int;
pub extern const twofish_desc: struct_ltc_cipher_descriptor;
pub extern fn des_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn des_ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn des_ecb_decrypt(ct: [*c]const u8, pt: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn des_test() c_int;
pub extern fn des_done(skey: [*c]symmetric_key) void;
pub extern fn des_keysize(keysize: [*c]c_int) c_int;
pub extern fn des3_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn des3_ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn des3_ecb_decrypt(ct: [*c]const u8, pt: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn des3_test() c_int;
pub extern fn des3_done(skey: [*c]symmetric_key) void;
pub extern fn des3_keysize(keysize: [*c]c_int) c_int;
pub extern const des_desc: struct_ltc_cipher_descriptor;
pub extern const des3_desc: struct_ltc_cipher_descriptor;
pub extern fn cast5_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn cast5_ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn cast5_ecb_decrypt(ct: [*c]const u8, pt: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn cast5_test() c_int;
pub extern fn cast5_done(skey: [*c]symmetric_key) void;
pub extern fn cast5_keysize(keysize: [*c]c_int) c_int;
pub extern const cast5_desc: struct_ltc_cipher_descriptor;
pub extern fn noekeon_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn noekeon_ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn noekeon_ecb_decrypt(ct: [*c]const u8, pt: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn noekeon_test() c_int;
pub extern fn noekeon_done(skey: [*c]symmetric_key) void;
pub extern fn noekeon_keysize(keysize: [*c]c_int) c_int;
pub extern const noekeon_desc: struct_ltc_cipher_descriptor;
pub extern fn skipjack_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn skipjack_ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn skipjack_ecb_decrypt(ct: [*c]const u8, pt: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn skipjack_test() c_int;
pub extern fn skipjack_done(skey: [*c]symmetric_key) void;
pub extern fn skipjack_keysize(keysize: [*c]c_int) c_int;
pub extern const skipjack_desc: struct_ltc_cipher_descriptor;
pub extern fn khazad_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn khazad_ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn khazad_ecb_decrypt(ct: [*c]const u8, pt: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn khazad_test() c_int;
pub extern fn khazad_done(skey: [*c]symmetric_key) void;
pub extern fn khazad_keysize(keysize: [*c]c_int) c_int;
pub extern const khazad_desc: struct_ltc_cipher_descriptor;
pub extern fn anubis_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn anubis_ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn anubis_ecb_decrypt(ct: [*c]const u8, pt: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn anubis_test() c_int;
pub extern fn anubis_done(skey: [*c]symmetric_key) void;
pub extern fn anubis_keysize(keysize: [*c]c_int) c_int;
pub extern const anubis_desc: struct_ltc_cipher_descriptor;
pub extern fn kseed_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn kseed_ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn kseed_ecb_decrypt(ct: [*c]const u8, pt: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn kseed_test() c_int;
pub extern fn kseed_done(skey: [*c]symmetric_key) void;
pub extern fn kseed_keysize(keysize: [*c]c_int) c_int;
pub extern const kseed_desc: struct_ltc_cipher_descriptor;
pub extern fn kasumi_setup(key: [*c]const u8, keylen: c_int, num_rounds: c_int, skey: [*c]symmetric_key) c_int;
pub extern fn kasumi_ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn kasumi_ecb_decrypt(ct: [*c]const u8, pt: [*c]u8, skey: [*c]symmetric_key) c_int;
pub extern fn kasumi_test() c_int;
pub extern fn kasumi_done(skey: [*c]symmetric_key) void;
pub extern fn kasumi_keysize(keysize: [*c]c_int) c_int;
pub extern const kasumi_desc: struct_ltc_cipher_descriptor;
pub extern fn ecb_start(cipher: c_int, key: [*c]const u8, keylen: c_int, num_rounds: c_int, ecb: [*c]symmetric_ECB) c_int;
pub extern fn ecb_encrypt(pt: [*c]const u8, ct: [*c]u8, len: c_ulong, ecb: [*c]symmetric_ECB) c_int;
pub extern fn ecb_decrypt(ct: [*c]const u8, pt: [*c]u8, len: c_ulong, ecb: [*c]symmetric_ECB) c_int;
pub extern fn ecb_done(ecb: [*c]symmetric_ECB) c_int;
pub extern fn cfb_start(cipher: c_int, IV: [*c]const u8, key: [*c]const u8, keylen: c_int, num_rounds: c_int, cfb: [*c]symmetric_CFB) c_int;
pub extern fn cfb_encrypt(pt: [*c]const u8, ct: [*c]u8, len: c_ulong, cfb: [*c]symmetric_CFB) c_int;
pub extern fn cfb_decrypt(ct: [*c]const u8, pt: [*c]u8, len: c_ulong, cfb: [*c]symmetric_CFB) c_int;
pub extern fn cfb_getiv(IV: [*c]u8, len: [*c]c_ulong, cfb: [*c]symmetric_CFB) c_int;
pub extern fn cfb_setiv(IV: [*c]const u8, len: c_ulong, cfb: [*c]symmetric_CFB) c_int;
pub extern fn cfb_done(cfb: [*c]symmetric_CFB) c_int;
pub extern fn ofb_start(cipher: c_int, IV: [*c]const u8, key: [*c]const u8, keylen: c_int, num_rounds: c_int, ofb: [*c]symmetric_OFB) c_int;
pub extern fn ofb_encrypt(pt: [*c]const u8, ct: [*c]u8, len: c_ulong, ofb: [*c]symmetric_OFB) c_int;
pub extern fn ofb_decrypt(ct: [*c]const u8, pt: [*c]u8, len: c_ulong, ofb: [*c]symmetric_OFB) c_int;
pub extern fn ofb_getiv(IV: [*c]u8, len: [*c]c_ulong, ofb: [*c]symmetric_OFB) c_int;
pub extern fn ofb_setiv(IV: [*c]const u8, len: c_ulong, ofb: [*c]symmetric_OFB) c_int;
pub extern fn ofb_done(ofb: [*c]symmetric_OFB) c_int;
pub export fn cbc_start(arg_cipher: c_int, arg_IV: [*c]const u8, arg_key: [*c]const u8, arg_keylen: c_int, arg_num_rounds: c_int, arg_cbc: [*c]symmetric_CBC) c_int {
    var cipher = arg_cipher;
    _ = &cipher;
    var IV = arg_IV;
    _ = &IV;
    var key = arg_key;
    _ = &key;
    var keylen = arg_keylen;
    _ = &keylen;
    var num_rounds = arg_num_rounds;
    _ = &num_rounds;
    var cbc = arg_cbc;
    _ = &cbc;
    var x: c_int = undefined;
    _ = &x;
    var err: c_int = undefined;
    _ = &err;
    if (!(IV != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("IV != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33254));
    }
    if (!(key != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("key != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33255));
    }
    if (!(cbc != @as([*c]symmetric_CBC, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("cbc != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33256));
    }
    if ((blk: {
        const tmp = cipher_is_valid(cipher);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if ((blk: {
        const tmp = cipher_descriptor[@as(c_uint, @intCast(cipher))].setup.?(key, keylen, num_rounds, &cbc.*.key);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    cbc.*.blocklen = cipher_descriptor[@as(c_uint, @intCast(cipher))].block_length;
    cbc.*.cipher = cipher;
    {
        x = 0;
        while (x < cbc.*.blocklen) : (x += 1) {
            cbc.*.IV[@as(c_uint, @intCast(x))] = (blk: {
                const tmp = x;
                if (tmp >= 0) break :blk IV + @as(usize, @intCast(tmp)) else break :blk IV - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
        }
    }
    return CRYPT_OK;
}
pub export fn cbc_encrypt(arg_pt: [*c]const u8, arg_ct: [*c]u8, arg_len: c_ulong, arg_cbc: [*c]symmetric_CBC) c_int {
    var pt = arg_pt;
    _ = &pt;
    var ct = arg_ct;
    _ = &ct;
    var len = arg_len;
    _ = &len;
    var cbc = arg_cbc;
    _ = &cbc;
    var x: c_int = undefined;
    _ = &x;
    var err: c_int = undefined;
    _ = &err;
    if (!(pt != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("pt != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33058));
    }
    if (!(ct != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ct != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33059));
    }
    if (!(cbc != @as([*c]symmetric_CBC, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("cbc != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33060));
    }
    if ((blk: {
        const tmp = cipher_is_valid(cbc.*.cipher);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if ((cbc.*.blocklen < @as(c_int, 1)) or (cbc.*.blocklen > @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([128]u8))))))) {
        return CRYPT_INVALID_ARG;
    }
    if ((len % @as(c_ulong, @bitCast(@as(c_long, cbc.*.blocklen)))) != 0) {
        return CRYPT_INVALID_ARG;
    }
    if ((@as(c_ulong, @bitCast(@as(c_long, cbc.*.blocklen))) % @sizeOf(c_ulong)) != 0) {
        return CRYPT_INVALID_ARG;
    }
    if (cipher_descriptor[@as(c_uint, @intCast(cbc.*.cipher))].accel_cbc_encrypt != @as(?*const fn ([*c]const u8, [*c]u8, c_ulong, [*c]u8, [*c]symmetric_key) callconv(.c) c_int, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        return cipher_descriptor[@as(c_uint, @intCast(cbc.*.cipher))].accel_cbc_encrypt.?(pt, ct, len / @as(c_ulong, @bitCast(@as(c_long, cbc.*.blocklen))), @as([*c]u8, @ptrCast(@alignCast(&cbc.*.IV))), &cbc.*.key);
    } else {
        while (len != 0) {
            {
                x = 0;
                while (x < cbc.*.blocklen) : (x += @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf(c_ulong)))))) {
                    @as([*c]c_ulong, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&cbc.*.IV))) + @as(usize, @bitCast(@as(isize, @intCast(x))))))).* ^= @as([*c]c_ulong, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@volatileCast(@constCast(pt)))) + @as(usize, @bitCast(@as(isize, @intCast(x))))))).*;
                }
            }
            if ((blk: {
                const tmp = cipher_descriptor[@as(c_uint, @intCast(cbc.*.cipher))].ecb_encrypt.?(@as([*c]u8, @ptrCast(@alignCast(&cbc.*.IV))), ct, &cbc.*.key);
                err = tmp;
                break :blk tmp;
            }) != CRYPT_OK) {
                return err;
            }
            {
                x = 0;
                while (x < cbc.*.blocklen) : (x += @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf(c_ulong)))))) {
                    @as([*c]c_ulong, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&cbc.*.IV))) + @as(usize, @bitCast(@as(isize, @intCast(x))))))).* = @as([*c]c_ulong, @ptrCast(@alignCast(ct + @as(usize, @bitCast(@as(isize, @intCast(x))))))).*;
                }
            }
            ct += @as(usize, @bitCast(@as(isize, @intCast(cbc.*.blocklen))));
            pt += @as(usize, @bitCast(@as(isize, @intCast(cbc.*.blocklen))));
            len -%= @as(c_ulong, @bitCast(@as(c_long, cbc.*.blocklen)));
        }
    }
    return CRYPT_OK;
}
pub export fn cbc_decrypt(arg_ct: [*c]const u8, arg_pt: [*c]u8, arg_len: c_ulong, arg_cbc: [*c]symmetric_CBC) c_int {
    var ct = arg_ct;
    _ = &ct;
    var pt = arg_pt;
    _ = &pt;
    var len = arg_len;
    _ = &len;
    var cbc = arg_cbc;
    _ = &cbc;
    var x: c_int = undefined;
    _ = &x;
    var err: c_int = undefined;
    _ = &err;
    var tmp: [16]u8 = undefined;
    _ = &tmp;
    var tmpy: c_ulong = undefined;
    _ = &tmpy;
    if (!(pt != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("pt != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 32921));
    }
    if (!(ct != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ct != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 32922));
    }
    if (!(cbc != @as([*c]symmetric_CBC, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("cbc != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 32923));
    }
    if ((blk: {
        const tmp_1 = cipher_is_valid(cbc.*.cipher);
        err = tmp_1;
        break :blk tmp_1;
    }) != CRYPT_OK) {
        return err;
    }
    if ((cbc.*.blocklen < @as(c_int, 1)) or (cbc.*.blocklen > @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([128]u8))))))) {
        return CRYPT_INVALID_ARG;
    }
    if ((len % @as(c_ulong, @bitCast(@as(c_long, cbc.*.blocklen)))) != 0) {
        return CRYPT_INVALID_ARG;
    }
    if ((@as(c_ulong, @bitCast(@as(c_long, cbc.*.blocklen))) % @sizeOf(c_ulong)) != 0) {
        return CRYPT_INVALID_ARG;
    }
    if (cipher_descriptor[@as(c_uint, @intCast(cbc.*.cipher))].accel_cbc_decrypt != @as(?*const fn ([*c]const u8, [*c]u8, c_ulong, [*c]u8, [*c]symmetric_key) callconv(.c) c_int, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        return cipher_descriptor[@as(c_uint, @intCast(cbc.*.cipher))].accel_cbc_decrypt.?(ct, pt, len / @as(c_ulong, @bitCast(@as(c_long, cbc.*.blocklen))), @as([*c]u8, @ptrCast(@alignCast(&cbc.*.IV))), &cbc.*.key);
    } else {
        while (len != 0) {
            if ((blk: {
                const tmp_1 = cipher_descriptor[@as(c_uint, @intCast(cbc.*.cipher))].ecb_decrypt.?(ct, @as([*c]u8, @ptrCast(@alignCast(&tmp))), &cbc.*.key);
                err = tmp_1;
                break :blk tmp_1;
            }) != CRYPT_OK) {
                return err;
            }
            {
                x = 0;
                while (x < cbc.*.blocklen) : (x += @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf(c_ulong)))))) {
                    tmpy = @as([*c]c_ulong, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&cbc.*.IV))) + @as(usize, @bitCast(@as(isize, @intCast(x))))))).* ^ @as([*c]c_ulong, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&tmp))) + @as(usize, @bitCast(@as(isize, @intCast(x))))))).*;
                    @as([*c]c_ulong, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&cbc.*.IV))) + @as(usize, @bitCast(@as(isize, @intCast(x))))))).* = @as([*c]c_ulong, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@volatileCast(@constCast(ct)))) + @as(usize, @bitCast(@as(isize, @intCast(x))))))).*;
                    @as([*c]c_ulong, @ptrCast(@alignCast(pt + @as(usize, @bitCast(@as(isize, @intCast(x))))))).* = tmpy;
                }
            }
            ct += @as(usize, @bitCast(@as(isize, @intCast(cbc.*.blocklen))));
            pt += @as(usize, @bitCast(@as(isize, @intCast(cbc.*.blocklen))));
            len -%= @as(c_ulong, @bitCast(@as(c_long, cbc.*.blocklen)));
        }
    }
    return CRYPT_OK;
}
pub export fn cbc_getiv(arg_IV: [*c]u8, arg_len: [*c]c_ulong, arg_cbc: [*c]symmetric_CBC) c_int {
    var IV = arg_IV;
    _ = &IV;
    var len = arg_len;
    _ = &len;
    var cbc = arg_cbc;
    _ = &cbc;
    if (!(IV != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("IV != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33154));
    }
    if (!(len != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("len != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33155));
    }
    if (!(cbc != @as([*c]symmetric_CBC, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("cbc != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33156));
    }
    if (@as(c_ulong, @bitCast(@as(c_long, cbc.*.blocklen))) > len.*) {
        len.* = @as(c_ulong, @bitCast(@as(c_long, cbc.*.blocklen)));
        return CRYPT_BUFFER_OVERFLOW;
    }
    _ = memcpy(@as(?*anyopaque, @ptrCast(IV)), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&cbc.*.IV))))), @as(c_ulong, @bitCast(@as(c_long, cbc.*.blocklen))));
    len.* = @as(c_ulong, @bitCast(@as(c_long, cbc.*.blocklen)));
    return CRYPT_OK;
}
pub export fn cbc_setiv(arg_IV: [*c]const u8, arg_len: c_ulong, arg_cbc: [*c]symmetric_CBC) c_int {
    var IV = arg_IV;
    _ = &IV;
    var len = arg_len;
    _ = &len;
    var cbc = arg_cbc;
    _ = &cbc;
    if (!(IV != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("IV != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33203));
    }
    if (!(cbc != @as([*c]symmetric_CBC, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("cbc != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33204));
    }
    if (len != @as(c_ulong, @bitCast(@as(c_long, cbc.*.blocklen)))) {
        return CRYPT_INVALID_ARG;
    }
    _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&cbc.*.IV))))), @as(?*const anyopaque, @ptrCast(IV)), len);
    return CRYPT_OK;
}
pub export fn cbc_done(arg_cbc: [*c]symmetric_CBC) c_int {
    var cbc = arg_cbc;
    _ = &cbc;
    var err: c_int = undefined;
    _ = &err;
    if (!(cbc != @as([*c]symmetric_CBC, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("cbc != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33008));
    }
    if ((blk: {
        const tmp = cipher_is_valid(cbc.*.cipher);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    cipher_descriptor[@as(c_uint, @intCast(cbc.*.cipher))].done.?(&cbc.*.key);
    return CRYPT_OK;
}
pub export fn ctr_start(arg_cipher: c_int, arg_IV: [*c]const u8, arg_key: [*c]const u8, arg_keylen: c_int, arg_num_rounds: c_int, arg_ctr_mode: c_int, arg_ctr: [*c]symmetric_CTR) c_int {
    var cipher = arg_cipher;
    _ = &cipher;
    var IV = arg_IV;
    _ = &IV;
    var key = arg_key;
    _ = &key;
    var keylen = arg_keylen;
    _ = &keylen;
    var num_rounds = arg_num_rounds;
    _ = &num_rounds;
    var ctr_mode = arg_ctr_mode;
    _ = &ctr_mode;
    var ctr = arg_ctr;
    _ = &ctr;
    var x: c_int = undefined;
    _ = &x;
    var err: c_int = undefined;
    _ = &err;
    if (!(IV != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("IV != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34783));
    }
    if (!(key != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("key != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34784));
    }
    if (!(ctr != @as([*c]symmetric_CTR, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ctr != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34785));
    }
    if ((blk: {
        const tmp = cipher_is_valid(cipher);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    ctr.*.ctrlen = if ((ctr_mode & @as(c_int, 255)) != 0) ctr_mode & @as(c_int, 255) else cipher_descriptor[@as(c_uint, @intCast(cipher))].block_length;
    if (ctr.*.ctrlen > cipher_descriptor[@as(c_uint, @intCast(cipher))].block_length) {
        return CRYPT_INVALID_ARG;
    }
    if ((ctr_mode & @as(c_int, 4096)) == @as(c_int, 4096)) {
        ctr.*.ctrlen = cipher_descriptor[@as(c_uint, @intCast(cipher))].block_length - ctr.*.ctrlen;
    }
    if ((blk: {
        const tmp = cipher_descriptor[@as(c_uint, @intCast(cipher))].setup.?(key, keylen, num_rounds, &ctr.*.key);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    ctr.*.blocklen = cipher_descriptor[@as(c_uint, @intCast(cipher))].block_length;
    ctr.*.cipher = cipher;
    ctr.*.padlen = 0;
    ctr.*.mode = ctr_mode & @as(c_int, 4096);
    {
        x = 0;
        while (x < ctr.*.blocklen) : (x += 1) {
            ctr.*.ctr[@as(c_uint, @intCast(x))] = (blk: {
                const tmp = x;
                if (tmp >= 0) break :blk IV + @as(usize, @intCast(tmp)) else break :blk IV - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
        }
    }
    if ((ctr_mode & @as(c_int, 8192)) != 0) {
        if (ctr.*.mode == @as(c_int, 0)) {
            {
                x = 0;
                while (x < ctr.*.ctrlen) : (x += 1) {
                    ctr.*.ctr[@as(c_uint, @intCast(x))] = @as(u8, @bitCast(@as(i8, @truncate((@as(c_int, @bitCast(@as(c_uint, ctr.*.ctr[@as(c_uint, @intCast(x))]))) + @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))))))) & @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 255))))))))))));
                    if (@as(c_int, @bitCast(@as(c_uint, ctr.*.ctr[@as(c_uint, @intCast(x))]))) != @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))))))) {
                        break;
                    }
                }
            }
        } else {
            {
                x = ctr.*.blocklen - @as(c_int, 1);
                while (x >= ctr.*.ctrlen) : (x -= 1) {
                    ctr.*.ctr[@as(c_uint, @intCast(x))] = @as(u8, @bitCast(@as(i8, @truncate((@as(c_int, @bitCast(@as(c_uint, ctr.*.ctr[@as(c_uint, @intCast(x))]))) + @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))))))) & @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 255))))))))))));
                    if (@as(c_int, @bitCast(@as(c_uint, ctr.*.ctr[@as(c_uint, @intCast(x))]))) != @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))))))) {
                        break;
                    }
                }
            }
        }
    }
    return cipher_descriptor[@as(c_uint, @intCast(ctr.*.cipher))].ecb_encrypt.?(@as([*c]u8, @ptrCast(@alignCast(&ctr.*.ctr))), @as([*c]u8, @ptrCast(@alignCast(&ctr.*.pad))), &ctr.*.key);
}
pub export fn ctr_encrypt(arg_pt: [*c]const u8, arg_ct: [*c]u8, arg_len: c_ulong, arg_ctr: [*c]symmetric_CTR) c_int {
    var pt = arg_pt;
    _ = &pt;
    var ct = arg_ct;
    _ = &ct;
    var len = arg_len;
    _ = &len;
    var ctr = arg_ctr;
    _ = &ctr;
    var x: c_int = undefined;
    _ = &x;
    var err: c_int = undefined;
    _ = &err;
    if (!(pt != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("pt != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34580));
    }
    if (!(ct != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ct != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34581));
    }
    if (!(ctr != @as([*c]symmetric_CTR, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ctr != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34582));
    }
    if ((blk: {
        const tmp = cipher_is_valid(ctr.*.cipher);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if ((((ctr.*.blocklen < @as(c_int, 1)) or (ctr.*.blocklen > @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([128]u8))))))) or (ctr.*.padlen < @as(c_int, 0))) or (ctr.*.padlen > @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([128]u8))))))) {
        return CRYPT_INVALID_ARG;
    }
    if ((@as(c_ulong, @bitCast(@as(c_long, ctr.*.blocklen))) % @sizeOf(c_ulong)) != 0) {
        return CRYPT_INVALID_ARG;
    }
    if (((ctr.*.padlen == ctr.*.blocklen) and (cipher_descriptor[@as(c_uint, @intCast(ctr.*.cipher))].accel_ctr_encrypt != @as(?*const fn ([*c]const u8, [*c]u8, c_ulong, [*c]u8, c_int, [*c]symmetric_key) callconv(.c) c_int, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) and (len >= @as(c_ulong, @bitCast(@as(c_long, ctr.*.blocklen))))) {
        if ((blk: {
            const tmp = cipher_descriptor[@as(c_uint, @intCast(ctr.*.cipher))].accel_ctr_encrypt.?(pt, ct, len / @as(c_ulong, @bitCast(@as(c_long, ctr.*.blocklen))), @as([*c]u8, @ptrCast(@alignCast(&ctr.*.ctr))), ctr.*.mode, &ctr.*.key);
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            return err;
        }
        len %= @as(c_ulong, @bitCast(@as(c_long, ctr.*.blocklen)));
    }
    while (len != 0) {
        if (ctr.*.padlen == ctr.*.blocklen) {
            if (ctr.*.mode == @as(c_int, 0)) {
                {
                    x = 0;
                    while (x < ctr.*.ctrlen) : (x += 1) {
                        ctr.*.ctr[@as(c_uint, @intCast(x))] = @as(u8, @bitCast(@as(i8, @truncate((@as(c_int, @bitCast(@as(c_uint, ctr.*.ctr[@as(c_uint, @intCast(x))]))) + @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))))))) & @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 255))))))))))));
                        if (@as(c_int, @bitCast(@as(c_uint, ctr.*.ctr[@as(c_uint, @intCast(x))]))) != @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))))))) {
                            break;
                        }
                    }
                }
            } else {
                {
                    x = ctr.*.blocklen - @as(c_int, 1);
                    while (x >= ctr.*.ctrlen) : (x -= 1) {
                        ctr.*.ctr[@as(c_uint, @intCast(x))] = @as(u8, @bitCast(@as(i8, @truncate((@as(c_int, @bitCast(@as(c_uint, ctr.*.ctr[@as(c_uint, @intCast(x))]))) + @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))))))) & @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 255))))))))))));
                        if (@as(c_int, @bitCast(@as(c_uint, ctr.*.ctr[@as(c_uint, @intCast(x))]))) != @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))))))) {
                            break;
                        }
                    }
                }
            }
            if ((blk: {
                const tmp = cipher_descriptor[@as(c_uint, @intCast(ctr.*.cipher))].ecb_encrypt.?(@as([*c]u8, @ptrCast(@alignCast(&ctr.*.ctr))), @as([*c]u8, @ptrCast(@alignCast(&ctr.*.pad))), &ctr.*.key);
                err = tmp;
                break :blk tmp;
            }) != CRYPT_OK) {
                return err;
            }
            ctr.*.padlen = 0;
        }
        if ((ctr.*.padlen == @as(c_int, 0)) and (len >= @as(c_ulong, @bitCast(@as(c_long, ctr.*.blocklen))))) {
            {
                x = 0;
                while (x < ctr.*.blocklen) : (x += @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf(c_ulong)))))) {
                    @as([*c]c_ulong, @ptrCast(@alignCast(ct + @as(usize, @bitCast(@as(isize, @intCast(x))))))).* = @as([*c]c_ulong, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@volatileCast(@constCast(pt)))) + @as(usize, @bitCast(@as(isize, @intCast(x))))))).* ^ @as([*c]c_ulong, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&ctr.*.pad))) + @as(usize, @bitCast(@as(isize, @intCast(x))))))).*;
                }
            }
            pt += @as(usize, @bitCast(@as(isize, @intCast(ctr.*.blocklen))));
            ct += @as(usize, @bitCast(@as(isize, @intCast(ctr.*.blocklen))));
            len -%= @as(c_ulong, @bitCast(@as(c_long, ctr.*.blocklen)));
            ctr.*.padlen = ctr.*.blocklen;
            continue;
        }
        (blk: {
            const ref = &ct;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, (blk: {
            const ref = &pt;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).*))) ^ @as(c_int, @bitCast(@as(c_uint, ctr.*.pad[@as(c_uint, @intCast(blk: {
            const ref = &ctr.*.padlen;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }))])))))));
        len -%= 1;
    }
    return CRYPT_OK;
}
pub export fn ctr_decrypt(arg_ct: [*c]const u8, arg_pt: [*c]u8, arg_len: c_ulong, arg_ctr: [*c]symmetric_CTR) c_int {
    var ct = arg_ct;
    _ = &ct;
    var pt = arg_pt;
    _ = &pt;
    var len = arg_len;
    _ = &len;
    var ctr = arg_ctr;
    _ = &ctr;
    if (!(pt != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("pt != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34731));
    }
    if (!(ct != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ct != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34732));
    }
    if (!(ctr != @as([*c]symmetric_CTR, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ctr != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34733));
    }
    return ctr_encrypt(ct, pt, len, ctr);
}
pub export fn ctr_getiv(arg_IV: [*c]u8, arg_len: [*c]c_ulong, arg_ctr: [*c]symmetric_CTR) c_int {
    var IV = arg_IV;
    _ = &IV;
    var len = arg_len;
    _ = &len;
    var ctr = arg_ctr;
    _ = &ctr;
    if (!(IV != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("IV != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34929));
    }
    if (!(len != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("len != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34930));
    }
    if (!(ctr != @as([*c]symmetric_CTR, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ctr != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34931));
    }
    if (@as(c_ulong, @bitCast(@as(c_long, ctr.*.blocklen))) > len.*) {
        len.* = @as(c_ulong, @bitCast(@as(c_long, ctr.*.blocklen)));
        return CRYPT_BUFFER_OVERFLOW;
    }
    _ = memcpy(@as(?*anyopaque, @ptrCast(IV)), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&ctr.*.ctr))))), @as(c_ulong, @bitCast(@as(c_long, ctr.*.blocklen))));
    len.* = @as(c_ulong, @bitCast(@as(c_long, ctr.*.blocklen)));
    return CRYPT_OK;
}
pub export fn ctr_setiv(arg_IV: [*c]const u8, arg_len: c_ulong, arg_ctr: [*c]symmetric_CTR) c_int {
    var IV = arg_IV;
    _ = &IV;
    var len = arg_len;
    _ = &len;
    var ctr = arg_ctr;
    _ = &ctr;
    var err: c_int = undefined;
    _ = &err;
    if (!(IV != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("IV != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34875));
    }
    if (!(ctr != @as([*c]symmetric_CTR, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ctr != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34876));
    }
    if ((blk: {
        const tmp = cipher_is_valid(ctr.*.cipher);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if (len != @as(c_ulong, @bitCast(@as(c_long, ctr.*.blocklen)))) {
        return CRYPT_INVALID_ARG;
    }
    _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&ctr.*.ctr))))), @as(?*const anyopaque, @ptrCast(IV)), len);
    ctr.*.padlen = 0;
    return cipher_descriptor[@as(c_uint, @intCast(ctr.*.cipher))].ecb_encrypt.?(IV, @as([*c]u8, @ptrCast(@alignCast(&ctr.*.pad))), &ctr.*.key);
}
pub export fn ctr_done(arg_ctr: [*c]symmetric_CTR) c_int {
    var ctr = arg_ctr;
    _ = &ctr;
    var err: c_int = undefined;
    _ = &err;
    if (!(ctr != @as([*c]symmetric_CTR, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ctr != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34686));
    }
    if ((blk: {
        const tmp = cipher_is_valid(ctr.*.cipher);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    cipher_descriptor[@as(c_uint, @intCast(ctr.*.cipher))].done.?(&ctr.*.key);
    return CRYPT_OK;
}
pub extern fn ctr_test() c_int;
pub extern fn lrw_start(cipher: c_int, IV: [*c]const u8, key: [*c]const u8, keylen: c_int, tweak: [*c]const u8, num_rounds: c_int, lrw: [*c]symmetric_LRW) c_int;
pub extern fn lrw_encrypt(pt: [*c]const u8, ct: [*c]u8, len: c_ulong, lrw: [*c]symmetric_LRW) c_int;
pub extern fn lrw_decrypt(ct: [*c]const u8, pt: [*c]u8, len: c_ulong, lrw: [*c]symmetric_LRW) c_int;
pub extern fn lrw_getiv(IV: [*c]u8, len: [*c]c_ulong, lrw: [*c]symmetric_LRW) c_int;
pub extern fn lrw_setiv(IV: [*c]const u8, len: c_ulong, lrw: [*c]symmetric_LRW) c_int;
pub extern fn lrw_done(lrw: [*c]symmetric_LRW) c_int;
pub extern fn lrw_test() c_int;
pub extern fn lrw_process(pt: [*c]const u8, ct: [*c]u8, len: c_ulong, mode: c_int, lrw: [*c]symmetric_LRW) c_int;
pub extern fn f8_start(cipher: c_int, IV: [*c]const u8, key: [*c]const u8, keylen: c_int, salt_key: [*c]const u8, skeylen: c_int, num_rounds: c_int, f8: [*c]symmetric_F8) c_int;
pub extern fn f8_encrypt(pt: [*c]const u8, ct: [*c]u8, len: c_ulong, f8: [*c]symmetric_F8) c_int;
pub extern fn f8_decrypt(ct: [*c]const u8, pt: [*c]u8, len: c_ulong, f8: [*c]symmetric_F8) c_int;
pub extern fn f8_getiv(IV: [*c]u8, len: [*c]c_ulong, f8: [*c]symmetric_F8) c_int;
pub extern fn f8_setiv(IV: [*c]const u8, len: c_ulong, f8: [*c]symmetric_F8) c_int;
pub extern fn f8_done(f8: [*c]symmetric_F8) c_int;
pub extern fn f8_test_mode() c_int;
pub const symmetric_xts = extern struct {
    key1: symmetric_key = @import("std").mem.zeroes(symmetric_key),
    key2: symmetric_key = @import("std").mem.zeroes(symmetric_key),
    cipher: c_int = @import("std").mem.zeroes(c_int),
};
pub extern fn xts_start(cipher: c_int, key1: [*c]const u8, key2: [*c]const u8, keylen: c_ulong, num_rounds: c_int, xts: [*c]symmetric_xts) c_int;
pub extern fn xts_encrypt(pt: [*c]const u8, ptlen: c_ulong, ct: [*c]u8, tweak: [*c]const u8, xts: [*c]symmetric_xts) c_int;
pub extern fn xts_decrypt(ct: [*c]const u8, ptlen: c_ulong, pt: [*c]u8, tweak: [*c]const u8, xts: [*c]symmetric_xts) c_int;
pub extern fn xts_done(xts: [*c]symmetric_xts) void;
pub extern fn xts_test() c_int;
pub extern fn xts_mult_x(I: [*c]u8) void;
pub export fn find_cipher(arg_name: [*c]const u8) c_int {
    var name = arg_name;
    _ = &name;
    var x: c_int = undefined;
    _ = &x;
    if (!(name != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("name != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 17246));
    }
    {
        x = 0;
        while (x < @as(c_int, 256)) : (x += 1) {
            if ((cipher_descriptor[@as(c_uint, @intCast(x))].name != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) and !(strcmp(cipher_descriptor[@as(c_uint, @intCast(x))].name, name) != 0)) {
                return x;
            }
        }
    }
    return -@as(c_int, 1);
}
pub export fn find_cipher_any(arg_name: [*c]const u8, arg_blocklen: c_int, arg_keylen: c_int) c_int {
    var name = arg_name;
    _ = &name;
    var blocklen = arg_blocklen;
    _ = &blocklen;
    var keylen = arg_keylen;
    _ = &keylen;
    var x: c_int = undefined;
    _ = &x;
    if (!(name != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("name != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 17290));
    }
    x = find_cipher(name);
    if (x != -@as(c_int, 1)) return x;
    {
        x = 0;
        while (x < @as(c_int, 256)) : (x += 1) {
            if (cipher_descriptor[@as(c_uint, @intCast(x))].name == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
                continue;
            }
            if ((blocklen <= cipher_descriptor[@as(c_uint, @intCast(x))].block_length) and (keylen <= cipher_descriptor[@as(c_uint, @intCast(x))].max_key_length)) {
                return x;
            }
        }
    }
    return -@as(c_int, 1);
}
pub export fn find_cipher_id(arg_ID: u8) c_int {
    var ID = arg_ID;
    _ = &ID;
    var x: c_int = undefined;
    _ = &x;
    {
        x = 0;
        while (x < @as(c_int, 256)) : (x += 1) {
            if (@as(c_int, @bitCast(@as(c_uint, cipher_descriptor[@as(c_uint, @intCast(x))].ID))) == @as(c_int, @bitCast(@as(c_uint, ID)))) {
                x = if (cipher_descriptor[@as(c_uint, @intCast(x))].name == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) -@as(c_int, 1) else x;
                return x;
            }
        }
    }
    return -@as(c_int, 1);
}
pub export fn register_cipher(arg_cipher: [*c]const struct_ltc_cipher_descriptor) c_int {
    var cipher = arg_cipher;
    _ = &cipher;
    var x: c_int = undefined;
    _ = &x;
    if (!(cipher != @as([*c]const struct_ltc_cipher_descriptor, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("cipher != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 17800));
    }
    {
        x = 0;
        while (x < @as(c_int, 256)) : (x += 1) {
            if ((cipher_descriptor[@as(c_uint, @intCast(x))].name != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) and (@as(c_int, @bitCast(@as(c_uint, cipher_descriptor[@as(c_uint, @intCast(x))].ID))) == @as(c_int, @bitCast(@as(c_uint, cipher.*.ID))))) {
                return x;
            }
        }
    }
    {
        x = 0;
        while (x < @as(c_int, 256)) : (x += 1) {
            if (cipher_descriptor[@as(c_uint, @intCast(x))].name == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
                _ = memcpy(@as(?*anyopaque, @ptrCast(&cipher_descriptor[@as(c_uint, @intCast(x))])), @as(?*const anyopaque, @ptrCast(cipher)), @sizeOf(struct_ltc_cipher_descriptor));
                return x;
            }
        }
    }
    return -@as(c_int, 1);
}
pub export fn unregister_cipher(arg_cipher: [*c]const struct_ltc_cipher_descriptor) c_int {
    var cipher = arg_cipher;
    _ = &cipher;
    var x: c_int = undefined;
    _ = &x;
    if (!(cipher != @as([*c]const struct_ltc_cipher_descriptor, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("cipher != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 17965));
    }
    {
        x = 0;
        while (x < @as(c_int, 256)) : (x += 1) {
            if (memcmp(@as(?*const anyopaque, @ptrCast(&cipher_descriptor[@as(c_uint, @intCast(x))])), @as(?*const anyopaque, @ptrCast(cipher)), @sizeOf(struct_ltc_cipher_descriptor)) == @as(c_int, 0)) {
                cipher_descriptor[@as(c_uint, @intCast(x))].name = null;
                cipher_descriptor[@as(c_uint, @intCast(x))].ID = 255;
                return CRYPT_OK;
            }
        }
    }
    return CRYPT_ERROR;
}
pub export fn cipher_is_valid(arg_idx: c_int) c_int {
    var idx = arg_idx;
    _ = &idx;
    if (((idx < @as(c_int, 0)) or (idx >= @as(c_int, 256))) or (cipher_descriptor[@as(c_uint, @intCast(idx))].name == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        return CRYPT_INVALID_CIPHER;
    }
    return CRYPT_OK;
}
pub const struct_sha512_state = extern struct {
    length: ulong64 = @import("std").mem.zeroes(ulong64),
    state: [8]ulong64 = @import("std").mem.zeroes([8]ulong64),
    curlen: c_ulong = @import("std").mem.zeroes(c_ulong),
    buf: [128]u8 = @import("std").mem.zeroes([128]u8),
};
pub const struct_sha256_state = extern struct {
    length: ulong64 = @import("std").mem.zeroes(ulong64),
    state: [8]ulong32 = @import("std").mem.zeroes([8]ulong32),
    curlen: ulong32 = @import("std").mem.zeroes(ulong32),
    buf: [64]u8 = @import("std").mem.zeroes([64]u8),
};
pub const struct_sha1_state = extern struct {
    length: ulong64 = @import("std").mem.zeroes(ulong64),
    state: [5]ulong32 = @import("std").mem.zeroes([5]ulong32),
    curlen: ulong32 = @import("std").mem.zeroes(ulong32),
    buf: [64]u8 = @import("std").mem.zeroes([64]u8),
};
pub const struct_md5_state = extern struct {
    length: ulong64 = @import("std").mem.zeroes(ulong64),
    state: [4]ulong32 = @import("std").mem.zeroes([4]ulong32),
    curlen: ulong32 = @import("std").mem.zeroes(ulong32),
    buf: [64]u8 = @import("std").mem.zeroes([64]u8),
};
pub const struct_md4_state = extern struct {
    length: ulong64 = @import("std").mem.zeroes(ulong64),
    state: [4]ulong32 = @import("std").mem.zeroes([4]ulong32),
    curlen: ulong32 = @import("std").mem.zeroes(ulong32),
    buf: [64]u8 = @import("std").mem.zeroes([64]u8),
};
pub const struct_tiger_state = extern struct {
    state: [3]ulong64 = @import("std").mem.zeroes([3]ulong64),
    length: ulong64 = @import("std").mem.zeroes(ulong64),
    curlen: c_ulong = @import("std").mem.zeroes(c_ulong),
    buf: [64]u8 = @import("std").mem.zeroes([64]u8),
};
pub const struct_md2_state = extern struct {
    chksum: [16]u8 = @import("std").mem.zeroes([16]u8),
    X: [48]u8 = @import("std").mem.zeroes([48]u8),
    buf: [16]u8 = @import("std").mem.zeroes([16]u8),
    curlen: c_ulong = @import("std").mem.zeroes(c_ulong),
};
pub const struct_rmd128_state = extern struct {
    length: ulong64 = @import("std").mem.zeroes(ulong64),
    buf: [64]u8 = @import("std").mem.zeroes([64]u8),
    curlen: ulong32 = @import("std").mem.zeroes(ulong32),
    state: [4]ulong32 = @import("std").mem.zeroes([4]ulong32),
};
pub const struct_rmd160_state = extern struct {
    length: ulong64 = @import("std").mem.zeroes(ulong64),
    buf: [64]u8 = @import("std").mem.zeroes([64]u8),
    curlen: ulong32 = @import("std").mem.zeroes(ulong32),
    state: [5]ulong32 = @import("std").mem.zeroes([5]ulong32),
};
pub const struct_rmd256_state = extern struct {
    length: ulong64 = @import("std").mem.zeroes(ulong64),
    buf: [64]u8 = @import("std").mem.zeroes([64]u8),
    curlen: ulong32 = @import("std").mem.zeroes(ulong32),
    state: [8]ulong32 = @import("std").mem.zeroes([8]ulong32),
};
pub const struct_rmd320_state = extern struct {
    length: ulong64 = @import("std").mem.zeroes(ulong64),
    buf: [64]u8 = @import("std").mem.zeroes([64]u8),
    curlen: ulong32 = @import("std").mem.zeroes(ulong32),
    state: [10]ulong32 = @import("std").mem.zeroes([10]ulong32),
};
pub const struct_whirlpool_state = extern struct {
    length: ulong64 = @import("std").mem.zeroes(ulong64),
    state: [8]ulong64 = @import("std").mem.zeroes([8]ulong64),
    buf: [64]u8 = @import("std").mem.zeroes([64]u8),
    curlen: ulong32 = @import("std").mem.zeroes(ulong32),
};
pub const struct_chc_state = extern struct {
    length: ulong64 = @import("std").mem.zeroes(ulong64),
    state: [128]u8 = @import("std").mem.zeroes([128]u8),
    buf: [128]u8 = @import("std").mem.zeroes([128]u8),
    curlen: ulong32 = @import("std").mem.zeroes(ulong32),
};
pub const union_Hash_state = extern union {
    dummy: [1]u8,
    chc: struct_chc_state,
    whirlpool: struct_whirlpool_state,
    sha512: struct_sha512_state,
    sha256: struct_sha256_state,
    sha1: struct_sha1_state,
    md5: struct_md5_state,
    md4: struct_md4_state,
    md2: struct_md2_state,
    tiger: struct_tiger_state,
    rmd128: struct_rmd128_state,
    rmd160: struct_rmd160_state,
    rmd256: struct_rmd256_state,
    rmd320: struct_rmd320_state,
    data: ?*anyopaque,
};
pub const hash_state = union_Hash_state;
pub const struct_ltc_hash_descriptor = extern struct {
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    ID: u8 = @import("std").mem.zeroes(u8),
    hashsize: c_ulong = @import("std").mem.zeroes(c_ulong),
    blocksize: c_ulong = @import("std").mem.zeroes(c_ulong),
    OID: [16]c_ulong = @import("std").mem.zeroes([16]c_ulong),
    OIDlen: c_ulong = @import("std").mem.zeroes(c_ulong),
    init: ?*const fn ([*c]hash_state) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]hash_state) callconv(.c) c_int),
    process: ?*const fn ([*c]hash_state, [*c]const u8, c_ulong) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]hash_state, [*c]const u8, c_ulong) callconv(.c) c_int),
    done: ?*const fn ([*c]hash_state, [*c]u8) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]hash_state, [*c]u8) callconv(.c) c_int),
    @"test": ?*const fn () callconv(.c) c_int = @import("std").mem.zeroes(?*const fn () callconv(.c) c_int),
    hmac_block: ?*const fn ([*c]const u8, c_ulong, [*c]const u8, c_ulong, [*c]u8, [*c]c_ulong) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, c_ulong, [*c]const u8, c_ulong, [*c]u8, [*c]c_ulong) callconv(.c) c_int),
};
pub const hash_descriptor: [*c]struct_ltc_hash_descriptor = @extern([*c]struct_ltc_hash_descriptor, .{
    .name = "hash_descriptor",
});
pub extern fn chc_register(cipher: c_int) c_int;
pub extern fn chc_init(md: [*c]hash_state) c_int;
pub extern fn chc_process(md: [*c]hash_state, in: [*c]const u8, inlen: c_ulong) c_int;
pub extern fn chc_done(md: [*c]hash_state, hash: [*c]u8) c_int;
pub extern fn chc_test() c_int;
pub extern const chc_desc: struct_ltc_hash_descriptor;
pub extern fn whirlpool_init(md: [*c]hash_state) c_int;
pub extern fn whirlpool_process(md: [*c]hash_state, in: [*c]const u8, inlen: c_ulong) c_int;
pub extern fn whirlpool_done(md: [*c]hash_state, hash: [*c]u8) c_int;
pub extern fn whirlpool_test() c_int;
pub extern const whirlpool_desc: struct_ltc_hash_descriptor;
pub export fn sha512_init(arg_md: [*c]hash_state) c_int {
    var md = arg_md;
    _ = &md;
    if (!(md != @as([*c]hash_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("md != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 30678));
    }
    md.*.sha512.curlen = 0;
    md.*.sha512.length = 0;
    md.*.sha512.state[@as(c_uint, @intCast(@as(c_int, 0)))] = 7640891576956012808;
    md.*.sha512.state[@as(c_uint, @intCast(@as(c_int, 1)))] = 13503953896175478587;
    md.*.sha512.state[@as(c_uint, @intCast(@as(c_int, 2)))] = 4354685564936845355;
    md.*.sha512.state[@as(c_uint, @intCast(@as(c_int, 3)))] = 11912009170470909681;
    md.*.sha512.state[@as(c_uint, @intCast(@as(c_int, 4)))] = 5840696475078001361;
    md.*.sha512.state[@as(c_uint, @intCast(@as(c_int, 5)))] = 11170449401992604703;
    md.*.sha512.state[@as(c_uint, @intCast(@as(c_int, 6)))] = 2270897969802886507;
    md.*.sha512.state[@as(c_uint, @intCast(@as(c_int, 7)))] = 6620516959819538809;
    return CRYPT_OK;
}
pub export fn sha512_process(arg_md: [*c]hash_state, arg_in: [*c]const u8, arg_inlen: c_ulong) c_int {
    var md = arg_md;
    _ = &md;
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var n: c_ulong = undefined;
    _ = &n;
    var err: c_int = undefined;
    _ = &err;
    if (!(md != @as([*c]hash_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("md != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 30699));
    }
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 30699));
    }
    if (md.*.sha512.curlen > @sizeOf([128]u8)) {
        return CRYPT_INVALID_ARG;
    }
    while (inlen > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) {
        if ((md.*.sha512.curlen == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) and (inlen >= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128)))))) {
            if ((blk: {
                const tmp = sha512_compress(md, @as([*c]u8, @ptrCast(@volatileCast(@constCast(in)))));
                err = tmp;
                break :blk tmp;
            }) != CRYPT_OK) {
                return err;
            }
            md.*.sha512.length +%= @as(ulong64, @bitCast(@as(c_longlong, @as(c_int, 128) * @as(c_int, 8))));
            in += @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 128)))));
            inlen -%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))));
        } else {
            n = if (inlen < (@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128)))) -% md.*.sha512.curlen)) inlen else @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128)))) -% md.*.sha512.curlen;
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&md.*.sha512.buf))) + md.*.sha512.curlen)), @as(?*const anyopaque, @ptrCast(in)), @as(usize, @bitCast(n)));
            md.*.sha512.curlen +%= n;
            in += n;
            inlen -%= n;
            if (md.*.sha512.curlen == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
                if ((blk: {
                    const tmp = sha512_compress(md, @as([*c]u8, @ptrCast(@alignCast(&md.*.sha512.buf))));
                    err = tmp;
                    break :blk tmp;
                }) != CRYPT_OK) {
                    return err;
                }
                md.*.sha512.length +%= @as(ulong64, @bitCast(@as(c_longlong, @as(c_int, 8) * @as(c_int, 128))));
                md.*.sha512.curlen = 0;
            }
        }
    }
    return CRYPT_OK;
}
// ./libtomcrypt.c:13690:5: warning: TODO implement translation of stmt class GCCAsmStmtClass

// ./libtomcrypt.c:30707:5: warning: unable to translate function, demoted to extern
pub extern fn sha512_done(arg_md: [*c]hash_state, arg_out: [*c]u8) c_int;
pub export fn sha512_test() c_int {
    const struct_unnamed_44 = extern struct {
        msg: [*c]u8 = @import("std").mem.zeroes([*c]u8),
        hash: [64]u8 = @import("std").mem.zeroes([64]u8),
    };
    _ = &struct_unnamed_44;
    const tests = struct {
        const static: [2]struct_unnamed_44 = [2]struct_unnamed_44{
            struct_unnamed_44{
                .msg = @as([*c]u8, @ptrCast(@volatileCast(@constCast("abc")))),
                .hash = [64]u8{
                    221,
                    175,
                    53,
                    161,
                    147,
                    97,
                    122,
                    186,
                    204,
                    65,
                    115,
                    73,
                    174,
                    32,
                    65,
                    49,
                    18,
                    230,
                    250,
                    78,
                    137,
                    169,
                    126,
                    162,
                    10,
                    158,
                    238,
                    230,
                    75,
                    85,
                    211,
                    154,
                    33,
                    146,
                    153,
                    42,
                    39,
                    79,
                    193,
                    168,
                    54,
                    186,
                    60,
                    35,
                    163,
                    254,
                    235,
                    189,
                    69,
                    77,
                    68,
                    35,
                    100,
                    60,
                    232,
                    14,
                    42,
                    154,
                    201,
                    79,
                    165,
                    76,
                    164,
                    159,
                },
            },
            struct_unnamed_44{
                .msg = @as([*c]u8, @ptrCast(@volatileCast(@constCast("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu")))),
                .hash = [64]u8{
                    142,
                    149,
                    155,
                    117,
                    218,
                    227,
                    19,
                    218,
                    140,
                    244,
                    247,
                    40,
                    20,
                    252,
                    20,
                    63,
                    143,
                    119,
                    121,
                    198,
                    235,
                    159,
                    127,
                    161,
                    114,
                    153,
                    174,
                    173,
                    182,
                    136,
                    144,
                    24,
                    80,
                    29,
                    40,
                    158,
                    73,
                    0,
                    247,
                    228,
                    51,
                    27,
                    153,
                    222,
                    196,
                    181,
                    67,
                    58,
                    199,
                    211,
                    41,
                    238,
                    182,
                    221,
                    38,
                    84,
                    94,
                    150,
                    229,
                    91,
                    135,
                    75,
                    233,
                    9,
                },
            },
        };
    };
    _ = &tests;
    var i: c_int = undefined;
    _ = &i;
    var tmp: [64]u8 = undefined;
    _ = &tmp;
    var md: hash_state = undefined;
    _ = &md;
    {
        i = 0;
        while (i < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([2]struct_unnamed_44) / @sizeOf(struct_unnamed_44)))))) : (i += 1) {
            _ = sha512_init(&md);
            _ = sha512_process(&md, @as([*c]u8, @ptrCast(@alignCast(tests.static[@as(c_uint, @intCast(i))].msg))), strlen(tests.static[@as(c_uint, @intCast(i))].msg));
            _ = sha512_done(&md, @as([*c]u8, @ptrCast(@alignCast(&tmp))));
            if (memcmp(@as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&tmp))))), @as(?*const anyopaque, @ptrCast(@as([*c]const u8, @ptrCast(@alignCast(&tests.static[@as(c_uint, @intCast(i))].hash))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 64))))) != @as(c_int, 0)) {
                return CRYPT_FAIL_TESTVECTOR;
            }
        }
    }
    return CRYPT_OK;
}
pub extern const sha512_desc: struct_ltc_hash_descriptor;
pub export fn sha384_init(arg_md: [*c]hash_state) c_int {
    var md = arg_md;
    _ = &md;
    if (!(md != @as([*c]hash_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("md != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 30401));
    }
    md.*.sha512.curlen = 0;
    md.*.sha512.length = 0;
    md.*.sha512.state[@as(c_uint, @intCast(@as(c_int, 0)))] = 14680500436340154072;
    md.*.sha512.state[@as(c_uint, @intCast(@as(c_int, 1)))] = 7105036623409894663;
    md.*.sha512.state[@as(c_uint, @intCast(@as(c_int, 2)))] = 10473403895298186519;
    md.*.sha512.state[@as(c_uint, @intCast(@as(c_int, 3)))] = 1526699215303891257;
    md.*.sha512.state[@as(c_uint, @intCast(@as(c_int, 4)))] = 7436329637833083697;
    md.*.sha512.state[@as(c_uint, @intCast(@as(c_int, 5)))] = 10282925794625328401;
    md.*.sha512.state[@as(c_uint, @intCast(@as(c_int, 6)))] = 15784041429090275239;
    md.*.sha512.state[@as(c_uint, @intCast(@as(c_int, 7)))] = 5167115440072839076;
    return CRYPT_OK;
}
pub export fn sha384_done(arg_md: [*c]hash_state, arg_out: [*c]u8) c_int {
    var md = arg_md;
    _ = &md;
    var out = arg_out;
    _ = &out;
    var buf: [64]u8 = undefined;
    _ = &buf;
    if (!(md != @as([*c]hash_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("md != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 30426));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 30427));
    }
    if (md.*.sha512.curlen >= @sizeOf([128]u8)) {
        return CRYPT_INVALID_ARG;
    }
    _ = sha512_done(md, @as([*c]u8, @ptrCast(@alignCast(&buf))));
    _ = memcpy(@as(?*anyopaque, @ptrCast(out)), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&buf))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 48)))));
    return CRYPT_OK;
}
pub export fn sha384_test() c_int {
    const struct_unnamed_45 = extern struct {
        msg: [*c]u8 = @import("std").mem.zeroes([*c]u8),
        hash: [48]u8 = @import("std").mem.zeroes([48]u8),
    };
    _ = &struct_unnamed_45;
    const tests = struct {
        const static: [2]struct_unnamed_45 = [2]struct_unnamed_45{
            struct_unnamed_45{
                .msg = @as([*c]u8, @ptrCast(@volatileCast(@constCast("abc")))),
                .hash = [48]u8{
                    203,
                    0,
                    117,
                    63,
                    69,
                    163,
                    94,
                    139,
                    181,
                    160,
                    61,
                    105,
                    154,
                    198,
                    80,
                    7,
                    39,
                    44,
                    50,
                    171,
                    14,
                    222,
                    209,
                    99,
                    26,
                    139,
                    96,
                    90,
                    67,
                    255,
                    91,
                    237,
                    128,
                    134,
                    7,
                    43,
                    161,
                    231,
                    204,
                    35,
                    88,
                    186,
                    236,
                    161,
                    52,
                    200,
                    37,
                    167,
                },
            },
            struct_unnamed_45{
                .msg = @as([*c]u8, @ptrCast(@volatileCast(@constCast("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu")))),
                .hash = [48]u8{
                    9,
                    51,
                    12,
                    51,
                    247,
                    17,
                    71,
                    232,
                    61,
                    25,
                    47,
                    199,
                    130,
                    205,
                    27,
                    71,
                    83,
                    17,
                    27,
                    23,
                    59,
                    59,
                    5,
                    210,
                    47,
                    160,
                    128,
                    134,
                    227,
                    176,
                    247,
                    18,
                    252,
                    199,
                    199,
                    26,
                    85,
                    126,
                    45,
                    185,
                    102,
                    195,
                    233,
                    250,
                    145,
                    116,
                    96,
                    57,
                },
            },
        };
    };
    _ = &tests;
    var i: c_int = undefined;
    _ = &i;
    var tmp: [48]u8 = undefined;
    _ = &tmp;
    var md: hash_state = undefined;
    _ = &md;
    {
        i = 0;
        while (i < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([2]struct_unnamed_45) / @sizeOf(struct_unnamed_45)))))) : (i += 1) {
            _ = sha384_init(&md);
            _ = sha512_process(&md, @as([*c]u8, @ptrCast(@alignCast(tests.static[@as(c_uint, @intCast(i))].msg))), strlen(tests.static[@as(c_uint, @intCast(i))].msg));
            _ = sha384_done(&md, @as([*c]u8, @ptrCast(@alignCast(&tmp))));
            if (memcmp(@as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&tmp))))), @as(?*const anyopaque, @ptrCast(@as([*c]const u8, @ptrCast(@alignCast(&tests.static[@as(c_uint, @intCast(i))].hash))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 48))))) != @as(c_int, 0)) {
                return CRYPT_FAIL_TESTVECTOR;
            }
        }
    }
    return CRYPT_OK;
}
pub extern const sha384_desc: struct_ltc_hash_descriptor;
pub export fn sha256_init(arg_md: [*c]hash_state) c_int {
    var md = arg_md;
    _ = &md;
    if (!(md != @as([*c]hash_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("md != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 30226));
    }
    md.*.sha256.curlen = 0;
    md.*.sha256.length = 0;
    md.*.sha256.state[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1779033703)))));
    md.*.sha256.state[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3144134277)))));
    md.*.sha256.state[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1013904242)))));
    md.*.sha256.state[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2773480762)))));
    md.*.sha256.state[@as(c_uint, @intCast(@as(c_int, 4)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1359893119)))));
    md.*.sha256.state[@as(c_uint, @intCast(@as(c_int, 5)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2600822924)))));
    md.*.sha256.state[@as(c_uint, @intCast(@as(c_int, 6)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 528734635)))));
    md.*.sha256.state[@as(c_uint, @intCast(@as(c_int, 7)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1541459225)))));
    return CRYPT_OK;
}
pub export fn sha256_process(arg_md: [*c]hash_state, arg_in: [*c]const u8, arg_inlen: c_ulong) c_int {
    var md = arg_md;
    _ = &md;
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var n: c_ulong = undefined;
    _ = &n;
    var err: c_int = undefined;
    _ = &err;
    if (!(md != @as([*c]hash_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("md != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 30248));
    }
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 30248));
    }
    if (@as(c_ulong, @bitCast(@as(c_ulong, md.*.sha256.curlen))) > @sizeOf([64]u8)) {
        return CRYPT_INVALID_ARG;
    }
    while (inlen > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) {
        if ((md.*.sha256.curlen == @as(ulong32, @bitCast(@as(c_int, 0)))) and (inlen >= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 64)))))) {
            if ((blk: {
                const tmp = sha256_compress(md, @as([*c]u8, @ptrCast(@volatileCast(@constCast(in)))));
                err = tmp;
                break :blk tmp;
            }) != CRYPT_OK) {
                return err;
            }
            md.*.sha256.length +%= @as(ulong64, @bitCast(@as(c_longlong, @as(c_int, 64) * @as(c_int, 8))));
            in += @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 64)))));
            inlen -%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 64))));
        } else {
            n = if (inlen < @as(c_ulong, @bitCast(@as(c_ulong, @as(ulong32, @bitCast(@as(c_int, 64))) -% md.*.sha256.curlen)))) inlen else @as(c_ulong, @bitCast(@as(c_ulong, @as(ulong32, @bitCast(@as(c_int, 64))) -% md.*.sha256.curlen)));
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&md.*.sha256.buf))) + md.*.sha256.curlen)), @as(?*const anyopaque, @ptrCast(in)), @as(usize, @bitCast(n)));
            md.*.sha256.curlen +%= @as(ulong32, @bitCast(@as(c_uint, @truncate(n))));
            in += n;
            inlen -%= n;
            if (md.*.sha256.curlen == @as(ulong32, @bitCast(@as(c_int, 64)))) {
                if ((blk: {
                    const tmp = sha256_compress(md, @as([*c]u8, @ptrCast(@alignCast(&md.*.sha256.buf))));
                    err = tmp;
                    break :blk tmp;
                }) != CRYPT_OK) {
                    return err;
                }
                md.*.sha256.length +%= @as(ulong64, @bitCast(@as(c_longlong, @as(c_int, 8) * @as(c_int, 64))));
                md.*.sha256.curlen = 0;
            }
        }
    }
    return CRYPT_OK;
}
// ./libtomcrypt.c:13690:5: warning: TODO implement translation of stmt class GCCAsmStmtClass

// ./libtomcrypt.c:30256:5: warning: unable to translate function, demoted to extern
pub extern fn sha256_done(arg_md: [*c]hash_state, arg_out: [*c]u8) c_int;
pub export fn sha256_test() c_int {
    const struct_unnamed_46 = extern struct {
        msg: [*c]u8 = @import("std").mem.zeroes([*c]u8),
        hash: [32]u8 = @import("std").mem.zeroes([32]u8),
    };
    _ = &struct_unnamed_46;
    const tests = struct {
        const static: [2]struct_unnamed_46 = [2]struct_unnamed_46{
            struct_unnamed_46{
                .msg = @as([*c]u8, @ptrCast(@volatileCast(@constCast("abc")))),
                .hash = [32]u8{
                    186,
                    120,
                    22,
                    191,
                    143,
                    1,
                    207,
                    234,
                    65,
                    65,
                    64,
                    222,
                    93,
                    174,
                    34,
                    35,
                    176,
                    3,
                    97,
                    163,
                    150,
                    23,
                    122,
                    156,
                    180,
                    16,
                    255,
                    97,
                    242,
                    0,
                    21,
                    173,
                },
            },
            struct_unnamed_46{
                .msg = @as([*c]u8, @ptrCast(@volatileCast(@constCast("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq")))),
                .hash = [32]u8{
                    36,
                    141,
                    106,
                    97,
                    210,
                    6,
                    56,
                    184,
                    229,
                    192,
                    38,
                    147,
                    12,
                    62,
                    96,
                    57,
                    163,
                    60,
                    228,
                    89,
                    100,
                    255,
                    33,
                    103,
                    246,
                    236,
                    237,
                    212,
                    25,
                    219,
                    6,
                    193,
                },
            },
        };
    };
    _ = &tests;
    var i: c_int = undefined;
    _ = &i;
    var tmp: [32]u8 = undefined;
    _ = &tmp;
    var md: hash_state = undefined;
    _ = &md;
    {
        i = 0;
        while (i < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([2]struct_unnamed_46) / @sizeOf(struct_unnamed_46)))))) : (i += 1) {
            _ = sha256_init(&md);
            _ = sha256_process(&md, @as([*c]u8, @ptrCast(@alignCast(tests.static[@as(c_uint, @intCast(i))].msg))), strlen(tests.static[@as(c_uint, @intCast(i))].msg));
            _ = sha256_done(&md, @as([*c]u8, @ptrCast(@alignCast(&tmp))));
            if (memcmp(@as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&tmp))))), @as(?*const anyopaque, @ptrCast(@as([*c]const u8, @ptrCast(@alignCast(&tests.static[@as(c_uint, @intCast(i))].hash))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32))))) != @as(c_int, 0)) {
                return CRYPT_FAIL_TESTVECTOR;
            }
        }
    }
    return CRYPT_OK;
}
pub extern const sha256_desc: struct_ltc_hash_descriptor;
pub export fn sha224_init(arg_md: [*c]hash_state) c_int {
    var md = arg_md;
    _ = &md;
    if (!(md != @as([*c]hash_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("md != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 29937));
    }
    md.*.sha256.curlen = 0;
    md.*.sha256.length = 0;
    md.*.sha256.state[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3238371032)))));
    md.*.sha256.state[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 914150663)))));
    md.*.sha256.state[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 812702999)))));
    md.*.sha256.state[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4144912697)))));
    md.*.sha256.state[@as(c_uint, @intCast(@as(c_int, 4)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4290775857)))));
    md.*.sha256.state[@as(c_uint, @intCast(@as(c_int, 5)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1750603025)))));
    md.*.sha256.state[@as(c_uint, @intCast(@as(c_int, 6)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1694076839)))));
    md.*.sha256.state[@as(c_uint, @intCast(@as(c_int, 7)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3204075428)))));
    return CRYPT_OK;
}
pub export fn sha224_done(arg_md: [*c]hash_state, arg_out: [*c]u8) c_int {
    var md = arg_md;
    _ = &md;
    var out = arg_out;
    _ = &out;
    var buf: [32]u8 = undefined;
    _ = &buf;
    var err: c_int = undefined;
    _ = &err;
    if (!(md != @as([*c]hash_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("md != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 29963));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 29964));
    }
    err = sha256_done(md, @as([*c]u8, @ptrCast(@alignCast(&buf))));
    _ = memcpy(@as(?*anyopaque, @ptrCast(out)), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&buf))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 28)))));
    return err;
}
pub export fn sha224_test() c_int {
    const struct_unnamed_47 = extern struct {
        msg: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
        hash: [28]u8 = @import("std").mem.zeroes([28]u8),
    };
    _ = &struct_unnamed_47;
    const tests = struct {
        const static: [2]struct_unnamed_47 = [2]struct_unnamed_47{
            struct_unnamed_47{
                .msg = "abc",
                .hash = [28]u8{
                    35,
                    9,
                    125,
                    34,
                    52,
                    5,
                    216,
                    34,
                    134,
                    66,
                    164,
                    119,
                    189,
                    162,
                    85,
                    179,
                    42,
                    173,
                    188,
                    228,
                    189,
                    160,
                    179,
                    247,
                    227,
                    108,
                    157,
                    167,
                },
            },
            struct_unnamed_47{
                .msg = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
                .hash = [28]u8{
                    117,
                    56,
                    139,
                    22,
                    81,
                    39,
                    118,
                    204,
                    93,
                    186,
                    93,
                    161,
                    253,
                    137,
                    1,
                    80,
                    176,
                    198,
                    69,
                    92,
                    180,
                    245,
                    139,
                    25,
                    82,
                    82,
                    37,
                    37,
                },
            },
        };
    };
    _ = &tests;
    var i: c_int = undefined;
    _ = &i;
    var tmp: [28]u8 = undefined;
    _ = &tmp;
    var md: hash_state = undefined;
    _ = &md;
    {
        i = 0;
        while (i < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([2]struct_unnamed_47) / @sizeOf(struct_unnamed_47)))))) : (i += 1) {
            _ = sha224_init(&md);
            _ = sha256_process(&md, @as([*c]u8, @ptrCast(@volatileCast(@constCast(tests.static[@as(c_uint, @intCast(i))].msg)))), strlen(tests.static[@as(c_uint, @intCast(i))].msg));
            _ = sha224_done(&md, @as([*c]u8, @ptrCast(@alignCast(&tmp))));
            if (memcmp(@as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&tmp))))), @as(?*const anyopaque, @ptrCast(@as([*c]const u8, @ptrCast(@alignCast(&tests.static[@as(c_uint, @intCast(i))].hash))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 28))))) != @as(c_int, 0)) {
                return CRYPT_FAIL_TESTVECTOR;
            }
        }
    }
    return CRYPT_OK;
}
pub extern const sha224_desc: struct_ltc_hash_descriptor;
pub export fn sha1_init(arg_md: [*c]hash_state) c_int {
    var md = arg_md;
    _ = &md;
    if (!(md != @as([*c]hash_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("md != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 29791));
    }
    md.*.sha1.state[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1732584193)))));
    md.*.sha1.state[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4023233417)))));
    md.*.sha1.state[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2562383102)))));
    md.*.sha1.state[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 271733878)))));
    md.*.sha1.state[@as(c_uint, @intCast(@as(c_int, 4)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3285377520)))));
    md.*.sha1.curlen = 0;
    md.*.sha1.length = 0;
    return CRYPT_OK;
}
pub export fn sha1_process(arg_md: [*c]hash_state, arg_in: [*c]const u8, arg_inlen: c_ulong) c_int {
    var md = arg_md;
    _ = &md;
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var n: c_ulong = undefined;
    _ = &n;
    var err: c_int = undefined;
    _ = &err;
    if (!(md != @as([*c]hash_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("md != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 29809));
    }
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 29809));
    }
    if (@as(c_ulong, @bitCast(@as(c_ulong, md.*.sha1.curlen))) > @sizeOf([64]u8)) {
        return CRYPT_INVALID_ARG;
    }
    while (inlen > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) {
        if ((md.*.sha1.curlen == @as(ulong32, @bitCast(@as(c_int, 0)))) and (inlen >= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 64)))))) {
            if ((blk: {
                const tmp = sha1_compress(md, @as([*c]u8, @ptrCast(@volatileCast(@constCast(in)))));
                err = tmp;
                break :blk tmp;
            }) != CRYPT_OK) {
                return err;
            }
            md.*.sha1.length +%= @as(ulong64, @bitCast(@as(c_longlong, @as(c_int, 64) * @as(c_int, 8))));
            in += @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 64)))));
            inlen -%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 64))));
        } else {
            n = if (inlen < @as(c_ulong, @bitCast(@as(c_ulong, @as(ulong32, @bitCast(@as(c_int, 64))) -% md.*.sha1.curlen)))) inlen else @as(c_ulong, @bitCast(@as(c_ulong, @as(ulong32, @bitCast(@as(c_int, 64))) -% md.*.sha1.curlen)));
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&md.*.sha1.buf))) + md.*.sha1.curlen)), @as(?*const anyopaque, @ptrCast(in)), @as(usize, @bitCast(n)));
            md.*.sha1.curlen +%= @as(ulong32, @bitCast(@as(c_uint, @truncate(n))));
            in += n;
            inlen -%= n;
            if (md.*.sha1.curlen == @as(ulong32, @bitCast(@as(c_int, 64)))) {
                if ((blk: {
                    const tmp = sha1_compress(md, @as([*c]u8, @ptrCast(@alignCast(&md.*.sha1.buf))));
                    err = tmp;
                    break :blk tmp;
                }) != CRYPT_OK) {
                    return err;
                }
                md.*.sha1.length +%= @as(ulong64, @bitCast(@as(c_longlong, @as(c_int, 8) * @as(c_int, 64))));
                md.*.sha1.curlen = 0;
            }
        }
    }
    return CRYPT_OK;
}
// ./libtomcrypt.c:13690:5: warning: TODO implement translation of stmt class GCCAsmStmtClass

// ./libtomcrypt.c:29817:5: warning: unable to translate function, demoted to extern
pub extern fn sha1_done(arg_md: [*c]hash_state, arg_out: [*c]u8) c_int;
pub export fn sha1_test() c_int {
    const struct_unnamed_48 = extern struct {
        msg: [*c]u8 = @import("std").mem.zeroes([*c]u8),
        hash: [20]u8 = @import("std").mem.zeroes([20]u8),
    };
    _ = &struct_unnamed_48;
    const tests = struct {
        const static: [2]struct_unnamed_48 = [2]struct_unnamed_48{
            struct_unnamed_48{
                .msg = @as([*c]u8, @ptrCast(@volatileCast(@constCast("abc")))),
                .hash = [20]u8{
                    169,
                    153,
                    62,
                    54,
                    71,
                    6,
                    129,
                    106,
                    186,
                    62,
                    37,
                    113,
                    120,
                    80,
                    194,
                    108,
                    156,
                    208,
                    216,
                    157,
                },
            },
            struct_unnamed_48{
                .msg = @as([*c]u8, @ptrCast(@volatileCast(@constCast("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq")))),
                .hash = [20]u8{
                    132,
                    152,
                    62,
                    68,
                    28,
                    59,
                    210,
                    110,
                    186,
                    174,
                    74,
                    161,
                    249,
                    81,
                    41,
                    229,
                    229,
                    70,
                    112,
                    241,
                },
            },
        };
    };
    _ = &tests;
    var i: c_int = undefined;
    _ = &i;
    var tmp: [20]u8 = undefined;
    _ = &tmp;
    var md: hash_state = undefined;
    _ = &md;
    {
        i = 0;
        while (i < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([2]struct_unnamed_48) / @sizeOf(struct_unnamed_48)))))) : (i += 1) {
            _ = sha1_init(&md);
            _ = sha1_process(&md, @as([*c]u8, @ptrCast(@alignCast(tests.static[@as(c_uint, @intCast(i))].msg))), strlen(tests.static[@as(c_uint, @intCast(i))].msg));
            _ = sha1_done(&md, @as([*c]u8, @ptrCast(@alignCast(&tmp))));
            if (memcmp(@as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&tmp))))), @as(?*const anyopaque, @ptrCast(@as([*c]const u8, @ptrCast(@alignCast(&tests.static[@as(c_uint, @intCast(i))].hash))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 20))))) != @as(c_int, 0)) {
                return CRYPT_FAIL_TESTVECTOR;
            }
        }
    }
    return CRYPT_OK;
}
pub extern const sha1_desc: struct_ltc_hash_descriptor;
pub export fn md5_init(arg_md: [*c]hash_state) c_int {
    var md = arg_md;
    _ = &md;
    if (!(md != @as([*c]hash_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("md != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34416));
    }
    md.*.md5.state[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1732584193)))));
    md.*.md5.state[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4023233417)))));
    md.*.md5.state[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2562383102)))));
    md.*.md5.state[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 271733878)))));
    md.*.md5.curlen = 0;
    md.*.md5.length = 0;
    return CRYPT_OK;
}
pub export fn md5_process(arg_md: [*c]hash_state, arg_in: [*c]const u8, arg_inlen: c_ulong) c_int {
    var md = arg_md;
    _ = &md;
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var n: c_ulong = undefined;
    _ = &n;
    var err: c_int = undefined;
    _ = &err;
    if (!(md != @as([*c]hash_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("md != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34433));
    }
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34433));
    }
    if (@as(c_ulong, @bitCast(@as(c_ulong, md.*.md5.curlen))) > @sizeOf([64]u8)) {
        return CRYPT_INVALID_ARG;
    }
    while (inlen > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) {
        if ((md.*.md5.curlen == @as(ulong32, @bitCast(@as(c_int, 0)))) and (inlen >= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 64)))))) {
            if ((blk: {
                const tmp = md5_compress(md, @as([*c]u8, @ptrCast(@volatileCast(@constCast(in)))));
                err = tmp;
                break :blk tmp;
            }) != CRYPT_OK) {
                return err;
            }
            md.*.md5.length +%= @as(ulong64, @bitCast(@as(c_longlong, @as(c_int, 64) * @as(c_int, 8))));
            in += @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 64)))));
            inlen -%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 64))));
        } else {
            n = if (inlen < @as(c_ulong, @bitCast(@as(c_ulong, @as(ulong32, @bitCast(@as(c_int, 64))) -% md.*.md5.curlen)))) inlen else @as(c_ulong, @bitCast(@as(c_ulong, @as(ulong32, @bitCast(@as(c_int, 64))) -% md.*.md5.curlen)));
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&md.*.md5.buf))) + md.*.md5.curlen)), @as(?*const anyopaque, @ptrCast(in)), @as(usize, @bitCast(n)));
            md.*.md5.curlen +%= @as(ulong32, @bitCast(@as(c_uint, @truncate(n))));
            in += n;
            inlen -%= n;
            if (md.*.md5.curlen == @as(ulong32, @bitCast(@as(c_int, 64)))) {
                if ((blk: {
                    const tmp = md5_compress(md, @as([*c]u8, @ptrCast(@alignCast(&md.*.md5.buf))));
                    err = tmp;
                    break :blk tmp;
                }) != CRYPT_OK) {
                    return err;
                }
                md.*.md5.length +%= @as(ulong64, @bitCast(@as(c_longlong, @as(c_int, 8) * @as(c_int, 64))));
                md.*.md5.curlen = 0;
            }
        }
    }
    return CRYPT_OK;
}
pub export fn md5_done(arg_md: [*c]hash_state, arg_out: [*c]u8) c_int {
    var md = arg_md;
    _ = &md;
    var out = arg_out;
    _ = &out;
    var i: c_int = undefined;
    _ = &i;
    if (!(md != @as([*c]hash_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("md != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34445));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34446));
    }
    if (@as(c_ulong, @bitCast(@as(c_ulong, md.*.md5.curlen))) >= @sizeOf([64]u8)) {
        return CRYPT_INVALID_ARG;
    }
    md.*.md5.length +%= @as(ulong64, @bitCast(@as(c_ulonglong, md.*.md5.curlen *% @as(ulong32, @bitCast(@as(c_int, 8))))));
    md.*.md5.buf[blk: {
        const ref = &md.*.md5.curlen;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 128)))));
    if (md.*.md5.curlen > @as(ulong32, @bitCast(@as(c_int, 56)))) {
        while (md.*.md5.curlen < @as(ulong32, @bitCast(@as(c_int, 64)))) {
            md.*.md5.buf[blk: {
                const ref = &md.*.md5.curlen;
                const tmp = ref.*;
                ref.* +%= 1;
                break :blk tmp;
            }] = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0)))));
        }
        _ = md5_compress(md, @as([*c]u8, @ptrCast(@alignCast(&md.*.md5.buf))));
        md.*.md5.curlen = 0;
    }
    while (md.*.md5.curlen < @as(ulong32, @bitCast(@as(c_int, 56)))) {
        md.*.md5.buf[blk: {
            const ref = &md.*.md5.curlen;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0)))));
    }
    {
        var __t: ulong64 = md.*.md5.length;
        _ = &__t;
        _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&md.*.md5.buf))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 56))))))), @as(?*const anyopaque, @ptrCast(&__t)), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))));
    }
    _ = md5_compress(md, @as([*c]u8, @ptrCast(@alignCast(&md.*.md5.buf))));
    {
        i = 0;
        while (i < @as(c_int, 4)) : (i += 1) {
            {
                var __t: ulong32 = md.*.md5.state[@as(c_uint, @intCast(i))];
                _ = &__t;
                _ = memcpy(@as(?*anyopaque, @ptrCast(out + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4) * i)))))), @as(?*const anyopaque, @ptrCast(&__t)), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4)))));
            }
        }
    }
    return CRYPT_OK;
}
pub export fn md5_test() c_int {
    const struct_unnamed_49 = extern struct {
        msg: [*c]u8 = @import("std").mem.zeroes([*c]u8),
        hash: [16]u8 = @import("std").mem.zeroes([16]u8),
    };
    _ = &struct_unnamed_49;
    const tests = struct {
        const static: [8]struct_unnamed_49 = [8]struct_unnamed_49{
            struct_unnamed_49{
                .msg = @as([*c]u8, @ptrCast(@volatileCast(@constCast("")))),
                .hash = [16]u8{
                    212,
                    29,
                    140,
                    217,
                    143,
                    0,
                    178,
                    4,
                    233,
                    128,
                    9,
                    152,
                    236,
                    248,
                    66,
                    126,
                },
            },
            struct_unnamed_49{
                .msg = @as([*c]u8, @ptrCast(@volatileCast(@constCast("a")))),
                .hash = [16]u8{
                    12,
                    193,
                    117,
                    185,
                    192,
                    241,
                    182,
                    168,
                    49,
                    195,
                    153,
                    226,
                    105,
                    119,
                    38,
                    97,
                },
            },
            struct_unnamed_49{
                .msg = @as([*c]u8, @ptrCast(@volatileCast(@constCast("abc")))),
                .hash = [16]u8{
                    144,
                    1,
                    80,
                    152,
                    60,
                    210,
                    79,
                    176,
                    214,
                    150,
                    63,
                    125,
                    40,
                    225,
                    127,
                    114,
                },
            },
            struct_unnamed_49{
                .msg = @as([*c]u8, @ptrCast(@volatileCast(@constCast("message digest")))),
                .hash = [16]u8{
                    249,
                    107,
                    105,
                    125,
                    124,
                    183,
                    147,
                    141,
                    82,
                    90,
                    47,
                    49,
                    170,
                    241,
                    97,
                    208,
                },
            },
            struct_unnamed_49{
                .msg = @as([*c]u8, @ptrCast(@volatileCast(@constCast("abcdefghijklmnopqrstuvwxyz")))),
                .hash = [16]u8{
                    195,
                    252,
                    211,
                    215,
                    97,
                    146,
                    228,
                    0,
                    125,
                    251,
                    73,
                    108,
                    202,
                    103,
                    225,
                    59,
                },
            },
            struct_unnamed_49{
                .msg = @as([*c]u8, @ptrCast(@volatileCast(@constCast("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789")))),
                .hash = [16]u8{
                    209,
                    116,
                    171,
                    152,
                    210,
                    119,
                    217,
                    245,
                    165,
                    97,
                    28,
                    44,
                    159,
                    65,
                    157,
                    159,
                },
            },
            struct_unnamed_49{
                .msg = @as([*c]u8, @ptrCast(@volatileCast(@constCast("12345678901234567890123456789012345678901234567890123456789012345678901234567890")))),
                .hash = [16]u8{
                    87,
                    237,
                    244,
                    162,
                    43,
                    227,
                    201,
                    85,
                    172,
                    73,
                    218,
                    46,
                    33,
                    7,
                    182,
                    122,
                },
            },
            struct_unnamed_49{
                .msg = null,
                .hash = [1]u8{
                    0,
                } ++ [1]u8{0} ** 15,
            },
        };
    };
    _ = &tests;
    var i: c_int = undefined;
    _ = &i;
    var tmp: [16]u8 = undefined;
    _ = &tmp;
    var md: hash_state = undefined;
    _ = &md;
    {
        i = 0;
        while (tests.static[@as(c_uint, @intCast(i))].msg != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) : (i += 1) {
            _ = md5_init(&md);
            _ = md5_process(&md, @as([*c]u8, @ptrCast(@alignCast(tests.static[@as(c_uint, @intCast(i))].msg))), strlen(tests.static[@as(c_uint, @intCast(i))].msg));
            _ = md5_done(&md, @as([*c]u8, @ptrCast(@alignCast(&tmp))));
            if (memcmp(@as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&tmp))))), @as(?*const anyopaque, @ptrCast(@as([*c]const u8, @ptrCast(@alignCast(&tests.static[@as(c_uint, @intCast(i))].hash))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16))))) != @as(c_int, 0)) {
                return CRYPT_FAIL_TESTVECTOR;
            }
        }
    }
    return CRYPT_OK;
}
pub extern const md5_desc: struct_ltc_hash_descriptor;
pub extern fn md4_init(md: [*c]hash_state) c_int;
pub extern fn md4_process(md: [*c]hash_state, in: [*c]const u8, inlen: c_ulong) c_int;
pub extern fn md4_done(md: [*c]hash_state, hash: [*c]u8) c_int;
pub extern fn md4_test() c_int;
pub extern const md4_desc: struct_ltc_hash_descriptor;
pub extern fn md2_init(md: [*c]hash_state) c_int;
pub extern fn md2_process(md: [*c]hash_state, in: [*c]const u8, inlen: c_ulong) c_int;
pub extern fn md2_done(md: [*c]hash_state, hash: [*c]u8) c_int;
pub extern fn md2_test() c_int;
pub extern const md2_desc: struct_ltc_hash_descriptor;
pub extern fn tiger_init(md: [*c]hash_state) c_int;
pub extern fn tiger_process(md: [*c]hash_state, in: [*c]const u8, inlen: c_ulong) c_int;
pub extern fn tiger_done(md: [*c]hash_state, hash: [*c]u8) c_int;
pub extern fn tiger_test() c_int;
pub extern const tiger_desc: struct_ltc_hash_descriptor;
pub extern fn rmd128_init(md: [*c]hash_state) c_int;
pub extern fn rmd128_process(md: [*c]hash_state, in: [*c]const u8, inlen: c_ulong) c_int;
pub extern fn rmd128_done(md: [*c]hash_state, hash: [*c]u8) c_int;
pub extern fn rmd128_test() c_int;
pub extern const rmd128_desc: struct_ltc_hash_descriptor;
pub extern fn rmd160_init(md: [*c]hash_state) c_int;
pub extern fn rmd160_process(md: [*c]hash_state, in: [*c]const u8, inlen: c_ulong) c_int;
pub extern fn rmd160_done(md: [*c]hash_state, hash: [*c]u8) c_int;
pub extern fn rmd160_test() c_int;
pub extern const rmd160_desc: struct_ltc_hash_descriptor;
pub extern fn rmd256_init(md: [*c]hash_state) c_int;
pub extern fn rmd256_process(md: [*c]hash_state, in: [*c]const u8, inlen: c_ulong) c_int;
pub extern fn rmd256_done(md: [*c]hash_state, hash: [*c]u8) c_int;
pub extern fn rmd256_test() c_int;
pub extern const rmd256_desc: struct_ltc_hash_descriptor;
pub extern fn rmd320_init(md: [*c]hash_state) c_int;
pub extern fn rmd320_process(md: [*c]hash_state, in: [*c]const u8, inlen: c_ulong) c_int;
pub extern fn rmd320_done(md: [*c]hash_state, hash: [*c]u8) c_int;
pub extern fn rmd320_test() c_int;
pub extern const rmd320_desc: struct_ltc_hash_descriptor;
pub export fn find_hash(arg_name: [*c]const u8) c_int {
    var name = arg_name;
    _ = &name;
    var x: c_int = undefined;
    _ = &x;
    if (!(name != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("name != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 17381));
    }
    {
        x = 0;
        while (x < @as(c_int, 256)) : (x += 1) {
            if ((hash_descriptor[@as(c_uint, @intCast(x))].name != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) and (strcmp(hash_descriptor[@as(c_uint, @intCast(x))].name, name) == @as(c_int, 0))) {
                return x;
            }
        }
    }
    return -@as(c_int, 1);
}
pub export fn find_hash_id(arg_ID: u8) c_int {
    var ID = arg_ID;
    _ = &ID;
    var x: c_int = undefined;
    _ = &x;
    {
        x = 0;
        while (x < @as(c_int, 256)) : (x += 1) {
            if (@as(c_int, @bitCast(@as(c_uint, hash_descriptor[@as(c_uint, @intCast(x))].ID))) == @as(c_int, @bitCast(@as(c_uint, ID)))) {
                x = if (hash_descriptor[@as(c_uint, @intCast(x))].name == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) -@as(c_int, 1) else x;
                return x;
            }
        }
    }
    return -@as(c_int, 1);
}
pub export fn find_hash_oid(arg_ID: [*c]const c_ulong, arg_IDlen: c_ulong) c_int {
    var ID = arg_ID;
    _ = &ID;
    var IDlen = arg_IDlen;
    _ = &IDlen;
    var x: c_int = undefined;
    _ = &x;
    if (!(ID != @as([*c]const c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ID != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 17511));
    }
    {
        x = 0;
        while (x < @as(c_int, 256)) : (x += 1) {
            if (((hash_descriptor[@as(c_uint, @intCast(x))].name != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) and (hash_descriptor[@as(c_uint, @intCast(x))].OIDlen == IDlen)) and !(memcmp(@as(?*const anyopaque, @ptrCast(@as([*c]c_ulong, @ptrCast(@alignCast(&hash_descriptor[@as(c_uint, @intCast(x))].OID))))), @as(?*const anyopaque, @ptrCast(ID)), @sizeOf(c_ulong) *% IDlen) != 0)) {
                return x;
            }
        }
    }
    return -@as(c_int, 1);
}
pub export fn find_hash_any(arg_name: [*c]const u8, arg_digestlen: c_int) c_int {
    var name = arg_name;
    _ = &name;
    var digestlen = arg_digestlen;
    _ = &digestlen;
    var x: c_int = undefined;
    _ = &x;
    var y: c_int = undefined;
    _ = &y;
    var z: c_int = undefined;
    _ = &z;
    if (!(name != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("name != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 17423));
    }
    x = find_hash(name);
    if (x != -@as(c_int, 1)) return x;
    y = @as(c_int, 128) + @as(c_int, 1);
    z = -@as(c_int, 1);
    {
        x = 0;
        while (x < @as(c_int, 256)) : (x += 1) {
            if (hash_descriptor[@as(c_uint, @intCast(x))].name == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
                continue;
            }
            if ((@as(c_int, @bitCast(@as(c_uint, @truncate(hash_descriptor[@as(c_uint, @intCast(x))].hashsize)))) >= digestlen) and (@as(c_int, @bitCast(@as(c_uint, @truncate(hash_descriptor[@as(c_uint, @intCast(x))].hashsize)))) < y)) {
                z = x;
                y = @as(c_int, @bitCast(@as(c_uint, @truncate(hash_descriptor[@as(c_uint, @intCast(x))].hashsize))));
            }
        }
    }
    return z;
}
pub export fn register_hash(arg_hash: [*c]const struct_ltc_hash_descriptor) c_int {
    var hash = arg_hash;
    _ = &hash;
    var x: c_int = undefined;
    _ = &x;
    if (!(hash != @as([*c]const struct_ltc_hash_descriptor, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("hash != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 17855));
    }
    {
        x = 0;
        while (x < @as(c_int, 256)) : (x += 1) {
            if (memcmp(@as(?*const anyopaque, @ptrCast(&hash_descriptor[@as(c_uint, @intCast(x))])), @as(?*const anyopaque, @ptrCast(hash)), @sizeOf(struct_ltc_hash_descriptor)) == @as(c_int, 0)) {
                return x;
            }
        }
    }
    {
        x = 0;
        while (x < @as(c_int, 256)) : (x += 1) {
            if (hash_descriptor[@as(c_uint, @intCast(x))].name == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
                _ = memcpy(@as(?*anyopaque, @ptrCast(&hash_descriptor[@as(c_uint, @intCast(x))])), @as(?*const anyopaque, @ptrCast(hash)), @sizeOf(struct_ltc_hash_descriptor));
                return x;
            }
        }
    }
    return -@as(c_int, 1);
}
pub export fn unregister_hash(arg_hash: [*c]const struct_ltc_hash_descriptor) c_int {
    var hash = arg_hash;
    _ = &hash;
    var x: c_int = undefined;
    _ = &x;
    if (!(hash != @as([*c]const struct_ltc_hash_descriptor, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("hash != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18011));
    }
    {
        x = 0;
        while (x < @as(c_int, 256)) : (x += 1) {
            if (memcmp(@as(?*const anyopaque, @ptrCast(&hash_descriptor[@as(c_uint, @intCast(x))])), @as(?*const anyopaque, @ptrCast(hash)), @sizeOf(struct_ltc_hash_descriptor)) == @as(c_int, 0)) {
                hash_descriptor[@as(c_uint, @intCast(x))].name = null;
                return CRYPT_OK;
            }
        }
    }
    return CRYPT_ERROR;
}
pub export fn hash_is_valid(arg_idx: c_int) c_int {
    var idx = arg_idx;
    _ = &idx;
    if (((idx < @as(c_int, 0)) or (idx >= @as(c_int, 256))) or (hash_descriptor[@as(c_uint, @intCast(idx))].name == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        return CRYPT_INVALID_HASH;
    }
    return CRYPT_OK;
}
// ./libtomcrypt.c:24841:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:24818:5: warning: unable to translate function, demoted to extern
pub extern fn hash_memory(arg_hash: c_int, arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int;
// ./libtomcrypt.c:24890:5: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn hash_memory_multi(hash: c_int, out: [*c]u8, outlen: [*c]c_ulong, in: [*c]const u8, inlen: c_ulong, ...) c_int;
pub export fn hash_filehandle(arg_hash: c_int, arg_in: [*c]FILE, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var hash = arg_hash;
    _ = &hash;
    var in = arg_in;
    _ = &in;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var md: hash_state = undefined;
    _ = &md;
    var buf: [512]u8 = undefined;
    _ = &buf;
    var x: usize = undefined;
    _ = &x;
    var err: c_int = undefined;
    _ = &err;
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 24755));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 24756));
    }
    if (!(in != @as([*c]FILE, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 24757));
    }
    if ((blk: {
        const tmp = hash_is_valid(hash);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if (outlen.* < hash_descriptor[@as(c_uint, @intCast(hash))].hashsize) {
        outlen.* = hash_descriptor[@as(c_uint, @intCast(hash))].hashsize;
        return CRYPT_BUFFER_OVERFLOW;
    }
    if ((blk: {
        const tmp = hash_descriptor[@as(c_uint, @intCast(hash))].init.?(&md);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    outlen.* = hash_descriptor[@as(c_uint, @intCast(hash))].hashsize;
    while (true) {
        x = fread(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&buf))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))), @sizeOf([512]u8), in);
        if ((blk: {
            const tmp = hash_descriptor[@as(c_uint, @intCast(hash))].process.?(&md, @as([*c]u8, @ptrCast(@alignCast(&buf))), x);
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            return err;
        }
        if (!(x == @sizeOf([512]u8))) break;
    }
    err = hash_descriptor[@as(c_uint, @intCast(hash))].done.?(&md, out);
    return err;
}
pub export fn hash_file(arg_hash: c_int, arg_fname: [*c]const u8, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var hash = arg_hash;
    _ = &hash;
    var fname = arg_fname;
    _ = &fname;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var in: [*c]FILE = undefined;
    _ = &in;
    var err: c_int = undefined;
    _ = &err;
    if (!(fname != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("fname != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 24694));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 24695));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 24696));
    }
    if ((blk: {
        const tmp = hash_is_valid(hash);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    in = fopen(fname, "rb");
    if (in == @as([*c]FILE, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        return CRYPT_FILE_NOTFOUND;
    }
    err = hash_filehandle(hash, in, out, outlen);
    if (fclose(in) != @as(c_int, 0)) {
        return CRYPT_ERROR;
    }
    return err;
}
pub const struct_Hmac_state = extern struct {
    md: hash_state = @import("std").mem.zeroes(hash_state),
    hash: c_int = @import("std").mem.zeroes(c_int),
    hashstate: hash_state = @import("std").mem.zeroes(hash_state),
    key: [*c]u8 = @import("std").mem.zeroes([*c]u8),
};
pub const hmac_state = struct_Hmac_state;
// ./libtomcrypt.c:30887:12: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:30848:5: warning: unable to translate function, demoted to extern
pub extern fn hmac_init(arg_hmac: [*c]hmac_state, arg_hash: c_int, arg_key: [*c]const u8, arg_keylen: c_ulong) c_int;
pub export fn hmac_process(arg_hmac: [*c]hmac_state, arg_in: [*c]const u8, arg_inlen: c_ulong) c_int {
    var hmac = arg_hmac;
    _ = &hmac;
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var err: c_int = undefined;
    _ = &err;
    if (!(hmac != @as([*c]hmac_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("hmac != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 30960));
    }
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 30961));
    }
    if ((blk: {
        const tmp = hash_is_valid(hmac.*.hash);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    return hash_descriptor[@as(c_uint, @intCast(hmac.*.hash))].process.?(&hmac.*.md, in, inlen);
}
// ./libtomcrypt.c:31037:8: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:31004:5: warning: unable to translate function, demoted to extern
pub extern fn hmac_done(arg_hmac: [*c]hmac_state, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int;
pub extern fn hmac_test() c_int;
pub extern fn hmac_memory(hash: c_int, key: [*c]const u8, keylen: c_ulong, in: [*c]const u8, inlen: c_ulong, out: [*c]u8, outlen: [*c]c_ulong) c_int;
pub extern fn hmac_memory_multi(hash: c_int, key: [*c]const u8, keylen: c_ulong, out: [*c]u8, outlen: [*c]c_ulong, in: [*c]const u8, inlen: c_ulong, ...) c_int;
pub extern fn hmac_file(hash: c_int, fname: [*c]const u8, key: [*c]const u8, keylen: c_ulong, dst: [*c]u8, dstlen: [*c]c_ulong) c_int;
pub const omac_state = extern struct {
    cipher_idx: c_int = @import("std").mem.zeroes(c_int),
    buflen: c_int = @import("std").mem.zeroes(c_int),
    blklen: c_int = @import("std").mem.zeroes(c_int),
    block: [128]u8 = @import("std").mem.zeroes([128]u8),
    prev: [128]u8 = @import("std").mem.zeroes([128]u8),
    Lu: [2][128]u8 = @import("std").mem.zeroes([2][128]u8),
    key: symmetric_key = @import("std").mem.zeroes(symmetric_key),
};
pub extern fn omac_init(omac: [*c]omac_state, cipher: c_int, key: [*c]const u8, keylen: c_ulong) c_int;
pub extern fn omac_process(omac: [*c]omac_state, in: [*c]const u8, inlen: c_ulong) c_int;
pub extern fn omac_done(omac: [*c]omac_state, out: [*c]u8, outlen: [*c]c_ulong) c_int;
pub extern fn omac_memory(cipher: c_int, key: [*c]const u8, keylen: c_ulong, in: [*c]const u8, inlen: c_ulong, out: [*c]u8, outlen: [*c]c_ulong) c_int;
pub extern fn omac_memory_multi(cipher: c_int, key: [*c]const u8, keylen: c_ulong, out: [*c]u8, outlen: [*c]c_ulong, in: [*c]const u8, inlen: c_ulong, ...) c_int;
pub extern fn omac_file(cipher: c_int, key: [*c]const u8, keylen: c_ulong, filename: [*c]const u8, out: [*c]u8, outlen: [*c]c_ulong) c_int;
pub extern fn omac_test() c_int;
pub const pmac_state = extern struct {
    Ls: [32][128]u8 = @import("std").mem.zeroes([32][128]u8),
    Li: [128]u8 = @import("std").mem.zeroes([128]u8),
    Lr: [128]u8 = @import("std").mem.zeroes([128]u8),
    block: [128]u8 = @import("std").mem.zeroes([128]u8),
    checksum: [128]u8 = @import("std").mem.zeroes([128]u8),
    key: symmetric_key = @import("std").mem.zeroes(symmetric_key),
    block_index: c_ulong = @import("std").mem.zeroes(c_ulong),
    cipher_idx: c_int = @import("std").mem.zeroes(c_int),
    block_len: c_int = @import("std").mem.zeroes(c_int),
    buflen: c_int = @import("std").mem.zeroes(c_int),
};
pub extern fn pmac_init(pmac: [*c]pmac_state, cipher: c_int, key: [*c]const u8, keylen: c_ulong) c_int;
pub extern fn pmac_process(pmac: [*c]pmac_state, in: [*c]const u8, inlen: c_ulong) c_int;
pub extern fn pmac_done(pmac: [*c]pmac_state, out: [*c]u8, outlen: [*c]c_ulong) c_int;
pub extern fn pmac_memory(cipher: c_int, key: [*c]const u8, keylen: c_ulong, msg: [*c]const u8, msglen: c_ulong, out: [*c]u8, outlen: [*c]c_ulong) c_int;
pub extern fn pmac_memory_multi(cipher: c_int, key: [*c]const u8, keylen: c_ulong, out: [*c]u8, outlen: [*c]c_ulong, in: [*c]const u8, inlen: c_ulong, ...) c_int;
pub extern fn pmac_file(cipher: c_int, key: [*c]const u8, keylen: c_ulong, filename: [*c]const u8, out: [*c]u8, outlen: [*c]c_ulong) c_int;
pub extern fn pmac_test() c_int;
pub extern fn pmac_ntz(x: c_ulong) c_int;
pub extern fn pmac_shift_xor(pmac: [*c]pmac_state) void;
pub const eax_state = extern struct {
    N: [128]u8 = @import("std").mem.zeroes([128]u8),
    ctr: symmetric_CTR = @import("std").mem.zeroes(symmetric_CTR),
    headeromac: omac_state = @import("std").mem.zeroes(omac_state),
    ctomac: omac_state = @import("std").mem.zeroes(omac_state),
};
pub extern fn eax_init(eax: [*c]eax_state, cipher: c_int, key: [*c]const u8, keylen: c_ulong, nonce: [*c]const u8, noncelen: c_ulong, header: [*c]const u8, headerlen: c_ulong) c_int;
pub extern fn eax_encrypt(eax: [*c]eax_state, pt: [*c]const u8, ct: [*c]u8, length: c_ulong) c_int;
pub extern fn eax_decrypt(eax: [*c]eax_state, ct: [*c]const u8, pt: [*c]u8, length: c_ulong) c_int;
pub extern fn eax_addheader(eax: [*c]eax_state, header: [*c]const u8, length: c_ulong) c_int;
pub extern fn eax_done(eax: [*c]eax_state, tag: [*c]u8, taglen: [*c]c_ulong) c_int;
pub extern fn eax_encrypt_authenticate_memory(cipher: c_int, key: [*c]const u8, keylen: c_ulong, nonce: [*c]const u8, noncelen: c_ulong, header: [*c]const u8, headerlen: c_ulong, pt: [*c]const u8, ptlen: c_ulong, ct: [*c]u8, tag: [*c]u8, taglen: [*c]c_ulong) c_int;
pub extern fn eax_decrypt_verify_memory(cipher: c_int, key: [*c]const u8, keylen: c_ulong, nonce: [*c]const u8, noncelen: c_ulong, header: [*c]const u8, headerlen: c_ulong, ct: [*c]const u8, ctlen: c_ulong, pt: [*c]u8, tag: [*c]u8, taglen: c_ulong, stat: [*c]c_int) c_int;
pub extern fn eax_test() c_int;
pub const ocb_state = extern struct {
    L: [128]u8 = @import("std").mem.zeroes([128]u8),
    Ls: [32][128]u8 = @import("std").mem.zeroes([32][128]u8),
    Li: [128]u8 = @import("std").mem.zeroes([128]u8),
    Lr: [128]u8 = @import("std").mem.zeroes([128]u8),
    R: [128]u8 = @import("std").mem.zeroes([128]u8),
    checksum: [128]u8 = @import("std").mem.zeroes([128]u8),
    key: symmetric_key = @import("std").mem.zeroes(symmetric_key),
    block_index: c_ulong = @import("std").mem.zeroes(c_ulong),
    cipher: c_int = @import("std").mem.zeroes(c_int),
    block_len: c_int = @import("std").mem.zeroes(c_int),
};
pub extern fn ocb_init(ocb: [*c]ocb_state, cipher: c_int, key: [*c]const u8, keylen: c_ulong, nonce: [*c]const u8) c_int;
pub extern fn ocb_encrypt(ocb: [*c]ocb_state, pt: [*c]const u8, ct: [*c]u8) c_int;
pub extern fn ocb_decrypt(ocb: [*c]ocb_state, ct: [*c]const u8, pt: [*c]u8) c_int;
pub extern fn ocb_done_encrypt(ocb: [*c]ocb_state, pt: [*c]const u8, ptlen: c_ulong, ct: [*c]u8, tag: [*c]u8, taglen: [*c]c_ulong) c_int;
pub extern fn ocb_done_decrypt(ocb: [*c]ocb_state, ct: [*c]const u8, ctlen: c_ulong, pt: [*c]u8, tag: [*c]const u8, taglen: c_ulong, stat: [*c]c_int) c_int;
pub extern fn ocb_encrypt_authenticate_memory(cipher: c_int, key: [*c]const u8, keylen: c_ulong, nonce: [*c]const u8, pt: [*c]const u8, ptlen: c_ulong, ct: [*c]u8, tag: [*c]u8, taglen: [*c]c_ulong) c_int;
pub extern fn ocb_decrypt_verify_memory(cipher: c_int, key: [*c]const u8, keylen: c_ulong, nonce: [*c]const u8, ct: [*c]const u8, ctlen: c_ulong, pt: [*c]u8, tag: [*c]const u8, taglen: c_ulong, stat: [*c]c_int) c_int;
pub extern fn ocb_test() c_int;
pub extern fn ocb_shift_xor(ocb: [*c]ocb_state, Z: [*c]u8) void;
pub extern fn ocb_ntz(x: c_ulong) c_int;
pub extern fn s_ocb_done(ocb: [*c]ocb_state, pt: [*c]const u8, ptlen: c_ulong, ct: [*c]u8, tag: [*c]u8, taglen: [*c]c_ulong, mode: c_int) c_int;
pub extern fn ccm_memory(cipher: c_int, key: [*c]const u8, keylen: c_ulong, uskey: [*c]symmetric_key, nonce: [*c]const u8, noncelen: c_ulong, header: [*c]const u8, headerlen: c_ulong, pt: [*c]u8, ptlen: c_ulong, ct: [*c]u8, tag: [*c]u8, taglen: [*c]c_ulong, direction: c_int) c_int;
pub extern fn ccm_test() c_int;
// ./libtomcrypt.c:13697:5: warning: TODO implement translation of stmt class GCCAsmStmtClass

// ./libtomcrypt.c:33904:6: warning: unable to translate function, demoted to extern
pub extern fn gcm_gf_mult(arg_a: [*c]const u8, arg_b: [*c]const u8, arg_c: [*c]u8) void;
pub const gcm_shift_table: [*c]const u8 = @extern([*c]const u8, .{
    .name = "gcm_shift_table",
});
pub const gcm_state = extern struct {
    K: symmetric_key = @import("std").mem.zeroes(symmetric_key),
    H: [16]u8 = @import("std").mem.zeroes([16]u8),
    X: [16]u8 = @import("std").mem.zeroes([16]u8),
    Y: [16]u8 = @import("std").mem.zeroes([16]u8),
    Y_0: [16]u8 = @import("std").mem.zeroes([16]u8),
    buf: [16]u8 = @import("std").mem.zeroes([16]u8),
    cipher: c_int = @import("std").mem.zeroes(c_int),
    ivmode: c_int = @import("std").mem.zeroes(c_int),
    mode: c_int = @import("std").mem.zeroes(c_int),
    buflen: c_int = @import("std").mem.zeroes(c_int),
    totlen: ulong64 = @import("std").mem.zeroes(ulong64),
    pttotlen: ulong64 = @import("std").mem.zeroes(ulong64),
    PC: [16][256][16]u8 = @import("std").mem.zeroes([16][256][16]u8),
};
pub export fn gcm_mult_h(arg_gcm: [*c]gcm_state, arg_I_1: [*c]u8) void {
    var gcm = arg_gcm;
    _ = &gcm;
    var I_1 = arg_I_1;
    _ = &I_1;
    var T: [16]u8 = undefined;
    _ = &T;
    var x: c_int = undefined;
    _ = &x;
    var y: c_int = undefined;
    _ = &y;
    _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&T))))), @as(?*const anyopaque, @ptrCast(&gcm.*.PC[@as(c_uint, @intCast(@as(c_int, 0)))][I_1[@as(c_uint, @intCast(@as(c_int, 0)))]][@as(c_uint, @intCast(@as(c_int, 0)))])), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16)))));
    {
        x = 1;
        while (x < @as(c_int, 16)) : (x += 1) {
            {
                y = 0;
                while (y < @as(c_int, 16)) : (y += @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf(c_ulong)))))) {
                    @as([*c]c_ulong, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&T))) + @as(usize, @bitCast(@as(isize, @intCast(y))))))).* ^= @as([*c]c_ulong, @ptrCast(@alignCast(&gcm.*.PC[@as(c_uint, @intCast(x))][(blk: {
                        const tmp = x;
                        if (tmp >= 0) break :blk I_1 + @as(usize, @intCast(tmp)) else break :blk I_1 - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).*][@as(c_uint, @intCast(y))]))).*;
                }
            }
        }
    }
    _ = memcpy(@as(?*anyopaque, @ptrCast(I_1)), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&T))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16)))));
}
pub export fn gcm_init(arg_gcm: [*c]gcm_state, arg_cipher: c_int, arg_key: [*c]const u8, arg_keylen: c_int) c_int {
    var gcm = arg_gcm;
    _ = &gcm;
    var cipher = arg_cipher;
    _ = &cipher;
    var key = arg_key;
    _ = &key;
    var keylen = arg_keylen;
    _ = &keylen;
    var err: c_int = undefined;
    _ = &err;
    var B: [16]u8 = undefined;
    _ = &B;
    var x: c_int = undefined;
    _ = &x;
    var y: c_int = undefined;
    _ = &y;
    var z: c_int = undefined;
    _ = &z;
    var t: c_int = undefined;
    _ = &t;
    if (!(gcm != @as([*c]gcm_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("gcm != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33501));
    }
    if (!(key != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("key != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33502));
    }
    if ((@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16)))) % @sizeOf(c_ulong)) != 0) {
        return CRYPT_INVALID_ARG;
    }
    if ((blk: {
        const tmp = cipher_is_valid(cipher);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if (cipher_descriptor[@as(c_uint, @intCast(cipher))].block_length != @as(c_int, 16)) {
        return CRYPT_INVALID_CIPHER;
    }
    if ((blk: {
        const tmp = cipher_descriptor[@as(c_uint, @intCast(cipher))].setup.?(key, keylen, @as(c_int, 0), &gcm.*.K);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    zeromem(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&B))))), @as(usize, @bitCast(@as(c_long, @as(c_int, 16)))));
    if ((blk: {
        const tmp = cipher_descriptor[@as(c_uint, @intCast(cipher))].ecb_encrypt.?(@as([*c]u8, @ptrCast(@alignCast(&B))), @as([*c]u8, @ptrCast(@alignCast(&gcm.*.H))), &gcm.*.K);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    zeromem(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&gcm.*.buf))))), @sizeOf([16]u8));
    zeromem(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&gcm.*.X))))), @sizeOf([16]u8));
    gcm.*.cipher = cipher;
    gcm.*.mode = 0;
    gcm.*.ivmode = 0;
    gcm.*.buflen = 0;
    gcm.*.totlen = 0;
    gcm.*.pttotlen = 0;
    zeromem(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&B))))), @as(usize, @bitCast(@as(c_long, @as(c_int, 16)))));
    {
        y = 0;
        while (y < @as(c_int, 256)) : (y += 1) {
            B[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(i8, @truncate(y))));
            gcm_gf_mult(@as([*c]u8, @ptrCast(@alignCast(&gcm.*.H))), @as([*c]u8, @ptrCast(@alignCast(&B))), &gcm.*.PC[@as(c_uint, @intCast(@as(c_int, 0)))][@as(c_uint, @intCast(y))][@as(c_uint, @intCast(@as(c_int, 0)))]);
        }
    }
    {
        x = 1;
        while (x < @as(c_int, 16)) : (x += 1) {
            {
                y = 0;
                while (y < @as(c_int, 256)) : (y += 1) {
                    t = @as(c_int, @bitCast(@as(c_uint, gcm.*.PC[@as(c_uint, @intCast(x - @as(c_int, 1)))][@as(c_uint, @intCast(y))][@as(c_uint, @intCast(@as(c_int, 15)))])));
                    {
                        z = 15;
                        while (z > @as(c_int, 0)) : (z -= 1) {
                            gcm.*.PC[@as(c_uint, @intCast(x))][@as(c_uint, @intCast(y))][@as(c_uint, @intCast(z))] = gcm.*.PC[@as(c_uint, @intCast(x - @as(c_int, 1)))][@as(c_uint, @intCast(y))][@as(c_uint, @intCast(z - @as(c_int, 1)))];
                        }
                    }
                    gcm.*.PC[@as(c_uint, @intCast(x))][@as(c_uint, @intCast(y))][@as(c_uint, @intCast(@as(c_int, 0)))] = gcm_shift_table[@as(c_uint, @intCast(t << @intCast(1)))];
                    gcm.*.PC[@as(c_uint, @intCast(x))][@as(c_uint, @intCast(y))][@as(c_uint, @intCast(@as(c_int, 1)))] ^= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, gcm_shift_table[@as(c_uint, @intCast((t << @intCast(1)) + @as(c_int, 1)))])))))));
                }
            }
        }
    }
    return CRYPT_OK;
}
pub export fn gcm_reset(arg_gcm: [*c]gcm_state) c_int {
    var gcm = arg_gcm;
    _ = &gcm;
    if (!(gcm != @as([*c]gcm_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("gcm != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 34163));
    }
    zeromem(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&gcm.*.buf))))), @sizeOf([16]u8));
    zeromem(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&gcm.*.X))))), @sizeOf([16]u8));
    gcm.*.mode = 0;
    gcm.*.ivmode = 0;
    gcm.*.buflen = 0;
    gcm.*.totlen = 0;
    gcm.*.pttotlen = 0;
    return CRYPT_OK;
}
pub export fn gcm_add_iv(arg_gcm: [*c]gcm_state, arg_IV: [*c]const u8, arg_IVlen: c_ulong) c_int {
    var gcm = arg_gcm;
    _ = &gcm;
    var IV = arg_IV;
    _ = &IV;
    var IVlen = arg_IVlen;
    _ = &IVlen;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    var err: c_int = undefined;
    _ = &err;
    if (!(gcm != @as([*c]gcm_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("gcm != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33316));
    }
    if (IVlen > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) {
        if (!(IV != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
            crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("IV != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33318));
        }
    }
    if (gcm.*.mode != @as(c_int, 0)) {
        return CRYPT_INVALID_ARG;
    }
    if ((gcm.*.buflen >= @as(c_int, 16)) or (gcm.*.buflen < @as(c_int, 0))) {
        return CRYPT_INVALID_ARG;
    }
    if ((blk: {
        const tmp = cipher_is_valid(gcm.*.cipher);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if ((IVlen +% @as(c_ulong, @bitCast(@as(c_long, gcm.*.buflen)))) > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 12))))) {
        gcm.*.ivmode |= @as(c_int, 1);
    }
    x = 0;
    if (gcm.*.buflen == @as(c_int, 0)) {
        {
            x = 0;
            while (x < (IVlen & @as(c_ulong, @bitCast(@as(c_long, ~@as(c_int, 15)))))) : (x +%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16))))) {
                {
                    y = 0;
                    while (y < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16))))) : (y +%= @sizeOf(c_ulong)) {
                        @as([*c]c_ulong, @ptrCast(@alignCast(&gcm.*.X[y]))).* ^= @as([*c]c_ulong, @ptrCast(@volatileCast(@constCast(&IV[x +% y])))).*;
                    }
                }
                gcm_mult_h(gcm, @as([*c]u8, @ptrCast(@alignCast(&gcm.*.X))));
                gcm.*.totlen +%= @as(ulong64, @bitCast(@as(c_longlong, @as(c_int, 128))));
            }
        }
        IV += x;
    }
    while (x < IVlen) : (x +%= 1) {
        gcm.*.buf[@as(c_uint, @intCast(blk: {
            const ref = &gcm.*.buflen;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }))] = (blk: {
            const ref = &IV;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).*;
        if (gcm.*.buflen == @as(c_int, 16)) {
            {
                y = 0;
                while (y < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16))))) : (y +%= 1) {
                    gcm.*.X[y] ^= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, gcm.*.buf[y])))))));
                }
            }
            gcm_mult_h(gcm, @as([*c]u8, @ptrCast(@alignCast(&gcm.*.X))));
            gcm.*.buflen = 0;
            gcm.*.totlen +%= @as(ulong64, @bitCast(@as(c_longlong, @as(c_int, 128))));
        }
    }
    return CRYPT_OK;
}
// ./libtomcrypt.c:13690:5: warning: TODO implement translation of stmt class GCCAsmStmtClass

// ./libtomcrypt.c:34037:5: warning: unable to translate function, demoted to extern
pub extern fn gcm_add_aad(arg_gcm: [*c]gcm_state, arg_adata: [*c]const u8, arg_adatalen: c_ulong) c_int;
pub export fn gcm_process(arg_gcm: [*c]gcm_state, arg_pt: [*c]u8, arg_ptlen: c_ulong, arg_ct: [*c]u8, arg_direction: c_int) c_int {
    var gcm = arg_gcm;
    _ = &gcm;
    var pt = arg_pt;
    _ = &pt;
    var ptlen = arg_ptlen;
    _ = &ptlen;
    var ct = arg_ct;
    _ = &ct;
    var direction = arg_direction;
    _ = &direction;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_int = undefined;
    _ = &y;
    var err: c_int = undefined;
    _ = &err;
    var b: u8 = undefined;
    _ = &b;
    if (!(gcm != @as([*c]gcm_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("gcm != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33611));
    }
    if (ptlen > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) {
        if (!(pt != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
            crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("pt != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33613));
        }
        if (!(ct != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
            crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ct != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 33614));
        }
    }
    if ((gcm.*.buflen > @as(c_int, 16)) or (gcm.*.buflen < @as(c_int, 0))) {
        return CRYPT_INVALID_ARG;
    }
    if ((blk: {
        const tmp = cipher_is_valid(gcm.*.cipher);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if (gcm.*.mode == @as(c_int, 1)) {
        if (gcm.*.buflen != 0) {
            gcm.*.totlen +%= @as(ulong64, @bitCast(@as(c_ulonglong, @bitCast(@as(c_longlong, gcm.*.buflen))) *% @as(c_ulonglong, 8)));
            gcm_mult_h(gcm, @as([*c]u8, @ptrCast(@alignCast(&gcm.*.X))));
        }
        {
            y = 15;
            while (y >= @as(c_int, 12)) : (y -= 1) {
                if ((@as(c_int, @bitCast(@as(c_uint, blk: {
                    const ref = &gcm.*.Y[@as(c_uint, @intCast(y))];
                    ref.* +%= 1;
                    break :blk ref.*;
                }))) & @as(c_int, 255)) != 0) {
                    break;
                }
            }
        }
        if ((blk: {
            const tmp = cipher_descriptor[@as(c_uint, @intCast(gcm.*.cipher))].ecb_encrypt.?(@as([*c]u8, @ptrCast(@alignCast(&gcm.*.Y))), @as([*c]u8, @ptrCast(@alignCast(&gcm.*.buf))), &gcm.*.K);
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            return err;
        }
        gcm.*.buflen = 0;
        gcm.*.mode = 2;
    }
    if (gcm.*.mode != @as(c_int, 2)) {
        return CRYPT_INVALID_ARG;
    }
    x = 0;
    if (gcm.*.buflen == @as(c_int, 0)) {
        if (direction == @as(c_int, 0)) {
            {
                x = 0;
                while (x < (ptlen & @as(c_ulong, @bitCast(@as(c_long, ~@as(c_int, 15)))))) : (x +%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16))))) {
                    {
                        y = 0;
                        while (y < @as(c_int, 16)) : (y += @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf(c_ulong)))))) {
                            @as([*c]c_ulong, @ptrCast(@alignCast(&ct[x +% @as(c_ulong, @bitCast(@as(c_long, y)))]))).* = @as([*c]c_ulong, @ptrCast(@alignCast(&pt[x +% @as(c_ulong, @bitCast(@as(c_long, y)))]))).* ^ @as([*c]c_ulong, @ptrCast(@alignCast(&gcm.*.buf[@as(c_uint, @intCast(y))]))).*;
                            @as([*c]c_ulong, @ptrCast(@alignCast(&gcm.*.X[@as(c_uint, @intCast(y))]))).* ^= @as([*c]c_ulong, @ptrCast(@alignCast(&ct[x +% @as(c_ulong, @bitCast(@as(c_long, y)))]))).*;
                        }
                    }
                    gcm.*.pttotlen +%= @as(ulong64, @bitCast(@as(c_longlong, @as(c_int, 128))));
                    gcm_mult_h(gcm, @as([*c]u8, @ptrCast(@alignCast(&gcm.*.X))));
                    {
                        y = 15;
                        while (y >= @as(c_int, 12)) : (y -= 1) {
                            if ((@as(c_int, @bitCast(@as(c_uint, blk: {
                                const ref = &gcm.*.Y[@as(c_uint, @intCast(y))];
                                ref.* +%= 1;
                                break :blk ref.*;
                            }))) & @as(c_int, 255)) != 0) {
                                break;
                            }
                        }
                    }
                    if ((blk: {
                        const tmp = cipher_descriptor[@as(c_uint, @intCast(gcm.*.cipher))].ecb_encrypt.?(@as([*c]u8, @ptrCast(@alignCast(&gcm.*.Y))), @as([*c]u8, @ptrCast(@alignCast(&gcm.*.buf))), &gcm.*.K);
                        err = tmp;
                        break :blk tmp;
                    }) != CRYPT_OK) {
                        return err;
                    }
                }
            }
        } else {
            {
                x = 0;
                while (x < (ptlen & @as(c_ulong, @bitCast(@as(c_long, ~@as(c_int, 15)))))) : (x +%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16))))) {
                    {
                        y = 0;
                        while (y < @as(c_int, 16)) : (y += @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf(c_ulong)))))) {
                            @as([*c]c_ulong, @ptrCast(@alignCast(&gcm.*.X[@as(c_uint, @intCast(y))]))).* ^= @as([*c]c_ulong, @ptrCast(@alignCast(&ct[x +% @as(c_ulong, @bitCast(@as(c_long, y)))]))).*;
                            @as([*c]c_ulong, @ptrCast(@alignCast(&pt[x +% @as(c_ulong, @bitCast(@as(c_long, y)))]))).* = @as([*c]c_ulong, @ptrCast(@alignCast(&ct[x +% @as(c_ulong, @bitCast(@as(c_long, y)))]))).* ^ @as([*c]c_ulong, @ptrCast(@alignCast(&gcm.*.buf[@as(c_uint, @intCast(y))]))).*;
                        }
                    }
                    gcm.*.pttotlen +%= @as(ulong64, @bitCast(@as(c_longlong, @as(c_int, 128))));
                    gcm_mult_h(gcm, @as([*c]u8, @ptrCast(@alignCast(&gcm.*.X))));
                    {
                        y = 15;
                        while (y >= @as(c_int, 12)) : (y -= 1) {
                            if ((@as(c_int, @bitCast(@as(c_uint, blk: {
                                const ref = &gcm.*.Y[@as(c_uint, @intCast(y))];
                                ref.* +%= 1;
                                break :blk ref.*;
                            }))) & @as(c_int, 255)) != 0) {
                                break;
                            }
                        }
                    }
                    if ((blk: {
                        const tmp = cipher_descriptor[@as(c_uint, @intCast(gcm.*.cipher))].ecb_encrypt.?(@as([*c]u8, @ptrCast(@alignCast(&gcm.*.Y))), @as([*c]u8, @ptrCast(@alignCast(&gcm.*.buf))), &gcm.*.K);
                        err = tmp;
                        break :blk tmp;
                    }) != CRYPT_OK) {
                        return err;
                    }
                }
            }
        }
    }
    while (x < ptlen) : (x +%= 1) {
        if (gcm.*.buflen == @as(c_int, 16)) {
            gcm.*.pttotlen +%= @as(ulong64, @bitCast(@as(c_longlong, @as(c_int, 128))));
            gcm_mult_h(gcm, @as([*c]u8, @ptrCast(@alignCast(&gcm.*.X))));
            {
                y = 15;
                while (y >= @as(c_int, 12)) : (y -= 1) {
                    if ((@as(c_int, @bitCast(@as(c_uint, blk: {
                        const ref = &gcm.*.Y[@as(c_uint, @intCast(y))];
                        ref.* +%= 1;
                        break :blk ref.*;
                    }))) & @as(c_int, 255)) != 0) {
                        break;
                    }
                }
            }
            if ((blk: {
                const tmp = cipher_descriptor[@as(c_uint, @intCast(gcm.*.cipher))].ecb_encrypt.?(@as([*c]u8, @ptrCast(@alignCast(&gcm.*.Y))), @as([*c]u8, @ptrCast(@alignCast(&gcm.*.buf))), &gcm.*.K);
                err = tmp;
                break :blk tmp;
            }) != CRYPT_OK) {
                return err;
            }
            gcm.*.buflen = 0;
        }
        if (direction == @as(c_int, 0)) {
            b = blk: {
                const tmp = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, pt[x]))) ^ @as(c_int, @bitCast(@as(c_uint, gcm.*.buf[@as(c_uint, @intCast(gcm.*.buflen))])))))));
                ct[x] = tmp;
                break :blk tmp;
            };
        } else {
            b = ct[x];
            pt[x] = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, ct[x]))) ^ @as(c_int, @bitCast(@as(c_uint, gcm.*.buf[@as(c_uint, @intCast(gcm.*.buflen))])))))));
        }
        gcm.*.X[@as(c_uint, @intCast(blk: {
            const ref = &gcm.*.buflen;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }))] ^= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, b)))))));
    }
    return CRYPT_OK;
}
// ./libtomcrypt.c:13690:5: warning: TODO implement translation of stmt class GCCAsmStmtClass

// ./libtomcrypt.c:33406:5: warning: unable to translate function, demoted to extern
pub extern fn gcm_done(arg_gcm: [*c]gcm_state, arg_tag: [*c]u8, arg_taglen: [*c]c_ulong) c_int;
pub extern fn gcm_memory(cipher: c_int, key: [*c]const u8, keylen: c_ulong, IV: [*c]const u8, IVlen: c_ulong, adata: [*c]const u8, adatalen: c_ulong, pt: [*c]u8, ptlen: c_ulong, ct: [*c]u8, tag: [*c]u8, taglen: [*c]c_ulong, direction: c_int) c_int;
pub extern fn gcm_test() c_int;
pub const struct_pelican_state = extern struct {
    K: symmetric_key = @import("std").mem.zeroes(symmetric_key),
    state: [16]u8 = @import("std").mem.zeroes([16]u8),
    buflen: c_int = @import("std").mem.zeroes(c_int),
};
pub const pelican_state = struct_pelican_state;
pub extern fn pelican_init(pelmac: [*c]pelican_state, key: [*c]const u8, keylen: c_ulong) c_int;
pub extern fn pelican_process(pelmac: [*c]pelican_state, in: [*c]const u8, inlen: c_ulong) c_int;
pub extern fn pelican_done(pelmac: [*c]pelican_state, out: [*c]u8) c_int;
pub extern fn pelican_test() c_int;
pub extern fn pelican_memory(key: [*c]const u8, keylen: c_ulong, in: [*c]const u8, inlen: c_ulong, out: [*c]u8) c_int;
pub const xcbc_state = extern struct {
    K: [3][128]u8 = @import("std").mem.zeroes([3][128]u8),
    IV: [128]u8 = @import("std").mem.zeroes([128]u8),
    key: symmetric_key = @import("std").mem.zeroes(symmetric_key),
    cipher: c_int = @import("std").mem.zeroes(c_int),
    buflen: c_int = @import("std").mem.zeroes(c_int),
    blocksize: c_int = @import("std").mem.zeroes(c_int),
};
pub extern fn xcbc_init(xcbc: [*c]xcbc_state, cipher: c_int, key: [*c]const u8, keylen: c_ulong) c_int;
pub extern fn xcbc_process(xcbc: [*c]xcbc_state, in: [*c]const u8, inlen: c_ulong) c_int;
pub extern fn xcbc_done(xcbc: [*c]xcbc_state, out: [*c]u8, outlen: [*c]c_ulong) c_int;
pub extern fn xcbc_memory(cipher: c_int, key: [*c]const u8, keylen: c_ulong, in: [*c]const u8, inlen: c_ulong, out: [*c]u8, outlen: [*c]c_ulong) c_int;
pub extern fn xcbc_memory_multi(cipher: c_int, key: [*c]const u8, keylen: c_ulong, out: [*c]u8, outlen: [*c]c_ulong, in: [*c]const u8, inlen: c_ulong, ...) c_int;
pub extern fn xcbc_file(cipher: c_int, key: [*c]const u8, keylen: c_ulong, filename: [*c]const u8, out: [*c]u8, outlen: [*c]c_ulong) c_int;
pub extern fn xcbc_test() c_int;
pub const f9_state = extern struct {
    akey: [128]u8 = @import("std").mem.zeroes([128]u8),
    ACC: [128]u8 = @import("std").mem.zeroes([128]u8),
    IV: [128]u8 = @import("std").mem.zeroes([128]u8),
    key: symmetric_key = @import("std").mem.zeroes(symmetric_key),
    cipher: c_int = @import("std").mem.zeroes(c_int),
    buflen: c_int = @import("std").mem.zeroes(c_int),
    keylen: c_int = @import("std").mem.zeroes(c_int),
    blocksize: c_int = @import("std").mem.zeroes(c_int),
};
pub extern fn f9_init(f9: [*c]f9_state, cipher: c_int, key: [*c]const u8, keylen: c_ulong) c_int;
pub extern fn f9_process(f9: [*c]f9_state, in: [*c]const u8, inlen: c_ulong) c_int;
pub extern fn f9_done(f9: [*c]f9_state, out: [*c]u8, outlen: [*c]c_ulong) c_int;
pub extern fn f9_memory(cipher: c_int, key: [*c]const u8, keylen: c_ulong, in: [*c]const u8, inlen: c_ulong, out: [*c]u8, outlen: [*c]c_ulong) c_int;
pub extern fn f9_memory_multi(cipher: c_int, key: [*c]const u8, keylen: c_ulong, out: [*c]u8, outlen: [*c]c_ulong, in: [*c]const u8, inlen: c_ulong, ...) c_int;
pub extern fn f9_file(cipher: c_int, key: [*c]const u8, keylen: c_ulong, filename: [*c]const u8, out: [*c]u8, outlen: [*c]c_ulong) c_int;
pub extern fn f9_test() c_int;
pub const struct_yarrow_prng = extern struct {
    cipher: c_int = @import("std").mem.zeroes(c_int),
    hash: c_int = @import("std").mem.zeroes(c_int),
    pool: [128]u8 = @import("std").mem.zeroes([128]u8),
    ctr: symmetric_CTR = @import("std").mem.zeroes(symmetric_CTR),
};
pub const struct_rc4_prng = extern struct {
    x: c_int = @import("std").mem.zeroes(c_int),
    y: c_int = @import("std").mem.zeroes(c_int),
    buf: [256]u8 = @import("std").mem.zeroes([256]u8),
};
pub const struct_fortuna_prng = extern struct {
    pool: [32]hash_state = @import("std").mem.zeroes([32]hash_state),
    skey: symmetric_key = @import("std").mem.zeroes(symmetric_key),
    K: [32]u8 = @import("std").mem.zeroes([32]u8),
    IV: [16]u8 = @import("std").mem.zeroes([16]u8),
    pool_idx: c_ulong = @import("std").mem.zeroes(c_ulong),
    pool0_len: c_ulong = @import("std").mem.zeroes(c_ulong),
    wd: c_ulong = @import("std").mem.zeroes(c_ulong),
    reset_cnt: ulong64 = @import("std").mem.zeroes(ulong64),
};
pub const struct_sober128_prng = extern struct {
    R: [17]ulong32 = @import("std").mem.zeroes([17]ulong32),
    initR: [17]ulong32 = @import("std").mem.zeroes([17]ulong32),
    konst: ulong32 = @import("std").mem.zeroes(ulong32),
    sbuf: ulong32 = @import("std").mem.zeroes(ulong32),
    nbuf: c_int = @import("std").mem.zeroes(c_int),
    flag: c_int = @import("std").mem.zeroes(c_int),
    set: c_int = @import("std").mem.zeroes(c_int),
};
pub const union_Prng_state = extern union {
    dummy: [1]u8,
    yarrow: struct_yarrow_prng,
    rc4: struct_rc4_prng,
    fortuna: struct_fortuna_prng,
    sober128: struct_sober128_prng,
};
pub const prng_state = union_Prng_state;
pub const struct_ltc_prng_descriptor = extern struct {
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    export_size: c_int = @import("std").mem.zeroes(c_int),
    start: ?*const fn ([*c]prng_state) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]prng_state) callconv(.c) c_int),
    add_entropy: ?*const fn ([*c]const u8, c_ulong, [*c]prng_state) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, c_ulong, [*c]prng_state) callconv(.c) c_int),
    ready: ?*const fn ([*c]prng_state) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]prng_state) callconv(.c) c_int),
    read: ?*const fn ([*c]u8, c_ulong, [*c]prng_state) callconv(.c) c_ulong = @import("std").mem.zeroes(?*const fn ([*c]u8, c_ulong, [*c]prng_state) callconv(.c) c_ulong),
    done: ?*const fn ([*c]prng_state) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]prng_state) callconv(.c) c_int),
    pexport: ?*const fn ([*c]u8, [*c]c_ulong, [*c]prng_state) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]u8, [*c]c_ulong, [*c]prng_state) callconv(.c) c_int),
    pimport: ?*const fn ([*c]const u8, c_ulong, [*c]prng_state) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, c_ulong, [*c]prng_state) callconv(.c) c_int),
    @"test": ?*const fn () callconv(.c) c_int = @import("std").mem.zeroes(?*const fn () callconv(.c) c_int),
};
pub const prng_descriptor: [*c]struct_ltc_prng_descriptor = @extern([*c]struct_ltc_prng_descriptor, .{
    .name = "prng_descriptor",
});
pub extern fn yarrow_start(prng: [*c]prng_state) c_int;
pub extern fn yarrow_add_entropy(in: [*c]const u8, inlen: c_ulong, prng: [*c]prng_state) c_int;
pub extern fn yarrow_ready(prng: [*c]prng_state) c_int;
pub extern fn yarrow_read(out: [*c]u8, outlen: c_ulong, prng: [*c]prng_state) c_ulong;
pub extern fn yarrow_done(prng: [*c]prng_state) c_int;
pub extern fn yarrow_export(out: [*c]u8, outlen: [*c]c_ulong, prng: [*c]prng_state) c_int;
pub extern fn yarrow_import(in: [*c]const u8, inlen: c_ulong, prng: [*c]prng_state) c_int;
pub extern fn yarrow_test() c_int;
pub extern const yarrow_desc: struct_ltc_prng_descriptor;
pub extern fn fortuna_start(prng: [*c]prng_state) c_int;
pub extern fn fortuna_add_entropy(in: [*c]const u8, inlen: c_ulong, prng: [*c]prng_state) c_int;
pub extern fn fortuna_ready(prng: [*c]prng_state) c_int;
pub extern fn fortuna_read(out: [*c]u8, outlen: c_ulong, prng: [*c]prng_state) c_ulong;
pub extern fn fortuna_done(prng: [*c]prng_state) c_int;
pub extern fn fortuna_export(out: [*c]u8, outlen: [*c]c_ulong, prng: [*c]prng_state) c_int;
pub extern fn fortuna_import(in: [*c]const u8, inlen: c_ulong, prng: [*c]prng_state) c_int;
pub extern fn fortuna_test() c_int;
pub extern const fortuna_desc: struct_ltc_prng_descriptor;
pub extern fn rc4_start(prng: [*c]prng_state) c_int;
pub extern fn rc4_add_entropy(in: [*c]const u8, inlen: c_ulong, prng: [*c]prng_state) c_int;
pub extern fn rc4_ready(prng: [*c]prng_state) c_int;
pub extern fn rc4_read(out: [*c]u8, outlen: c_ulong, prng: [*c]prng_state) c_ulong;
pub extern fn rc4_done(prng: [*c]prng_state) c_int;
pub extern fn rc4_export(out: [*c]u8, outlen: [*c]c_ulong, prng: [*c]prng_state) c_int;
pub extern fn rc4_import(in: [*c]const u8, inlen: c_ulong, prng: [*c]prng_state) c_int;
pub extern fn rc4_test() c_int;
pub extern const rc4_desc: struct_ltc_prng_descriptor;
pub export fn sprng_start(arg_prng: [*c]prng_state) c_int {
    var prng = arg_prng;
    _ = &prng;
    return CRYPT_OK;
}
pub export fn sprng_add_entropy(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_prng: [*c]prng_state) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var prng = arg_prng;
    _ = &prng;
    return CRYPT_OK;
}
pub export fn sprng_ready(arg_prng: [*c]prng_state) c_int {
    var prng = arg_prng;
    _ = &prng;
    return CRYPT_OK;
}
pub export fn sprng_read(arg_out: [*c]u8, arg_outlen: c_ulong, arg_prng: [*c]prng_state) c_ulong {
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var prng = arg_prng;
    _ = &prng;
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 29513));
    }
    return rng_get_bytes(out, outlen, null);
}
pub export fn sprng_done(arg_prng: [*c]prng_state) c_int {
    var prng = arg_prng;
    _ = &prng;
    return CRYPT_OK;
}
pub export fn sprng_export(arg_out: [*c]u8, arg_outlen: [*c]c_ulong, arg_prng: [*c]prng_state) c_int {
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var prng = arg_prng;
    _ = &prng;
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 29534));
    }
    outlen.* = 0;
    return CRYPT_OK;
}
pub export fn sprng_import(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_prng: [*c]prng_state) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var prng = arg_prng;
    _ = &prng;
    return CRYPT_OK;
}
pub export fn sprng_test() c_int {
    return CRYPT_OK;
}
pub extern const sprng_desc: struct_ltc_prng_descriptor;
pub extern fn sober128_start(prng: [*c]prng_state) c_int;
pub extern fn sober128_add_entropy(in: [*c]const u8, inlen: c_ulong, prng: [*c]prng_state) c_int;
pub extern fn sober128_ready(prng: [*c]prng_state) c_int;
pub extern fn sober128_read(out: [*c]u8, outlen: c_ulong, prng: [*c]prng_state) c_ulong;
pub extern fn sober128_done(prng: [*c]prng_state) c_int;
pub extern fn sober128_export(out: [*c]u8, outlen: [*c]c_ulong, prng: [*c]prng_state) c_int;
pub extern fn sober128_import(in: [*c]const u8, inlen: c_ulong, prng: [*c]prng_state) c_int;
pub extern fn sober128_test() c_int;
pub extern const sober128_desc: struct_ltc_prng_descriptor;
pub export fn find_prng(arg_name: [*c]const u8) c_int {
    var name = arg_name;
    _ = &name;
    var x: c_int = undefined;
    _ = &x;
    if (!(name != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("name != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 17553));
    }
    {
        x = 0;
        while (x < @as(c_int, 256)) : (x += 1) {
            if ((prng_descriptor[@as(c_uint, @intCast(x))].name != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) and (strcmp(prng_descriptor[@as(c_uint, @intCast(x))].name, name) == @as(c_int, 0))) {
                return x;
            }
        }
    }
    return -@as(c_int, 1);
}
pub export fn register_prng(arg_prng: [*c]const struct_ltc_prng_descriptor) c_int {
    var prng = arg_prng;
    _ = &prng;
    var x: c_int = undefined;
    _ = &x;
    if (!(prng != @as([*c]const struct_ltc_prng_descriptor, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("prng != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 17910));
    }
    {
        x = 0;
        while (x < @as(c_int, 256)) : (x += 1) {
            if (memcmp(@as(?*const anyopaque, @ptrCast(&prng_descriptor[@as(c_uint, @intCast(x))])), @as(?*const anyopaque, @ptrCast(prng)), @sizeOf(struct_ltc_prng_descriptor)) == @as(c_int, 0)) {
                return x;
            }
        }
    }
    {
        x = 0;
        while (x < @as(c_int, 256)) : (x += 1) {
            if (prng_descriptor[@as(c_uint, @intCast(x))].name == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
                _ = memcpy(@as(?*anyopaque, @ptrCast(&prng_descriptor[@as(c_uint, @intCast(x))])), @as(?*const anyopaque, @ptrCast(prng)), @sizeOf(struct_ltc_prng_descriptor));
                return x;
            }
        }
    }
    return -@as(c_int, 1);
}
pub export fn unregister_prng(arg_prng: [*c]const struct_ltc_prng_descriptor) c_int {
    var prng = arg_prng;
    _ = &prng;
    var x: c_int = undefined;
    _ = &x;
    if (!(prng != @as([*c]const struct_ltc_prng_descriptor, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("prng != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18056));
    }
    {
        x = 0;
        while (x < @as(c_int, 256)) : (x += 1) {
            if (memcmp(@as(?*const anyopaque, @ptrCast(&prng_descriptor[@as(c_uint, @intCast(x))])), @as(?*const anyopaque, @ptrCast(prng)), @sizeOf(struct_ltc_prng_descriptor)) != @as(c_int, 0)) {
                prng_descriptor[@as(c_uint, @intCast(x))].name = null;
                return CRYPT_OK;
            }
        }
    }
    return CRYPT_ERROR;
}
pub export fn prng_is_valid(arg_idx: c_int) c_int {
    var idx = arg_idx;
    _ = &idx;
    if (((idx < @as(c_int, 0)) or (idx >= @as(c_int, 256))) or (prng_descriptor[@as(c_uint, @intCast(idx))].name == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        return CRYPT_INVALID_PRNG;
    }
    return CRYPT_OK;
}
pub export fn rng_get_bytes(arg_out: [*c]u8, arg_outlen: c_ulong, arg_callback: ?*const fn () callconv(.c) void) c_ulong {
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var callback = arg_callback;
    _ = &callback;
    var x: c_ulong = undefined;
    _ = &x;
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 28374));
    }
    x = rng_nix(out, outlen, callback);
    if (x != @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) {
        return x;
    }
    x = rng_ansic(out, outlen, callback);
    if (x != @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) {
        return x;
    }
    return 0;
}
pub export fn rng_make_prng(arg_bits: c_int, arg_wprng: c_int, arg_prng: [*c]prng_state, arg_callback: ?*const fn () callconv(.c) void) c_int {
    var bits = arg_bits;
    _ = &bits;
    var wprng = arg_wprng;
    _ = &wprng;
    var prng = arg_prng;
    _ = &prng;
    var callback = arg_callback;
    _ = &callback;
    var buf: [256]u8 = undefined;
    _ = &buf;
    var err: c_int = undefined;
    _ = &err;
    if (!(prng != @as([*c]prng_state, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("prng != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 28432));
    }
    if ((blk: {
        const tmp = prng_is_valid(wprng);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if ((bits < @as(c_int, 64)) or (bits > @as(c_int, 1024))) {
        return CRYPT_INVALID_PRNGSIZE;
    }
    if ((blk: {
        const tmp = prng_descriptor[@as(c_uint, @intCast(wprng))].start.?(prng);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    bits = (@divTrunc(bits, @as(c_int, 8)) + (if ((bits & @as(c_int, 7)) != @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0))) * @as(c_int, 2);
    if (rng_get_bytes(@as([*c]u8, @ptrCast(@alignCast(&buf))), @as(c_ulong, @bitCast(@as(c_long, bits))), callback) != @as(c_ulong, @bitCast(@as(c_long, bits)))) {
        return CRYPT_ERROR_READPRNG;
    }
    if ((blk: {
        const tmp = prng_descriptor[@as(c_uint, @intCast(wprng))].add_entropy.?(@as([*c]u8, @ptrCast(@alignCast(&buf))), @as(c_ulong, @bitCast(@as(c_long, bits))), prng);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if ((blk: {
        const tmp = prng_descriptor[@as(c_uint, @intCast(wprng))].ready.?(prng);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    return CRYPT_OK;
}
pub const LTC_PKA_UNDEF: c_int = 0;
pub const LTC_PKA_RSA: c_int = 1;
pub const LTC_PKA_DSA: c_int = 2;
pub const LTC_PKA_EC: c_int = 3;
pub const LTC_PKA_X25519: c_int = 4;
pub const LTC_PKA_ED25519: c_int = 5;
pub const LTC_PKA_DH: c_int = 6;
pub const LTC_PKA_NUM: c_int = 7;
pub const enum_ltc_pka_id = c_uint;
pub const PK_PUBLIC: c_int = 0;
pub const PK_PRIVATE: c_int = 1;
pub const enum_public_key_type = c_uint;
pub export fn rand_prime(arg_N: ?*anyopaque, arg_len: c_long, arg_prng: [*c]prng_state, arg_wprng: c_int) c_int {
    var N = arg_N;
    _ = &N;
    var len = arg_len;
    _ = &len;
    var prng = arg_prng;
    _ = &prng;
    var wprng = arg_wprng;
    _ = &wprng;
    var err: c_int = undefined;
    _ = &err;
    var res: c_int = undefined;
    _ = &res;
    var @"type": c_int = undefined;
    _ = &@"type";
    var buf: [*c]u8 = undefined;
    _ = &buf;
    if (!(N != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("N != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 28184));
    }
    if (len < @as(c_long, @bitCast(@as(c_long, @as(c_int, 0))))) {
        @"type" = 1;
        len = -len;
    } else {
        @"type" = 0;
    }
    if ((len < @as(c_long, @bitCast(@as(c_long, @as(c_int, 2))))) or (len > @as(c_long, @bitCast(@as(c_long, @as(c_int, 512)))))) {
        return CRYPT_INVALID_PRIME_SIZE;
    }
    if ((blk: {
        const tmp = prng_is_valid(wprng);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    buf = @as([*c]u8, @ptrCast(@alignCast(calloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))), @as(c_ulong, @bitCast(len))))));
    if (buf == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        return CRYPT_MEM;
    }
    while (true) {
        if (prng_descriptor[@as(c_uint, @intCast(wprng))].read.?(buf, @as(c_ulong, @bitCast(len)), prng) != @as(c_ulong, @bitCast(len))) {
            free(@as(?*anyopaque, @ptrCast(buf)));
            return CRYPT_ERROR_READPRNG;
        }
        buf[@as(c_uint, @intCast(@as(c_int, 0)))] |= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 128) | @as(c_int, 64)))));
        (blk: {
            const tmp = len - @as(c_long, @bitCast(@as(c_long, @as(c_int, 1))));
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* |= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1) | (if ((@"type" & @as(c_int, 1)) != 0) @as(c_int, 2) else @as(c_int, 0))))));
        if ((blk: {
            const tmp = ltc_mp.unsigned_read.?(N, buf, @as(c_ulong, @bitCast(len)));
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            free(@as(?*anyopaque, @ptrCast(buf)));
            return err;
        }
        if ((blk: {
            const tmp = ltc_mp.isprime.?(N, &res);
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            free(@as(?*anyopaque, @ptrCast(buf)));
            return err;
        }
        if (!(res == @as(c_int, 0))) break;
    }
    free(@as(?*anyopaque, @ptrCast(buf)));
    return CRYPT_OK;
}
pub const struct_Rsa_key = extern struct {
    type: c_int = @import("std").mem.zeroes(c_int),
    e: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    d: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    N: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    p: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    q: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    qP: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    dP: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    dQ: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const rsa_key = struct_Rsa_key;
// ./libtomcrypt.c:29040:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:29015:5: warning: unable to translate function, demoted to extern
pub extern fn rsa_make_key(arg_prng: [*c]prng_state, arg_wprng: c_int, arg_size: c_int, arg_e: c_long, arg_key: [*c]rsa_key) c_int;
// ./libtomcrypt.c:28734:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:28707:5: warning: unable to translate function, demoted to extern
pub extern fn rsa_exptmod(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong, arg_which: c_int, arg_key: [*c]rsa_key) c_int;
pub export fn rsa_free(arg_key: [*c]rsa_key) void {
    var key = arg_key;
    _ = &key;
    if (!(key != @as([*c]rsa_key, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("key != ((void*)0)")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 28835));
    }
    ltc_deinit_multi(key.*.e, key.*.d, key.*.N, key.*.dQ, key.*.dP, key.*.qP, key.*.p, key.*.q, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
}
pub export fn rsa_encrypt_key_ex(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong, arg_lparam: [*c]const u8, arg_lparamlen: c_ulong, arg_prng: [*c]prng_state, arg_prng_idx: c_int, arg_hash_idx: c_int, arg_padding: c_int, arg_key: [*c]rsa_key) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var lparam = arg_lparam;
    _ = &lparam;
    var lparamlen = arg_lparamlen;
    _ = &lparamlen;
    var prng = arg_prng;
    _ = &prng;
    var prng_idx = arg_prng_idx;
    _ = &prng_idx;
    var hash_idx = arg_hash_idx;
    _ = &hash_idx;
    var padding = arg_padding;
    _ = &padding;
    var key = arg_key;
    _ = &key;
    var modulus_bitlen: c_ulong = undefined;
    _ = &modulus_bitlen;
    var modulus_bytelen: c_ulong = undefined;
    _ = &modulus_bytelen;
    var x: c_ulong = undefined;
    _ = &x;
    var err: c_int = undefined;
    _ = &err;
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 28617));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 28618));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 28619));
    }
    if (!(key != @as([*c]rsa_key, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("key != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 28620));
    }
    if ((padding != LTC_LTC_PKCS_1_V1_5) and (padding != LTC_LTC_PKCS_1_OAEP)) {
        return CRYPT_PK_INVALID_PADDING;
    }
    if ((blk: {
        const tmp = prng_is_valid(prng_idx);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if (padding == LTC_LTC_PKCS_1_OAEP) {
        if ((blk: {
            const tmp = hash_is_valid(hash_idx);
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            return err;
        }
    }
    modulus_bitlen = @as(c_ulong, @bitCast(@as(c_long, ltc_mp.count_bits.?(key.*.N))));
    modulus_bytelen = ltc_mp.unsigned_size.?(key.*.N);
    if (modulus_bytelen > outlen.*) {
        outlen.* = modulus_bytelen;
        return CRYPT_BUFFER_OVERFLOW;
    }
    if (padding == LTC_LTC_PKCS_1_OAEP) {
        x = outlen.*;
        if ((blk: {
            const tmp = pkcs_1_oaep_encode(in, inlen, lparam, lparamlen, modulus_bitlen, prng, prng_idx, hash_idx, out, &x);
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            return err;
        }
    } else {
        x = outlen.*;
        if ((blk: {
            const tmp = pkcs_1_v1_5_encode(in, inlen, LTC_LTC_PKCS_1_EME, modulus_bitlen, prng, prng_idx, out, &x);
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            return err;
        }
    }
    return ltc_mp.rsa_me.?(out, x, out, outlen, PK_PUBLIC, key);
}
pub export fn rsa_decrypt_key_ex(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong, arg_lparam: [*c]const u8, arg_lparamlen: c_ulong, arg_hash_idx: c_int, arg_padding: c_int, arg_stat: [*c]c_int, arg_key: [*c]rsa_key) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var lparam = arg_lparam;
    _ = &lparam;
    var lparamlen = arg_lparamlen;
    _ = &lparamlen;
    var hash_idx = arg_hash_idx;
    _ = &hash_idx;
    var padding = arg_padding;
    _ = &padding;
    var stat = arg_stat;
    _ = &stat;
    var key = arg_key;
    _ = &key;
    var modulus_bitlen: c_ulong = undefined;
    _ = &modulus_bitlen;
    var modulus_bytelen: c_ulong = undefined;
    _ = &modulus_bytelen;
    var x: c_ulong = undefined;
    _ = &x;
    var err: c_int = undefined;
    _ = &err;
    var tmp: [*c]u8 = undefined;
    _ = &tmp;
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 28513));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 28514));
    }
    if (!(key != @as([*c]rsa_key, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("key != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 28515));
    }
    if (!(stat != @as([*c]c_int, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("stat != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 28516));
    }
    stat.* = 0;
    if ((padding != LTC_LTC_PKCS_1_V1_5) and (padding != LTC_LTC_PKCS_1_OAEP)) {
        return CRYPT_PK_INVALID_PADDING;
    }
    if (padding == LTC_LTC_PKCS_1_OAEP) {
        if ((blk: {
            const tmp_1 = hash_is_valid(hash_idx);
            err = tmp_1;
            break :blk tmp_1;
        }) != CRYPT_OK) {
            return err;
        }
    }
    modulus_bitlen = @as(c_ulong, @bitCast(@as(c_long, ltc_mp.count_bits.?(key.*.N))));
    modulus_bytelen = ltc_mp.unsigned_size.?(key.*.N);
    if (modulus_bytelen != inlen) {
        return CRYPT_INVALID_PACKET;
    }
    tmp = @as([*c]u8, @ptrCast(@alignCast(malloc(inlen))));
    if (tmp == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        return CRYPT_MEM;
    }
    x = inlen;
    if ((blk: {
        const tmp_1 = ltc_mp.rsa_me.?(in, inlen, tmp, &x, PK_PRIVATE, key);
        err = tmp_1;
        break :blk tmp_1;
    }) != CRYPT_OK) {
        free(@as(?*anyopaque, @ptrCast(tmp)));
        return err;
    }
    if (padding == LTC_LTC_PKCS_1_OAEP) {
        err = pkcs_1_oaep_decode(tmp, x, lparam, lparamlen, modulus_bitlen, hash_idx, out, outlen, stat);
    } else {
        err = pkcs_1_v1_5_decode(tmp, x, LTC_LTC_PKCS_1_EME, modulus_bitlen, out, outlen, stat);
    }
    free(@as(?*anyopaque, @ptrCast(tmp)));
    return err;
}
pub const struct_ltc_asn1_list_ = extern struct {
    type: c_int = @import("std").mem.zeroes(c_int),
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    size: c_ulong = @import("std").mem.zeroes(c_ulong),
    used: c_int = @import("std").mem.zeroes(c_int),
    prev: [*c]struct_ltc_asn1_list_ = @import("std").mem.zeroes([*c]struct_ltc_asn1_list_),
    next: [*c]struct_ltc_asn1_list_ = @import("std").mem.zeroes([*c]struct_ltc_asn1_list_),
    child: [*c]struct_ltc_asn1_list_ = @import("std").mem.zeroes([*c]struct_ltc_asn1_list_),
    parent: [*c]struct_ltc_asn1_list_ = @import("std").mem.zeroes([*c]struct_ltc_asn1_list_),
};
pub const ltc_asn1_list = struct_ltc_asn1_list_;
pub export fn rsa_sign_hash_ex(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong, arg_padding: c_int, arg_prng: [*c]prng_state, arg_prng_idx: c_int, arg_hash_idx: c_int, arg_saltlen: c_ulong, arg_key: [*c]rsa_key) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var padding = arg_padding;
    _ = &padding;
    var prng = arg_prng;
    _ = &prng;
    var prng_idx = arg_prng_idx;
    _ = &prng_idx;
    var hash_idx = arg_hash_idx;
    _ = &hash_idx;
    var saltlen = arg_saltlen;
    _ = &saltlen;
    var key = arg_key;
    _ = &key;
    var modulus_bitlen: c_ulong = undefined;
    _ = &modulus_bitlen;
    var modulus_bytelen: c_ulong = undefined;
    _ = &modulus_bytelen;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    var err: c_int = undefined;
    _ = &err;
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 29179));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 29180));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 29181));
    }
    if (!(key != @as([*c]rsa_key, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("key != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 29182));
    }
    if ((padding != LTC_LTC_PKCS_1_V1_5) and (padding != LTC_LTC_PKCS_1_PSS)) {
        return CRYPT_PK_INVALID_PADDING;
    }
    if (padding == LTC_LTC_PKCS_1_PSS) {
        if ((blk: {
            const tmp = prng_is_valid(prng_idx);
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            return err;
        }
        if ((blk: {
            const tmp = hash_is_valid(hash_idx);
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            return err;
        }
    }
    modulus_bitlen = @as(c_ulong, @bitCast(@as(c_long, ltc_mp.count_bits.?(key.*.N))));
    modulus_bytelen = ltc_mp.unsigned_size.?(key.*.N);
    if (modulus_bytelen > outlen.*) {
        outlen.* = modulus_bytelen;
        return CRYPT_BUFFER_OVERFLOW;
    }
    if (padding == LTC_LTC_PKCS_1_PSS) {
        x = outlen.*;
        if ((blk: {
            const tmp = pkcs_1_pss_encode(in, inlen, saltlen, prng, prng_idx, hash_idx, modulus_bitlen, out, &x);
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            return err;
        }
    } else {
        var tmpin: [*c]u8 = undefined;
        _ = &tmpin;
        var digestinfo: [2]ltc_asn1_list = undefined;
        _ = &digestinfo;
        var siginfo: [2]ltc_asn1_list = undefined;
        _ = &siginfo;
        if (hash_descriptor[@as(c_uint, @intCast(hash_idx))].OIDlen == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) {
            return CRYPT_INVALID_ARG;
        }
        while (true) {
            var LTC_MACRO_temp: c_int = @as(c_int, 0);
            _ = &LTC_MACRO_temp;
            var LTC_MACRO_list: [*c]ltc_asn1_list = @as([*c]ltc_asn1_list, @ptrCast(@alignCast(&digestinfo)));
            _ = &LTC_MACRO_list;
            (blk: {
                const tmp = LTC_MACRO_temp;
                if (tmp >= 0) break :blk LTC_MACRO_list + @as(usize, @intCast(tmp)) else break :blk LTC_MACRO_list - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*.type = LTC_ASN1_OBJECT_IDENTIFIER;
            (blk: {
                const tmp = LTC_MACRO_temp;
                if (tmp >= 0) break :blk LTC_MACRO_list + @as(usize, @intCast(tmp)) else break :blk LTC_MACRO_list - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*.data = @as(?*anyopaque, @ptrCast(@as([*c]c_ulong, @ptrCast(@alignCast(&hash_descriptor[@as(c_uint, @intCast(hash_idx))].OID)))));
            (blk: {
                const tmp = LTC_MACRO_temp;
                if (tmp >= 0) break :blk LTC_MACRO_list + @as(usize, @intCast(tmp)) else break :blk LTC_MACRO_list - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*.size = hash_descriptor[@as(c_uint, @intCast(hash_idx))].OIDlen;
            (blk: {
                const tmp = LTC_MACRO_temp;
                if (tmp >= 0) break :blk LTC_MACRO_list + @as(usize, @intCast(tmp)) else break :blk LTC_MACRO_list - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*.used = 0;
            if (!false) break;
        }
        while (true) {
            var LTC_MACRO_temp: c_int = @as(c_int, 1);
            _ = &LTC_MACRO_temp;
            var LTC_MACRO_list: [*c]ltc_asn1_list = @as([*c]ltc_asn1_list, @ptrCast(@alignCast(&digestinfo)));
            _ = &LTC_MACRO_list;
            (blk: {
                const tmp = LTC_MACRO_temp;
                if (tmp >= 0) break :blk LTC_MACRO_list + @as(usize, @intCast(tmp)) else break :blk LTC_MACRO_list - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*.type = LTC_ASN1_NULL;
            (blk: {
                const tmp = LTC_MACRO_temp;
                if (tmp >= 0) break :blk LTC_MACRO_list + @as(usize, @intCast(tmp)) else break :blk LTC_MACRO_list - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*.data = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
            (blk: {
                const tmp = LTC_MACRO_temp;
                if (tmp >= 0) break :blk LTC_MACRO_list + @as(usize, @intCast(tmp)) else break :blk LTC_MACRO_list - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*.size = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))));
            (blk: {
                const tmp = LTC_MACRO_temp;
                if (tmp >= 0) break :blk LTC_MACRO_list + @as(usize, @intCast(tmp)) else break :blk LTC_MACRO_list - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*.used = 0;
            if (!false) break;
        }
        while (true) {
            var LTC_MACRO_temp: c_int = @as(c_int, 0);
            _ = &LTC_MACRO_temp;
            var LTC_MACRO_list: [*c]ltc_asn1_list = @as([*c]ltc_asn1_list, @ptrCast(@alignCast(&siginfo)));
            _ = &LTC_MACRO_list;
            (blk: {
                const tmp = LTC_MACRO_temp;
                if (tmp >= 0) break :blk LTC_MACRO_list + @as(usize, @intCast(tmp)) else break :blk LTC_MACRO_list - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*.type = LTC_ASN1_SEQUENCE;
            (blk: {
                const tmp = LTC_MACRO_temp;
                if (tmp >= 0) break :blk LTC_MACRO_list + @as(usize, @intCast(tmp)) else break :blk LTC_MACRO_list - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*.data = @as(?*anyopaque, @ptrCast(@as([*c]ltc_asn1_list, @ptrCast(@alignCast(&digestinfo)))));
            (blk: {
                const tmp = LTC_MACRO_temp;
                if (tmp >= 0) break :blk LTC_MACRO_list + @as(usize, @intCast(tmp)) else break :blk LTC_MACRO_list - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*.size = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))));
            (blk: {
                const tmp = LTC_MACRO_temp;
                if (tmp >= 0) break :blk LTC_MACRO_list + @as(usize, @intCast(tmp)) else break :blk LTC_MACRO_list - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*.used = 0;
            if (!false) break;
        }
        while (true) {
            var LTC_MACRO_temp: c_int = @as(c_int, 1);
            _ = &LTC_MACRO_temp;
            var LTC_MACRO_list: [*c]ltc_asn1_list = @as([*c]ltc_asn1_list, @ptrCast(@alignCast(&siginfo)));
            _ = &LTC_MACRO_list;
            (blk: {
                const tmp = LTC_MACRO_temp;
                if (tmp >= 0) break :blk LTC_MACRO_list + @as(usize, @intCast(tmp)) else break :blk LTC_MACRO_list - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*.type = LTC_ASN1_OCTET_STRING;
            (blk: {
                const tmp = LTC_MACRO_temp;
                if (tmp >= 0) break :blk LTC_MACRO_list + @as(usize, @intCast(tmp)) else break :blk LTC_MACRO_list - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*.data = @as(?*anyopaque, @ptrCast(@volatileCast(@constCast(in))));
            (blk: {
                const tmp = LTC_MACRO_temp;
                if (tmp >= 0) break :blk LTC_MACRO_list + @as(usize, @intCast(tmp)) else break :blk LTC_MACRO_list - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*.size = inlen;
            (blk: {
                const tmp = LTC_MACRO_temp;
                if (tmp >= 0) break :blk LTC_MACRO_list + @as(usize, @intCast(tmp)) else break :blk LTC_MACRO_list - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*.used = 0;
            if (!false) break;
        }
        y = ltc_mp.unsigned_size.?(key.*.N);
        tmpin = @as([*c]u8, @ptrCast(@alignCast(malloc(y))));
        if (tmpin == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
            return CRYPT_MEM;
        }
        if ((blk: {
            const tmp = der_encode_sequence_ex(@as([*c]ltc_asn1_list, @ptrCast(@alignCast(&siginfo))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2)))), tmpin, &y, LTC_ASN1_SEQUENCE);
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            free(@as(?*anyopaque, @ptrCast(tmpin)));
            return err;
        }
        x = outlen.*;
        if ((blk: {
            const tmp = pkcs_1_v1_5_encode(tmpin, y, LTC_LTC_PKCS_1_EMSA, modulus_bitlen, null, @as(c_int, 0), out, &x);
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            free(@as(?*anyopaque, @ptrCast(tmpin)));
            return err;
        }
        free(@as(?*anyopaque, @ptrCast(tmpin)));
    }
    return ltc_mp.rsa_me.?(out, x, out, outlen, PK_PRIVATE, key);
}
// ./libtomcrypt.c:29375:13: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:29303:5: warning: unable to translate function, demoted to extern
pub extern fn rsa_verify_hash_ex(arg_sig: [*c]const u8, arg_siglen: c_ulong, arg_hash: [*c]const u8, arg_hashlen: c_ulong, arg_padding: c_int, arg_hash_idx: c_int, arg_saltlen: c_ulong, arg_stat: [*c]c_int, arg_key: [*c]rsa_key) c_int;
pub extern fn rsa_export(out: [*c]u8, outlen: [*c]c_ulong, @"type": c_int, key: [*c]rsa_key) c_int;
// ./libtomcrypt.c:28893:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:28871:5: warning: unable to translate function, demoted to extern
pub extern fn rsa_import(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_key: [*c]rsa_key) c_int;
pub const ltc_ecc_set_type = extern struct {
    size: c_int = @import("std").mem.zeroes(c_int),
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    prime: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    B: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    order: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    Gx: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    Gy: [*c]u8 = @import("std").mem.zeroes([*c]u8),
};
pub const ecc_point = extern struct {
    x: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    y: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    z: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const ecc_key = extern struct {
    type: c_int = @import("std").mem.zeroes(c_int),
    idx: c_int = @import("std").mem.zeroes(c_int),
    dp: [*c]const ltc_ecc_set_type = @import("std").mem.zeroes([*c]const ltc_ecc_set_type),
    pubkey: ecc_point = @import("std").mem.zeroes(ecc_point),
    k: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const ltc_ecc_sets: [*c]const ltc_ecc_set_type = @extern([*c]const ltc_ecc_set_type, .{
    .name = "ltc_ecc_sets",
});
// ./libtomcrypt.c:24311:13: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:24288:5: warning: unable to translate function, demoted to extern
pub extern fn ecc_test() c_int;
pub export fn ecc_sizes(arg_low: [*c]c_int, arg_high: [*c]c_int) void {
    var low = arg_low;
    _ = &low;
    var high = arg_high;
    _ = &high;
    var i: c_int = undefined;
    _ = &i;
    if (!(low != @as([*c]c_int, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("low != ((void*)0)")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 24239));
    }
    if (!(high != @as([*c]c_int, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("high != ((void*)0)")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 24240));
    }
    low.* = 2147483647;
    high.* = 0;
    {
        i = 0;
        while (ltc_ecc_sets[@as(c_uint, @intCast(i))].size != @as(c_int, 0)) : (i += 1) {
            if (ltc_ecc_sets[@as(c_uint, @intCast(i))].size < low.*) {
                low.* = ltc_ecc_sets[@as(c_uint, @intCast(i))].size;
            }
            if (ltc_ecc_sets[@as(c_uint, @intCast(i))].size > high.*) {
                high.* = ltc_ecc_sets[@as(c_uint, @intCast(i))].size;
            }
        }
    }
}
pub export fn ecc_get_size(arg_key: [*c]ecc_key) c_int {
    var key = arg_key;
    _ = &key;
    if (!(key != @as([*c]ecc_key, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("key != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 23628));
    }
    if (ltc_ecc_is_valid_idx(key.*.idx) != 0) return key.*.dp.*.size else return 2147483647;
    return 0;
}
pub export fn ecc_make_key(arg_prng: [*c]prng_state, arg_wprng: c_int, arg_keysize: c_int, arg_key: [*c]ecc_key) c_int {
    var prng = arg_prng;
    _ = &prng;
    var wprng = arg_wprng;
    _ = &wprng;
    var keysize = arg_keysize;
    _ = &keysize;
    var key = arg_key;
    _ = &key;
    var x: c_int = undefined;
    _ = &x;
    var err: c_int = undefined;
    _ = &err;
    {
        x = 0;
        while ((keysize > ltc_ecc_sets[@as(c_uint, @intCast(x))].size) and (ltc_ecc_sets[@as(c_uint, @intCast(x))].size != @as(c_int, 0))) : (x += 1) {}
    }
    keysize = ltc_ecc_sets[@as(c_uint, @intCast(x))].size;
    if ((keysize > @as(c_int, 66)) or (ltc_ecc_sets[@as(c_uint, @intCast(x))].size == @as(c_int, 0))) {
        return CRYPT_INVALID_KEYSIZE;
    }
    err = ecc_make_key_ex(prng, wprng, key, &ltc_ecc_sets[@as(c_uint, @intCast(x))]);
    key.*.idx = x;
    return err;
}
// ./libtomcrypt.c:23916:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:23886:5: warning: unable to translate function, demoted to extern
pub extern fn ecc_make_key_ex(arg_prng: [*c]prng_state, arg_wprng: c_int, arg_key: [*c]ecc_key, arg_dp: [*c]const ltc_ecc_set_type) c_int;
pub export fn ecc_free(arg_key: [*c]ecc_key) void {
    var key = arg_key;
    _ = &key;
    if (!(key != @as([*c]ecc_key, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("key != ((void*)0)")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 23588));
    }
    ltc_deinit_multi(key.*.pubkey.x, key.*.pubkey.y, key.*.pubkey.z, key.*.k, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
}
pub export fn ecc_export(arg_out: [*c]u8, arg_outlen: [*c]c_ulong, arg_type: c_int, arg_key: [*c]ecc_key) c_int {
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var @"type" = arg_type;
    _ = &@"type";
    var key = arg_key;
    _ = &key;
    var err: c_int = undefined;
    _ = &err;
    var flags: [1]u8 = undefined;
    _ = &flags;
    var key_size: c_ulong = undefined;
    _ = &key_size;
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 23515));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 23516));
    }
    if (!(key != @as([*c]ecc_key, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("key != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 23517));
    }
    if ((key.*.type != PK_PRIVATE) and (@"type" == PK_PRIVATE)) {
        return CRYPT_PK_TYPE_MISMATCH;
    }
    if (ltc_ecc_is_valid_idx(key.*.idx) == @as(c_int, 0)) {
        return CRYPT_INVALID_ARG;
    }
    key_size = @as(c_ulong, @bitCast(@as(c_long, key.*.dp.*.size)));
    if (@"type" == PK_PRIVATE) {
        flags[@as(c_uint, @intCast(@as(c_int, 0)))] = 1;
        err = der_encode_sequence_multi(out, outlen, LTC_ASN1_BIT_STRING, @as(c_ulong, 1), @as([*c]u8, @ptrCast(@alignCast(&flags))), LTC_ASN1_SHORT_INTEGER, @as(c_ulong, 1), &key_size, LTC_ASN1_INTEGER, @as(c_ulong, 1), key.*.pubkey.x, LTC_ASN1_INTEGER, @as(c_ulong, 1), key.*.pubkey.y, LTC_ASN1_INTEGER, @as(c_ulong, 1), key.*.k, LTC_ASN1_EOL, @as(c_ulong, 0), @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
    } else {
        flags[@as(c_uint, @intCast(@as(c_int, 0)))] = 0;
        err = der_encode_sequence_multi(out, outlen, LTC_ASN1_BIT_STRING, @as(c_ulong, 1), @as([*c]u8, @ptrCast(@alignCast(&flags))), LTC_ASN1_SHORT_INTEGER, @as(c_ulong, 1), &key_size, LTC_ASN1_INTEGER, @as(c_ulong, 1), key.*.pubkey.x, LTC_ASN1_INTEGER, @as(c_ulong, 1), key.*.pubkey.y, LTC_ASN1_EOL, @as(c_ulong, 0), @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
    }
    return err;
}
pub export fn ecc_import(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_key: [*c]ecc_key) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var key = arg_key;
    _ = &key;
    return ecc_import_ex(in, inlen, key, null);
}
// ./libtomcrypt.c:23775:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:23757:5: warning: unable to translate function, demoted to extern
pub extern fn ecc_import_ex(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_key: [*c]ecc_key, arg_dp: [*c]const ltc_ecc_set_type) c_int;
pub export fn ecc_ansi_x963_export(arg_key: [*c]ecc_key, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var key = arg_key;
    _ = &key;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var buf: [256]u8 = undefined;
    _ = &buf;
    var numlen: c_ulong = undefined;
    _ = &numlen;
    if (!(key != @as([*c]ecc_key, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("key != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 23051));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 23052));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 23053));
    }
    if (ltc_ecc_is_valid_idx(key.*.idx) == @as(c_int, 0)) {
        return CRYPT_INVALID_ARG;
    }
    numlen = @as(c_ulong, @bitCast(@as(c_long, key.*.dp.*.size)));
    if (outlen.* < (@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))) +% (@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2)))) *% numlen))) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))) +% (@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2)))) *% numlen);
        return CRYPT_BUFFER_OVERFLOW;
    }
    out[@as(c_uint, @intCast(@as(c_int, 0)))] = 4;
    zeromem(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&buf))))), @sizeOf([256]u8));
    _ = ltc_mp.unsigned_write.?(key.*.pubkey.x, @as([*c]u8, @ptrCast(@alignCast(&buf))) + (numlen -% ltc_mp.unsigned_size.?(key.*.pubkey.x)));
    _ = memcpy(@as(?*anyopaque, @ptrCast(out + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))))), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&buf))))), numlen);
    zeromem(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&buf))))), @sizeOf([256]u8));
    _ = ltc_mp.unsigned_write.?(key.*.pubkey.y, @as([*c]u8, @ptrCast(@alignCast(&buf))) + (numlen -% ltc_mp.unsigned_size.?(key.*.pubkey.y)));
    _ = memcpy(@as(?*anyopaque, @ptrCast((out + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1)))))) + numlen)), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&buf))))), numlen);
    outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))) +% (@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2)))) *% numlen);
    return CRYPT_OK;
}
pub export fn ecc_ansi_x963_import(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_key: [*c]ecc_key) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var key = arg_key;
    _ = &key;
    return ecc_ansi_x963_import_ex(in, inlen, key, null);
}
// ./libtomcrypt.c:23141:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:23122:5: warning: unable to translate function, demoted to extern
pub extern fn ecc_ansi_x963_import_ex(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_key: [*c]ecc_key, arg_dp: [*c]ltc_ecc_set_type) c_int;
// ./libtomcrypt.c:24052:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:24015:5: warning: unable to translate function, demoted to extern
pub extern fn ecc_shared_secret(arg_private_key: [*c]ecc_key, arg_public_key: [*c]ecc_key, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int;
// ./libtomcrypt.c:23431:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:23379:5: warning: unable to translate function, demoted to extern
pub extern fn ecc_encrypt_key(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong, arg_prng: [*c]prng_state, arg_wprng: c_int, arg_hash: c_int, arg_key: [*c]ecc_key) c_int;
// ./libtomcrypt.c:23281:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:23227:5: warning: unable to translate function, demoted to extern
pub extern fn ecc_decrypt_key(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong, arg_key: [*c]ecc_key) c_int;
// ./libtomcrypt.c:24150:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:24118:5: warning: unable to translate function, demoted to extern
pub extern fn ecc_sign_hash(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong, arg_prng: [*c]prng_state, arg_wprng: c_int, arg_key: [*c]ecc_key) c_int;
// ./libtomcrypt.c:24446:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:24414:5: warning: unable to translate function, demoted to extern
pub extern fn ecc_verify_hash(arg_sig: [*c]const u8, arg_siglen: c_ulong, arg_hash: [*c]const u8, arg_hashlen: c_ulong, arg_stat: [*c]c_int, arg_key: [*c]ecc_key) c_int;
pub export fn ltc_ecc_new_point() [*c]ecc_point {
    var p: [*c]ecc_point = undefined;
    _ = &p;
    p = @as([*c]ecc_point, @ptrCast(@alignCast(calloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))), @sizeOf(ecc_point)))));
    if (p == @as([*c]ecc_point, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        return null;
    }
    if (ltc_init_multi(&p.*.x, &p.*.y, &p.*.z, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))) != CRYPT_OK) {
        free(@as(?*anyopaque, @ptrCast(p)));
        return null;
    }
    return p;
}
pub export fn ltc_ecc_del_point(arg_p: [*c]ecc_point) void {
    var p = arg_p;
    _ = &p;
    if (p != @as([*c]ecc_point, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        ltc_deinit_multi(p.*.x, p.*.y, p.*.z, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
        free(@as(?*anyopaque, @ptrCast(p)));
    }
}
pub export fn ltc_ecc_is_valid_idx(arg_n: c_int) c_int {
    var n = arg_n;
    _ = &n;
    var x: c_int = undefined;
    _ = &x;
    {
        x = 0;
        while (ltc_ecc_sets[@as(c_uint, @intCast(x))].size != @as(c_int, 0)) : (x += 1) {}
    }
    if ((n >= -@as(c_int, 1)) and (n < x)) {
        return 1;
    }
    return 0;
}
// ./libtomcrypt.c:26226:13: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:26211:5: warning: unable to translate function, demoted to extern
pub extern fn ltc_ecc_projective_dbl_point(arg_P: [*c]ecc_point, arg_R_1: [*c]ecc_point, arg_modulus: ?*anyopaque, arg_mp: ?*anyopaque) c_int;
// ./libtomcrypt.c:25911:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:25895:5: warning: unable to translate function, demoted to extern
pub extern fn ltc_ecc_projective_add_point(arg_P: [*c]ecc_point, arg_Q: [*c]ecc_point, arg_R_1: [*c]ecc_point, arg_modulus: ?*anyopaque, arg_mp: ?*anyopaque) c_int;
// ./libtomcrypt.c:25416:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:25373:5: warning: unable to translate function, demoted to extern
pub extern fn ltc_ecc_mulmod(arg_k: ?*anyopaque, arg_G_1: [*c]ecc_point, arg_R_2: [*c]ecc_point, arg_modulus: ?*anyopaque, arg_map: c_int) c_int;
// ./libtomcrypt.c:25166:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:25129:5: warning: unable to translate function, demoted to extern
pub extern fn ltc_ecc_mul2add(arg_A_1: [*c]ecc_point, arg_kA: ?*anyopaque, arg_B: [*c]ecc_point, arg_kB: ?*anyopaque, arg_C: [*c]ecc_point, arg_modulus: ?*anyopaque) c_int;
// ./libtomcrypt.c:25042:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:25028:5: warning: unable to translate function, demoted to extern
pub extern fn ltc_ecc_map(arg_P: [*c]ecc_point, arg_modulus: ?*anyopaque, arg_mp: ?*anyopaque) c_int;
pub const curve25519_key = extern struct {
    type: enum_public_key_type = @import("std").mem.zeroes(enum_public_key_type),
    pka: enum_ltc_pka_id = @import("std").mem.zeroes(enum_ltc_pka_id),
    priv: [32]u8 = @import("std").mem.zeroes([32]u8),
    @"pub": [32]u8 = @import("std").mem.zeroes([32]u8),
};
pub export fn x25519_import_raw(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_which: c_int, arg_key: [*c]curve25519_key) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var which = arg_which;
    _ = &which;
    var key = arg_key;
    _ = &key;
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 35464));
    }
    if (!(inlen == @as(c_ulong, 32))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("inlen == 32uL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 35465));
    }
    if (!(key != @as([*c]curve25519_key, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("key != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 35466));
    }
    if (which == PK_PRIVATE) {
        _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&key.*.priv))))), @as(?*const anyopaque, @ptrCast(in)), @sizeOf([32]u8));
        _ = tweetnacl_crypto_scalarmult_base(@as([*c]u8, @ptrCast(@alignCast(&key.*.@"pub"))), @as([*c]u8, @ptrCast(@alignCast(&key.*.priv))));
    } else if (which == PK_PUBLIC) {
        _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&key.*.@"pub"))))), @as(?*const anyopaque, @ptrCast(in)), @sizeOf([32]u8));
    } else {
        return CRYPT_INVALID_ARG;
    }
    key.*.pka = @as(c_uint, @bitCast(LTC_PKA_X25519));
    key.*.type = @as(c_uint, @bitCast(which));
    return CRYPT_OK;
}
pub export fn x25519_shared_secret(arg_private_key: [*c]const curve25519_key, arg_public_key: [*c]const curve25519_key, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var private_key = arg_private_key;
    _ = &private_key;
    var public_key = arg_public_key;
    _ = &public_key;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    if (!(private_key != @as([*c]const curve25519_key, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("private_key != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 35503));
    }
    if (!(public_key != @as([*c]const curve25519_key, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("public_key != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 35504));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 35505));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 35506));
    }
    if (public_key.*.pka != @as(c_uint, @bitCast(LTC_PKA_X25519))) return CRYPT_PK_INVALID_TYPE;
    if (private_key.*.type != @as(c_uint, @bitCast(PK_PRIVATE))) return CRYPT_PK_INVALID_TYPE;
    if (outlen.* < @as(c_ulong, 32)) {
        outlen.* = 32;
        return CRYPT_BUFFER_OVERFLOW;
    }
    _ = tweetnacl_crypto_scalarmult(out, @as([*c]const u8, @ptrCast(@alignCast(&private_key.*.priv))), @as([*c]const u8, @ptrCast(@alignCast(&public_key.*.@"pub"))));
    outlen.* = 32;
    return CRYPT_OK;
}
pub const dsa_key = extern struct {
    type: c_int = @import("std").mem.zeroes(c_int),
    qord: c_int = @import("std").mem.zeroes(c_int),
    g: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    q: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    p: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    x: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    y: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub extern fn dsa_make_key(prng: [*c]prng_state, wprng: c_int, group_size: c_int, modulus_size: c_int, key: [*c]dsa_key) c_int;
pub extern fn dsa_free(key: [*c]dsa_key) void;
pub extern fn dsa_sign_hash_raw(in: [*c]const u8, inlen: c_ulong, r: ?*anyopaque, s: ?*anyopaque, prng: [*c]prng_state, wprng: c_int, key: [*c]dsa_key) c_int;
pub extern fn dsa_sign_hash(in: [*c]const u8, inlen: c_ulong, out: [*c]u8, outlen: [*c]c_ulong, prng: [*c]prng_state, wprng: c_int, key: [*c]dsa_key) c_int;
pub extern fn dsa_verify_hash_raw(r: ?*anyopaque, s: ?*anyopaque, hash: [*c]const u8, hashlen: c_ulong, stat: [*c]c_int, key: [*c]dsa_key) c_int;
pub extern fn dsa_verify_hash(sig: [*c]const u8, siglen: c_ulong, hash: [*c]const u8, hashlen: c_ulong, stat: [*c]c_int, key: [*c]dsa_key) c_int;
pub extern fn dsa_encrypt_key(in: [*c]const u8, inlen: c_ulong, out: [*c]u8, outlen: [*c]c_ulong, prng: [*c]prng_state, wprng: c_int, hash: c_int, key: [*c]dsa_key) c_int;
pub extern fn dsa_decrypt_key(in: [*c]const u8, inlen: c_ulong, out: [*c]u8, outlen: [*c]c_ulong, key: [*c]dsa_key) c_int;
pub extern fn dsa_import(in: [*c]const u8, inlen: c_ulong, key: [*c]dsa_key) c_int;
pub extern fn dsa_export(out: [*c]u8, outlen: [*c]c_ulong, @"type": c_int, key: [*c]dsa_key) c_int;
pub extern fn dsa_verify_key(key: [*c]dsa_key, stat: [*c]c_int) c_int;
pub extern fn dsa_shared_secret(private_key: ?*anyopaque, base: ?*anyopaque, public_key: [*c]dsa_key, out: [*c]u8, outlen: [*c]c_ulong) c_int;
pub const LTC_ASN1_EOL: c_int = 0;
pub const LTC_ASN1_BOOLEAN: c_int = 1;
pub const LTC_ASN1_INTEGER: c_int = 2;
pub const LTC_ASN1_SHORT_INTEGER: c_int = 3;
pub const LTC_ASN1_BIT_STRING: c_int = 4;
pub const LTC_ASN1_OCTET_STRING: c_int = 5;
pub const LTC_ASN1_NULL: c_int = 6;
pub const LTC_ASN1_OBJECT_IDENTIFIER: c_int = 7;
pub const LTC_ASN1_IA5_STRING: c_int = 8;
pub const LTC_ASN1_PRINTABLE_STRING: c_int = 9;
pub const LTC_ASN1_UTF8_STRING: c_int = 10;
pub const LTC_ASN1_UTCTIME: c_int = 11;
pub const LTC_ASN1_CHOICE: c_int = 12;
pub const LTC_ASN1_SEQUENCE: c_int = 13;
pub const LTC_ASN1_SET: c_int = 14;
pub const LTC_ASN1_SETOF: c_int = 15;
const enum_unnamed_50 = c_uint;
// ./libtomcrypt.c:20763:21: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:20739:5: warning: unable to translate function, demoted to extern
pub extern fn der_encode_sequence_ex(arg_list: [*c]ltc_asn1_list, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong, arg_type_of: c_int) c_int;
// ./libtomcrypt.c:18999:21: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:18929:5: warning: unable to translate function, demoted to extern
pub extern fn der_decode_sequence_ex(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_list: [*c]ltc_asn1_list, arg_outlen: c_ulong, arg_ordered: c_int) c_int;
// ./libtomcrypt.c:22495:21: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:22472:5: warning: unable to translate function, demoted to extern
pub extern fn der_length_sequence(arg_list: [*c]ltc_asn1_list, arg_inlen: c_ulong, arg_outlen: [*c]c_ulong) c_int;
pub export fn der_encode_set(arg_list: [*c]ltc_asn1_list, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var list = arg_list;
    _ = &list;
    var inlen = arg_inlen;
    _ = &inlen;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var copy_1: [*c]ltc_asn1_list = undefined;
    _ = &copy_1;
    var x: c_ulong = undefined;
    _ = &x;
    var err: c_int = undefined;
    _ = &err;
    copy_1 = @as([*c]ltc_asn1_list, @ptrCast(@alignCast(calloc(inlen, @sizeOf(ltc_asn1_list)))));
    if (copy_1 == @as([*c]ltc_asn1_list, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        return CRYPT_MEM;
    }
    {
        x = 0;
        while (x < inlen) : (x +%= 1) {
            copy_1[x] = list[x];
            copy_1[x].used = @as(c_int, @bitCast(@as(c_uint, @truncate(x))));
        }
    }
    qsort(@as(?*anyopaque, @ptrCast(copy_1)), inlen, @sizeOf(ltc_asn1_list), &qsort_helper_set);
    err = der_encode_sequence_ex(copy_1, inlen, out, outlen, LTC_ASN1_SET);
    free(@as(?*anyopaque, @ptrCast(copy_1)));
    return err;
}
pub const struct_edge = extern struct {
    start: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    size: c_ulong = @import("std").mem.zeroes(c_ulong),
};
pub export fn der_encode_setof(arg_list: [*c]ltc_asn1_list, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var list = arg_list;
    _ = &list;
    var inlen = arg_inlen;
    _ = &inlen;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    var z: c_ulong = undefined;
    _ = &z;
    var hdrlen: c_ulong = undefined;
    _ = &hdrlen;
    var err: c_int = undefined;
    _ = &err;
    var edges: [*c]struct_edge = undefined;
    _ = &edges;
    var ptr: [*c]u8 = undefined;
    _ = &ptr;
    var buf: [*c]u8 = undefined;
    _ = &buf;
    {
        x = 1;
        while (x < inlen) : (x +%= 1) {
            if (list[x].type != list[x -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))].type) {
                return CRYPT_INVALID_ARG;
            }
        }
    }
    buf = @as([*c]u8, @ptrCast(@alignCast(calloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))), outlen.*))));
    if (buf == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        return CRYPT_MEM;
    }
    if ((blk: {
        const tmp = der_encode_sequence_ex(list, inlen, buf, outlen, LTC_ASN1_SETOF);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        free(@as(?*anyopaque, @ptrCast(buf)));
        return err;
    }
    edges = @as([*c]struct_edge, @ptrCast(@alignCast(calloc(inlen, @sizeOf(struct_edge)))));
    if (edges == @as([*c]struct_edge, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        free(@as(?*anyopaque, @ptrCast(buf)));
        return CRYPT_MEM;
    }
    ptr = buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1)))));
    x = @as(c_ulong, @bitCast(@as(c_ulong, (blk: {
        const ref = &ptr;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }).*)));
    if (x >= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
        ptr += x & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 127))));
    }
    hdrlen = @as(c_ulong, @intCast(@intFromPtr(ptr))) -% @as(c_ulong, @intCast(@intFromPtr(buf)));
    x = 0;
    while (ptr < (buf + outlen.*)) {
        edges[x].start = ptr;
        z = 1;
        y = @as(c_ulong, @bitCast(@as(c_ulong, ptr[blk: {
            const ref = &z;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }])));
        if (y < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
            edges[x].size = y;
        } else {
            y &= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 127))));
            edges[x].size = 0;
            while ((blk: {
                const ref = &y;
                const tmp = ref.*;
                ref.* -%= 1;
                break :blk tmp;
            }) != 0) {
                edges[x].size = (edges[x].size << @intCast(8)) | @as(c_ulong, @bitCast(@as(c_ulong, ptr[blk: {
                    const ref = &z;
                    const tmp = ref.*;
                    ref.* +%= 1;
                    break :blk tmp;
                }])));
            }
        }
        edges[x].size +%= z;
        ptr += edges[x].size;
        x +%= 1;
    }
    qsort(@as(?*anyopaque, @ptrCast(edges)), inlen, @sizeOf(struct_edge), &qsort_helper);
    _ = memcpy(@as(?*anyopaque, @ptrCast(out)), @as(?*const anyopaque, @ptrCast(buf)), hdrlen);
    {
        _ = blk: {
            y = hdrlen;
            break :blk blk_1: {
                const tmp = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))));
                x = tmp;
                break :blk_1 tmp;
            };
        };
        while (x < inlen) : (x +%= 1) {
            _ = memcpy(@as(?*anyopaque, @ptrCast(out + y)), @as(?*const anyopaque, @ptrCast(edges[x].start)), edges[x].size);
            y +%= edges[x].size;
        }
    }
    free(@as(?*anyopaque, @ptrCast(edges)));
    free(@as(?*anyopaque, @ptrCast(buf)));
    return CRYPT_OK;
}
// ./libtomcrypt.c:21072:5: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn der_encode_sequence_multi(out: [*c]u8, outlen: [*c]c_ulong, ...) c_int;
// ./libtomcrypt.c:19632:5: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn der_decode_sequence_multi(in: [*c]const u8, inlen: c_ulong, ...) c_int;
// ./libtomcrypt.c:19298:13: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:19277:5: warning: unable to translate function, demoted to extern
pub extern fn der_decode_sequence_flexi(arg_in: [*c]const u8, arg_inlen: [*c]c_ulong, arg_out: [*c][*c]ltc_asn1_list) c_int;
pub extern fn der_free_sequence_flexi(list: [*c]ltc_asn1_list) void;
pub export fn der_sequence_free(arg_in: [*c]ltc_asn1_list) void {
    var in = arg_in;
    _ = &in;
    var l: [*c]ltc_asn1_list = undefined;
    _ = &l;
    while ((in.*.prev != @as([*c]struct_ltc_asn1_list_, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) or (in.*.parent != @as([*c]struct_ltc_asn1_list_, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        if (in.*.parent != @as([*c]struct_ltc_asn1_list_, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
            in = in.*.parent;
        } else {
            in = in.*.prev;
        }
    }
    while (in != @as([*c]ltc_asn1_list, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        if (in.*.child != null) {
            in.*.child.*.parent = null;
            der_sequence_free(in.*.child);
        }
        while (true) {
            switch (in.*.type) {
                @as(c_int, 14), @as(c_int, 15), @as(c_int, 13) => break,
                @as(c_int, 2) => {
                    if (in.*.data != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))) {
                        ltc_mp.deinit.?(in.*.data);
                    }
                    break;
                },
                else => {
                    if (in.*.data != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))) {
                        free(in.*.data);
                    }
                },
            }
            break;
        }
        l = in.*.next;
        free(@as(?*anyopaque, @ptrCast(in)));
        in = l;
    }
}
pub export fn der_length_boolean(arg_outlen: [*c]c_ulong) c_int {
    var outlen = arg_outlen;
    _ = &outlen;
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 21850));
    }
    outlen.* = 3;
    return CRYPT_OK;
}
pub export fn der_encode_boolean(arg_in: c_int, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var in = arg_in;
    _ = &in;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20186));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20187));
    }
    if (outlen.* < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3))))) {
        outlen.* = 3;
        return CRYPT_BUFFER_OVERFLOW;
    }
    outlen.* = 3;
    out[@as(c_uint, @intCast(@as(c_int, 0)))] = 1;
    out[@as(c_uint, @intCast(@as(c_int, 1)))] = 1;
    out[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(i8, @truncate(if (in != 0) @as(c_int, 255) else @as(c_int, 0)))));
    return CRYPT_OK;
}
pub export fn der_decode_boolean(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]c_int) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var out = arg_out;
    _ = &out;
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18207));
    }
    if (!(out != @as([*c]c_int, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18208));
    }
    if ((((inlen != @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3))))) or (@as(c_int, @bitCast(@as(c_uint, in[@as(c_uint, @intCast(@as(c_int, 0)))]))) != @as(c_int, 1))) or (@as(c_int, @bitCast(@as(c_uint, in[@as(c_uint, @intCast(@as(c_int, 1)))]))) != @as(c_int, 1))) or ((@as(c_int, @bitCast(@as(c_uint, in[@as(c_uint, @intCast(@as(c_int, 2)))]))) != @as(c_int, 0)) and (@as(c_int, @bitCast(@as(c_uint, in[@as(c_uint, @intCast(@as(c_int, 2)))]))) != @as(c_int, 255)))) {
        return CRYPT_INVALID_ARG;
    }
    out.* = if (@as(c_int, @bitCast(@as(c_uint, in[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 255)) @as(c_int, 1) else @as(c_int, 0);
    return CRYPT_OK;
}
pub export fn der_encode_integer(arg_num: ?*anyopaque, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var num = arg_num;
    _ = &num;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var tmplen: c_ulong = undefined;
    _ = &tmplen;
    var y: c_ulong = undefined;
    _ = &y;
    var err: c_int = undefined;
    _ = &err;
    var leading_zero: c_int = undefined;
    _ = &leading_zero;
    if (!(num != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("num != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20326));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20327));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20328));
    }
    if ((blk: {
        const tmp = der_length_integer(num, &tmplen);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if (outlen.* < tmplen) {
        outlen.* = tmplen;
        return CRYPT_BUFFER_OVERFLOW;
    }
    if (ltc_mp.compare_d.?(num, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) != -@as(c_int, 1)) {
        if (((ltc_mp.count_bits.?(num) & @as(c_int, 7)) == @as(c_int, 0)) or ((if (ltc_mp.compare_d.?(num, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) == @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0)) == @as(c_int, 1))) {
            leading_zero = 1;
        } else {
            leading_zero = 0;
        }
        y = ltc_mp.unsigned_size.?(num) +% @as(c_ulong, @bitCast(@as(c_long, leading_zero)));
    } else {
        leading_zero = 0;
        y = @as(c_ulong, @bitCast(@as(c_long, ltc_mp.count_bits.?(num))));
        y = y +% (@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))) -% (y & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7))))));
        y = y >> @intCast(3);
        if (((ltc_mp.count_lsb_bits.?(num) + @as(c_int, 1)) == ltc_mp.count_bits.?(num)) and ((ltc_mp.count_bits.?(num) & @as(c_int, 7)) == @as(c_int, 0))) {
            y -%= 1;
        }
    }
    (blk: {
        const ref = &out;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }).* = 2;
    if (y < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
        (blk: {
            const ref = &out;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = @as(u8, @bitCast(@as(u8, @truncate(y))));
    } else if (y < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 256))))) {
        (blk: {
            const ref = &out;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = 129;
        (blk: {
            const ref = &out;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = @as(u8, @bitCast(@as(u8, @truncate(y))));
    } else if (y < @as(c_ulong, 65536)) {
        (blk: {
            const ref = &out;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = 130;
        (blk: {
            const ref = &out;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = @as(u8, @bitCast(@as(u8, @truncate((y >> @intCast(8)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
        (blk: {
            const ref = &out;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = @as(u8, @bitCast(@as(u8, @truncate(y))));
    } else if (y < @as(c_ulong, 16777216)) {
        (blk: {
            const ref = &out;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = 131;
        (blk: {
            const ref = &out;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = @as(u8, @bitCast(@as(u8, @truncate((y >> @intCast(16)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
        (blk: {
            const ref = &out;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = @as(u8, @bitCast(@as(u8, @truncate((y >> @intCast(8)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
        (blk: {
            const ref = &out;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = @as(u8, @bitCast(@as(u8, @truncate(y))));
    } else {
        return CRYPT_INVALID_ARG;
    }
    if (leading_zero != 0) {
        (blk: {
            const ref = &out;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = 0;
    }
    if (ltc_mp.compare_d.?(num, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) == @as(c_int, 1)) {
        if ((blk: {
            const tmp = ltc_mp.unsigned_write.?(num, out);
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            return err;
        }
    } else if ((if (ltc_mp.compare_d.?(num, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) == @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0)) != @as(c_int, 1)) {
        var tmp: ?*anyopaque = undefined;
        _ = &tmp;
        if (ltc_mp.init.?(&tmp) != CRYPT_OK) {
            return CRYPT_MEM;
        }
        y = @as(c_ulong, @bitCast(@as(c_long, ltc_mp.count_bits.?(num))));
        y = y +% (@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))) -% (y & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7))))));
        if (((ltc_mp.count_lsb_bits.?(num) + @as(c_int, 1)) == ltc_mp.count_bits.?(num)) and ((ltc_mp.count_bits.?(num) & @as(c_int, 7)) == @as(c_int, 0))) {
            y -%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))));
        }
        if ((ltc_mp.twoexpt.?(tmp, @as(c_int, @bitCast(@as(c_uint, @truncate(y))))) != CRYPT_OK) or (ltc_mp.add.?(tmp, num, tmp) != CRYPT_OK)) {
            ltc_mp.deinit.?(tmp);
            return CRYPT_MEM;
        }
        if ((blk: {
            const tmp_1 = ltc_mp.unsigned_write.?(tmp, out);
            err = tmp_1;
            break :blk tmp_1;
        }) != CRYPT_OK) {
            ltc_mp.deinit.?(tmp);
            return err;
        }
        ltc_mp.deinit.?(tmp);
    }
    outlen.* = tmplen;
    return CRYPT_OK;
}
pub export fn der_decode_integer(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_num: ?*anyopaque) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var num = arg_num;
    _ = &num;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    var z: c_ulong = undefined;
    _ = &z;
    var err: c_int = undefined;
    _ = &err;
    if (!(num != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("num != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18534));
    }
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18535));
    }
    if (inlen < @as(c_ulong, @bitCast(@as(c_long, (@as(c_int, 1) + @as(c_int, 1)) + @as(c_int, 1))))) {
        return CRYPT_INVALID_PACKET;
    }
    x = 0;
    if ((@as(c_int, @bitCast(@as(c_uint, in[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }]))) & @as(c_int, 31)) != @as(c_int, 2)) {
        return CRYPT_INVALID_PACKET;
    }
    z = @as(c_ulong, @bitCast(@as(c_ulong, in[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }])));
    if ((z & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) {
        if ((x +% z) > inlen) {
            return CRYPT_INVALID_PACKET;
        }
        if ((blk: {
            const tmp = ltc_mp.unsigned_read.?(num, @as([*c]u8, @ptrCast(@volatileCast(@constCast(in)))) + x, z);
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            return err;
        }
    } else {
        z &= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 127))));
        if ((((x +% z) > inlen) or (z > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4)))))) or (z == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0)))))) {
            return CRYPT_INVALID_PACKET;
        }
        y = 0;
        while ((blk: {
            const ref = &z;
            const tmp = ref.*;
            ref.* -%= 1;
            break :blk tmp;
        }) != 0) {
            y = @as(c_ulong, @bitCast(@as(c_ulong, in[blk: {
                const ref = &x;
                const tmp = ref.*;
                ref.* +%= 1;
                break :blk tmp;
            }]))) | (y << @intCast(8));
        }
        if ((x +% y) > inlen) {
            return CRYPT_INVALID_PACKET;
        }
        if ((blk: {
            const tmp = ltc_mp.unsigned_read.?(num, @as([*c]u8, @ptrCast(@volatileCast(@constCast(in)))) + x, y);
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            return err;
        }
    }
    if ((@as(c_int, @bitCast(@as(c_uint, in[x]))) & @as(c_int, 128)) != 0) {
        var tmp: ?*anyopaque = undefined;
        _ = &tmp;
        if (ltc_mp.init.?(&tmp) != CRYPT_OK) {
            return CRYPT_MEM;
        }
        if ((ltc_mp.twoexpt.?(tmp, ltc_mp.count_bits.?(num)) != CRYPT_OK) or (ltc_mp.sub.?(num, tmp, num) != CRYPT_OK)) {
            ltc_mp.deinit.?(tmp);
            return CRYPT_MEM;
        }
        ltc_mp.deinit.?(tmp);
    }
    return CRYPT_OK;
}
pub export fn der_length_integer(arg_num: ?*anyopaque, arg_outlen: [*c]c_ulong) c_int {
    var num = arg_num;
    _ = &num;
    var outlen = arg_outlen;
    _ = &outlen;
    var z: c_ulong = undefined;
    _ = &z;
    var len: c_ulong = undefined;
    _ = &len;
    var leading_zero: c_int = undefined;
    _ = &leading_zero;
    if (!(num != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("num != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 22085));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 22086));
    }
    if (ltc_mp.compare_d.?(num, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) != -@as(c_int, 1)) {
        if (((ltc_mp.count_bits.?(num) & @as(c_int, 7)) == @as(c_int, 0)) or ((if (ltc_mp.compare_d.?(num, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) == @as(c_int, 0)) @as(c_int, 1) else @as(c_int, 0)) == @as(c_int, 1))) {
            leading_zero = 1;
        } else {
            leading_zero = 0;
        }
        z = blk: {
            const tmp = @as(c_ulong, @bitCast(@as(c_long, leading_zero))) +% ltc_mp.unsigned_size.?(num);
            len = tmp;
            break :blk tmp;
        };
    } else {
        leading_zero = 0;
        z = @as(c_ulong, @bitCast(@as(c_long, ltc_mp.count_bits.?(num))));
        z = z +% (@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))) -% (z & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7))))));
        if (((ltc_mp.count_lsb_bits.?(num) + @as(c_int, 1)) == ltc_mp.count_bits.?(num)) and ((ltc_mp.count_bits.?(num) & @as(c_int, 7)) == @as(c_int, 0))) {
            z -%= 1;
        }
        len = blk: {
            const tmp = z >> @intCast(3);
            z = tmp;
            break :blk tmp;
        };
    }
    if (z < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
        len +%= 1;
    } else {
        len +%= 1;
        while (z != 0) {
            len +%= 1;
            z >>= @intCast(@as(c_int, 8));
        }
    }
    len +%= 1;
    outlen.* = len;
    return CRYPT_OK;
}
pub export fn der_decode_short_integer(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_num: [*c]c_ulong) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var num = arg_num;
    _ = &num;
    var len: c_ulong = undefined;
    _ = &len;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    if (!(num != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("num != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 19773));
    }
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 19774));
    }
    if (inlen < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))) {
        return CRYPT_INVALID_PACKET;
    }
    x = 0;
    if ((@as(c_int, @bitCast(@as(c_uint, in[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }]))) & @as(c_int, 31)) != @as(c_int, 2)) {
        return CRYPT_INVALID_PACKET;
    }
    len = @as(c_ulong, @bitCast(@as(c_ulong, in[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }])));
    if ((x +% len) > inlen) {
        return CRYPT_INVALID_PACKET;
    }
    y = 0;
    while ((blk: {
        const ref = &len;
        const tmp = ref.*;
        ref.* -%= 1;
        break :blk tmp;
    }) != 0) {
        y = (y << @intCast(8)) | @as(c_ulong, @bitCast(@as(c_ulong, in[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }])));
    }
    num.* = y;
    return CRYPT_OK;
}
pub export fn der_encode_short_integer(arg_num: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var num = arg_num;
    _ = &num;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var len: c_ulong = undefined;
    _ = &len;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    var z: c_ulong = undefined;
    _ = &z;
    var err: c_int = undefined;
    _ = &err;
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 21498));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 21499));
    }
    num &= @as(c_ulong, 4294967295);
    if ((blk: {
        const tmp = der_length_short_integer(num, &len);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if (outlen.* < len) {
        outlen.* = len;
        return CRYPT_BUFFER_OVERFLOW;
    }
    z = 0;
    y = num;
    while (y != 0) {
        z +%= 1;
        y >>= @intCast(@as(c_int, 8));
    }
    if (z == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) {
        z = 1;
    }
    z +%= @as(c_ulong, @bitCast(@as(c_long, if ((num & (@as(c_ulong, 1) << @intCast((z << @intCast(3)) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))))) != 0) @as(c_int, 1) else @as(c_int, 0))));
    {
        x = 0;
        while ((z <= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4))))) and (x < (@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4)))) -% z))) : (x +%= 1) {
            num <<= @intCast(@as(c_int, 8));
        }
    }
    x = 0;
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = 2;
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = @as(u8, @bitCast(@as(u8, @truncate(z))));
    if (z == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 5))))) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = 0;
        z -%= 1;
    }
    {
        y = 0;
        while (y < z) : (y +%= 1) {
            out[blk: {
                const ref = &x;
                const tmp = ref.*;
                ref.* +%= 1;
                break :blk tmp;
            }] = @as(u8, @bitCast(@as(u8, @truncate((num >> @intCast(24)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
            num <<= @intCast(@as(c_int, 8));
        }
    }
    outlen.* = x;
    return CRYPT_OK;
}
pub export fn der_length_short_integer(arg_num: c_ulong, arg_outlen: [*c]c_ulong) c_int {
    var num = arg_num;
    _ = &num;
    var outlen = arg_outlen;
    _ = &outlen;
    var z: c_ulong = undefined;
    _ = &z;
    var y: c_ulong = undefined;
    _ = &y;
    var len: c_ulong = undefined;
    _ = &len;
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 22644));
    }
    num &= @as(c_ulong, 4294967295);
    z = 0;
    y = num;
    while (y != 0) {
        z +%= 1;
        y >>= @intCast(@as(c_int, 8));
    }
    if (z == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) {
        z = 1;
    }
    len = 1;
    len +%= 1;
    len +%= z;
    len +%= @as(c_ulong, @bitCast(@as(c_long, if ((num & (@as(c_ulong, 1) << @intCast((z << @intCast(3)) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))))) != 0) @as(c_int, 1) else @as(c_int, 0))));
    outlen.* = len;
    return CRYPT_OK;
}
pub export fn der_encode_bit_string(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var len: c_ulong = undefined;
    _ = &len;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    var buf: u8 = undefined;
    _ = &buf;
    var err: c_int = undefined;
    _ = &err;
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20102));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20103));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20104));
    }
    if ((blk: {
        const tmp = der_length_bit_string(inlen, &len);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if (len > outlen.*) {
        outlen.* = len;
        return CRYPT_BUFFER_OVERFLOW;
    }
    x = 0;
    y = ((inlen >> @intCast(3)) +% @as(c_ulong, @bitCast(@as(c_long, if ((inlen & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7))))) != 0) @as(c_int, 1) else @as(c_int, 0))))) +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))));
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = 3;
    if (y < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(y))));
    } else if (y < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 256))))) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = 129;
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(y))));
    } else if (y < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 65536))))) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = 130;
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate((y >> @intCast(8)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(y & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
    }
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = @as(u8, @bitCast(@as(u8, @truncate((@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))) -% inlen) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7))))))));
    {
        y = @as(c_ulong, @bitCast(@as(c_ulong, blk: {
            const tmp = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0)))));
            buf = tmp;
            break :blk tmp;
        })));
        while (y < inlen) : (y +%= 1) {
            buf |= @as(u8, @bitCast(@as(i8, @truncate((if (@as(c_int, @bitCast(@as(c_uint, in[y]))) != 0) @as(c_int, 1) else @as(c_int, 0)) << @intCast(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7)))) -% (y & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7))))))))));
            if ((y & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7))))) == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7))))) {
                out[blk: {
                    const ref = &x;
                    const tmp = ref.*;
                    ref.* +%= 1;
                    break :blk tmp;
                }] = buf;
                buf = 0;
            }
        }
    }
    if ((inlen & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7))))) != 0) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = buf;
    }
    outlen.* = x;
    return CRYPT_OK;
}
pub export fn der_decode_bit_string(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var dlen: c_ulong = undefined;
    _ = &dlen;
    var blen: c_ulong = undefined;
    _ = &blen;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18108));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18109));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18110));
    }
    if (inlen < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4))))) {
        return CRYPT_INVALID_ARG;
    }
    if ((@as(c_int, @bitCast(@as(c_uint, in[@as(c_uint, @intCast(@as(c_int, 0)))]))) & @as(c_int, 31)) != @as(c_int, 3)) {
        return CRYPT_INVALID_PACKET;
    }
    x = 1;
    if ((@as(c_int, @bitCast(@as(c_uint, in[x]))) & @as(c_int, 128)) != 0) {
        y = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, in[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }]))) & @as(c_int, 127))));
        if ((y == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) or (y > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2)))))) {
            return CRYPT_INVALID_PACKET;
        }
        dlen = 0;
        while ((blk: {
            const ref = &y;
            const tmp = ref.*;
            ref.* -%= 1;
            break :blk tmp;
        }) != 0) {
            dlen = (dlen << @intCast(8)) | @as(c_ulong, @bitCast(@as(c_ulong, in[blk: {
                const ref = &x;
                const tmp = ref.*;
                ref.* +%= 1;
                break :blk tmp;
            }])));
        }
    } else {
        dlen = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, in[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }]))) & @as(c_int, 127))));
    }
    if ((dlen == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) or ((dlen +% x) > inlen)) {
        return CRYPT_INVALID_PACKET;
    }
    blen = ((dlen -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))) << @intCast(3)) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, in[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }]))) & @as(c_int, 7))));
    if (blen > outlen.*) {
        outlen.* = blen;
        return CRYPT_BUFFER_OVERFLOW;
    }
    {
        y = 0;
        while (y < blen) : (y +%= 1) {
            out[y] = @as(u8, @bitCast(@as(i8, @truncate(if ((@as(c_int, @bitCast(@as(c_uint, in[x]))) & (@as(c_int, 1) << @intCast(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7)))) -% (y & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7)))))))) != 0) @as(c_int, 1) else @as(c_int, 0)))));
            if ((y & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7))))) == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7))))) {
                x +%= 1;
            }
        }
    }
    outlen.* = blen;
    return CRYPT_OK;
}
pub export fn der_length_bit_string(arg_nbits: c_ulong, arg_outlen: [*c]c_ulong) c_int {
    var nbits = arg_nbits;
    _ = &nbits;
    var outlen = arg_outlen;
    _ = &outlen;
    var nbytes: c_ulong = undefined;
    _ = &nbytes;
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 21797));
    }
    nbytes = ((nbits >> @intCast(3)) +% @as(c_ulong, @bitCast(@as(c_long, if ((nbits & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7))))) != 0) @as(c_int, 1) else @as(c_int, 0))))) +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))));
    if (nbytes < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2)))) +% nbytes;
    } else if (nbytes < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 256))))) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3)))) +% nbytes;
    } else if (nbytes < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 65536))))) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4)))) +% nbytes;
    } else {
        return CRYPT_INVALID_ARG;
    }
    return CRYPT_OK;
}
pub export fn der_encode_octet_string(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    var len: c_ulong = undefined;
    _ = &len;
    var err: c_int = undefined;
    _ = &err;
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20571));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20572));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20573));
    }
    if ((blk: {
        const tmp = der_length_octet_string(inlen, &len);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if (len > outlen.*) {
        outlen.* = len;
        return CRYPT_BUFFER_OVERFLOW;
    }
    x = 0;
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = 4;
    if (inlen < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(inlen))));
    } else if (inlen < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 256))))) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = 129;
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(inlen))));
    } else if (inlen < @as(c_ulong, 65536)) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = 130;
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate((inlen >> @intCast(8)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(inlen & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
    } else if (inlen < @as(c_ulong, 16777216)) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = 131;
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate((inlen >> @intCast(16)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate((inlen >> @intCast(8)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(inlen & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
    } else {
        return CRYPT_INVALID_ARG;
    }
    {
        y = 0;
        while (y < inlen) : (y +%= 1) {
            out[blk: {
                const ref = &x;
                const tmp = ref.*;
                ref.* +%= 1;
                break :blk tmp;
            }] = in[y];
        }
    }
    outlen.* = x;
    return CRYPT_OK;
}
pub export fn der_decode_octet_string(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    var len: c_ulong = undefined;
    _ = &len;
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18744));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18745));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18746));
    }
    if (inlen < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))) {
        return CRYPT_INVALID_PACKET;
    }
    if ((@as(c_int, @bitCast(@as(c_uint, in[@as(c_uint, @intCast(@as(c_int, 0)))]))) & @as(c_int, 31)) != @as(c_int, 4)) {
        return CRYPT_INVALID_PACKET;
    }
    x = 1;
    if ((@as(c_int, @bitCast(@as(c_uint, in[x]))) & @as(c_int, 128)) != 0) {
        y = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, in[x]))) & @as(c_int, 127))));
        if (((y == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) or (y > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3)))))) or ((x +% y) > inlen)) {
            return CRYPT_INVALID_PACKET;
        }
        len = 0;
        x +%= 1;
        while ((blk: {
            const ref = &y;
            const tmp = ref.*;
            ref.* -%= 1;
            break :blk tmp;
        }) != 0) {
            len = (len << @intCast(8)) | @as(c_ulong, @bitCast(@as(c_ulong, in[blk: {
                const ref = &x;
                const tmp = ref.*;
                ref.* +%= 1;
                break :blk tmp;
            }])));
        }
    } else {
        len = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, in[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }]))) & @as(c_int, 127))));
    }
    if (len > outlen.*) {
        outlen.* = len;
        return CRYPT_BUFFER_OVERFLOW;
    }
    if ((len +% x) > inlen) {
        return CRYPT_INVALID_PACKET;
    }
    {
        y = 0;
        while (y < len) : (y +%= 1) {
            out[y] = in[blk: {
                const ref = &x;
                const tmp = ref.*;
                ref.* +%= 1;
                break :blk tmp;
            }];
        }
    }
    outlen.* = y;
    return CRYPT_OK;
}
pub export fn der_length_octet_string(arg_noctets: c_ulong, arg_outlen: [*c]c_ulong) c_int {
    var noctets = arg_noctets;
    _ = &noctets;
    var outlen = arg_outlen;
    _ = &outlen;
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 22252));
    }
    if (noctets < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2)))) +% noctets;
    } else if (noctets < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 256))))) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3)))) +% noctets;
    } else if (noctets < @as(c_ulong, 65536)) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4)))) +% noctets;
    } else if (noctets < @as(c_ulong, 16777216)) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 5)))) +% noctets;
    } else {
        return CRYPT_INVALID_ARG;
    }
    return CRYPT_OK;
}
pub export fn der_encode_object_identifier(arg_words: [*c]c_ulong, arg_nwords: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var words = arg_words;
    _ = &words;
    var nwords = arg_nwords;
    _ = &nwords;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var i: c_ulong = undefined;
    _ = &i;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    var z: c_ulong = undefined;
    _ = &z;
    var t: c_ulong = undefined;
    _ = &t;
    var mask: c_ulong = undefined;
    _ = &mask;
    var wordbuf: c_ulong = undefined;
    _ = &wordbuf;
    var err: c_int = undefined;
    _ = &err;
    if (!(words != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("words != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20456));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20457));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20458));
    }
    if ((blk: {
        const tmp = der_length_object_identifier(words, nwords, &x);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if (x > outlen.*) {
        outlen.* = x;
        return CRYPT_BUFFER_OVERFLOW;
    }
    z = 0;
    wordbuf = (words[@as(c_uint, @intCast(@as(c_int, 0)))] *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 40))))) +% words[@as(c_uint, @intCast(@as(c_int, 1)))];
    {
        y = 1;
        while (y < nwords) : (y +%= 1) {
            t = der_object_identifier_bits(wordbuf);
            z +%= ((t / @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7))))) +% @as(c_ulong, @bitCast(@as(c_long, if ((t % @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7))))) != 0) @as(c_int, 1) else @as(c_int, 0))))) +% @as(c_ulong, @bitCast(@as(c_long, if (wordbuf == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) @as(c_int, 1) else @as(c_int, 0))));
            if (y < (nwords -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))))) {
                wordbuf = words[y +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))];
            }
        }
    }
    x = 0;
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = 6;
    if (z < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(z))));
    } else if (z < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 256))))) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = 129;
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(z))));
    } else if (z < @as(c_ulong, 65536)) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = 130;
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate((z >> @intCast(8)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(z & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
    } else {
        return CRYPT_INVALID_ARG;
    }
    wordbuf = (words[@as(c_uint, @intCast(@as(c_int, 0)))] *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 40))))) +% words[@as(c_uint, @intCast(@as(c_int, 1)))];
    {
        i = 1;
        while (i < nwords) : (i +%= 1) {
            t = wordbuf & @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, 4294967295))));
            if (t != 0) {
                y = x;
                mask = 0;
                while (t != 0) {
                    out[blk: {
                        const ref = &x;
                        const tmp = ref.*;
                        ref.* +%= 1;
                        break :blk tmp;
                    }] = @as(u8, @bitCast(@as(u8, @truncate((t & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 127))))) | mask))));
                    t >>= @intCast(@as(c_int, 7));
                    mask |= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))));
                }
                z = x -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))));
                while (y < z) {
                    t = @as(c_ulong, @bitCast(@as(c_ulong, out[y])));
                    out[y] = out[z];
                    out[z] = @as(u8, @bitCast(@as(u8, @truncate(t))));
                    y +%= 1;
                    z -%= 1;
                }
            } else {
                out[blk: {
                    const ref = &x;
                    const tmp = ref.*;
                    ref.* +%= 1;
                    break :blk tmp;
                }] = 0;
            }
            if (i < (nwords -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))))) {
                wordbuf = words[i +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))];
            }
        }
    }
    outlen.* = x;
    return CRYPT_OK;
}
pub export fn der_decode_object_identifier(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_words: [*c]c_ulong, arg_outlen: [*c]c_ulong) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var words = arg_words;
    _ = &words;
    var outlen = arg_outlen;
    _ = &outlen;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    var t: c_ulong = undefined;
    _ = &t;
    var len: c_ulong = undefined;
    _ = &len;
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18643));
    }
    if (!(words != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("words != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18644));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18645));
    }
    if (inlen < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3))))) {
        return CRYPT_INVALID_PACKET;
    }
    if (outlen.* < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))) {
        return CRYPT_BUFFER_OVERFLOW;
    }
    x = 0;
    if ((@as(c_int, @bitCast(@as(c_uint, in[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }]))) & @as(c_int, 31)) != @as(c_int, 6)) {
        return CRYPT_INVALID_PACKET;
    }
    if (@as(c_int, @bitCast(@as(c_uint, in[x]))) < @as(c_int, 128)) {
        len = @as(c_ulong, @bitCast(@as(c_ulong, in[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }])));
    } else {
        if ((@as(c_int, @bitCast(@as(c_uint, in[x]))) < @as(c_int, 129)) or (@as(c_int, @bitCast(@as(c_uint, in[x]))) > @as(c_int, 130))) {
            return CRYPT_INVALID_PACKET;
        }
        y = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, in[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }]))) & @as(c_int, 127))));
        len = 0;
        while ((blk: {
            const ref = &y;
            const tmp = ref.*;
            ref.* -%= 1;
            break :blk tmp;
        }) != 0) {
            len = (len << @intCast(8)) | @as(c_ulong, @bitCast(@as(c_ulong, in[blk: {
                const ref = &x;
                const tmp = ref.*;
                ref.* +%= 1;
                break :blk tmp;
            }])));
        }
    }
    if ((len < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))) or ((len +% x) > inlen)) {
        return CRYPT_INVALID_PACKET;
    }
    y = 0;
    t = 0;
    while ((blk: {
        const ref = &len;
        const tmp = ref.*;
        ref.* -%= 1;
        break :blk tmp;
    }) != 0) {
        t = (t << @intCast(7)) | @as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, in[x]))) & @as(c_int, 127))));
        if (!((@as(c_int, @bitCast(@as(c_uint, in[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }]))) & @as(c_int, 128)) != 0)) {
            if (y >= outlen.*) {
                return CRYPT_BUFFER_OVERFLOW;
            }
            if (y == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) {
                words[@as(c_uint, @intCast(@as(c_int, 0)))] = t / @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 40))));
                words[@as(c_uint, @intCast(@as(c_int, 1)))] = t % @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 40))));
                y = 2;
            } else {
                words[blk: {
                    const ref = &y;
                    const tmp = ref.*;
                    ref.* +%= 1;
                    break :blk tmp;
                }] = t;
            }
            t = 0;
        }
    }
    outlen.* = y;
    return CRYPT_OK;
}
pub export fn der_length_object_identifier(arg_words: [*c]c_ulong, arg_nwords: c_ulong, arg_outlen: [*c]c_ulong) c_int {
    var words = arg_words;
    _ = &words;
    var nwords = arg_nwords;
    _ = &nwords;
    var outlen = arg_outlen;
    _ = &outlen;
    var y: c_ulong = undefined;
    _ = &y;
    var z: c_ulong = undefined;
    _ = &z;
    var t: c_ulong = undefined;
    _ = &t;
    var wordbuf: c_ulong = undefined;
    _ = &wordbuf;
    if (!(words != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("words != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 22179));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 22180));
    }
    if (nwords < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))) {
        return CRYPT_INVALID_ARG;
    }
    if ((words[@as(c_uint, @intCast(@as(c_int, 0)))] > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3))))) or ((words[@as(c_uint, @intCast(@as(c_int, 0)))] < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))) and (words[@as(c_uint, @intCast(@as(c_int, 1)))] > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 39))))))) {
        return CRYPT_INVALID_ARG;
    }
    z = 0;
    wordbuf = (words[@as(c_uint, @intCast(@as(c_int, 0)))] *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 40))))) +% words[@as(c_uint, @intCast(@as(c_int, 1)))];
    {
        y = 1;
        while (y < nwords) : (y +%= 1) {
            t = der_object_identifier_bits(wordbuf);
            z +%= ((t / @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7))))) +% @as(c_ulong, @bitCast(@as(c_long, if ((t % @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7))))) != 0) @as(c_int, 1) else @as(c_int, 0))))) +% @as(c_ulong, @bitCast(@as(c_long, if (wordbuf == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) @as(c_int, 1) else @as(c_int, 0))));
            if (y < (nwords -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))))) {
                wordbuf = words[y +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))];
            }
        }
    }
    if (z < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
        z +%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))));
    } else if (z < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 256))))) {
        z +%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3))));
    } else if (z < @as(c_ulong, 65536)) {
        z +%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4))));
    } else {
        return CRYPT_INVALID_ARG;
    }
    outlen.* = z;
    return CRYPT_OK;
}
pub export fn der_object_identifier_bits(arg_x: c_ulong) c_ulong {
    var x = arg_x;
    _ = &x;
    var c: c_ulong = undefined;
    _ = &c;
    x &= @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, 4294967295))));
    c = 0;
    while (x != 0) {
        c +%= 1;
        x >>= @intCast(@as(c_int, 1));
    }
    return c;
}
pub export fn der_encode_ia5_string(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    var len: c_ulong = undefined;
    _ = &len;
    var err: c_int = undefined;
    _ = &err;
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20240));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20241));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20242));
    }
    if ((blk: {
        const tmp = der_length_ia5_string(in, inlen, &len);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if (len > outlen.*) {
        outlen.* = len;
        return CRYPT_BUFFER_OVERFLOW;
    }
    x = 0;
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = 22;
    if (inlen < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(inlen))));
    } else if (inlen < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 256))))) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = 129;
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(inlen))));
    } else if (inlen < @as(c_ulong, 65536)) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = 130;
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate((inlen >> @intCast(8)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(inlen & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
    } else if (inlen < @as(c_ulong, 16777216)) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = 131;
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate((inlen >> @intCast(16)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate((inlen >> @intCast(8)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(inlen & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
    } else {
        return CRYPT_INVALID_ARG;
    }
    {
        y = 0;
        while (y < inlen) : (y +%= 1) {
            out[blk: {
                const ref = &x;
                const tmp = ref.*;
                ref.* +%= 1;
                break :blk tmp;
            }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(@as(c_int, @bitCast(@as(c_uint, in[y]))))))));
        }
    }
    outlen.* = x;
    return CRYPT_OK;
}
pub export fn der_decode_ia5_string(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    var len: c_ulong = undefined;
    _ = &len;
    var t: c_int = undefined;
    _ = &t;
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18440));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18441));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18442));
    }
    if (inlen < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))) {
        return CRYPT_INVALID_PACKET;
    }
    if ((@as(c_int, @bitCast(@as(c_uint, in[@as(c_uint, @intCast(@as(c_int, 0)))]))) & @as(c_int, 31)) != @as(c_int, 22)) {
        return CRYPT_INVALID_PACKET;
    }
    x = 1;
    if ((@as(c_int, @bitCast(@as(c_uint, in[x]))) & @as(c_int, 128)) != 0) {
        y = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, in[x]))) & @as(c_int, 127))));
        if (((y == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) or (y > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3)))))) or ((x +% y) > inlen)) {
            return CRYPT_INVALID_PACKET;
        }
        len = 0;
        x +%= 1;
        while ((blk: {
            const ref = &y;
            const tmp = ref.*;
            ref.* -%= 1;
            break :blk tmp;
        }) != 0) {
            len = (len << @intCast(8)) | @as(c_ulong, @bitCast(@as(c_ulong, in[blk: {
                const ref = &x;
                const tmp = ref.*;
                ref.* +%= 1;
                break :blk tmp;
            }])));
        }
    } else {
        len = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, in[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }]))) & @as(c_int, 127))));
    }
    if (len > outlen.*) {
        outlen.* = len;
        return CRYPT_BUFFER_OVERFLOW;
    }
    if ((len +% x) > inlen) {
        return CRYPT_INVALID_PACKET;
    }
    {
        y = 0;
        while (y < len) : (y +%= 1) {
            t = der_ia5_value_decode(@as(c_int, @bitCast(@as(c_uint, in[blk: {
                const ref = &x;
                const tmp = ref.*;
                ref.* +%= 1;
                break :blk tmp;
            }]))));
            if (t == -@as(c_int, 1)) {
                return CRYPT_INVALID_ARG;
            }
            out[y] = @as(u8, @bitCast(@as(i8, @truncate(t))));
        }
    }
    outlen.* = y;
    return CRYPT_OK;
}
pub export fn der_length_ia5_string(arg_octets: [*c]const u8, arg_noctets: c_ulong, arg_outlen: [*c]c_ulong) c_int {
    var octets = arg_octets;
    _ = &octets;
    var noctets = arg_noctets;
    _ = &noctets;
    var outlen = arg_outlen;
    _ = &outlen;
    var x: c_ulong = undefined;
    _ = &x;
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 22019));
    }
    if (!(octets != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("octets != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 22020));
    }
    {
        x = 0;
        while (x < noctets) : (x +%= 1) {
            if (der_ia5_char_encode(@as(c_int, @bitCast(@as(c_uint, octets[x])))) == -@as(c_int, 1)) {
                return CRYPT_INVALID_ARG;
            }
        }
    }
    if (noctets < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2)))) +% noctets;
    } else if (noctets < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 256))))) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3)))) +% noctets;
    } else if (noctets < @as(c_ulong, 65536)) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4)))) +% noctets;
    } else if (noctets < @as(c_ulong, 16777216)) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 5)))) +% noctets;
    } else {
        return CRYPT_INVALID_ARG;
    }
    return CRYPT_OK;
}
const struct_unnamed_51 = extern struct {
    code: c_int = @import("std").mem.zeroes(c_int),
    value: c_int = @import("std").mem.zeroes(c_int),
};
pub export fn der_ia5_char_encode(arg_c: c_int) c_int {
    var c = arg_c;
    _ = &c;
    var x: c_int = undefined;
    _ = &x;
    {
        x = 0;
        while (x < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([102]struct_unnamed_51) / @sizeOf(struct_unnamed_51)))))) : (x += 1) {
            if (ia5_table[@as(c_uint, @intCast(x))].code == c) {
                return ia5_table[@as(c_uint, @intCast(x))].value;
            }
        }
    }
    return -@as(c_int, 1);
}
pub export fn der_ia5_value_decode(arg_v: c_int) c_int {
    var v = arg_v;
    _ = &v;
    var x: c_int = undefined;
    _ = &x;
    {
        x = 0;
        while (x < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([102]struct_unnamed_51) / @sizeOf(struct_unnamed_51)))))) : (x += 1) {
            if (ia5_table[@as(c_uint, @intCast(x))].value == v) {
                return ia5_table[@as(c_uint, @intCast(x))].code;
            }
        }
    }
    return -@as(c_int, 1);
}
pub export fn der_encode_printable_string(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    var len: c_ulong = undefined;
    _ = &len;
    var err: c_int = undefined;
    _ = &err;
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20656));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20657));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 20658));
    }
    if ((blk: {
        const tmp = der_length_printable_string(in, inlen, &len);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if (len > outlen.*) {
        outlen.* = len;
        return CRYPT_BUFFER_OVERFLOW;
    }
    x = 0;
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = 19;
    if (inlen < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(inlen))));
    } else if (inlen < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 256))))) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = 129;
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(inlen))));
    } else if (inlen < @as(c_ulong, 65536)) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = 130;
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate((inlen >> @intCast(8)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(inlen & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
    } else if (inlen < @as(c_ulong, 16777216)) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = 131;
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate((inlen >> @intCast(16)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate((inlen >> @intCast(8)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(inlen & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
    } else {
        return CRYPT_INVALID_ARG;
    }
    {
        y = 0;
        while (y < inlen) : (y +%= 1) {
            out[blk: {
                const ref = &x;
                const tmp = ref.*;
                ref.* +%= 1;
                break :blk tmp;
            }] = @as(u8, @bitCast(@as(i8, @truncate(der_printable_char_encode(@as(c_int, @bitCast(@as(c_uint, in[y]))))))));
        }
    }
    outlen.* = x;
    return CRYPT_OK;
}
pub export fn der_decode_printable_string(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    var len: c_ulong = undefined;
    _ = &len;
    var t: c_int = undefined;
    _ = &t;
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18836));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18837));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18838));
    }
    if (inlen < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))) {
        return CRYPT_INVALID_PACKET;
    }
    if ((@as(c_int, @bitCast(@as(c_uint, in[@as(c_uint, @intCast(@as(c_int, 0)))]))) & @as(c_int, 31)) != @as(c_int, 19)) {
        return CRYPT_INVALID_PACKET;
    }
    x = 1;
    if ((@as(c_int, @bitCast(@as(c_uint, in[x]))) & @as(c_int, 128)) != 0) {
        y = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, in[x]))) & @as(c_int, 127))));
        if (((y == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) or (y > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3)))))) or ((x +% y) > inlen)) {
            return CRYPT_INVALID_PACKET;
        }
        len = 0;
        x +%= 1;
        while ((blk: {
            const ref = &y;
            const tmp = ref.*;
            ref.* -%= 1;
            break :blk tmp;
        }) != 0) {
            len = (len << @intCast(8)) | @as(c_ulong, @bitCast(@as(c_ulong, in[blk: {
                const ref = &x;
                const tmp = ref.*;
                ref.* +%= 1;
                break :blk tmp;
            }])));
        }
    } else {
        len = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, in[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }]))) & @as(c_int, 127))));
    }
    if (len > outlen.*) {
        outlen.* = len;
        return CRYPT_BUFFER_OVERFLOW;
    }
    if ((len +% x) > inlen) {
        return CRYPT_INVALID_PACKET;
    }
    {
        y = 0;
        while (y < len) : (y +%= 1) {
            t = der_printable_value_decode(@as(c_int, @bitCast(@as(c_uint, in[blk: {
                const ref = &x;
                const tmp = ref.*;
                ref.* +%= 1;
                break :blk tmp;
            }]))));
            if (t == -@as(c_int, 1)) {
                return CRYPT_INVALID_ARG;
            }
            out[y] = @as(u8, @bitCast(@as(i8, @truncate(t))));
        }
    }
    outlen.* = y;
    return CRYPT_OK;
}
pub export fn der_length_printable_string(arg_octets: [*c]const u8, arg_noctets: c_ulong, arg_outlen: [*c]c_ulong) c_int {
    var octets = arg_octets;
    _ = &octets;
    var noctets = arg_noctets;
    _ = &noctets;
    var outlen = arg_outlen;
    _ = &outlen;
    var x: c_ulong = undefined;
    _ = &x;
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 22410));
    }
    if (!(octets != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("octets != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 22411));
    }
    {
        x = 0;
        while (x < noctets) : (x +%= 1) {
            if (der_printable_char_encode(@as(c_int, @bitCast(@as(c_uint, octets[x])))) == -@as(c_int, 1)) {
                return CRYPT_INVALID_ARG;
            }
        }
    }
    if (noctets < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2)))) +% noctets;
    } else if (noctets < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 256))))) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3)))) +% noctets;
    } else if (noctets < @as(c_ulong, 65536)) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4)))) +% noctets;
    } else if (noctets < @as(c_ulong, 16777216)) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 5)))) +% noctets;
    } else {
        return CRYPT_INVALID_ARG;
    }
    return CRYPT_OK;
}
const struct_unnamed_52 = extern struct {
    code: c_int = @import("std").mem.zeroes(c_int),
    value: c_int = @import("std").mem.zeroes(c_int),
};
pub export fn der_printable_char_encode(arg_c: c_int) c_int {
    var c = arg_c;
    _ = &c;
    var x: c_int = undefined;
    _ = &x;
    {
        x = 0;
        while (x < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([74]struct_unnamed_52) / @sizeOf(struct_unnamed_52)))))) : (x += 1) {
            if (printable_table[@as(c_uint, @intCast(x))].code == c) {
                return printable_table[@as(c_uint, @intCast(x))].value;
            }
        }
    }
    return -@as(c_int, 1);
}
pub export fn der_printable_value_decode(arg_v: c_int) c_int {
    var v = arg_v;
    _ = &v;
    var x: c_int = undefined;
    _ = &x;
    {
        x = 0;
        while (x < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([74]struct_unnamed_52) / @sizeOf(struct_unnamed_52)))))) : (x += 1) {
            if (printable_table[@as(c_uint, @intCast(x))].value == v) {
                return printable_table[@as(c_uint, @intCast(x))].code;
            }
        }
    }
    return -@as(c_int, 1);
}
pub const wint_t = c_uint;
pub const mbstate_t = __mbstate_t;
pub extern fn wcscpy(noalias __dest: [*c]wchar_t, noalias __src: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcsncpy(noalias __dest: [*c]wchar_t, noalias __src: [*c]const wchar_t, __n: usize) [*c]wchar_t;
pub extern fn wcslcpy(noalias __dest: [*c]wchar_t, noalias __src: [*c]const wchar_t, __n: usize) usize;
pub extern fn wcslcat(noalias __dest: [*c]wchar_t, noalias __src: [*c]const wchar_t, __n: usize) usize;
pub extern fn wcscat(noalias __dest: [*c]wchar_t, noalias __src: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcsncat(noalias __dest: [*c]wchar_t, noalias __src: [*c]const wchar_t, __n: usize) [*c]wchar_t;
pub extern fn wcscmp(__s1: [*c]const c_int, __s2: [*c]const c_int) c_int;
pub extern fn wcsncmp(__s1: [*c]const c_int, __s2: [*c]const c_int, __n: c_ulong) c_int;
pub extern fn wcscasecmp(__s1: [*c]const wchar_t, __s2: [*c]const wchar_t) c_int;
pub extern fn wcsncasecmp(__s1: [*c]const wchar_t, __s2: [*c]const wchar_t, __n: usize) c_int;
pub extern fn wcscasecmp_l(__s1: [*c]const wchar_t, __s2: [*c]const wchar_t, __loc: locale_t) c_int;
pub extern fn wcsncasecmp_l(__s1: [*c]const wchar_t, __s2: [*c]const wchar_t, __n: usize, __loc: locale_t) c_int;
pub extern fn wcscoll(__s1: [*c]const wchar_t, __s2: [*c]const wchar_t) c_int;
pub extern fn wcsxfrm(noalias __s1: [*c]wchar_t, noalias __s2: [*c]const wchar_t, __n: usize) usize;
pub extern fn wcscoll_l(__s1: [*c]const wchar_t, __s2: [*c]const wchar_t, __loc: locale_t) c_int;
pub extern fn wcsxfrm_l(__s1: [*c]wchar_t, __s2: [*c]const wchar_t, __n: usize, __loc: locale_t) usize;
pub extern fn wcsdup(__s: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcschr(__wcs: [*c]const c_int, __wc: c_int) [*c]c_int;
pub extern fn wcsrchr(__wcs: [*c]const wchar_t, __wc: wchar_t) [*c]wchar_t;
pub extern fn wcscspn(__wcs: [*c]const wchar_t, __reject: [*c]const wchar_t) usize;
pub extern fn wcsspn(__wcs: [*c]const wchar_t, __accept: [*c]const wchar_t) usize;
pub extern fn wcspbrk(__wcs: [*c]const wchar_t, __accept: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcsstr(__haystack: [*c]const wchar_t, __needle: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcstok(noalias __s: [*c]wchar_t, noalias __delim: [*c]const wchar_t, noalias __ptr: [*c][*c]wchar_t) [*c]wchar_t;
pub extern fn wcslen(__s: [*c]const c_int) c_ulong;
pub extern fn wcsnlen(__s: [*c]const wchar_t, __maxlen: usize) usize;
pub extern fn wmemchr(__s: [*c]const c_int, __c: c_int, __n: c_ulong) [*c]c_int;
pub extern fn wmemcmp(__s1: [*c]const c_int, __s2: [*c]const c_int, __n: c_ulong) c_int;
pub extern fn wmemcpy(__s1: [*c]c_int, __s2: [*c]const c_int, __n: c_ulong) [*c]c_int;
pub extern fn wmemmove(__s1: [*c]c_int, __s2: [*c]const c_int, __n: c_ulong) [*c]c_int;
pub extern fn wmemset(__s: [*c]wchar_t, __c: wchar_t, __n: usize) [*c]wchar_t;
pub extern fn btowc(__c: c_int) wint_t;
pub extern fn wctob(__c: wint_t) c_int;
pub extern fn mbsinit(__ps: [*c]const mbstate_t) c_int;
pub extern fn mbrtowc(noalias __pwc: [*c]wchar_t, noalias __s: [*c]const u8, __n: usize, noalias __p: [*c]mbstate_t) usize;
pub extern fn wcrtomb(noalias __s: [*c]u8, __wc: wchar_t, noalias __ps: [*c]mbstate_t) usize;
pub extern fn __mbrlen(noalias __s: [*c]const u8, __n: usize, noalias __ps: [*c]mbstate_t) usize;
pub extern fn mbrlen(noalias __s: [*c]const u8, __n: usize, noalias __ps: [*c]mbstate_t) usize;
pub extern fn mbsrtowcs(noalias __dst: [*c]wchar_t, noalias __src: [*c][*c]const u8, __len: usize, noalias __ps: [*c]mbstate_t) usize;
pub extern fn wcsrtombs(noalias __dst: [*c]u8, noalias __src: [*c][*c]const wchar_t, __len: usize, noalias __ps: [*c]mbstate_t) usize;
pub extern fn mbsnrtowcs(noalias __dst: [*c]wchar_t, noalias __src: [*c][*c]const u8, __nmc: usize, __len: usize, noalias __ps: [*c]mbstate_t) usize;
pub extern fn wcsnrtombs(noalias __dst: [*c]u8, noalias __src: [*c][*c]const wchar_t, __nwc: usize, __len: usize, noalias __ps: [*c]mbstate_t) usize;
pub extern fn wcstod(noalias __nptr: [*c]const wchar_t, noalias __endptr: [*c][*c]wchar_t) f64;
pub extern fn wcstof(noalias __nptr: [*c]const wchar_t, noalias __endptr: [*c][*c]wchar_t) f32;
pub extern fn wcstold(noalias __nptr: [*c]const wchar_t, noalias __endptr: [*c][*c]wchar_t) c_longdouble;
pub extern fn wcstol(noalias __nptr: [*c]const wchar_t, noalias __endptr: [*c][*c]wchar_t, __base: c_int) c_long;
pub extern fn wcstoul(noalias __nptr: [*c]const wchar_t, noalias __endptr: [*c][*c]wchar_t, __base: c_int) c_ulong;
pub extern fn wcstoll(noalias __nptr: [*c]const wchar_t, noalias __endptr: [*c][*c]wchar_t, __base: c_int) c_longlong;
pub extern fn wcstoull(noalias __nptr: [*c]const wchar_t, noalias __endptr: [*c][*c]wchar_t, __base: c_int) c_ulonglong;
pub extern fn wcpcpy(noalias __dest: [*c]wchar_t, noalias __src: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcpncpy(noalias __dest: [*c]wchar_t, noalias __src: [*c]const wchar_t, __n: usize) [*c]wchar_t;
pub extern fn open_wmemstream(__bufloc: [*c][*c]wchar_t, __sizeloc: [*c]usize) [*c]__FILE;
pub extern fn fwide(__fp: [*c]__FILE, __mode: c_int) c_int;
pub extern fn fwprintf(noalias __stream: [*c]__FILE, noalias __format: [*c]const wchar_t, ...) c_int;
pub extern fn wprintf(noalias __format: [*c]const wchar_t, ...) c_int;
pub extern fn swprintf(noalias __s: [*c]wchar_t, __n: usize, noalias __format: [*c]const wchar_t, ...) c_int;
pub extern fn vfwprintf(noalias __s: [*c]__FILE, noalias __format: [*c]const wchar_t, __arg: [*c]struct___va_list_tag_2) c_int;
pub extern fn vwprintf(noalias __format: [*c]const wchar_t, __arg: [*c]struct___va_list_tag_2) c_int;
pub extern fn vswprintf(noalias __s: [*c]wchar_t, __n: usize, noalias __format: [*c]const wchar_t, __arg: [*c]struct___va_list_tag_2) c_int;
pub extern fn fwscanf(noalias __stream: [*c]__FILE, noalias __format: [*c]const wchar_t, ...) c_int;
pub extern fn wscanf(noalias __format: [*c]const wchar_t, ...) c_int;
pub extern fn swscanf(noalias __s: [*c]const wchar_t, noalias __format: [*c]const wchar_t, ...) c_int;
pub extern fn vfwscanf(noalias __s: [*c]__FILE, noalias __format: [*c]const wchar_t, __arg: [*c]struct___va_list_tag_2) c_int;
pub extern fn vwscanf(noalias __format: [*c]const wchar_t, __arg: [*c]struct___va_list_tag_2) c_int;
pub extern fn vswscanf(noalias __s: [*c]const wchar_t, noalias __format: [*c]const wchar_t, __arg: [*c]struct___va_list_tag_2) c_int;
pub extern fn fgetwc(__stream: [*c]__FILE) wint_t;
pub extern fn getwc(__stream: [*c]__FILE) wint_t;
pub extern fn getwchar() wint_t;
pub extern fn fputwc(__wc: wchar_t, __stream: [*c]__FILE) wint_t;
pub extern fn putwc(__wc: wchar_t, __stream: [*c]__FILE) wint_t;
pub extern fn putwchar(__wc: wchar_t) wint_t;
pub extern fn fgetws(noalias __ws: [*c]wchar_t, __n: c_int, noalias __stream: [*c]__FILE) [*c]wchar_t;
pub extern fn fputws(noalias __ws: [*c]const wchar_t, noalias __stream: [*c]__FILE) c_int;
pub extern fn ungetwc(__wc: wint_t, __stream: [*c]__FILE) wint_t;
pub extern fn wcsftime(noalias __s: [*c]wchar_t, __maxsize: usize, noalias __format: [*c]const wchar_t, noalias __tp: [*c]const struct_tm) usize;
pub export fn der_encode_utf8_string(arg_in: [*c]const wchar_t, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    var len: c_ulong = undefined;
    _ = &len;
    if (!(in != @as([*c]const wchar_t, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 21679));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 21680));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 21681));
    }
    {
        x = blk: {
            const tmp = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))));
            len = tmp;
            break :blk tmp;
        };
        while (x < inlen) : (x +%= 1) {
            if ((in[x] < @as(c_int, 0)) or (in[x] > @as(c_int, 131071))) {
                return CRYPT_INVALID_ARG;
            }
            len +%= der_utf8_charsize(in[x]);
        }
    }
    if (len < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
        y = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2)))) +% len;
    } else if (len < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 256))))) {
        y = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3)))) +% len;
    } else if (len < @as(c_ulong, 65536)) {
        y = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4)))) +% len;
    } else if (len < @as(c_ulong, 16777216)) {
        y = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 5)))) +% len;
    } else {
        return CRYPT_INVALID_ARG;
    }
    if (y > outlen.*) {
        outlen.* = len;
        return CRYPT_BUFFER_OVERFLOW;
    }
    x = 0;
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = 12;
    if (len < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(len))));
    } else if (len < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 256))))) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = 129;
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(len))));
    } else if (len < @as(c_ulong, 65536)) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = 130;
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate((len >> @intCast(8)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(len & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
    } else if (len < @as(c_ulong, 16777216)) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = 131;
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate((len >> @intCast(16)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate((len >> @intCast(8)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(u8, @truncate(len & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
    } else {
        return CRYPT_INVALID_ARG;
    }
    {
        y = 0;
        while (y < inlen) : (y +%= 1) {
            while (true) {
                switch (der_utf8_charsize(in[y])) {
                    @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))) => {
                        out[blk: {
                            const ref = &x;
                            const tmp = ref.*;
                            ref.* +%= 1;
                            break :blk tmp;
                        }] = @as(u8, @bitCast(@as(i8, @truncate(in[y]))));
                        break;
                    },
                    @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2)))) => {
                        out[blk: {
                            const ref = &x;
                            const tmp = ref.*;
                            ref.* +%= 1;
                            break :blk tmp;
                        }] = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 192) | ((in[y] >> @intCast(6)) & @as(c_int, 31))))));
                        out[blk: {
                            const ref = &x;
                            const tmp = ref.*;
                            ref.* +%= 1;
                            break :blk tmp;
                        }] = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 128) | (in[y] & @as(c_int, 63))))));
                        break;
                    },
                    @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3)))) => {
                        out[blk: {
                            const ref = &x;
                            const tmp = ref.*;
                            ref.* +%= 1;
                            break :blk tmp;
                        }] = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 224) | ((in[y] >> @intCast(12)) & @as(c_int, 15))))));
                        out[blk: {
                            const ref = &x;
                            const tmp = ref.*;
                            ref.* +%= 1;
                            break :blk tmp;
                        }] = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 128) | ((in[y] >> @intCast(6)) & @as(c_int, 63))))));
                        out[blk: {
                            const ref = &x;
                            const tmp = ref.*;
                            ref.* +%= 1;
                            break :blk tmp;
                        }] = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 128) | (in[y] & @as(c_int, 63))))));
                        break;
                    },
                    @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4)))) => {
                        out[blk: {
                            const ref = &x;
                            const tmp = ref.*;
                            ref.* +%= 1;
                            break :blk tmp;
                        }] = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 240) | ((in[y] >> @intCast(18)) & @as(c_int, 7))))));
                        out[blk: {
                            const ref = &x;
                            const tmp = ref.*;
                            ref.* +%= 1;
                            break :blk tmp;
                        }] = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 128) | ((in[y] >> @intCast(12)) & @as(c_int, 63))))));
                        out[blk: {
                            const ref = &x;
                            const tmp = ref.*;
                            ref.* +%= 1;
                            break :blk tmp;
                        }] = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 128) | ((in[y] >> @intCast(6)) & @as(c_int, 63))))));
                        out[blk: {
                            const ref = &x;
                            const tmp = ref.*;
                            ref.* +%= 1;
                            break :blk tmp;
                        }] = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 128) | (in[y] & @as(c_int, 63))))));
                        break;
                    },
                    else => {},
                }
                break;
            }
        }
    }
    outlen.* = x;
    return CRYPT_OK;
}
pub export fn der_decode_utf8_string(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]wchar_t, arg_outlen: [*c]c_ulong) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var tmp: wchar_t = undefined;
    _ = &tmp;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    var z: c_ulong = undefined;
    _ = &z;
    var len: c_ulong = undefined;
    _ = &len;
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 19988));
    }
    if (!(out != @as([*c]wchar_t, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 19989));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 19990));
    }
    if (inlen < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))) {
        return CRYPT_INVALID_PACKET;
    }
    if ((@as(c_int, @bitCast(@as(c_uint, in[@as(c_uint, @intCast(@as(c_int, 0)))]))) & @as(c_int, 31)) != @as(c_int, 12)) {
        return CRYPT_INVALID_PACKET;
    }
    x = 1;
    if ((@as(c_int, @bitCast(@as(c_uint, in[x]))) & @as(c_int, 128)) != 0) {
        y = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, in[x]))) & @as(c_int, 127))));
        if (((y == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) or (y > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3)))))) or ((x +% y) > inlen)) {
            return CRYPT_INVALID_PACKET;
        }
        len = 0;
        x +%= 1;
        while ((blk: {
            const ref = &y;
            const tmp_1 = ref.*;
            ref.* -%= 1;
            break :blk tmp_1;
        }) != 0) {
            len = (len << @intCast(8)) | @as(c_ulong, @bitCast(@as(c_ulong, in[blk: {
                const ref = &x;
                const tmp_1 = ref.*;
                ref.* +%= 1;
                break :blk tmp_1;
            }])));
        }
    } else {
        len = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, in[blk: {
            const ref = &x;
            const tmp_1 = ref.*;
            ref.* +%= 1;
            break :blk tmp_1;
        }]))) & @as(c_int, 127))));
    }
    if ((len +% x) > inlen) {
        return CRYPT_INVALID_PACKET;
    }
    {
        y = 0;
        while (x < inlen) {
            tmp = @as(wchar_t, @bitCast(@as(c_uint, in[blk: {
                const ref = &x;
                const tmp_1 = ref.*;
                ref.* +%= 1;
                break :blk tmp_1;
            }])));
            {
                z = 0;
                while (((tmp & @as(c_int, 128)) != 0) and (z <= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4)))))) : (_ = blk: {
                    z +%= 1;
                    break :blk blk_1: {
                        const tmp_2 = (tmp << @intCast(1)) & @as(c_int, 255);
                        tmp = tmp_2;
                        break :blk_1 tmp_2;
                    };
                }) {}
            }
            if ((z > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4))))) or ((x +% (z -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))))) > inlen)) {
                return CRYPT_INVALID_PACKET;
            }
            tmp >>= @intCast(z);
            if (z > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))) {
                z -%= 1;
            }
            while ((blk: {
                const ref = &z;
                const tmp_1 = ref.*;
                ref.* -%= 1;
                break :blk tmp_1;
            }) != @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) {
                if ((@as(c_int, @bitCast(@as(c_uint, in[x]))) & @as(c_int, 192)) != @as(c_int, 128)) {
                    return CRYPT_INVALID_PACKET;
                }
                tmp = (tmp << @intCast(6)) | (@as(wchar_t, @bitCast(@as(c_uint, in[blk: {
                    const ref = &x;
                    const tmp_1 = ref.*;
                    ref.* +%= 1;
                    break :blk tmp_1;
                }]))) & @as(c_int, 63));
            }
            if (y > outlen.*) {
                outlen.* = y;
                return CRYPT_BUFFER_OVERFLOW;
            }
            out[blk: {
                const ref = &y;
                const tmp_1 = ref.*;
                ref.* +%= 1;
                break :blk tmp_1;
            }] = tmp;
        }
    }
    outlen.* = y;
    return CRYPT_OK;
}
pub export fn der_utf8_charsize(c: wchar_t) c_ulong {
    _ = &c;
    if (c <= @as(c_int, 127)) {
        return 1;
    } else if (c <= @as(c_int, 2047)) {
        return 2;
    } else if (c <= @as(c_int, 65535)) {
        return 3;
    } else {
        return 4;
    }
    return 0;
}
pub export fn der_length_utf8_string(arg_in: [*c]const wchar_t, arg_noctets: c_ulong, arg_outlen: [*c]c_ulong) c_int {
    var in = arg_in;
    _ = &in;
    var noctets = arg_noctets;
    _ = &noctets;
    var outlen = arg_outlen;
    _ = &outlen;
    var x: c_ulong = undefined;
    _ = &x;
    var len: c_ulong = undefined;
    _ = &len;
    if (!(in != @as([*c]const wchar_t, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 22777));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 22778));
    }
    len = 0;
    {
        x = 0;
        while (x < noctets) : (x +%= 1) {
            if ((in[x] < @as(c_int, 0)) or (in[x] > @as(c_int, 1114111))) {
                return CRYPT_INVALID_ARG;
            }
            len +%= der_utf8_charsize(in[x]);
        }
    }
    if (len < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2)))) +% len;
    } else if (len < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 256))))) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3)))) +% len;
    } else if (len < @as(c_ulong, 65536)) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4)))) +% len;
    } else if (len < @as(c_ulong, 16777216)) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 5)))) +% len;
    } else {
        return CRYPT_INVALID_ARG;
    }
    return CRYPT_OK;
}
pub export fn der_decode_choice(arg_in: [*c]const u8, arg_inlen: [*c]c_ulong, arg_list: [*c]ltc_asn1_list, arg_outlen: c_ulong) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var list = arg_list;
    _ = &list;
    var outlen = arg_outlen;
    _ = &outlen;
    var size: c_ulong = undefined;
    _ = &size;
    var x: c_ulong = undefined;
    _ = &x;
    var z: c_ulong = undefined;
    _ = &z;
    var data: ?*anyopaque = undefined;
    _ = &data;
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18257));
    }
    if (!(inlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("inlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18258));
    }
    if (!(list != @as([*c]ltc_asn1_list, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("list != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 18259));
    }
    if (inlen.* < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))) {
        return CRYPT_INVALID_PACKET;
    }
    {
        x = 0;
        while (x < outlen) : (x +%= 1) {
            list[x].used = 0;
        }
    }
    {
        x = 0;
        while (x < outlen) : (x +%= 1) {
            size = list[x].size;
            data = list[x].data;
            while (true) {
                switch (list[x].type) {
                    @as(c_int, 2) => {
                        if (der_decode_integer(in, inlen.*, data) == CRYPT_OK) {
                            if (der_length_integer(data, &z) == CRYPT_OK) {
                                list[x].used = 1;
                                inlen.* = z;
                                return CRYPT_OK;
                            }
                        }
                        break;
                    },
                    @as(c_int, 3) => {
                        if (der_decode_short_integer(in, inlen.*, @as([*c]c_ulong, @ptrCast(@alignCast(data)))) == CRYPT_OK) {
                            if (der_length_short_integer(size, &z) == CRYPT_OK) {
                                list[x].used = 1;
                                inlen.* = z;
                                return CRYPT_OK;
                            }
                        }
                        break;
                    },
                    @as(c_int, 4) => {
                        if (der_decode_bit_string(in, inlen.*, @as([*c]u8, @ptrCast(@alignCast(data))), &size) == CRYPT_OK) {
                            if (der_length_bit_string(size, &z) == CRYPT_OK) {
                                list[x].used = 1;
                                list[x].size = size;
                                inlen.* = z;
                                return CRYPT_OK;
                            }
                        }
                        break;
                    },
                    @as(c_int, 5) => {
                        if (der_decode_octet_string(in, inlen.*, @as([*c]u8, @ptrCast(@alignCast(data))), &size) == CRYPT_OK) {
                            if (der_length_octet_string(size, &z) == CRYPT_OK) {
                                list[x].used = 1;
                                list[x].size = size;
                                inlen.* = z;
                                return CRYPT_OK;
                            }
                        }
                        break;
                    },
                    @as(c_int, 6) => {
                        if (((inlen.* == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))) and (@as(c_int, @bitCast(@as(c_uint, in[x]))) == @as(c_int, 5))) and (@as(c_int, @bitCast(@as(c_uint, in[x +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))]))) == @as(c_int, 0))) {
                            inlen.* = 2;
                            list[x].used = 1;
                            return CRYPT_OK;
                        }
                        break;
                    },
                    @as(c_int, 7) => {
                        if (der_decode_object_identifier(in, inlen.*, @as([*c]c_ulong, @ptrCast(@alignCast(data))), &size) == CRYPT_OK) {
                            if (der_length_object_identifier(@as([*c]c_ulong, @ptrCast(@alignCast(data))), size, &z) == CRYPT_OK) {
                                list[x].used = 1;
                                list[x].size = size;
                                inlen.* = z;
                                return CRYPT_OK;
                            }
                        }
                        break;
                    },
                    @as(c_int, 8) => {
                        if (der_decode_ia5_string(in, inlen.*, @as([*c]u8, @ptrCast(@alignCast(data))), &size) == CRYPT_OK) {
                            if (der_length_ia5_string(@as([*c]const u8, @ptrCast(@alignCast(data))), size, &z) == CRYPT_OK) {
                                list[x].used = 1;
                                list[x].size = size;
                                inlen.* = z;
                                return CRYPT_OK;
                            }
                        }
                        break;
                    },
                    @as(c_int, 9) => {
                        if (der_decode_printable_string(in, inlen.*, @as([*c]u8, @ptrCast(@alignCast(data))), &size) == CRYPT_OK) {
                            if (der_length_printable_string(@as([*c]const u8, @ptrCast(@alignCast(data))), size, &z) == CRYPT_OK) {
                                list[x].used = 1;
                                list[x].size = size;
                                inlen.* = z;
                                return CRYPT_OK;
                            }
                        }
                        break;
                    },
                    @as(c_int, 10) => {
                        if (der_decode_utf8_string(in, inlen.*, @as([*c]wchar_t, @ptrCast(@alignCast(data))), &size) == CRYPT_OK) {
                            if (der_length_utf8_string(@as([*c]const wchar_t, @ptrCast(@alignCast(data))), size, &z) == CRYPT_OK) {
                                list[x].used = 1;
                                list[x].size = size;
                                inlen.* = z;
                                return CRYPT_OK;
                            }
                        }
                        break;
                    },
                    @as(c_int, 11) => {
                        z = inlen.*;
                        if (der_decode_utctime(in, &z, @as([*c]ltc_utctime, @ptrCast(@alignCast(data)))) == CRYPT_OK) {
                            list[x].used = 1;
                            inlen.* = z;
                            return CRYPT_OK;
                        }
                        break;
                    },
                    @as(c_int, 14), @as(c_int, 15), @as(c_int, 13) => {
                        if (der_decode_sequence_ex(in, inlen.*, @as([*c]ltc_asn1_list, @ptrCast(@alignCast(data))), size, @as(c_int, 1)) == CRYPT_OK) {
                            if (der_length_sequence(@as([*c]ltc_asn1_list, @ptrCast(@alignCast(data))), size, &z) == CRYPT_OK) {
                                list[x].used = 1;
                                inlen.* = z;
                                return CRYPT_OK;
                            }
                        }
                        break;
                    },
                    else => return CRYPT_INVALID_ARG,
                }
                break;
            }
        }
    }
    return CRYPT_INVALID_PACKET;
}
pub const ltc_utctime = extern struct {
    YY: c_uint = @import("std").mem.zeroes(c_uint),
    MM: c_uint = @import("std").mem.zeroes(c_uint),
    DD: c_uint = @import("std").mem.zeroes(c_uint),
    hh: c_uint = @import("std").mem.zeroes(c_uint),
    mm: c_uint = @import("std").mem.zeroes(c_uint),
    ss: c_uint = @import("std").mem.zeroes(c_uint),
    off_dir: c_uint = @import("std").mem.zeroes(c_uint),
    off_hh: c_uint = @import("std").mem.zeroes(c_uint),
    off_mm: c_uint = @import("std").mem.zeroes(c_uint),
};
pub export fn der_encode_utctime(arg_utctime: [*c]ltc_utctime, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var utctime = arg_utctime;
    _ = &utctime;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var x: c_ulong = undefined;
    _ = &x;
    var tmplen: c_ulong = undefined;
    _ = &tmplen;
    var err: c_int = undefined;
    _ = &err;
    if (!(utctime != @as([*c]ltc_utctime, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("utctime != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 21601));
    }
    if (!(out != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 21602));
    }
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 21603));
    }
    if ((blk: {
        const tmp = der_length_utctime(utctime, &tmplen);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if (tmplen > outlen.*) {
        outlen.* = tmplen;
        return CRYPT_BUFFER_OVERFLOW;
    }
    out[@as(c_uint, @intCast(@as(c_int, 0)))] = 23;
    x = 2;
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(@as(c_int, @bitCast(@as(c_uint, baseten[(utctime.*.YY / @as(c_uint, @bitCast(@as(c_int, 10)))) % @as(c_uint, @bitCast(@as(c_int, 10)))]))))))));
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(@as(c_int, @bitCast(@as(c_uint, baseten[utctime.*.YY % @as(c_uint, @bitCast(@as(c_int, 10)))]))))))));
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(@as(c_int, @bitCast(@as(c_uint, baseten[(utctime.*.MM / @as(c_uint, @bitCast(@as(c_int, 10)))) % @as(c_uint, @bitCast(@as(c_int, 10)))]))))))));
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(@as(c_int, @bitCast(@as(c_uint, baseten[utctime.*.MM % @as(c_uint, @bitCast(@as(c_int, 10)))]))))))));
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(@as(c_int, @bitCast(@as(c_uint, baseten[(utctime.*.DD / @as(c_uint, @bitCast(@as(c_int, 10)))) % @as(c_uint, @bitCast(@as(c_int, 10)))]))))))));
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(@as(c_int, @bitCast(@as(c_uint, baseten[utctime.*.DD % @as(c_uint, @bitCast(@as(c_int, 10)))]))))))));
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(@as(c_int, @bitCast(@as(c_uint, baseten[(utctime.*.hh / @as(c_uint, @bitCast(@as(c_int, 10)))) % @as(c_uint, @bitCast(@as(c_int, 10)))]))))))));
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(@as(c_int, @bitCast(@as(c_uint, baseten[utctime.*.hh % @as(c_uint, @bitCast(@as(c_int, 10)))]))))))));
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(@as(c_int, @bitCast(@as(c_uint, baseten[(utctime.*.mm / @as(c_uint, @bitCast(@as(c_int, 10)))) % @as(c_uint, @bitCast(@as(c_int, 10)))]))))))));
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(@as(c_int, @bitCast(@as(c_uint, baseten[utctime.*.mm % @as(c_uint, @bitCast(@as(c_int, 10)))]))))))));
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(@as(c_int, @bitCast(@as(c_uint, baseten[(utctime.*.ss / @as(c_uint, @bitCast(@as(c_int, 10)))) % @as(c_uint, @bitCast(@as(c_int, 10)))]))))))));
    out[blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(@as(c_int, @bitCast(@as(c_uint, baseten[utctime.*.ss % @as(c_uint, @bitCast(@as(c_int, 10)))]))))))));
    if ((utctime.*.off_mm != 0) or (utctime.*.off_hh != 0)) {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(if (utctime.*.off_dir != 0) @as(c_int, '-') else @as(c_int, '+'))))));
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(@as(c_int, @bitCast(@as(c_uint, baseten[(utctime.*.off_hh / @as(c_uint, @bitCast(@as(c_int, 10)))) % @as(c_uint, @bitCast(@as(c_int, 10)))]))))))));
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(@as(c_int, @bitCast(@as(c_uint, baseten[utctime.*.off_hh % @as(c_uint, @bitCast(@as(c_int, 10)))]))))))));
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(@as(c_int, @bitCast(@as(c_uint, baseten[(utctime.*.off_mm / @as(c_uint, @bitCast(@as(c_int, 10)))) % @as(c_uint, @bitCast(@as(c_int, 10)))]))))))));
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(@as(c_int, @bitCast(@as(c_uint, baseten[utctime.*.off_mm % @as(c_uint, @bitCast(@as(c_int, 10)))]))))))));
    } else {
        out[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = @as(u8, @bitCast(@as(i8, @truncate(der_ia5_char_encode(@as(c_int, 'Z'))))));
    }
    out[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(x -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))))));
    outlen.* = x;
    return CRYPT_OK;
}
pub export fn der_decode_utctime(arg_in: [*c]const u8, arg_inlen: [*c]c_ulong, arg_out: [*c]ltc_utctime) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var out = arg_out;
    _ = &out;
    var buf: [32]u8 = undefined;
    _ = &buf;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_int = undefined;
    _ = &y;
    if (!(in != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("in != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 19882));
    }
    if (!(inlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("inlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 19883));
    }
    if (!(out != @as([*c]ltc_utctime, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 19884));
    }
    if (((inlen.* < @as(c_ulong, 2)) or (@as(c_ulong, @bitCast(@as(c_ulong, in[@as(c_uint, @intCast(@as(c_int, 1)))]))) >= @sizeOf([32]u8))) or ((@as(c_ulong, @bitCast(@as(c_ulong, in[@as(c_uint, @intCast(@as(c_int, 1)))]))) +% @as(c_ulong, 2)) > inlen.*)) {
        return CRYPT_INVALID_PACKET;
    }
    {
        x = 0;
        while (x < @as(c_ulong, @bitCast(@as(c_ulong, in[@as(c_uint, @intCast(@as(c_int, 1)))])))) : (x +%= 1) {
            y = der_ia5_value_decode(@as(c_int, @bitCast(@as(c_uint, in[x +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))]))));
            if (y == -@as(c_int, 1)) {
                return CRYPT_INVALID_PACKET;
            }
            buf[x] = @as(u8, @bitCast(@as(i8, @truncate(y))));
        }
    }
    inlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2)))) +% x;
    x = 0;
    out.*.YY = @as(c_uint, @bitCast((char_to_int(buf[x]) * @as(c_int, 10)) + char_to_int(buf[x +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))])));
    if (out.*.YY >= @as(c_uint, @bitCast(@as(c_int, 100)))) return CRYPT_INVALID_PACKET;
    x +%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))));
    out.*.MM = @as(c_uint, @bitCast((char_to_int(buf[x]) * @as(c_int, 10)) + char_to_int(buf[x +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))])));
    if (out.*.MM >= @as(c_uint, @bitCast(@as(c_int, 13)))) return CRYPT_INVALID_PACKET;
    x +%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))));
    out.*.DD = @as(c_uint, @bitCast((char_to_int(buf[x]) * @as(c_int, 10)) + char_to_int(buf[x +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))])));
    if (out.*.DD >= @as(c_uint, @bitCast(@as(c_int, 32)))) return CRYPT_INVALID_PACKET;
    x +%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))));
    out.*.hh = @as(c_uint, @bitCast((char_to_int(buf[x]) * @as(c_int, 10)) + char_to_int(buf[x +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))])));
    if (out.*.hh >= @as(c_uint, @bitCast(@as(c_int, 24)))) return CRYPT_INVALID_PACKET;
    x +%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))));
    out.*.mm = @as(c_uint, @bitCast((char_to_int(buf[x]) * @as(c_int, 10)) + char_to_int(buf[x +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))])));
    if (out.*.mm >= @as(c_uint, @bitCast(@as(c_int, 60)))) return CRYPT_INVALID_PACKET;
    x +%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))));
    out.*.off_dir = blk: {
        const tmp = blk_1: {
            const tmp_2 = blk_2: {
                const tmp_3 = @as(c_uint, @bitCast(@as(c_int, 0)));
                out.*.ss = tmp_3;
                break :blk_2 tmp_3;
            };
            out.*.off_mm = tmp_2;
            break :blk_1 tmp_2;
        };
        out.*.off_hh = tmp;
        break :blk tmp;
    };
    if (@as(c_int, @bitCast(@as(c_uint, buf[x]))) == @as(c_int, 'Z')) {
        return CRYPT_OK;
    } else if ((@as(c_int, @bitCast(@as(c_uint, buf[x]))) == @as(c_int, '+')) or (@as(c_int, @bitCast(@as(c_uint, buf[x]))) == @as(c_int, '-'))) {
        out.*.off_dir = @as(c_uint, @bitCast(if (@as(c_int, @bitCast(@as(c_uint, buf[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }]))) == @as(c_int, '+')) @as(c_int, 0) else @as(c_int, 1)));
        out.*.off_hh = @as(c_uint, @bitCast((char_to_int(buf[x]) * @as(c_int, 10)) + char_to_int(buf[x +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))])));
        if (out.*.off_hh >= @as(c_uint, @bitCast(@as(c_int, 24)))) return CRYPT_INVALID_PACKET;
        x +%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))));
        out.*.off_mm = @as(c_uint, @bitCast((char_to_int(buf[x]) * @as(c_int, 10)) + char_to_int(buf[x +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))])));
        if (out.*.off_mm >= @as(c_uint, @bitCast(@as(c_int, 60)))) return CRYPT_INVALID_PACKET;
        x +%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))));
        return CRYPT_OK;
    }
    out.*.ss = @as(c_uint, @bitCast((char_to_int(buf[x]) * @as(c_int, 10)) + char_to_int(buf[x +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))])));
    if (out.*.ss >= @as(c_uint, @bitCast(@as(c_int, 60)))) return CRYPT_INVALID_PACKET;
    x +%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))));
    if (@as(c_int, @bitCast(@as(c_uint, buf[x]))) == @as(c_int, 'Z')) {
        return CRYPT_OK;
    } else if ((@as(c_int, @bitCast(@as(c_uint, buf[x]))) == @as(c_int, '+')) or (@as(c_int, @bitCast(@as(c_uint, buf[x]))) == @as(c_int, '-'))) {
        out.*.off_dir = @as(c_uint, @bitCast(if (@as(c_int, @bitCast(@as(c_uint, buf[blk: {
            const ref = &x;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }]))) == @as(c_int, '+')) @as(c_int, 0) else @as(c_int, 1)));
        out.*.off_hh = @as(c_uint, @bitCast((char_to_int(buf[x]) * @as(c_int, 10)) + char_to_int(buf[x +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))])));
        if (out.*.off_hh >= @as(c_uint, @bitCast(@as(c_int, 24)))) return CRYPT_INVALID_PACKET;
        x +%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))));
        out.*.off_mm = @as(c_uint, @bitCast((char_to_int(buf[x]) * @as(c_int, 10)) + char_to_int(buf[x +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))])));
        if (out.*.off_mm >= @as(c_uint, @bitCast(@as(c_int, 60)))) return CRYPT_INVALID_PACKET;
        x +%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))));
        return CRYPT_OK;
    } else {
        return CRYPT_INVALID_PACKET;
    }
    return 0;
}
pub export fn der_length_utctime(arg_utctime: [*c]ltc_utctime, arg_outlen: [*c]c_ulong) c_int {
    var utctime = arg_utctime;
    _ = &utctime;
    var outlen = arg_outlen;
    _ = &outlen;
    if (!(outlen != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("outlen != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 22712));
    }
    if (!(utctime != @as([*c]ltc_utctime, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("utctime != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 22713));
    }
    if ((utctime.*.off_hh == @as(c_uint, @bitCast(@as(c_int, 0)))) and (utctime.*.off_mm == @as(c_uint, @bitCast(@as(c_int, 0))))) {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2) + @as(c_int, 13))));
    } else {
        outlen.* = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2) + @as(c_int, 17))));
    }
    return CRYPT_OK;
}
pub const ltc_math_descriptor = extern struct {
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    bits_per_digit: c_int = @import("std").mem.zeroes(c_int),
    init: ?*const fn ([*c]?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]?*anyopaque) callconv(.c) c_int),
    init_copy: ?*const fn ([*c]?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    deinit: ?*const fn (?*anyopaque) callconv(.c) void = @import("std").mem.zeroes(?*const fn (?*anyopaque) callconv(.c) void),
    neg: ?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    copy: ?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    set_int: ?*const fn (?*anyopaque, c_ulong) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, c_ulong) callconv(.c) c_int),
    get_int: ?*const fn (?*anyopaque) callconv(.c) c_ulong = @import("std").mem.zeroes(?*const fn (?*anyopaque) callconv(.c) c_ulong),
    get_digit: ?*const fn (?*anyopaque, c_int) callconv(.c) c_ulong = @import("std").mem.zeroes(?*const fn (?*anyopaque, c_int) callconv(.c) c_ulong),
    get_digit_count: ?*const fn (?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque) callconv(.c) c_int),
    compare: ?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    compare_d: ?*const fn (?*anyopaque, c_ulong) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, c_ulong) callconv(.c) c_int),
    count_bits: ?*const fn (?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque) callconv(.c) c_int),
    count_lsb_bits: ?*const fn (?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque) callconv(.c) c_int),
    twoexpt: ?*const fn (?*anyopaque, c_int) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, c_int) callconv(.c) c_int),
    read_radix: ?*const fn (?*anyopaque, [*c]const u8, c_int) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, [*c]const u8, c_int) callconv(.c) c_int),
    write_radix: ?*const fn (?*anyopaque, [*c]u8, c_int) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, [*c]u8, c_int) callconv(.c) c_int),
    unsigned_size: ?*const fn (?*anyopaque) callconv(.c) c_ulong = @import("std").mem.zeroes(?*const fn (?*anyopaque) callconv(.c) c_ulong),
    unsigned_write: ?*const fn (?*anyopaque, [*c]u8) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, [*c]u8) callconv(.c) c_int),
    unsigned_read: ?*const fn (?*anyopaque, [*c]u8, c_ulong) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, [*c]u8, c_ulong) callconv(.c) c_int),
    add: ?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    addi: ?*const fn (?*anyopaque, c_ulong, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, c_ulong, ?*anyopaque) callconv(.c) c_int),
    sub: ?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    subi: ?*const fn (?*anyopaque, c_ulong, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, c_ulong, ?*anyopaque) callconv(.c) c_int),
    mul: ?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    muli: ?*const fn (?*anyopaque, c_ulong, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, c_ulong, ?*anyopaque) callconv(.c) c_int),
    sqr: ?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    mpdiv: ?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    div_2: ?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    modi: ?*const fn (?*anyopaque, c_ulong, [*c]c_ulong) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, c_ulong, [*c]c_ulong) callconv(.c) c_int),
    gcd: ?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    lcm: ?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    mulmod: ?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    sqrmod: ?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    invmod: ?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    montgomery_setup: ?*const fn (?*anyopaque, [*c]?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, [*c]?*anyopaque) callconv(.c) c_int),
    montgomery_normalization: ?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    montgomery_reduce: ?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    montgomery_deinit: ?*const fn (?*anyopaque) callconv(.c) void = @import("std").mem.zeroes(?*const fn (?*anyopaque) callconv(.c) void),
    exptmod: ?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, ?*anyopaque, ?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    isprime: ?*const fn (?*anyopaque, [*c]c_int) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, [*c]c_int) callconv(.c) c_int),
    ecc_ptmul: ?*const fn (?*anyopaque, [*c]ecc_point, [*c]ecc_point, ?*anyopaque, c_int) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*anyopaque, [*c]ecc_point, [*c]ecc_point, ?*anyopaque, c_int) callconv(.c) c_int),
    ecc_ptadd: ?*const fn ([*c]ecc_point, [*c]ecc_point, [*c]ecc_point, ?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]ecc_point, [*c]ecc_point, [*c]ecc_point, ?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    ecc_ptdbl: ?*const fn ([*c]ecc_point, [*c]ecc_point, ?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]ecc_point, [*c]ecc_point, ?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    ecc_map: ?*const fn ([*c]ecc_point, ?*anyopaque, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]ecc_point, ?*anyopaque, ?*anyopaque) callconv(.c) c_int),
    ecc_mul2add: ?*const fn ([*c]ecc_point, ?*anyopaque, [*c]ecc_point, ?*anyopaque, [*c]ecc_point, ?*anyopaque) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]ecc_point, ?*anyopaque, [*c]ecc_point, ?*anyopaque, [*c]ecc_point, ?*anyopaque) callconv(.c) c_int),
    rsa_keygen: ?*const fn ([*c]prng_state, c_int, c_int, c_long, [*c]rsa_key) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]prng_state, c_int, c_int, c_long, [*c]rsa_key) callconv(.c) c_int),
    rsa_me: ?*const fn ([*c]const u8, c_ulong, [*c]u8, [*c]c_ulong, c_int, [*c]rsa_key) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const u8, c_ulong, [*c]u8, [*c]c_ulong, c_int, [*c]rsa_key) callconv(.c) c_int),
};
pub extern var ltc_mp: ltc_math_descriptor;
// ./libtomcrypt.c:26982:5: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn ltc_init_multi(a: [*c]?*anyopaque, ...) c_int;
// ./libtomcrypt.c:27009:6: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn ltc_deinit_multi(a: ?*anyopaque, ...) void;
pub extern const ltm_desc: ltc_math_descriptor;
pub extern fn base64_encode(in: [*c]const u8, len: c_ulong, out: [*c]u8, outlen: [*c]c_ulong) c_int;
pub extern fn base64_decode(in: [*c]const u8, len: c_ulong, out: [*c]u8, outlen: [*c]c_ulong) c_int;
pub export fn zeromem(arg_out: ?*anyopaque, arg_outlen: usize) void {
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var mem: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(out)));
    _ = &mem;
    if (!(out != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("out != ((void*)0)")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 29592));
    }
    while ((blk: {
        const ref = &outlen;
        const tmp = ref.*;
        ref.* -%= 1;
        break :blk tmp;
    }) > @as(usize, @bitCast(@as(c_long, @as(c_int, 0))))) {
        (blk: {
            const ref = &mem;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = 0;
    }
}
pub extern fn burn_stack(len: c_ulong) void;
pub export fn error_to_string(arg_err: c_int) [*c]const u8 {
    var err = arg_err;
    _ = &err;
    if ((err < @as(c_int, 0)) or (err >= @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([24][*c]const u8) / @sizeOf([*c]const u8))))))) {
        return "Invalid error code.";
    } else {
        return err_2_str[@as(c_uint, @intCast(err))];
    }
    return null;
}
// ./libtomcrypt.c:17589:5: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn crypt_fsa(mp: ?*anyopaque, ...) c_int;
pub const LTC_LTC_PKCS_1_EMSA: c_int = 1;
pub const LTC_LTC_PKCS_1_EME: c_int = 2;
pub const enum_ltc_pkcs_1_v1_5_blocks = c_uint;
pub const LTC_LTC_PKCS_1_V1_5: c_int = 1;
pub const LTC_LTC_PKCS_1_OAEP: c_int = 2;
pub const LTC_LTC_PKCS_1_PSS: c_int = 3;
pub const enum_ltc_pkcs_1_paddings = c_uint;
// ./libtomcrypt.c:13660:5: warning: TODO implement translation of stmt class GCCAsmStmtClass

// ./libtomcrypt.c:27106:5: warning: unable to translate function, demoted to extern
pub extern fn pkcs_1_mgf1(arg_hash_idx: c_int, arg_seed: [*c]const u8, arg_seedlen: c_ulong, arg_mask: [*c]u8, arg_masklen: c_ulong) c_int;
pub export fn pkcs_1_i2osp(arg_n: ?*anyopaque, arg_modulus_len: c_ulong, arg_out: [*c]u8) c_int {
    var n = arg_n;
    _ = &n;
    var modulus_len = arg_modulus_len;
    _ = &modulus_len;
    var out = arg_out;
    _ = &out;
    var size: c_ulong = undefined;
    _ = &size;
    size = ltc_mp.unsigned_size.?(n);
    if (size > modulus_len) {
        return CRYPT_BUFFER_OVERFLOW;
    }
    zeromem(@as(?*anyopaque, @ptrCast(out)), modulus_len);
    return ltc_mp.unsigned_write.?(n, out + (modulus_len -% size));
}
pub export fn pkcs_1_os2ip(arg_n: ?*anyopaque, arg_in: [*c]u8, arg_inlen: c_ulong) c_int {
    var n = arg_n;
    _ = &n;
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    return ltc_mp.unsigned_read.?(n, in, inlen);
}
// ./libtomcrypt.c:28116:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:28082:5: warning: unable to translate function, demoted to extern
pub extern fn pkcs_1_v1_5_encode(arg_msg: [*c]const u8, arg_msglen: c_ulong, arg_block_type: c_int, arg_modulus_bitlen: c_ulong, arg_prng: [*c]prng_state, arg_prng_idx: c_int, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int;
// ./libtomcrypt.c:27992:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:27967:5: warning: unable to translate function, demoted to extern
pub extern fn pkcs_1_v1_5_decode(arg_msg: [*c]const u8, arg_msglen: c_ulong, arg_block_type: c_int, arg_modulus_bitlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong, arg_is_valid: [*c]c_int) c_int;
// ./libtomcrypt.c:27461:13: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:27408:5: warning: unable to translate function, demoted to extern
pub extern fn pkcs_1_oaep_encode(arg_msg: [*c]const u8, arg_msglen: c_ulong, arg_lparam: [*c]const u8, arg_lparamlen: c_ulong, arg_modulus_bitlen: c_ulong, arg_prng: [*c]prng_state, arg_prng_idx: c_int, arg_hash_idx: c_int, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int;
// ./libtomcrypt.c:27275:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:27218:5: warning: unable to translate function, demoted to extern
pub extern fn pkcs_1_oaep_decode(arg_msg: [*c]const u8, arg_msglen: c_ulong, arg_lparam: [*c]const u8, arg_lparamlen: c_ulong, arg_modulus_bitlen: c_ulong, arg_hash_idx: c_int, arg_out: [*c]u8, arg_outlen: [*c]c_ulong, arg_res: [*c]c_int) c_int;
// ./libtomcrypt.c:27849:13: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:27793:5: warning: unable to translate function, demoted to extern
pub extern fn pkcs_1_pss_encode(arg_msghash: [*c]const u8, arg_msghashlen: c_ulong, arg_saltlen: c_ulong, arg_prng: [*c]prng_state, arg_prng_idx: c_int, arg_hash_idx: c_int, arg_modulus_bitlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int;
// ./libtomcrypt.c:27668:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:27615:5: warning: unable to translate function, demoted to extern
pub extern fn pkcs_1_pss_decode(arg_msghash: [*c]const u8, arg_msghashlen: c_ulong, arg_sig: [*c]const u8, arg_siglen: c_ulong, arg_saltlen: c_ulong, arg_hash_idx: c_int, arg_modulus_bitlen: c_ulong, arg_res: [*c]c_int) c_int;
pub extern fn pkcs_5_alg1(password: [*c]const u8, password_len: c_ulong, salt: [*c]const u8, iteration_count: c_int, hash_idx: c_int, out: [*c]u8, outlen: [*c]c_ulong) c_int;
pub extern fn pkcs_5_alg2(password: [*c]const u8, password_len: c_ulong, salt: [*c]const u8, salt_len: c_ulong, iteration_count: c_int, hash_idx: c_int, out: [*c]u8, outlen: [*c]c_ulong) c_int;
pub fn fetch_length(arg_in: [*c]const u8, arg_inlen: c_ulong) callconv(.c) c_ulong {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var x: c_ulong = undefined;
    _ = &x;
    var y: c_ulong = undefined;
    _ = &y;
    var z: c_ulong = undefined;
    _ = &z;
    y = 0;
    if (inlen < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))) {
        return @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, 4294967295))));
    }
    in += 1;
    y +%= 1;
    x = @as(c_ulong, @bitCast(@as(c_ulong, (blk: {
        const ref = &in;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }).*)));
    y +%= 1;
    if (x < @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 128))))) {
        return x +% y;
    }
    x &= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 127))));
    inlen -%= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))));
    if (((x == @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) or (x > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4)))))) or (x > inlen)) {
        return @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, 4294967295))));
    }
    y +%= x;
    z = 0;
    while ((blk: {
        const ref = &x;
        const tmp = ref.*;
        ref.* -%= 1;
        break :blk tmp;
    }) != 0) {
        z = (z << @intCast(8)) | @as(c_ulong, @bitCast(@as(c_ulong, in.*)));
        in += 1;
    }
    return z +% y;
}
pub fn char_to_int(arg_x: u8) callconv(.c) c_int {
    var x = arg_x;
    _ = &x;
    while (true) {
        switch (@as(c_int, @bitCast(@as(c_uint, x)))) {
            @as(c_int, 48) => return 0,
            @as(c_int, 49) => return 1,
            @as(c_int, 50) => return 2,
            @as(c_int, 51) => return 3,
            @as(c_int, 52) => return 4,
            @as(c_int, 53) => return 5,
            @as(c_int, 54) => return 6,
            @as(c_int, 55) => return 7,
            @as(c_int, 56) => return 8,
            @as(c_int, 57) => return 9,
            else => {},
        }
        break;
    }
    return 100;
}
pub fn ltc_to_asn1(arg_v: c_int) callconv(.c) c_int {
    var v = arg_v;
    _ = &v;
    while (true) {
        switch (v) {
            @as(c_int, 1) => return 1,
            @as(c_int, 2), @as(c_int, 3) => return 2,
            @as(c_int, 4) => return 3,
            @as(c_int, 5) => return 4,
            @as(c_int, 6) => return 5,
            @as(c_int, 7) => return 6,
            @as(c_int, 10) => return 12,
            @as(c_int, 9) => return 19,
            @as(c_int, 8) => return 22,
            @as(c_int, 11) => return 23,
            @as(c_int, 13) => return 48,
            @as(c_int, 14), @as(c_int, 15) => return 49,
            else => return -@as(c_int, 1),
        }
        break;
    }
    return 0;
}
pub fn qsort_helper_set(arg_a: ?*const anyopaque, arg_b: ?*const anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var A_1: [*c]ltc_asn1_list = @as([*c]ltc_asn1_list, @ptrCast(@volatileCast(@constCast(a))));
    _ = &A_1;
    var B: [*c]ltc_asn1_list = @as([*c]ltc_asn1_list, @ptrCast(@volatileCast(@constCast(b))));
    _ = &B;
    var r: c_int = undefined;
    _ = &r;
    r = ltc_to_asn1(A_1.*.type) - ltc_to_asn1(B.*.type);
    if (r == @as(c_int, 0)) {
        return A_1.*.used - B.*.used;
    } else {
        return r;
    }
    return 0;
}
pub fn qsort_helper(arg_a: ?*const anyopaque, arg_b: ?*const anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var A_1: [*c]struct_edge = @as([*c]struct_edge, @ptrCast(@volatileCast(@constCast(a))));
    _ = &A_1;
    var B: [*c]struct_edge = @as([*c]struct_edge, @ptrCast(@volatileCast(@constCast(b))));
    _ = &B;
    var r: c_int = undefined;
    _ = &r;
    var x: c_ulong = undefined;
    _ = &x;
    r = memcmp(@as(?*const anyopaque, @ptrCast(A_1.*.start)), @as(?*const anyopaque, @ptrCast(B.*.start)), if (A_1.*.size < B.*.size) A_1.*.size else B.*.size);
    if ((r == @as(c_int, 0)) and (A_1.*.size != B.*.size)) {
        if (A_1.*.size > B.*.size) {
            {
                x = B.*.size;
                while (x < A_1.*.size) : (x +%= 1) {
                    if (A_1.*.start[x] != 0) {
                        return 1;
                    }
                }
            }
        } else {
            {
                x = A_1.*.size;
                while (x < B.*.size) : (x +%= 1) {
                    if (B.*.start[x] != 0) {
                        return -@as(c_int, 1);
                    }
                }
            }
        }
    }
    return r;
}
pub const baseten: [10:0]u8 = "0123456789".*;
pub const ia5_table: [102]struct_unnamed_51 = [102]struct_unnamed_51{
    struct_unnamed_51{
        .code = @as(c_int, '\x00'),
        .value = @as(c_int, 0),
    },
    struct_unnamed_51{
        .code = @as(c_int, '\x07'),
        .value = @as(c_int, 7),
    },
    struct_unnamed_51{
        .code = @as(c_int, '\x08'),
        .value = @as(c_int, 8),
    },
    struct_unnamed_51{
        .code = @as(c_int, '\t'),
        .value = @as(c_int, 9),
    },
    struct_unnamed_51{
        .code = @as(c_int, '\n'),
        .value = @as(c_int, 10),
    },
    struct_unnamed_51{
        .code = @as(c_int, '\x0c'),
        .value = @as(c_int, 12),
    },
    struct_unnamed_51{
        .code = @as(c_int, '\r'),
        .value = @as(c_int, 13),
    },
    struct_unnamed_51{
        .code = @as(c_int, ' '),
        .value = @as(c_int, 32),
    },
    struct_unnamed_51{
        .code = @as(c_int, '!'),
        .value = @as(c_int, 33),
    },
    struct_unnamed_51{
        .code = @as(c_int, '"'),
        .value = @as(c_int, 34),
    },
    struct_unnamed_51{
        .code = @as(c_int, '#'),
        .value = @as(c_int, 35),
    },
    struct_unnamed_51{
        .code = @as(c_int, '$'),
        .value = @as(c_int, 36),
    },
    struct_unnamed_51{
        .code = @as(c_int, '%'),
        .value = @as(c_int, 37),
    },
    struct_unnamed_51{
        .code = @as(c_int, '&'),
        .value = @as(c_int, 38),
    },
    struct_unnamed_51{
        .code = @as(c_int, '\''),
        .value = @as(c_int, 39),
    },
    struct_unnamed_51{
        .code = @as(c_int, '('),
        .value = @as(c_int, 40),
    },
    struct_unnamed_51{
        .code = @as(c_int, ')'),
        .value = @as(c_int, 41),
    },
    struct_unnamed_51{
        .code = @as(c_int, '*'),
        .value = @as(c_int, 42),
    },
    struct_unnamed_51{
        .code = @as(c_int, '+'),
        .value = @as(c_int, 43),
    },
    struct_unnamed_51{
        .code = @as(c_int, ','),
        .value = @as(c_int, 44),
    },
    struct_unnamed_51{
        .code = @as(c_int, '-'),
        .value = @as(c_int, 45),
    },
    struct_unnamed_51{
        .code = @as(c_int, '.'),
        .value = @as(c_int, 46),
    },
    struct_unnamed_51{
        .code = @as(c_int, '/'),
        .value = @as(c_int, 47),
    },
    struct_unnamed_51{
        .code = @as(c_int, '0'),
        .value = @as(c_int, 48),
    },
    struct_unnamed_51{
        .code = @as(c_int, '1'),
        .value = @as(c_int, 49),
    },
    struct_unnamed_51{
        .code = @as(c_int, '2'),
        .value = @as(c_int, 50),
    },
    struct_unnamed_51{
        .code = @as(c_int, '3'),
        .value = @as(c_int, 51),
    },
    struct_unnamed_51{
        .code = @as(c_int, '4'),
        .value = @as(c_int, 52),
    },
    struct_unnamed_51{
        .code = @as(c_int, '5'),
        .value = @as(c_int, 53),
    },
    struct_unnamed_51{
        .code = @as(c_int, '6'),
        .value = @as(c_int, 54),
    },
    struct_unnamed_51{
        .code = @as(c_int, '7'),
        .value = @as(c_int, 55),
    },
    struct_unnamed_51{
        .code = @as(c_int, '8'),
        .value = @as(c_int, 56),
    },
    struct_unnamed_51{
        .code = @as(c_int, '9'),
        .value = @as(c_int, 57),
    },
    struct_unnamed_51{
        .code = @as(c_int, ':'),
        .value = @as(c_int, 58),
    },
    struct_unnamed_51{
        .code = @as(c_int, ';'),
        .value = @as(c_int, 59),
    },
    struct_unnamed_51{
        .code = @as(c_int, '<'),
        .value = @as(c_int, 60),
    },
    struct_unnamed_51{
        .code = @as(c_int, '='),
        .value = @as(c_int, 61),
    },
    struct_unnamed_51{
        .code = @as(c_int, '>'),
        .value = @as(c_int, 62),
    },
    struct_unnamed_51{
        .code = @as(c_int, '?'),
        .value = @as(c_int, 63),
    },
    struct_unnamed_51{
        .code = @as(c_int, '@'),
        .value = @as(c_int, 64),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'A'),
        .value = @as(c_int, 65),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'B'),
        .value = @as(c_int, 66),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'C'),
        .value = @as(c_int, 67),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'D'),
        .value = @as(c_int, 68),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'E'),
        .value = @as(c_int, 69),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'F'),
        .value = @as(c_int, 70),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'G'),
        .value = @as(c_int, 71),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'H'),
        .value = @as(c_int, 72),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'I'),
        .value = @as(c_int, 73),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'J'),
        .value = @as(c_int, 74),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'K'),
        .value = @as(c_int, 75),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'L'),
        .value = @as(c_int, 76),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'M'),
        .value = @as(c_int, 77),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'N'),
        .value = @as(c_int, 78),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'O'),
        .value = @as(c_int, 79),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'P'),
        .value = @as(c_int, 80),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'Q'),
        .value = @as(c_int, 81),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'R'),
        .value = @as(c_int, 82),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'S'),
        .value = @as(c_int, 83),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'T'),
        .value = @as(c_int, 84),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'U'),
        .value = @as(c_int, 85),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'V'),
        .value = @as(c_int, 86),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'W'),
        .value = @as(c_int, 87),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'X'),
        .value = @as(c_int, 88),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'Y'),
        .value = @as(c_int, 89),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'Z'),
        .value = @as(c_int, 90),
    },
    struct_unnamed_51{
        .code = @as(c_int, '['),
        .value = @as(c_int, 91),
    },
    struct_unnamed_51{
        .code = @as(c_int, '\\'),
        .value = @as(c_int, 92),
    },
    struct_unnamed_51{
        .code = @as(c_int, ']'),
        .value = @as(c_int, 93),
    },
    struct_unnamed_51{
        .code = @as(c_int, '^'),
        .value = @as(c_int, 94),
    },
    struct_unnamed_51{
        .code = @as(c_int, '_'),
        .value = @as(c_int, 95),
    },
    struct_unnamed_51{
        .code = @as(c_int, '`'),
        .value = @as(c_int, 96),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'a'),
        .value = @as(c_int, 97),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'b'),
        .value = @as(c_int, 98),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'c'),
        .value = @as(c_int, 99),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'd'),
        .value = @as(c_int, 100),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'e'),
        .value = @as(c_int, 101),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'f'),
        .value = @as(c_int, 102),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'g'),
        .value = @as(c_int, 103),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'h'),
        .value = @as(c_int, 104),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'i'),
        .value = @as(c_int, 105),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'j'),
        .value = @as(c_int, 106),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'k'),
        .value = @as(c_int, 107),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'l'),
        .value = @as(c_int, 108),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'm'),
        .value = @as(c_int, 109),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'n'),
        .value = @as(c_int, 110),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'o'),
        .value = @as(c_int, 111),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'p'),
        .value = @as(c_int, 112),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'q'),
        .value = @as(c_int, 113),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'r'),
        .value = @as(c_int, 114),
    },
    struct_unnamed_51{
        .code = @as(c_int, 's'),
        .value = @as(c_int, 115),
    },
    struct_unnamed_51{
        .code = @as(c_int, 't'),
        .value = @as(c_int, 116),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'u'),
        .value = @as(c_int, 117),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'v'),
        .value = @as(c_int, 118),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'w'),
        .value = @as(c_int, 119),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'x'),
        .value = @as(c_int, 120),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'y'),
        .value = @as(c_int, 121),
    },
    struct_unnamed_51{
        .code = @as(c_int, 'z'),
        .value = @as(c_int, 122),
    },
    struct_unnamed_51{
        .code = @as(c_int, '{'),
        .value = @as(c_int, 123),
    },
    struct_unnamed_51{
        .code = @as(c_int, '|'),
        .value = @as(c_int, 124),
    },
    struct_unnamed_51{
        .code = @as(c_int, '}'),
        .value = @as(c_int, 125),
    },
    struct_unnamed_51{
        .code = @as(c_int, '~'),
        .value = @as(c_int, 126),
    },
};
pub const printable_table: [74]struct_unnamed_52 = [74]struct_unnamed_52{
    struct_unnamed_52{
        .code = @as(c_int, ' '),
        .value = @as(c_int, 32),
    },
    struct_unnamed_52{
        .code = @as(c_int, '\''),
        .value = @as(c_int, 39),
    },
    struct_unnamed_52{
        .code = @as(c_int, '('),
        .value = @as(c_int, 40),
    },
    struct_unnamed_52{
        .code = @as(c_int, ')'),
        .value = @as(c_int, 41),
    },
    struct_unnamed_52{
        .code = @as(c_int, '+'),
        .value = @as(c_int, 43),
    },
    struct_unnamed_52{
        .code = @as(c_int, ','),
        .value = @as(c_int, 44),
    },
    struct_unnamed_52{
        .code = @as(c_int, '-'),
        .value = @as(c_int, 45),
    },
    struct_unnamed_52{
        .code = @as(c_int, '.'),
        .value = @as(c_int, 46),
    },
    struct_unnamed_52{
        .code = @as(c_int, '/'),
        .value = @as(c_int, 47),
    },
    struct_unnamed_52{
        .code = @as(c_int, '0'),
        .value = @as(c_int, 48),
    },
    struct_unnamed_52{
        .code = @as(c_int, '1'),
        .value = @as(c_int, 49),
    },
    struct_unnamed_52{
        .code = @as(c_int, '2'),
        .value = @as(c_int, 50),
    },
    struct_unnamed_52{
        .code = @as(c_int, '3'),
        .value = @as(c_int, 51),
    },
    struct_unnamed_52{
        .code = @as(c_int, '4'),
        .value = @as(c_int, 52),
    },
    struct_unnamed_52{
        .code = @as(c_int, '5'),
        .value = @as(c_int, 53),
    },
    struct_unnamed_52{
        .code = @as(c_int, '6'),
        .value = @as(c_int, 54),
    },
    struct_unnamed_52{
        .code = @as(c_int, '7'),
        .value = @as(c_int, 55),
    },
    struct_unnamed_52{
        .code = @as(c_int, '8'),
        .value = @as(c_int, 56),
    },
    struct_unnamed_52{
        .code = @as(c_int, '9'),
        .value = @as(c_int, 57),
    },
    struct_unnamed_52{
        .code = @as(c_int, ':'),
        .value = @as(c_int, 58),
    },
    struct_unnamed_52{
        .code = @as(c_int, '='),
        .value = @as(c_int, 61),
    },
    struct_unnamed_52{
        .code = @as(c_int, '?'),
        .value = @as(c_int, 63),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'A'),
        .value = @as(c_int, 65),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'B'),
        .value = @as(c_int, 66),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'C'),
        .value = @as(c_int, 67),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'D'),
        .value = @as(c_int, 68),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'E'),
        .value = @as(c_int, 69),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'F'),
        .value = @as(c_int, 70),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'G'),
        .value = @as(c_int, 71),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'H'),
        .value = @as(c_int, 72),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'I'),
        .value = @as(c_int, 73),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'J'),
        .value = @as(c_int, 74),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'K'),
        .value = @as(c_int, 75),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'L'),
        .value = @as(c_int, 76),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'M'),
        .value = @as(c_int, 77),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'N'),
        .value = @as(c_int, 78),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'O'),
        .value = @as(c_int, 79),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'P'),
        .value = @as(c_int, 80),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'Q'),
        .value = @as(c_int, 81),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'R'),
        .value = @as(c_int, 82),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'S'),
        .value = @as(c_int, 83),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'T'),
        .value = @as(c_int, 84),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'U'),
        .value = @as(c_int, 85),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'V'),
        .value = @as(c_int, 86),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'W'),
        .value = @as(c_int, 87),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'X'),
        .value = @as(c_int, 88),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'Y'),
        .value = @as(c_int, 89),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'Z'),
        .value = @as(c_int, 90),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'a'),
        .value = @as(c_int, 97),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'b'),
        .value = @as(c_int, 98),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'c'),
        .value = @as(c_int, 99),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'd'),
        .value = @as(c_int, 100),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'e'),
        .value = @as(c_int, 101),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'f'),
        .value = @as(c_int, 102),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'g'),
        .value = @as(c_int, 103),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'h'),
        .value = @as(c_int, 104),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'i'),
        .value = @as(c_int, 105),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'j'),
        .value = @as(c_int, 106),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'k'),
        .value = @as(c_int, 107),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'l'),
        .value = @as(c_int, 108),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'm'),
        .value = @as(c_int, 109),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'n'),
        .value = @as(c_int, 110),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'o'),
        .value = @as(c_int, 111),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'p'),
        .value = @as(c_int, 112),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'q'),
        .value = @as(c_int, 113),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'r'),
        .value = @as(c_int, 114),
    },
    struct_unnamed_52{
        .code = @as(c_int, 's'),
        .value = @as(c_int, 115),
    },
    struct_unnamed_52{
        .code = @as(c_int, 't'),
        .value = @as(c_int, 116),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'u'),
        .value = @as(c_int, 117),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'v'),
        .value = @as(c_int, 118),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'w'),
        .value = @as(c_int, 119),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'x'),
        .value = @as(c_int, 120),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'y'),
        .value = @as(c_int, 121),
    },
    struct_unnamed_52{
        .code = @as(c_int, 'z'),
        .value = @as(c_int, 122),
    },
};
// ./libtomcrypt.c:23675:9: warning: TODO implement translation of stmt class GotoStmtClass

// ./libtomcrypt.c:23665:12: warning: unable to translate function, demoted to extern
pub extern fn is_point(arg_key: [*c]ecc_key) callconv(.c) c_int;
pub const err_2_str: [24][*c]const u8 = [24][*c]const u8{
    "CRYPT_OK",
    "CRYPT_ERROR",
    "Non-fatal 'no-operation' requested.",
    "Invalid keysize for block cipher.",
    "Invalid number of rounds for block cipher.",
    "Algorithm failed test vectors.",
    "Buffer overflow.",
    "Invalid input packet.",
    "Invalid number of bits for a PRNG.",
    "Error reading the PRNG.",
    "Invalid cipher specified.",
    "Invalid hash specified.",
    "Invalid PRNG specified.",
    "Out of memory.",
    "Invalid PK key or key type specified for function.",
    "A private PK key is required.",
    "Invalid argument provided.",
    "File Not Found",
    "Invalid PK type.",
    "Invalid PK system.",
    "Duplicate PK key found on keyring.",
    "Key not found in keyring.",
    "Invalid sized parameter.",
    "Invalid size for prime.",
};
const struct_unnamed_53 = extern struct {
    mpi_code: c_int = @import("std").mem.zeroes(c_int),
    ltc_code: c_int = @import("std").mem.zeroes(c_int),
};
pub const mpi_to_ltc_codes: [3]struct_unnamed_53 = [3]struct_unnamed_53{
    struct_unnamed_53{
        .mpi_code = @as(c_int, 0),
        .ltc_code = CRYPT_OK,
    },
    struct_unnamed_53{
        .mpi_code = -@as(c_int, 2),
        .ltc_code = CRYPT_MEM,
    },
    struct_unnamed_53{
        .mpi_code = -@as(c_int, 3),
        .ltc_code = CRYPT_INVALID_ARG,
    },
};
pub fn mpi_to_ltc_error(arg_err: c_int) callconv(.c) c_int {
    var err = arg_err;
    _ = &err;
    var x: c_int = undefined;
    _ = &x;
    {
        x = 0;
        while (x < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([3]struct_unnamed_53) / @sizeOf(struct_unnamed_53)))))) : (x += 1) {
            if (err == mpi_to_ltc_codes[@as(c_uint, @intCast(x))].mpi_code) {
                return mpi_to_ltc_codes[@as(c_uint, @intCast(x))].ltc_code;
            }
        }
    }
    return CRYPT_ERROR;
}
pub fn init(arg_a: [*c]?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var err: c_int = undefined;
    _ = &err;
    if (!(a != @as([*c]?*anyopaque, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26498));
    }
    a.* = calloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))), @sizeOf(mp_int));
    if (a.* == @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))) {
        return CRYPT_MEM;
    }
    if ((blk: {
        const tmp = mpi_to_ltc_error(mp_init(@as([*c]mp_int, @ptrCast(@alignCast(a.*)))));
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        free(a.*);
    }
    return err;
}
pub fn deinit(arg_a: ?*anyopaque) callconv(.c) void {
    var a = arg_a;
    _ = &a;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != ((void*)0)")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26511));
    }
    mp_clear(@as([*c]mp_int, @ptrCast(@alignCast(a))));
    free(a);
}
pub fn neg(arg_a: ?*anyopaque, arg_b: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26517));
    }
    if (!(b != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26518));
    }
    return mpi_to_ltc_error(mp_neg(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as([*c]mp_int, @ptrCast(@alignCast(b)))));
}
pub fn copy(arg_a: ?*anyopaque, arg_b: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26523));
    }
    if (!(b != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26524));
    }
    return mpi_to_ltc_error(mp_copy(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as([*c]mp_int, @ptrCast(@alignCast(b)))));
}
pub fn init_copy(arg_a: [*c]?*anyopaque, arg_b: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    if (init(a) != CRYPT_OK) {
        return CRYPT_MEM;
    }
    return copy(b, a.*);
}
pub fn set_int(arg_a: ?*anyopaque, arg_b: c_ulong) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26537));
    }
    return mpi_to_ltc_error(mp_set_int(@as([*c]mp_int, @ptrCast(@alignCast(a))), b));
}
pub fn get_int(arg_a: ?*anyopaque) callconv(.c) c_ulong {
    var a = arg_a;
    _ = &a;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26542));
    }
    return mp_get_int(@as([*c]mp_int, @ptrCast(@alignCast(a))));
}
pub fn get_digit(arg_a: ?*anyopaque, arg_n: c_int) callconv(.c) c_ulong {
    var a = arg_a;
    _ = &a;
    var n = arg_n;
    _ = &n;
    var A_1: [*c]mp_int = undefined;
    _ = &A_1;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26549));
    }
    A_1 = @as([*c]mp_int, @ptrCast(@alignCast(a)));
    return if ((n >= A_1.*.used) or (n < @as(c_int, 0))) @as(mp_digit, @bitCast(@as(c_long, @as(c_int, 0)))) else (blk: {
        const tmp = n;
        if (tmp >= 0) break :blk A_1.*.dp + @as(usize, @intCast(tmp)) else break :blk A_1.*.dp - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
}
pub fn get_digit_count(arg_a: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var A_1: [*c]mp_int = undefined;
    _ = &A_1;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26557));
    }
    A_1 = @as([*c]mp_int, @ptrCast(@alignCast(a)));
    return A_1.*.used;
}
pub fn compare(arg_a: ?*anyopaque, arg_b: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var ret: c_int = undefined;
    _ = &ret;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26565));
    }
    if (!(b != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26566));
    }
    ret = mp_cmp(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as([*c]mp_int, @ptrCast(@alignCast(b))));
    while (true) {
        switch (ret) {
            @as(c_int, -1) => return -@as(c_int, 1),
            @as(c_int, 0) => return 0,
            @as(c_int, 1) => return 1,
            else => {},
        }
        break;
    }
    return 0;
}
pub fn compare_d(arg_a: ?*anyopaque, arg_b: c_ulong) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var ret: c_int = undefined;
    _ = &ret;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26584));
    }
    ret = mp_cmp_d(@as([*c]mp_int, @ptrCast(@alignCast(a))), b);
    while (true) {
        switch (ret) {
            @as(c_int, -1) => return -@as(c_int, 1),
            @as(c_int, 0) => return 0,
            @as(c_int, 1) => return 1,
            else => {},
        }
        break;
    }
    return 0;
}
pub fn count_bits(arg_a: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26600));
    }
    return mp_count_bits(@as([*c]mp_int, @ptrCast(@alignCast(a))));
}
pub fn count_lsb_bits(arg_a: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26605));
    }
    return mp_cnt_lsb(@as([*c]mp_int, @ptrCast(@alignCast(a))));
}
pub fn twoexpt(arg_a: ?*anyopaque, arg_n: c_int) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var n = arg_n;
    _ = &n;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26610));
    }
    return mpi_to_ltc_error(mp_2expt(@as([*c]mp_int, @ptrCast(@alignCast(a))), n));
}
pub fn read_radix(arg_a: ?*anyopaque, arg_b: [*c]const u8, arg_radix: c_int) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var radix = arg_radix;
    _ = &radix;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26618));
    }
    if (!(b != @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26619));
    }
    return mpi_to_ltc_error(mp_read_radix(@as([*c]mp_int, @ptrCast(@alignCast(a))), b, radix));
}
pub fn write_radix(arg_a: ?*anyopaque, arg_b: [*c]u8, arg_radix: c_int) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var radix = arg_radix;
    _ = &radix;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26625));
    }
    if (!(b != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26626));
    }
    return mpi_to_ltc_error(mp_toradix(@as([*c]mp_int, @ptrCast(@alignCast(a))), b, radix));
}
pub fn unsigned_size(arg_a: ?*anyopaque) callconv(.c) c_ulong {
    var a = arg_a;
    _ = &a;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26632));
    }
    return @as(c_ulong, @bitCast(@as(c_long, mp_unsigned_bin_size(@as([*c]mp_int, @ptrCast(@alignCast(a)))))));
}
pub fn unsigned_write(arg_a: ?*anyopaque, arg_b: [*c]u8) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26638));
    }
    if (!(b != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26639));
    }
    return mpi_to_ltc_error(mp_to_unsigned_bin(@as([*c]mp_int, @ptrCast(@alignCast(a))), b));
}
pub fn unsigned_read(arg_a: ?*anyopaque, arg_b: [*c]u8, arg_len: c_ulong) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var len = arg_len;
    _ = &len;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26645));
    }
    if (!(b != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26646));
    }
    return mpi_to_ltc_error(mp_read_unsigned_bin(@as([*c]mp_int, @ptrCast(@alignCast(a))), b, @as(c_int, @bitCast(@as(c_uint, @truncate(len))))));
}
pub fn add(arg_a: ?*anyopaque, arg_b: ?*anyopaque, arg_c: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26652));
    }
    if (!(b != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26653));
    }
    if (!(c != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26654));
    }
    return mpi_to_ltc_error(mp_add(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as([*c]mp_int, @ptrCast(@alignCast(b))), @as([*c]mp_int, @ptrCast(@alignCast(c)))));
}
pub fn addi(arg_a: ?*anyopaque, arg_b: c_ulong, arg_c: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26659));
    }
    if (!(c != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26660));
    }
    return mpi_to_ltc_error(mp_add_d(@as([*c]mp_int, @ptrCast(@alignCast(a))), b, @as([*c]mp_int, @ptrCast(@alignCast(c)))));
}
pub fn sub(arg_a: ?*anyopaque, arg_b: ?*anyopaque, arg_c: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26666));
    }
    if (!(b != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26667));
    }
    if (!(c != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26668));
    }
    return mpi_to_ltc_error(mp_sub(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as([*c]mp_int, @ptrCast(@alignCast(b))), @as([*c]mp_int, @ptrCast(@alignCast(c)))));
}
pub fn subi(arg_a: ?*anyopaque, arg_b: c_ulong, arg_c: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26673));
    }
    if (!(c != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26674));
    }
    return mpi_to_ltc_error(mp_sub_d(@as([*c]mp_int, @ptrCast(@alignCast(a))), b, @as([*c]mp_int, @ptrCast(@alignCast(c)))));
}
pub fn mul(arg_a: ?*anyopaque, arg_b: ?*anyopaque, arg_c: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26680));
    }
    if (!(b != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26681));
    }
    if (!(c != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26682));
    }
    return mpi_to_ltc_error(mp_mul(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as([*c]mp_int, @ptrCast(@alignCast(b))), @as([*c]mp_int, @ptrCast(@alignCast(c)))));
}
pub fn muli(arg_a: ?*anyopaque, arg_b: c_ulong, arg_c: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26687));
    }
    if (!(c != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26688));
    }
    return mpi_to_ltc_error(mp_mul_d(@as([*c]mp_int, @ptrCast(@alignCast(a))), b, @as([*c]mp_int, @ptrCast(@alignCast(c)))));
}
pub fn sqr(arg_a: ?*anyopaque, arg_b: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26694));
    }
    if (!(b != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26695));
    }
    return mpi_to_ltc_error(mp_sqr(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as([*c]mp_int, @ptrCast(@alignCast(b)))));
}
pub fn divide(arg_a: ?*anyopaque, arg_b: ?*anyopaque, arg_c: ?*anyopaque, arg_d: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var d = arg_d;
    _ = &d;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26701));
    }
    if (!(b != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26702));
    }
    return mpi_to_ltc_error(mp_div(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as([*c]mp_int, @ptrCast(@alignCast(b))), @as([*c]mp_int, @ptrCast(@alignCast(c))), @as([*c]mp_int, @ptrCast(@alignCast(d)))));
}
pub fn div_2(arg_a: ?*anyopaque, arg_b: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26707));
    }
    if (!(b != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26708));
    }
    return mpi_to_ltc_error(mp_div_2(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as([*c]mp_int, @ptrCast(@alignCast(b)))));
}
pub fn modi(arg_a: ?*anyopaque, arg_b: c_ulong, arg_c: [*c]c_ulong) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var tmp: mp_digit = undefined;
    _ = &tmp;
    var err: c_int = undefined;
    _ = &err;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26717));
    }
    if (!(c != @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26718));
    }
    if ((blk: {
        const tmp_1 = mpi_to_ltc_error(mp_mod_d(@as([*c]mp_int, @ptrCast(@alignCast(a))), b, &tmp));
        err = tmp_1;
        break :blk tmp_1;
    }) != CRYPT_OK) {
        return err;
    }
    c.* = tmp;
    return CRYPT_OK;
}
pub fn gcd(arg_a: ?*anyopaque, arg_b: ?*anyopaque, arg_c: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26729));
    }
    if (!(b != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26730));
    }
    if (!(c != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26731));
    }
    return mpi_to_ltc_error(mp_gcd(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as([*c]mp_int, @ptrCast(@alignCast(b))), @as([*c]mp_int, @ptrCast(@alignCast(c)))));
}
pub fn lcm(arg_a: ?*anyopaque, arg_b: ?*anyopaque, arg_c: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26737));
    }
    if (!(b != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26738));
    }
    if (!(c != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26739));
    }
    return mpi_to_ltc_error(mp_lcm(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as([*c]mp_int, @ptrCast(@alignCast(b))), @as([*c]mp_int, @ptrCast(@alignCast(c)))));
}
pub fn mulmod(arg_a: ?*anyopaque, arg_b: ?*anyopaque, arg_c: ?*anyopaque, arg_d: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var d = arg_d;
    _ = &d;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26744));
    }
    if (!(b != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26745));
    }
    if (!(c != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26746));
    }
    if (!(d != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("d != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26747));
    }
    return mpi_to_ltc_error(mp_mulmod(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as([*c]mp_int, @ptrCast(@alignCast(b))), @as([*c]mp_int, @ptrCast(@alignCast(c))), @as([*c]mp_int, @ptrCast(@alignCast(d)))));
}
pub fn sqrmod(arg_a: ?*anyopaque, arg_b: ?*anyopaque, arg_c: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26752));
    }
    if (!(b != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26753));
    }
    if (!(c != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26754));
    }
    return mpi_to_ltc_error(mp_sqrmod(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as([*c]mp_int, @ptrCast(@alignCast(b))), @as([*c]mp_int, @ptrCast(@alignCast(c)))));
}
pub fn invmod(arg_a: ?*anyopaque, arg_b: ?*anyopaque, arg_c: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26760));
    }
    if (!(b != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26761));
    }
    if (!(c != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26762));
    }
    return mpi_to_ltc_error(mp_invmod(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as([*c]mp_int, @ptrCast(@alignCast(b))), @as([*c]mp_int, @ptrCast(@alignCast(c)))));
}
pub fn montgomery_setup(arg_a: ?*anyopaque, arg_b: [*c]?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var err: c_int = undefined;
    _ = &err;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26770));
    }
    if (!(b != @as([*c]?*anyopaque, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26771));
    }
    b.* = calloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))), @sizeOf(mp_digit));
    if (b.* == @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))) {
        return CRYPT_MEM;
    }
    if ((blk: {
        const tmp = mpi_to_ltc_error(mp_montgomery_setup(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as([*c]mp_digit, @ptrCast(@alignCast(b.*)))));
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        free(b.*);
    }
    return err;
}
pub fn montgomery_normalization(arg_a: ?*anyopaque, arg_b: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26784));
    }
    if (!(b != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26785));
    }
    return mpi_to_ltc_error(mp_montgomery_calc_normalization(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as([*c]mp_int, @ptrCast(@alignCast(b)))));
}
pub fn montgomery_reduce(arg_a: ?*anyopaque, arg_b: ?*anyopaque, arg_c: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26791));
    }
    if (!(b != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26792));
    }
    if (!(c != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26793));
    }
    return mpi_to_ltc_error(mp_montgomery_reduce(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as([*c]mp_int, @ptrCast(@alignCast(b))), @as([*c]mp_digit, @ptrCast(@alignCast(c))).*));
}
pub fn montgomery_deinit(arg_a: ?*anyopaque) callconv(.c) void {
    var a = arg_a;
    _ = &a;
    free(a);
}
pub fn exptmod(arg_a: ?*anyopaque, arg_b: ?*anyopaque, arg_c: ?*anyopaque, arg_d: ?*anyopaque) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var c = arg_c;
    _ = &c;
    var d = arg_d;
    _ = &d;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26803));
    }
    if (!(b != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26804));
    }
    if (!(c != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26805));
    }
    if (!(d != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("d != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26806));
    }
    return mpi_to_ltc_error(mp_exptmod(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as([*c]mp_int, @ptrCast(@alignCast(b))), @as([*c]mp_int, @ptrCast(@alignCast(c))), @as([*c]mp_int, @ptrCast(@alignCast(d)))));
}
pub fn isprime(arg_a: ?*anyopaque, arg_b: [*c]c_int) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    var err: c_int = undefined;
    _ = &err;
    if (!(a != @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26813));
    }
    if (!(b != @as([*c]c_int, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
        crypt_argchk(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b != NULL")))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("./libtomcrypt.c")))), @as(c_int, 26814));
    }
    err = mpi_to_ltc_error(mp_prime_is_prime(@as([*c]mp_int, @ptrCast(@alignCast(a))), @as(c_int, 8), b));
    b.* = if (b.* == @as(c_int, 1)) @as(c_int, 1) else @as(c_int, 0);
    return err;
}
pub fn rng_nix(arg_buf: [*c]u8, arg_len: c_ulong, arg_callback: ?*const fn () callconv(.c) void) callconv(.c) c_ulong {
    var buf = arg_buf;
    _ = &buf;
    var len = arg_len;
    _ = &len;
    var callback = arg_callback;
    _ = &callback;
    var f: [*c]FILE = undefined;
    _ = &f;
    var x: c_ulong = undefined;
    _ = &x;
    f = fopen("/dev/urandom", "rb");
    if (f == @as([*c]FILE, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        f = fopen("/dev/random", "rb");
    }
    if (f == @as([*c]FILE, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        return 0;
    }
    if (setvbuf(f, null, @as(c_int, 2), @as(usize, @bitCast(@as(c_long, @as(c_int, 0))))) != @as(c_int, 0)) {
        _ = fclose(f);
        return 0;
    }
    x = fread(@as(?*anyopaque, @ptrCast(buf)), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))), @as(usize, @bitCast(len)), f);
    _ = fclose(f);
    return x;
}
pub fn rng_ansic(arg_buf: [*c]u8, arg_len: c_ulong, arg_callback: ?*const fn () callconv(.c) void) callconv(.c) c_ulong {
    var buf = arg_buf;
    _ = &buf;
    var len = arg_len;
    _ = &len;
    var callback = arg_callback;
    _ = &callback;
    var t1: clock_t = undefined;
    _ = &t1;
    var l: c_int = undefined;
    _ = &l;
    var acc: c_int = undefined;
    _ = &acc;
    var bits: c_int = undefined;
    _ = &bits;
    var a: c_int = undefined;
    _ = &a;
    var b: c_int = undefined;
    _ = &b;
    if ((@as(__clock_t, @bitCast(@as(c_long, @as(c_int, 1000000)))) < @as(__clock_t, @bitCast(@as(c_long, @as(c_int, 100))))) or (@as(__clock_t, @bitCast(@as(c_long, @as(c_int, 1000000)))) > @as(__clock_t, @bitCast(@as(c_long, @as(c_int, 10000)))))) {
        return 0;
    }
    l = @as(c_int, @bitCast(@as(c_uint, @truncate(len))));
    bits = 8;
    acc = blk: {
        const tmp = blk_1: {
            const tmp_2 = @as(c_int, 0);
            b = tmp_2;
            break :blk_1 tmp_2;
        };
        a = tmp;
        break :blk tmp;
    };
    while ((blk: {
        const ref = &len;
        const tmp = ref.*;
        ref.* -%= 1;
        break :blk tmp;
    }) != 0) {
        if (callback != @as(?*const fn () callconv(.c) void, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
            callback.?();
        }
        while ((blk: {
            const ref = &bits;
            const tmp = ref.*;
            ref.* -= 1;
            break :blk tmp;
        }) != 0) {
            while (true) {
                t1 = clock();
                while (t1 == clock()) {
                    a ^= @as(c_int, 1);
                }
                t1 = clock();
                while (t1 == clock()) {
                    b ^= @as(c_int, 1);
                }
                if (!(a == b)) break;
            }
            acc = (acc << @intCast(1)) | a;
        }
        (blk: {
            const ref = &buf;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = @as(u8, @bitCast(@as(i8, @truncate(acc))));
        acc = 0;
        bits = 8;
    }
    acc = blk: {
        const tmp = blk_1: {
            const tmp_2 = blk_2: {
                const tmp_3 = @as(c_int, 0);
                b = tmp_3;
                break :blk_2 tmp_3;
            };
            a = tmp_2;
            break :blk_1 tmp_2;
        };
        bits = tmp;
        break :blk tmp;
    };
    return @as(c_ulong, @bitCast(@as(c_long, l)));
}
// ./libtomcrypt.c:13667:5: warning: TODO implement translation of stmt class GCCAsmStmtClass

// ./libtomcrypt.c:29649:13: warning: unable to translate function, demoted to extern
pub extern fn sha1_compress(arg_md: [*c]hash_state, arg_buf: [*c]u8) callconv(.c) c_int;
// ./libtomcrypt.c:13667:5: warning: TODO implement translation of stmt class GCCAsmStmtClass

// ./libtomcrypt.c:30089:13: warning: unable to translate function, demoted to extern
pub extern fn sha256_compress(arg_md: [*c]hash_state, arg_buf: [*c]u8) callconv(.c) c_int;
pub const K: [80]ulong64 = [80]ulong64{
    4794697086780616226,
    8158064640168781261,
    13096744586834688815,
    16840607885511220156,
    4131703408338449720,
    6480981068601479193,
    10538285296894168987,
    12329834152419229976,
    15566598209576043074,
    1334009975649890238,
    2608012711638119052,
    6128411473006802146,
    8268148722764581231,
    9286055187155687089,
    11230858885718282805,
    13951009754708518548,
    16472876342353939154,
    17275323862435702243,
    1135362057144423861,
    2597628984639134821,
    3308224258029322869,
    5365058923640841347,
    6679025012923562964,
    8573033837759648693,
    10970295158949994411,
    12119686244451234320,
    12683024718118986047,
    13788192230050041572,
    14330467153632333762,
    15395433587784984357,
    489312712824947311,
    1452737877330783856,
    2861767655752347644,
    3322285676063803686,
    5560940570517711597,
    5996557281743188959,
    7280758554555802590,
    8532644243296465576,
    9350256976987008742,
    10552545826968843579,
    11727347734174303076,
    12113106623233404929,
    14000437183269869457,
    14369950271660146224,
    15101387698204529176,
    15463397548674623760,
    17586052441742319658,
    1182934255886127544,
    1847814050463011016,
    2177327727835720531,
    2830643537854262169,
    3796741975233480872,
    4115178125766777443,
    5681478168544905931,
    6601373596472566643,
    7507060721942968483,
    8399075790359081724,
    8693463985226723168,
    9568029438360202098,
    10144078919501101548,
    10430055236837252648,
    11840083180663258601,
    13761210420658862357,
    14299343276471374635,
    14566680578165727644,
    15097957966210449927,
    16922976911328602910,
    17689382322260857208,
    500013540394364858,
    748580250866718886,
    1242879168328830382,
    1977374033974150939,
    2944078676154940804,
    3659926193048069267,
    4368137639120453308,
    4836135668995329356,
    5532061633213252278,
    6448918945643986474,
    6902733635092675308,
    7801388544844847127,
};
// ./libtomcrypt.c:13697:5: warning: TODO implement translation of stmt class GCCAsmStmtClass

// ./libtomcrypt.c:30597:13: warning: unable to translate function, demoted to extern
pub extern fn sha512_compress(arg_md: [*c]hash_state, arg_buf: [*c]u8) callconv(.c) c_int;
pub const TE0: [256]ulong32 = [256]ulong32{
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3328402341))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4168907908))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4000806809))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4135287693))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4294111757))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3597364157))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3731845041))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2445657428))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1613770832))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 33620227))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3462883241))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1445669757))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3892248089))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3050821474))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1303096294))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3967186586))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2412431941))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 528646813))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2311702848))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4202528135))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4026202645))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2992200171))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2387036105))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4226871307))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1101901292))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3017069671))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1604494077))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1169141738))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 597466303))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1403299063))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3832705686))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2613100635))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1974974402))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3791519004))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1033081774))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1277568618))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1815492186))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2118074177))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4126668546))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2211236943))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1748251740))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1369810420))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3521504564))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4193382664))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3799085459))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2883115123))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1647391059))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 706024767))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 134480908))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2512897874))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1176707941))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2646852446))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 806885416))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 932615841))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 168101135))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 798661301))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 235341577))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 605164086))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 461406363))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3756188221))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3454790438))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1311188841))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2142417613))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3933566367))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 302582043))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 495158174))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1479289972))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 874125870))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 907746093))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3698224818))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3025820398))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1537253627))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2756858614))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1983593293))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3084310113))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2108928974))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1378429307))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3722699582))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1580150641))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 327451799))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2790478837))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3117535592))))),
    0,
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3253595436))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1075847264))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3825007647))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2041688520))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3059440621))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3563743934))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2378943302))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1740553945))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1916352843))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2487896798))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2555137236))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2958579944))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2244988746))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3151024235))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3320835882))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1336584933))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3992714006))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2252555205))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2588757463))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1714631509))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 293963156))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2319795663))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3925473552))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 67240454))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4269768577))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2689618160))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2017213508))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 631218106))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1269344483))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2723238387))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1571005438))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2151694528))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 93294474))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1066570413))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 563977660))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1882732616))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4059428100))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1673313503))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2008463041))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2950355573))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1109467491))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 537923632))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3858759450))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4260623118))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3218264685))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2177748300))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 403442708))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 638784309))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3287084079))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3193921505))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 899127202))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2286175436))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 773265209))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2479146071))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1437050866))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4236148354))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2050833735))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3362022572))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3126681063))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 840505643))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3866325909))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3227541664))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 427917720))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2655997905))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2749160575))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1143087718))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1412049534))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 999329963))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 193497219))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2353415882))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3354324521))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1807268051))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 672404540))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2816401017))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3160301282))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 369822493))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2916866934))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3688947771))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1681011286))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1949973070))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 336202270))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2454276571))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 201721354))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1210328172))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3093060836))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2680341085))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3184776046))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1135389935))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3294782118))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 965841320))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 831886756))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3554993207))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4068047243))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3588745010))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2345191491))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1849112409))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3664604599))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 26054028))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2983581028))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2622377682))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1235855840))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3630984372))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2891339514))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4092916743))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3488279077))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3395642799))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4101667470))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1202630377))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 268961816))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1874508501))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4034427016))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1243948399))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1546530418))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 941366308))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1470539505))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1941222599))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2546386513))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3421038627))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2715671932))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3899946140))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1042226977))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2521517021))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1639824860))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 227249030))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 260737669))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3765465232))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2084453954))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1907733956))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3429263018))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2420656344))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 100860677))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4160157185))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 470683154))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3261161891))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1781871967))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2924959737))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1773779408))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 394692241))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2579611992))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 974986535))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 664706745))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3655459128))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3958962195))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 731420851))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 571543859))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3530123707))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2849626480))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 126783113))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 865375399))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 765172662))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1008606754))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 361203602))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3387549984))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2278477385))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2857719295))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1344809080))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2782912378))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 59542671))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1503764984))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 160008576))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 437062935))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1707065306))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3622233649))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2218934982))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3496503480))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2185314755))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 697932208))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1512910199))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 504303377))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2075177163))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2824099068))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1841019862))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 739644986))))),
};
pub const Te4: [256]ulong32 = [256]ulong32{
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1667457891))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2088533116))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2004318071))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2071690107))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4076008178))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1802201963))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1869573999))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3318072773))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 808464432))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16843009))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1734829927))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 724249387))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4278124286))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3621246935))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2880154539))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1987475062))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3402287818))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2189591170))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3385444809))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2105376125))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4210752250))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1499027801))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1195853639))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4042322160))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2913840557))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3570717908))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2728567458))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2947526575))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2627509404))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2762253476))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1920103026))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3233857728))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3082270647))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4261281277))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2475922323))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 640034342))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 909522486))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1061109567))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4160223223))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3435973836))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 875836468))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2779096485))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3857049061))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4059165169))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1903260017))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3638089944))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 825307441))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 353703189))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 67372036))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3351758791))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 589505315))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3284386755))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 404232216))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2526451350))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 84215045))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2593823386))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 117901063))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 303174162))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2155905152))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3806520034))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3958107115))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 656877351))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2998055602))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1970632053))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 151587081))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2206434179))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 741092396))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 437918234))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 454761243))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1852730990))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1515870810))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2694881440))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1381126738))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 993737531))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3604403926))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3014898611))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 690563369))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3823363043))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 791621423))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2223277188))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1397969747))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3520188881))))),
    0,
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3991793133))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 538976288))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4244438268))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2981212593))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1532713819))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1785358954))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3419130827))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3200171710))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 960051513))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1246382666))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1280068684))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1482184792))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3486502863))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3503345872))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4025479151))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2863311530))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4227595259))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1128481603))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1296911693))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 858993459))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2240120197))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1162167621))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4193909241))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 33686018))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2139062143))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1347440720))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1010580540))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2678038431))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2829625512))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1364283729))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2745410467))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1077952576))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2408550287))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2459079314))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2644352413))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 943208504))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4126537205))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3166485692))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3065427638))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3671775962))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 555819297))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 269488144))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4294967295))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4092851187))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3537031890))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3452816845))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 202116108))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 320017171))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3974950124))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1600085855))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2543294359))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1145324612))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 387389207))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3301229764))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2812782503))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2122219134))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1027423549))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1684300900))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1566399837))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 421075225))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1936946035))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1616928864))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2172748161))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1330597711))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3705461980))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 572662306))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 707406378))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2425393296))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2290649224))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1179010630))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4008636142))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3099113656))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 336860180))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3739147998))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1583242846))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 185273099))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3688618971))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3772834016))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 842150450))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 976894522))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 168430090))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1229539657))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 101058054))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 606348324))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1549556828))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3267543746))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3553874899))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2896997548))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1650614882))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2442236305))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2509608341))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3840206052))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2038004089))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3890735079))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3368601800))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 926365495))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1835887981))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2374864269))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3587560917))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1313754702))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2846468521))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1819044972))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1448498774))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4109694196))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3941264106))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1701143909))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2054847098))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2930683566))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 134744072))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3132799674))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2021161080))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 623191333))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 774778414))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 471604252))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2795939494))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3031741620))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3334915782))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3907578088))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3722304989))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1953789044))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 522133279))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1263225675))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3183328701))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2341178251))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2324335242))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1886417008))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1044266558))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3048584629))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1717986918))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1212696648))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 50529027))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4143380214))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 235802126))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1633771873))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 892679477))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1465341783))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3115956665))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2256963206))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3250700737))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 488447261))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2661195422))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3789677025))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4177066232))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2560137368))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 286331153))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1768515945))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3654932953))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2391707278))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2492765332))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2610666395))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 505290270))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2273806215))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3924421097))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3469659854))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1431655765))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 673720360))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3755991007))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2358021260))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2711724449))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2307492233))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 218959117))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3217014719))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3873892070))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1111638594))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1751672936))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1094795585))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2576980377))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 757935405))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 252645135))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2964369584))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1414812756))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3149642683))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 370546198))))),
};
pub const TD0: [256]ulong32 = [256]ulong32{
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1374988112))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2118214995))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 437757123))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 975658646))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1001089995))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 530400753))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2902087851))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1273168787))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 540080725))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2910219766))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2295101073))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4110568485))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1340463100))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3307916247))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 641025152))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3043140495))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3736164937))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 632953703))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1172967064))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1576976609))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3274667266))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2169303058))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2370213795))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1809054150))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 59727847))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 361929877))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3211623147))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2505202138))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3569255213))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1484005843))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1239443753))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2395588676))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1975683434))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4102977912))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2572697195))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 666464733))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3202437046))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4035489047))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3374361702))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2110667444))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1675577880))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3843699074))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2538681184))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1649639237))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2976151520))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3144396420))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4269907996))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4178062228))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1883793496))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2403728665))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2497604743))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1383856311))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2876494627))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1917518562))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3810496343))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1716890410))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3001755655))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 800440835))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2261089178))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3543599269))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 807962610))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 599762354))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 33778362))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3977675356))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2328828971))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2809771154))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4077384432))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1315562145))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1708848333))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 101039829))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3509871135))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3299278474))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 875451293))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2733856160))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 92987698))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2767645557))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 193195065))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1080094634))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1584504582))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3178106961))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1042385657))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2531067453))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3711829422))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1306967366))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2438237621))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1908694277))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 67556463))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1615861247))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 429456164))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3602770327))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2302690252))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1742315127))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2968011453))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 126454664))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3877198648))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2043211483))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2709260871))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2084704233))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4169408201))))),
    0,
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 159417987))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 841739592))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 504459436))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1817866830))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4245618683))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 260388950))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1034867998))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 908933415))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 168810852))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1750902305))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2606453969))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 607530554))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 202008497))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2472011535))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3035535058))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 463180190))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2160117071))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1641816226))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1517767529))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 470948374))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3801332234))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3231722213))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1008918595))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 303765277))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 235474187))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4069246893))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 766945465))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 337553864))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1475418501))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2943682380))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4003061179))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2743034109))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4144047775))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1551037884))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1147550661))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1543208500))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2336434550))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3408119516))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3069049960))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3102011747))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3610369226))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1113818384))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 328671808))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2227573024))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2236228733))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3535486456))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2935566865))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3341394285))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 496906059))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3702665459))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 226906860))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2009195472))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 733156972))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2842737049))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 294930682))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1206477858))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2835123396))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2700099354))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1451044056))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 573804783))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2269728455))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3644379585))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2362090238))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2564033334))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2801107407))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2776292904))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3669462566))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1068351396))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 742039012))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1350078989))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1784663195))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1417561698))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4136440770))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2430122216))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 775550814))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2193862645))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2673705150))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1775276924))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1876241833))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3475313331))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3366754619))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 270040487))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3902563182))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3678124923))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3441850377))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1851332852))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3969562369))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2203032232))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3868552805))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2868897406))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 566021896))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4011190502))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3135740889))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1248802510))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3936291284))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 699432150))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 832877231))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 708780849))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3332740144))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 899835584))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1951317047))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4236429990))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3767586992))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 866637845))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4043610186))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1106041591))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2144161806))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 395441711))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1984812685))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1139781709))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3433712980))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3835036895))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2664543715))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1282050075))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3240894392))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1181045119))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2640243204))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 25965917))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4203181171))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4211818798))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3009879386))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2463879762))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3910161971))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1842759443))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2597806476))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 933301370))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1509430414))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3943906441))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3467192302))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3076639029))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3776767469))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2051518780))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2631065433))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1441952575))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 404016761))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1942435775))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1408749034))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1610459739))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3745345300))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2017778566))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3400528769))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3110650942))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 941896748))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3265478751))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 371049330))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3168937228))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 675039627))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4279080257))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 967311729))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 135050206))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3635733660))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1683407248))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2076935265))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3576870512))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1215061108))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3501741890))))),
};
pub const Td4: [256]ulong32 = [256]ulong32{
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1381126738))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 151587081))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1785358954))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3587560917))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 808464432))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 909522486))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2779096485))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 943208504))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3217014719))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1077952576))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2745410467))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2661195422))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2172748161))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4092851187))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3621246935))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4227595259))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2088533116))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3823363043))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 960051513))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2189591170))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2610666395))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 791621423))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4294967295))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2273806215))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 875836468))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2391707278))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1128481603))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1145324612))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3301229764))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3739147998))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3924421097))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3419130827))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1414812756))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2071690107))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2492765332))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 842150450))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2795939494))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3267543746))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 589505315))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1027423549))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4008636142))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1280068684))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2509608341))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 185273099))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1111638594))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4210752250))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3284386755))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1313754702))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 134744072))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 774778414))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2711724449))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1717986918))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 673720360))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3654932953))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 606348324))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2998055602))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1987475062))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1532713819))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2728567458))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1229539657))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1835887981))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2341178251))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3520188881))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 623191333))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1920103026))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4177066232))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4143380214))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1684300900))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2256963206))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1751672936))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2560137368))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 370546198))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3570717908))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2762253476))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1549556828))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3435973836))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1566399837))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1701143909))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3065427638))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2459079314))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1819044972))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1886417008))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1212696648))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1347440720))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4261281277))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3991793133))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3115956665))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3671775962))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1583242846))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 353703189))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1179010630))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1465341783))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2812782503))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2374864269))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2644352413))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2223277188))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2425393296))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3638089944))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2880154539))))),
    0,
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2358021260))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3166485692))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3553874899))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 168430090))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4160223223))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3840206052))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1482184792))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 84215045))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3099113656))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3014898611))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1162167621))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 101058054))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3503345872))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 741092396))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 505290270))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2408550287))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3402287818))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1061109567))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 252645135))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 33686018))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3250700737))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2947526575))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3183328701))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 50529027))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16843009))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 320017171))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2324335242))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1802201963))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 976894522))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2442236305))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 286331153))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1094795585))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1330597711))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1734829927))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3705461980))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3941264106))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2543294359))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4076008178))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3486502863))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3469659854))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4042322160))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3031741620))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3873892070))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1936946035))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2526451350))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2896997548))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1953789044))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 572662306))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3890735079))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2913840557))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 892679477))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2240120197))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3806520034))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4193909241))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 926365495))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3907578088))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 471604252))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1970632053))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3755991007))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1852730990))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1195853639))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4059165169))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 437918234))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1903260017))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 488447261))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 690563369))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3318072773))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2307492233))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1869573999))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3082270647))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1650614882))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 235802126))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2863311530))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 404232216))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3200171710))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 454761243))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4244438268))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1448498774))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1044266558))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1263225675))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3334915782))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3537031890))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2038004089))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 538976288))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2593823386))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3688618971))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3233857728))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4278124286))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2021161080))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3452816845))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1515870810))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4109694196))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 522133279))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3722304989))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2829625512))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 858993459))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2290649224))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 117901063))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3351758791))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 825307441))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2981212593))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 303174162))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 269488144))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1499027801))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 656877351))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2155905152))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3974950124))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1600085855))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1616928864))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1364283729))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2139062143))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2846468521))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 421075225))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3048584629))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1246382666))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 218959117))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 757935405))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3857049061))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2054847098))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2678038431))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2475922323))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3385444809))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2627509404))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4025479151))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2694881440))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3772834016))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 993737531))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1296911693))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2930683566))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 707406378))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4126537205))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2964369584))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3368601800))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3958107115))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3149642683))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1010580540))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2206434179))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1397969747))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2576980377))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1633771873))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 387389207))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 724249387))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 67372036))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2122219134))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3132799674))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2004318071))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3604403926))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 640034342))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3789677025))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1768515945))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 336860180))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1667457891))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1431655765))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 555819297))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 202116108))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2105376125))))),
};
pub const TE1: [256]ulong32 = [256]ulong32{
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2781242211))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2230877308))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2582542199))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2381740923))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 234877682))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3184946027))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2984144751))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1418839493))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1348481072))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 50462977))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2848876391))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2102799147))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 434634494))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1656084439))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3863849899))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2599188086))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1167051466))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2636087938))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1082771913))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2281340285))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 368048890))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3954334041))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3381544775))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 201060592))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3963727277))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1739838676))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4250903202))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3930435503))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3206782108))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4149453988))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2531553906))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1536934080))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3262494647))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 484572669))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2923271059))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1783375398))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1517041206))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1098792767))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 49674231))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1334037708))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1550332980))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4098991525))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 886171109))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 150598129))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2481090929))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1940642008))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1398944049))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1059722517))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 201851908))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1385547719))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1699095331))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1587397571))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 674240536))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2704774806))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 252314885))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3039795866))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 151914247))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 908333586))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2602270848))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1038082786))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 651029483))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1766729511))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3447698098))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2682942837))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 454166793))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2652734339))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1951935532))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 775166490))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 758520603))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3000790638))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4004797018))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4217086112))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4137964114))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1299594043))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1639438038))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3464344499))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2068982057))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1054729187))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1901997871))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2534638724))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4121318227))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1757008337))))),
    0,
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 750906861))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1614815264))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 535035132))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3363418545))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3988151131))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3201591914))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1183697867))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3647454910))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1265776953))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3734260298))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3566750796))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3903871064))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1250283471))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1807470800))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 717615087))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3847203498))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 384695291))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3313910595))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3617213773))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1432761139))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2484176261))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3481945413))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 283769337))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 100925954))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2180939647))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4037038160))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1148730428))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3123027871))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3813386408))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4087501137))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4267549603))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3229630528))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2315620239))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2906624658))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3156319645))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1215313976))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 82966005))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3747855548))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3245848246))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1974459098))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1665278241))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 807407632))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 451280895))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 251524083))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1841287890))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1283575245))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 337120268))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 891687699))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 801369324))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3787349855))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2721421207))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3431482436))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 959321879))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1469301956))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4065699751))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2197585534))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1199193405))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2898814052))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3887750493))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 724703513))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2514908019))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2696962144))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2551808385))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3516813135))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2141445340))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1715741218))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2119445034))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2872807568))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2198571144))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3398190662))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 700968686))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3547052216))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1009259540))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2041044702))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3803995742))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 487983883))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1991105499))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1004265696))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1449407026))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1316239930))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 504629770))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3683797321))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 168560134))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1816667172))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3837287516))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1570751170))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1857934291))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4014189740))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2797888098))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2822345105))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2754712981))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 936633572))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2347923833))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 852879335))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1133234376))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1500395319))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3084545389))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2348912013))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1689376213))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3533459022))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3762923945))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3034082412))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4205598294))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 133428468))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 634383082))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2949277029))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2398386810))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3913789102))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 403703816))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3580869306))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2297460856))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1867130149))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1918643758))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 607656988))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4049053350))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3346248884))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1368901318))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 600565992))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2090982877))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2632479860))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 557719327))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3717614411))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3697393085))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2249034635))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2232388234))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2430627952))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1115438654))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3295786421))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2865522278))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3633334344))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 84280067))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 33027830))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 303828494))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2747425121))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1600795957))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4188952407))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3496589753))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2434238086))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1486471617))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 658119965))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3106381470))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 953803233))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 334231800))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3005978776))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 857870609))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3151128937))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1890179545))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2298973838))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2805175444))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3056442267))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 574365214))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2450884487))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 550103529))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1233637070))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4289353045))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2018519080))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2057691103))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2399374476))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4166623649))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2148108681))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 387583245))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3664101311))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 836232934))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3330556482))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3100665960))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3280093505))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2955516313))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2002398509))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 287182607))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3413881008))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4238890068))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3597515707))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 975967766))))),
};
pub const TE2: [256]ulong32 = [256]ulong32{
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1671808611))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2089089148))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2006576759))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2072901243))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4061003762))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1807603307))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1873927791))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3310653893))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 810573872))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16974337))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1739181671))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 729634347))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4263110654))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3613570519))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2883997099))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1989864566))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3393556426))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2191335298))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3376449993))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2106063485))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4195741690))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1508618841))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1204391495))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4027317232))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2917941677))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3563566036))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2734514082))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2951366063))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2629772188))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2767672228))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1922491506))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3227229120))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3082974647))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4246528509))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2477669779))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 644500518))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 911895606))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1061256767))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4144166391))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3427763148))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 878471220))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2784252325))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3845444069))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4043897329))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1905517169))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3631459288))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 827548209))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 356461077))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 67897348))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3344078279))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 593839651))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3277757891))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 405286936))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2527147926))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 84871685))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2595565466))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 118033927))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 305538066))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2157648768))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3795705826))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3945188843))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 661212711))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2999812018))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1973414517))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 152769033))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2208177539))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 745822252))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 439235610))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 455947803))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1857215598))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1525593178))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2700827552))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1391895634))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 994932283))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3596728278))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3016654259))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 695947817))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3812548067))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 795958831))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2224493444))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1408607827))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3513301457))))),
    0,
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3979133421))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 543178784))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4229948412))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2982705585))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1542305371))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1790891114))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3410398667))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3201918910))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 961245753))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1256100938))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1289001036))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1491644504))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3477767631))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3496721360))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4012557807))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2867154858))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4212583931))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1137018435))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1305975373))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 861234739))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2241073541))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1171229253))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4178635257))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 33948674))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2139225727))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1357946960))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1011120188))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2679776671))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2833468328))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1374921297))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2751356323))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1086357568))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2408187279))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2460827538))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2646352285))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 944271416))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4110742005))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3168756668))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3066132406))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3665145818))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 560153121))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 271589392))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4279952895))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4077846003))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3530407890))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3444343245))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 202643468))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 322250259))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3962553324))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1608629855))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2543990167))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1154254916))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 389623319))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3294073796))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2817676711))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2122513534))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1028094525))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1689045092))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1575467613))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 422261273))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1939203699))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1621147744))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2174228865))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1339137615))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3699352540))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 577127458))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 712922154))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2427141008))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2290289544))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1187679302))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3995715566))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3100863416))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 339486740))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3732514782))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1591917662))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 186455563))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3681988059))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3762019296))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 844522546))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 978220090))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 169743370))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1239126601))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 101321734))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 611076132))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1558493276))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3260915650))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3547250131))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2901361580))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1655096418))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2443721105))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2510565781))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3828863972))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2039214713))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3878868455))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3359869896))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 928607799))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1840765549))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2374762893))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3580146133))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1322425422))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2850048425))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1823791212))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1459268694))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4094161908))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3928346602))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1706019429))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2056189050))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2934523822))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 135794696))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3134549946))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2022240376))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 628050469))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 779246638))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 472135708))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2800834470))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3032970164))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3327236038))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3894660072))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3715932637))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1956440180))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 522272287))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1272813131))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3185336765))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2340818315))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2323976074))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1888542832))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1044544574))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3049550261))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1722469478))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1222152264))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 50660867))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4127324150))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 236067854))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1638122081))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 895445557))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1475980887))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3117443513))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2257655686))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3243809217))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 489110045))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2662934430))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3778599393))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4162055160))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2561878936))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 288563729))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1773916777))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3648039385))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2391345038))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2493985684))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2612407707))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 505560094))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2274497927))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3911240169))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3460925390))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1442818645))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 678973480))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3749357023))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2358182796))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2717407649))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2306869641))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 219617805))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3218761151))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3862026214))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1120306242))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1756942440))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1103331905))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2578459033))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 762796589))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 252780047))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2966125488))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1425844308))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3151392187))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 372911126))))),
};
pub const TE3: [256]ulong32 = [256]ulong32{
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1667474886))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2088535288))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2004326894))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2071694838))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4075949567))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1802223062))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1869591006))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3318043793))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 808472672))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16843522))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1734846926))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 724270422))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4278065639))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3621216949))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2880169549))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1987484396))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3402253711))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2189597983))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3385409673))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2105378810))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4210693615))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1499065266))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1195886990))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4042263547))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2913856577))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3570689971))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2728590687))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2947541573))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2627518243))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2762274643))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1920112356))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3233831835))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3082273397))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4261223649))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2475929149))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 640051788))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 909531756))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1061110142))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4160160501))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3435941763))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 875846760))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2779116625))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3857003729))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4059105529))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1903268834))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3638064043))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 825316194))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 353713962))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 67374088))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3351728789))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 589522246))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3284360861))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 404236336))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2526454071))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 84217610))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2593830191))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 117901582))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 303183396))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2155911963))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3806477791))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3958056653))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 656894286))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2998062463))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1970642922))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 151591698))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2206440989))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 741110872))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 437923380))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 454765878))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1852748508))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1515908788))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2694904667))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1381168804))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 993742198))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3604373943))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3014905469))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 690584402))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3823320797))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 791638366))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2223281939))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1398011302))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3520161977))))),
    0,
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3991743681))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 538992704))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4244381667))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2981218425))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1532751286))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1785380564))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3419096717))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3200178535))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 960056178))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1246420628))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1280103576))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1482221744))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3486468741))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3503319995))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4025428677))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2863326543))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4227536621))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1128514950))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1296947098))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 859002214))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2240123921))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1162203018))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4193849577))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 33687044))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2139062782))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1347481760))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1010582648))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2678045221))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2829640523))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1364325282))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2745433693))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1077985408))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2408548869))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2459086143))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2644360225))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 943212656))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4126475505))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3166494563))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3065430391))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3671750063))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 555836226))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 269496352))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4294908645))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4092792573))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3537006015))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3452783745))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 202118168))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 320025894))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3974901699))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1600119230))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2543297077))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1145359496))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 387397934))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3301201811))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2812801621))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2122220284))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1027426170))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1684319432))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1566435258))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 421079858))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1936954854))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1616945344))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2172753945))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1330631070))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3705438115))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 572679748))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 707427924))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2425400123))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2290647819))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1179044492))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4008585671))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3099120491))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 336870440))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3739122087))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1583276732))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 185277718))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3688593069))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3772791771))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 842159716))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 976899700))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 168435220))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1229577106))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 101059084))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 606366792))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1549591736))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3267517855))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3553849021))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2897014595))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1650632388))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2442242105))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2509612081))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3840161747))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2038008818))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3890688725))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3368567691))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 926374254))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1835907034))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2374863873))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3587531953))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1313788572))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2846482505))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1819063512))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1448540844))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4109633523))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3941213647))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1701162954))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2054852340))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2930698567))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 134748176))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3132806511))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2021165296))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 623210314))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 774795868))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 471606328))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2795958615))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3031746419))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3334885783))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3907527627))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3722280097))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1953799400))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 522133822))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1263263126))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3183336545))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2341176845))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2324333839))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1886425312))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1044267644))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3048588401))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1718004428))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1212733584))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 50529542))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4143317495))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 235803164))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1633788866))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 892690282))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1465383342))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3115962473))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2256965911))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3250673817))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 488449850))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2661202215))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3789633753))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4177007595))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2560144171))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 286339874))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1768537042))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3654906025))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2391705863))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2492770099))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2610673197))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 505291324))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2273808917))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3924369609))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3469625735))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1431699370))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 673740880))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3755965093))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2358021891))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2711746649))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2307489801))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 218961690))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3217021541))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3873845719))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1111672452))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1751693520))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1094828930))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2576986153))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 757954394))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 252645662))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2964376443))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1414855848))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3149649517))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 370555436))))),
};
pub const Te4_0: [256]ulong32 = [256]ulong32{
    99,
    124,
    119,
    123,
    242,
    107,
    111,
    197,
    48,
    1,
    103,
    43,
    254,
    215,
    171,
    118,
    202,
    130,
    201,
    125,
    250,
    89,
    71,
    240,
    173,
    212,
    162,
    175,
    156,
    164,
    114,
    192,
    183,
    253,
    147,
    38,
    54,
    63,
    247,
    204,
    52,
    165,
    229,
    241,
    113,
    216,
    49,
    21,
    4,
    199,
    35,
    195,
    24,
    150,
    5,
    154,
    7,
    18,
    128,
    226,
    235,
    39,
    178,
    117,
    9,
    131,
    44,
    26,
    27,
    110,
    90,
    160,
    82,
    59,
    214,
    179,
    41,
    227,
    47,
    132,
    83,
    209,
    0,
    237,
    32,
    252,
    177,
    91,
    106,
    203,
    190,
    57,
    74,
    76,
    88,
    207,
    208,
    239,
    170,
    251,
    67,
    77,
    51,
    133,
    69,
    249,
    2,
    127,
    80,
    60,
    159,
    168,
    81,
    163,
    64,
    143,
    146,
    157,
    56,
    245,
    188,
    182,
    218,
    33,
    16,
    255,
    243,
    210,
    205,
    12,
    19,
    236,
    95,
    151,
    68,
    23,
    196,
    167,
    126,
    61,
    100,
    93,
    25,
    115,
    96,
    129,
    79,
    220,
    34,
    42,
    144,
    136,
    70,
    238,
    184,
    20,
    222,
    94,
    11,
    219,
    224,
    50,
    58,
    10,
    73,
    6,
    36,
    92,
    194,
    211,
    172,
    98,
    145,
    149,
    228,
    121,
    231,
    200,
    55,
    109,
    141,
    213,
    78,
    169,
    108,
    86,
    244,
    234,
    101,
    122,
    174,
    8,
    186,
    120,
    37,
    46,
    28,
    166,
    180,
    198,
    232,
    221,
    116,
    31,
    75,
    189,
    139,
    138,
    112,
    62,
    181,
    102,
    72,
    3,
    246,
    14,
    97,
    53,
    87,
    185,
    134,
    193,
    29,
    158,
    225,
    248,
    152,
    17,
    105,
    217,
    142,
    148,
    155,
    30,
    135,
    233,
    206,
    85,
    40,
    223,
    140,
    161,
    137,
    13,
    191,
    230,
    66,
    104,
    65,
    153,
    45,
    15,
    176,
    84,
    187,
    22,
};
pub const Te4_1: [256]ulong32 = [256]ulong32{
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 25344))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 31744))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 30464))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 31488))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 61952))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 27392))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 28416))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 50432))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12288))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 256))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 26368))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11008))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 65024))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 55040))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 43776))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 30208))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 51712))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 33280))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 51456))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 32000))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 64000))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 22784))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 18176))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 61440))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 44288))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 54272))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 41472))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 44800))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 39936))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 41984))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 29184))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 49152))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 46848))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 64768))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 37632))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9728))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13824))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16128))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 63232))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 52224))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13312))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 42240))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 58624))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 61696))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 28928))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 55296))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12544))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5376))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1024))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 50944))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8960))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 49920))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6144))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 38400))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1280))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 39424))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1792))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4608))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 32768))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 57856))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 60160))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9984))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 45568))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 29952))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2304))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 33536))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11264))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6656))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6912))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 28160))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 23040))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 40960))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 20992))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15104))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 54784))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 45824))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 10496))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 58112))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12032))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 33792))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 21248))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 53504))))),
    0,
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 60672))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8192))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 64512))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 45312))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 23296))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 27136))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 51968))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 48640))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14592))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 18944))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 19456))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 22528))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 52992))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 53248))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 61184))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 43520))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 64256))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 17152))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 19712))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13056))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 34048))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 17664))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 63744))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 512))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 32512))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 20480))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15360))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 40704))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 43008))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 20736))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 41728))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16384))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 36608))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 37376))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 40192))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14336))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 62720))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 48128))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 46592))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 55808))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8448))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4096))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 65280))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 62208))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 53760))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 52480))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3072))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4864))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 60416))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 24320))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 38656))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 17408))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5888))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 50176))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 42752))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 32256))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15616))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 25600))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 23808))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6400))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 29440))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 24576))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 33024))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 20224))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 56320))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8704))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 10752))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 36864))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 34816))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 17920))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 60928))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 47104))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5120))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 56832))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 24064))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2816))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 56064))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 57344))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12800))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14848))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2560))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 18688))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1536))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9216))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 23552))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 49664))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 54016))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 44032))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 25088))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 37120))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 38144))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 58368))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 30976))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 59136))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 51200))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14080))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 27904))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 36096))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 54528))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 19968))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 43264))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 27648))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 22016))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 62464))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 59904))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 25856))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 31232))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 44544))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2048))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 47616))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 30720))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9472))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11776))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7168))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 42496))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 46080))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 50688))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 59392))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 56576))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 29696))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7936))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 19200))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 48384))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 35584))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 35328))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 28672))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15872))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 46336))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 26112))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 18432))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 768))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 62976))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3584))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 24832))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13568))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 22272))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 47360))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 34304))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 49408))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7424))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 40448))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 57600))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 63488))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 38912))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4352))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 26880))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 55552))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 36352))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 37888))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 39680))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7680))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 34560))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 59648))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 52736))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 21760))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 10240))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 57088))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 35840))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 41216))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 35072))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3328))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 48896))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 58880))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16896))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 26624))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16640))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 39168))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11520))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3840))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 45056))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 21504))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 47872))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5632))))),
};
pub const Te4_2: [256]ulong32 = [256]ulong32{
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6488064))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8126464))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7798784))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8060928))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15859712))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7012352))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7274496))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12910592))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3145728))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 65536))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6750208))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2818048))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16646144))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14090240))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11206656))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7733248))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13238272))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8519680))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13172736))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8192000))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16384000))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5832704))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4653056))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15728640))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11337728))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13893632))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 10616832))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11468800))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 10223616))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 10747904))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7471104))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12582912))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11993088))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16580608))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9633792))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2490368))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3538944))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4128768))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16187392))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13369344))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3407872))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 10813440))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15007744))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15794176))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7405568))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14155776))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3211264))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1376256))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 262144))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13041664))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2293760))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12779520))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1572864))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9830400))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 327680))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 10092544))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 458752))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1179648))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8388608))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14811136))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15400960))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2555904))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11665408))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7667712))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 589824))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8585216))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2883584))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1703936))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1769472))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7208960))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5898240))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 10485760))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5373952))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3866624))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14024704))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11730944))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2686976))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14876672))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3080192))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8650752))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5439488))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13697024))))),
    0,
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15532032))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2097152))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16515072))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11599872))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5963776))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6946816))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13303808))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12451840))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3735552))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4849664))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4980736))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5767168))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13565952))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13631488))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15663104))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11141120))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16449536))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4390912))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5046272))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3342336))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8716288))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4521984))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16318464))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 131072))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8323072))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5242880))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3932160))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 10420224))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11010048))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5308416))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 10682368))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4194304))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9371648))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9568256))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 10289152))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3670016))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16056320))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12320768))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11927552))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14286848))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2162688))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1048576))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16711680))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15925248))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13762560))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13434880))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 786432))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1245184))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15466496))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6225920))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9895936))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4456448))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1507328))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12845056))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 10944512))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8257536))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3997696))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6553600))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6094848))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1638400))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7536640))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6291456))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8454144))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5177344))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14417920))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2228224))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2752512))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9437184))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8912896))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4587520))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15597568))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12058624))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1310720))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14548992))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6160384))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 720896))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14352384))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14680064))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3276800))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3801088))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 655360))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4784128))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 393216))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2359296))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6029312))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12713984))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13828096))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11272192))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6422528))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9502720))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9764864))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14942208))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7929856))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15138816))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13107200))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3604480))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7143424))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9240576))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13959168))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5111808))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11075584))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7077888))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5636096))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15990784))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15335424))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6619136))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7995392))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11403264))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 524288))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12189696))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7864320))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2424832))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3014656))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1835008))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 10878976))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11796480))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12976128))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15204352))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14483456))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7602176))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2031616))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4915200))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12386304))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9109504))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9043968))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 7340032))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4063232))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11862016))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6684672))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4718592))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 196608))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16121856))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 917504))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6356992))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3473408))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5701632))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12124160))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8781824))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12648448))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1900544))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 10354688))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14745600))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16252928))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9961472))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1114112))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6881280))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14221312))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9306112))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9699328))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 10158080))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1966080))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8847360))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15269888))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 13500416))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5570560))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2621440))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 14614528))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 9175040))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 10551296))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 8978432))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 851968))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12517376))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 15073280))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4325376))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 6815744))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4259840))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 10027008))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2949120))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 983040))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 11534336))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 5505024))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 12255232))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1441792))))),
};
pub const Te4_3: [256]ulong32 = [256]ulong32{
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1660944384))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2080374784))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1996488704))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2063597568))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4060086272))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1795162112))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1862270976))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3305111552))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 805306368))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16777216))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1728053248))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 721420288))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4261412864))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3607101440))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2868903936))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1979711488))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3388997632))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2181038080))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3372220416))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2097152000))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4194304000))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1493172224))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1191182336))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4026531840))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2902458368))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3556769792))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2717908992))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2936012800))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2617245696))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2751463424))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1912602624))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3221225472))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3070230528))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4244635648))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2466250752))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 637534208))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 905969664))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1056964608))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4143972352))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3422552064))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 872415232))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2768240640))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3841982464))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4043309056))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1895825408))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3623878656))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 822083584))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 352321536))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 67108864))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3338665984))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 587202560))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3271557120))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 402653184))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2516582400))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 83886080))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2583691264))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 117440512))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 301989888))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2147483648))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3791650816))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3942645760))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 654311424))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2986344448))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1962934272))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 150994944))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2197815296))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 738197504))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 436207616))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 452984832))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1845493760))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1509949440))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2684354560))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1375731712))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 989855744))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3590324224))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3003121664))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 687865856))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3808428032))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 788529152))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2214592512))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1392508928))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3506438144))))),
    0,
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3976200192))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 536870912))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4227858432))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2969567232))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1526726656))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1778384896))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3405774848))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3187671040))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 956301312))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1241513984))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1275068416))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1476395008))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3472883712))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3489660928))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4009754624))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2852126720))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4211081216))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1124073472))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1291845632))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 855638016))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2231369728))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1157627904))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4177526784))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 33554432))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2130706432))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1342177280))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1006632960))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2667577344))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2818572288))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1358954496))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2734686208))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1073741824))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2399141888))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2449473536))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2634022912))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 939524096))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4110417920))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3154116608))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3053453312))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3657433088))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 553648128))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 268435456))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4278190080))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4076863488))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3523215360))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3439329280))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 201326592))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 318767104))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3959422976))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1593835520))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2533359616))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1140850688))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 385875968))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3288334336))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2801795072))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2113929216))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1023410176))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1677721600))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1560281088))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 419430400))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1929379840))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1610612736))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2164260864))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1325400064))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3690987520))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 570425344))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 704643072))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2415919104))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2281701376))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1174405120))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3992977408))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3087007744))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 335544320))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3724541952))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1577058304))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 184549376))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3674210304))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3758096384))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 838860800))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 973078528))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 167772160))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1224736768))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 100663296))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 603979776))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1543503872))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3254779904))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3539992576))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2885681152))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1644167168))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2432696320))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2499805184))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3825205248))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2030043136))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3875536896))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3355443200))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 922746880))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1828716544))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2365587456))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3573547008))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1308622848))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2835349504))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1811939328))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1442840576))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4093640704))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3925868544))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1694498816))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2046820352))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2919235584))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 134217728))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3120562176))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2013265920))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 620756992))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 771751936))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 469762048))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2785017856))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3019898880))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3321888768))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3892314112))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3707764736))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1946157056))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 520093696))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1258291200))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3170893824))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2332033024))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2315255808))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1879048192))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1040187392))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3036676096))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1711276032))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1207959552))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 50331648))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4127195136))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 234881024))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1627389952))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 889192448))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1459617792))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3103784960))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2248146944))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3238002688))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 486539264))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2650800128))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3774873600))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4160749568))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2550136832))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 285212672))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1761607680))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3640655872))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2382364672))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2483027968))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2600468480))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 503316480))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2264924160))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3909091328))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3456106496))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1426063360))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 671088640))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3741319168))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2348810240))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2701131776))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2298478592))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 218103808))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3204448256))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3858759680))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1107296256))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1744830464))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1090519040))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2566914048))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 754974720))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 251658240))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2952790016))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1409286144))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3137339392))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 369098752))))),
};
pub const TD1: [256]ulong32 = [256]ulong32{
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1347548327))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1400783205))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3273267108))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2520393566))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3409685355))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4045380933))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2880240216))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2471224067))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1428173050))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4138563181))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2441661558))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 636813900))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4233094615))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3620022987))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2149987652))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2411029155))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1239331162))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1730525723))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2554718734))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3781033664))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 46346101))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 310463728))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2743944855))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3328955385))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3875770207))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2501218972))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3955191162))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3667219033))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 768917123))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3545789473))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 692707433))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1150208456))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1786102409))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2029293177))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1805211710))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3710368113))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3065962831))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 401639597))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1724457132))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3028143674))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 409198410))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2196052529))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1620529459))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1164071807))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3769721975))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2226875310))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 486441376))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2499348523))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1483753576))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 428819965))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2274680428))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3075636216))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 598438867))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3799141122))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1474502543))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 711349675))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 129166120))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 53458370))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2592523643))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2782082824))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4063242375))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2988687269))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3120694122))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1559041666))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 730517276))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2460449204))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4042459122))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2706270690))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3446004468))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3573941694))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 533804130))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2328143614))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2637442643))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2695033685))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 839224033))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1973745387))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 957055980))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2856345839))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 106852767))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1371368976))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4181598602))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1033297158))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2933734917))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1179510461))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3046200461))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 91341917))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1862534868))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4284502037))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 605657339))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2547432937))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3431546947))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2003294622))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3182487618))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2282195339))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 954669403))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3682191598))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1201765386))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3917234703))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3388507166))))),
    0,
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2198438022))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1211247597))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2887651696))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1315723890))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4227665663))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1443857720))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 507358933))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 657861945))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1678381017))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 560487590))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3516619604))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 975451694))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2970356327))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 261314535))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3535072918))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2652609425))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1333838021))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2724322336))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1767536459))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 370938394))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 182621114))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3854606378))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1128014560))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 487725847))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 185469197))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2918353863))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3106780840))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3356761769))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2237133081))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1286567175))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3152976349))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4255350624))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2683765030))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3160175349))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3309594171))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 878443390))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1988838185))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3704300486))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1756818940))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1673061617))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3403100636))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 272786309))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1075025698))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 545572369))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2105887268))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4174560061))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 296679730))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1841768865))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1260232239))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4091327024))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3960309330))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3497509347))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1814803222))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2578018489))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4195456072))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 575138148))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3299409036))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 446754879))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3629546796))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4011996048))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3347532110))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3252238545))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4270639778))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 915985419))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3483825537))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 681933534))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 651868046))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2755636671))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3828103837))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 223377554))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2607439820))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1649704518))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3270937875))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3901806776))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1580087799))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4118987695))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3198115200))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2087309459))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2842678573))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3016697106))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1003007129))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2802849917))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1860738147))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2077965243))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 164439672))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4100872472))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 32283319))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2827177882))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1709610350))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2125135846))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 136428751))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3874428392))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3652904859))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3460984630))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3572145929))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3593056380))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2939266226))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 824852259))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 818324884))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3224740454))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 930369212))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2801566410))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2967507152))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 355706840))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1257309336))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4148292826))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 243256656))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 790073846))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2373340630))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1296297904))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1422699085))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3756299780))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3818836405))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 457992840))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3099667487))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2135319889))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 77422314))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1560382517))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1945798516))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 788204353))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1521706781))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1385356242))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 870912086))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 325965383))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2358957921))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2050466060))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2388260884))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2313884476))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4006521127))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 901210569))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3990953189))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1014646705))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1503449823))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1062597235))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2031621326))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3212035895))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3931371469))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1533017514))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 350174575))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2256028891))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2177544179))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1052338372))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 741876788))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1606591296))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1914052035))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 213705253))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2334669897))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1107234197))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1899603969))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3725069491))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2631447780))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2422494913))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1635502980))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1893020342))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1950903388))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1120974935))))),
};
pub const TD2: [256]ulong32 = [256]ulong32{
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2807058932))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1699970625))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2764249623))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1586903591))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1808481195))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1173430173))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1487645946))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 59984867))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4199882800))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1844882806))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1989249228))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1277555970))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3623636965))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3419915562))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1149249077))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2744104290))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1514790577))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 459744698))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 244860394))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3235995134))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1963115311))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4027744588))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2544078150))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4190530515))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1608975247))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2627016082))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2062270317))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1507497298))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2200818878))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 567498868))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1764313568))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3359936201))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2305455554))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2037970062))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1047239000))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1910319033))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1337376481))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2904027272))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2892417312))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 984907214))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1243112415))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 830661914))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 861968209))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2135253587))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2011214180))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2927934315))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2686254721))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 731183368))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1750626376))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4246310725))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1820824798))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4172763771))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3542330227))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 48394827))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2404901663))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2871682645))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 671593195))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3254988725))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2073724613))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 145085239))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2280796200))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2779915199))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1790575107))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2187128086))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 472615631))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3029510009))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4075877127))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3802222185))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4107101658))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3201631749))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1646252340))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4270507174))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1402811438))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1436590835))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3778151818))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3950355702))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3963161475))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4020912224))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2667994737))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 273792366))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2331590177))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 104699613))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 95345982))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3175501286))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2377486676))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1560637892))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3564045318))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 369057872))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4213447064))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3919042237))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1137477952))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2658625497))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1119727848))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2340947849))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1530455833))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4007360968))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 172466556))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 266959938))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 516552836))))),
    0,
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2256734592))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3980931627))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1890328081))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1917742170))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4294704398))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 945164165))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3575528878))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 958871085))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3647212047))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2787207260))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1423022939))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 775562294))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1739656202))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3876557655))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2530391278))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2443058075))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3310321856))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 547512796))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1265195639))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 437656594))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3121275539))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 719700128))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3762502690))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 387781147))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 218828297))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3350065803))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2830708150))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2848461854))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 428169201))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 122466165))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3720081049))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1627235199))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 648017665))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4122762354))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1002783846))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2117360635))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 695634755))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3336358691))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4234721005))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4049844452))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3704280881))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2232435299))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 574624663))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 287343814))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 612205898))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1039717051))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 840019705))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2708326185))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 793451934))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 821288114))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1391201670))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3822090177))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 376187827))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3113855344))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1224348052))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1679968233))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2361698556))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1058709744))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 752375421))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2431590963))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1321699145))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3519142200))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2734591178))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 188127444))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2177869557))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3727205754))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2384911031))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3215212461))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2648976442))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2450346104))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3432737375))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1180849278))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 331544205))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3102249176))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4150144569))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2952102595))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2159976285))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2474404304))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 766078933))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 313773861))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2570832044))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2108100632))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1668212892))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3145456443))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2013908262))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 418672217))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3070356634))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2594734927))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1852171925))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3867060991))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3473416636))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3907448597))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2614737639))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 919489135))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 164948639))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2094410160))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2997825956))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 590424639))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2486224549))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1723872674))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3157750862))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3399941250))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3501252752))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3625268135))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2555048196))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3673637356))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1343127501))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4130281361))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3599595085))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2957853679))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1297403050))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 81781910))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3051593425))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2283490410))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 532201772))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1367295589))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3926170974))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 895287692))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1953757831))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1093597963))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 492483431))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3528626907))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1446242576))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1192455638))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1636604631))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 209336225))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 344873464))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1015671571))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 669961897))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3375740769))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3857572124))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2973530695))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3747192018))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1933530610))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3464042516))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 935293895))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3454686199))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2858115069))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1863638845))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3683022916))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4085369519))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3292445032))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 875313188))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1080017571))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3279033885))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 621591778))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1233856572))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2504130317))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 24197544))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3017672716))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3835484340))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3247465558))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2220981195))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3060847922))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1551124588))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1463996600))))),
};
pub const TD3: [256]ulong32 = [256]ulong32{
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4104605777))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1097159550))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 396673818))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 660510266))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2875968315))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2638606623))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4200115116))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3808662347))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 821712160))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1986918061))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3430322568))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 38544885))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3856137295))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 718002117))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 893681702))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1654886325))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2975484382))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3122358053))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3926825029))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4274053469))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 796197571))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1290801793))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1184342925))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3556361835))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2405426947))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2459735317))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1836772287))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1381620373))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3196267988))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1948373848))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3764988233))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3385345166))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3263785589))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2390325492))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1480485785))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3111247143))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3780097726))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2293045232))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 548169417))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3459953789))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3746175075))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 439452389))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1362321559))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1400849762))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1685577905))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1806599355))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2174754046))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 137073913))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1214797936))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1174215055))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3731654548))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2079897426))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1943217067))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1258480242))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 529487843))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1437280870))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3945269170))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3049390895))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3313212038))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 923313619))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 679998000))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3215307299))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 57326082))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 377642221))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3474729866))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2041877159))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 133361907))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1776460110))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3673476453))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 96392454))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 878845905))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2801699524))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 777231668))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4082475170))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2330014213))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4142626212))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2213296395))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1626319424))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1906247262))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1846563261))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 562755902))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3708173718))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1040559837))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3871163981))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1418573201))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3294430577))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 114585348))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1343618912))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2566595609))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3186202582))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1078185097))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3651041127))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3896688048))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2307622919))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 425408743))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3371096953))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2081048481))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1108339068))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2216610296))))),
    0,
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2156299017))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 736970802))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 292596766))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1517440620))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 251657213))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2235061775))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2933202493))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 758720310))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 265905162))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1554391400))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1532285339))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 908999204))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 174567692))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1474760595))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4002861748))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2610011675))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3234156416))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3693126241))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2001430874))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 303699484))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2478443234))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2687165888))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 585122620))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 454499602))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 151849742))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2345119218))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3064510765))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 514443284))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4044981591))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1963412655))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2581445614))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2137062819))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 19308535))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1928707164))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1715193156))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4219352155))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1126790795))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 600235211))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3992742070))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3841024952))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 836553431))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1669664834))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2535604243))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3323011204))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1243905413))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3141400786))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4180808110))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 698445255))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2653899549))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2989552604))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2253581325))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3252932727))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3004591147))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1891211689))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2487810577))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3915653703))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4237083816))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4030667424))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2100090966))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 865136418))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1229899655))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 953270745))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3399679628))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3557504664))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4118925222))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2061379749))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3079546586))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2915017791))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 983426092))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2022837584))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1607244650))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2118541908))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2366882550))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3635996816))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 972512814))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3283088770))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1568718495))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3499326569))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3576539503))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 621982671))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2895723464))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 410887952))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2623762152))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1002142683))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 645401037))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1494807662))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2595684844))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1335535747))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2507040230))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4293295786))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3167684641))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 367585007))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3885750714))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1865862730))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2668221674))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2960971305))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2763173681))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1059270954))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2777952454))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2724642869))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1320957812))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2194319100))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2429595872))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2815956275))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 77089521))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3973773121))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3444575871))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2448830231))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1305906550))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4021308739))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2857194700))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2516901860))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3518358430))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1787304780))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 740276417))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1699839814))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1592394909))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2352307457))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2272556026))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 188821243))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1729977011))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3687994002))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 274084841))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3594982253))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3613494426))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2701949495))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4162096729))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 322734571))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2837966542))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1640576439))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 484830689))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1202797690))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3537852828))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4067639125))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 349075736))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3342319475))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4157467219))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4255800159))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1030690015))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1155237496))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2951971274))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1757691577))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 607398968))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2738905026))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 499347990))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3794078908))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1011452712))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 227885567))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2818666809))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 213114376))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3034881240))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1455525988))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3414450555))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 850817237))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1817998408))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3092726480))))),
};
pub const Tks0: [256]ulong32 = [256]ulong32{
    0,
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 235474187))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 470948374))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 303765277))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 941896748))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 908933415))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 607530554))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 708780849))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1883793496))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2118214995))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1817866830))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1649639237))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1215061108))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1181045119))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1417561698))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1517767529))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3767586992))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4003061179))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4236429990))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4069246893))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3635733660))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3602770327))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3299278474))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3400528769))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2430122216))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2664543715))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2362090238))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2193862645))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2835123396))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2801107407))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3035535058))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3135740889))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3678124923))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3576870512))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3341394285))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3374361702))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3810496343))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3977675356))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4279080257))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4043610186))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2876494627))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2776292904))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3076639029))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3110650942))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2472011535))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2640243204))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2403728665))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2169303058))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1001089995))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 899835584))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 666464733))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 699432150))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 59727847))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 226906860))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 530400753))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 294930682))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1273168787))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1172967064))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1475418501))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1509430414))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1942435775))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2110667444))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1876241833))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1641816226))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2910219766))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2743034109))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2976151520))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3211623147))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2505202138))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2606453969))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2302690252))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2269728455))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3711829422))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3543599269))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3240894392))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3475313331))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3843699074))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3943906441))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4178062228))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4144047775))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1306967366))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1139781709))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1374988112))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1610459739))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1975683434))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2076935265))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1775276924))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1742315127))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1034867998))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 866637845))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 566021896))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 800440835))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 92987698))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 193195065))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 429456164))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 395441711))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1984812685))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2017778566))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1784663195))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1683407248))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1315562145))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1080094634))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1383856311))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1551037884))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 101039829))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 135050206))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 437757123))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 337553864))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1042385657))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 807962610))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 573804783))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 742039012))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2531067453))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2564033334))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2328828971))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2227573024))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2935566865))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2700099354))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3001755655))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3168937228))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3868552805))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3902563182))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4203181171))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4102977912))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3736164937))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3501741890))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3265478751))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3433712980))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1106041591))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1340463100))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1576976609))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1408749034))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2043211483))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2009195472))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1708848333))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1809054150))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 832877231))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1068351396))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 766945465))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 599762354))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 159417987))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 126454664))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 361929877))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 463180190))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2709260871))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2943682380))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3178106961))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3009879386))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2572697195))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2538681184))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2236228733))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2336434550))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3509871135))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3745345300))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3441850377))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3274667266))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3910161971))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3877198648))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4110568485))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4211818798))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2597806476))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2497604743))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2261089178))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2295101073))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2733856160))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2902087851))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3202437046))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2968011453))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3936291284))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3835036895))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4136440770))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4169408201))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3535486456))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3702665459))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3467192302))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3231722213))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2051518780))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1951317047))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1716890410))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1750902305))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1113818384))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1282050075))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1584504582))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1350078989))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 168810852))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 67556463))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 371049330))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 404016761))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 841739592))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1008918595))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 775550814))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 540080725))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3969562369))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3801332234))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4035489047))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4269907996))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3569255213))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3669462566))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3366754619))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3332740144))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2631065433))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2463879762))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2160117071))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2395588676))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2767645557))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2868897406))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3102011747))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3069049960))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 202008497))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 33778362))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 270040487))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 504459436))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 875451293))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 975658646))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 675039627))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 641025152))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2084704233))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1917518562))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1615861247))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1851332852))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1147550661))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1248802510))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1484005843))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1451044056))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 933301370))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 967311729))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 733156972))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 632953703))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 260388950))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 25965917))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 328671808))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 496906059))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1206477858))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1239443753))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1543208500))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1441952575))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2144161806))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1908694277))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1675577880))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1842759443))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3610369226))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3644379585))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3408119516))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3307916247))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4011190502))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3776767469))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4077384432))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4245618683))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2809771154))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2842737049))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3144396420))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3043140495))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2673705150))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2438237621))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2203032232))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2370213795))))),
};
pub const Tks1: [256]ulong32 = [256]ulong32{
    0,
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 185469197))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 370938394))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 487725847))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 741876788))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 657861945))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 975451694))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 824852259))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1483753576))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1400783205))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1315723890))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1164071807))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1950903388))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2135319889))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1649704518))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1767536459))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2967507152))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3152976349))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2801566410))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2918353863))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2631447780))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2547432937))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2328143614))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2177544179))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3901806776))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3818836405))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4270639778))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4118987695))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3299409036))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3483825537))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3535072918))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3652904859))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2077965243))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1893020342))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1841768865))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1724457132))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1474502543))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1559041666))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1107234197))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1257309336))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 598438867))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 681933534))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 901210569))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1052338372))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 261314535))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 77422314))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 428819965))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 310463728))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3409685355))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3224740454))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3710368113))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3593056380))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3875770207))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3960309330))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4045380933))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4195456072))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2471224067))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2554718734))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2237133081))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2388260884))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3212035895))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3028143674))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2842678573))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2724322336))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4138563181))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4255350624))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3769721975))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3955191162))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3667219033))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3516619604))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3431546947))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3347532110))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2933734917))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2782082824))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3099667487))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3016697106))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2196052529))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2313884476))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2499348523))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2683765030))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1179510461))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1296297904))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1347548327))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1533017514))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1786102409))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1635502980))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2087309459))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2003294622))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 507358933))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 355706840))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 136428751))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 53458370))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 839224033))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 957055980))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 605657339))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 790073846))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2373340630))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2256028891))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2607439820))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2422494913))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2706270690))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2856345839))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3075636216))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3160175349))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3573941694))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3725069491))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3273267108))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3356761769))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4181598602))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4063242375))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4011996048))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3828103837))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1033297158))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 915985419))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 730517276))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 545572369))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 296679730))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 446754879))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 129166120))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 213705253))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1709610350))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1860738147))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1945798516))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2029293177))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1239331162))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1120974935))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1606591296))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1422699085))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4148292826))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4233094615))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3781033664))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3931371469))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3682191598))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3497509347))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3446004468))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3328955385))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2939266226))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2755636671))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3106780840))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2988687269))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2198438022))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2282195339))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2501218972))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2652609425))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1201765386))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1286567175))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1371368976))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1521706781))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1805211710))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1620529459))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2105887268))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1988838185))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 533804130))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 350174575))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 164439672))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 46346101))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 870912086))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 954669403))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 636813900))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 788204353))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2358957921))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2274680428))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2592523643))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2441661558))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2695033685))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2880240216))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3065962831))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3182487618))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3572145929))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3756299780))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3270937875))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3388507166))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4174560061))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4091327024))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4006521127))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3854606378))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1014646705))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 930369212))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 711349675))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 560487590))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 272786309))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 457992840))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 106852767))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 223377554))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1678381017))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1862534868))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1914052035))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2031621326))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1211247597))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1128014560))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1580087799))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1428173050))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 32283319))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 182621114))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 401639597))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 486441376))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 768917123))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 651868046))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1003007129))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 818324884))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1503449823))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1385356242))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1333838021))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1150208456))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1973745387))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2125135846))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1673061617))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1756818940))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2970356327))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3120694122))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2802849917))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2887651696))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2637442643))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2520393566))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2334669897))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2149987652))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3917234703))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3799141122))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4284502037))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4100872472))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3309594171))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3460984630))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3545789473))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3629546796))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2050466060))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1899603969))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1814803222))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1730525723))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1443857720))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1560382517))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1075025698))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1260232239))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 575138148))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 692707433))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 878443390))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1062597235))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 243256656))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 91341917))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 409198410))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 325965383))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3403100636))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3252238545))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3704300486))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3620022987))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3874428392))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3990953189))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4042459122))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4227665663))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2460449204))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2578018489))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2226875310))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2411029155))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3198115200))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3046200461))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2827177882))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2743944855))))),
};
pub const Tks2: [256]ulong32 = [256]ulong32{
    0,
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 218828297))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 437656594))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 387781147))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 875313188))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 958871085))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 775562294))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 590424639))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1750626376))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1699970625))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1917742170))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2135253587))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1551124588))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1367295589))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1180849278))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1265195639))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3501252752))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3720081049))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3399941250))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3350065803))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3835484340))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3919042237))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4270507174))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4085369519))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3102249176))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3051593425))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2734591178))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2952102595))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2361698556))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2177869557))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2530391278))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2614737639))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3145456443))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3060847922))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2708326185))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2892417312))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2404901663))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2187128086))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2504130317))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2555048196))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3542330227))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3727205754))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3375740769))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3292445032))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3876557655))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3926170974))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4246310725))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4027744588))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1808481195))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1723872674))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1910319033))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2094410160))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1608975247))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1391201670))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1173430173))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1224348052))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 59984867))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 244860394))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 428169201))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 344873464))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 935293895))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 984907214))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 766078933))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 547512796))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1844882806))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1627235199))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2011214180))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2062270317))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1507497298))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1423022939))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1137477952))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1321699145))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 95345982))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 145085239))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 532201772))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 313773861))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 830661914))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1015671571))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 731183368))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 648017665))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3175501286))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2957853679))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2807058932))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2858115069))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2305455554))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2220981195))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2474404304))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2658625497))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3575528878))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3625268135))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3473416636))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3254988725))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3778151818))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3963161475))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4213447064))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4130281361))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3599595085))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3683022916))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3432737375))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3247465558))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3802222185))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4020912224))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4172763771))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4122762354))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3201631749))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3017672716))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2764249623))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2848461854))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2331590177))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2280796200))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2431590963))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2648976442))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 104699613))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 188127444))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 472615631))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 287343814))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 840019705))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1058709744))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 671593195))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 621591778))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1852171925))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1668212892))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1953757831))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2037970062))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1514790577))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1463996600))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1080017571))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1297403050))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3673637356))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3623636965))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3235995134))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3454686199))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4007360968))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3822090177))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4107101658))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4190530515))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2997825956))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3215212461))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2830708150))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2779915199))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2256734592))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2340947849))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2627016082))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2443058075))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 172466556))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 122466165))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 273792366))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 492483431))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1047239000))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 861968209))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 612205898))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 695634755))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1646252340))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1863638845))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2013908262))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1963115311))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1446242576))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1530455833))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1277555970))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1093597963))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1636604631))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1820824798))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2073724613))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1989249228))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1436590835))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1487645946))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1337376481))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1119727848))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 164948639))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 81781910))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 331544205))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 516552836))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1039717051))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 821288114))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 669961897))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 719700128))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2973530695))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3157750862))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2871682645))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2787207260))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2232435299))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2283490410))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2667994737))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2450346104))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3647212047))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3564045318))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3279033885))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3464042516))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3980931627))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3762502690))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4150144569))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4199882800))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3070356634))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3121275539))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2904027272))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2686254721))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2200818878))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2384911031))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2570832044))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2486224549))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3747192018))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3528626907))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3310321856))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3359936201))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3950355702))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3867060991))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4049844452))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4234721005))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1739656202))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1790575107))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2108100632))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1890328081))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1402811438))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1586903591))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1233856572))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1149249077))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 266959938))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 48394827))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 369057872))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 418672217))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1002783846))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 919489135))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 567498868))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 752375421))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 209336225))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 24197544))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 376187827))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 459744698))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 945164165))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 895287692))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 574624663))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 793451934))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1679968233))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1764313568))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2117360635))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1933530610))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1343127501))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1560637892))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1243112415))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1192455638))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3704280881))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3519142200))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3336358691))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3419915562))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3907448597))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3857572124))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4075877127))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4294704398))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3029510009))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3113855344))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2927934315))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2744104290))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2159976285))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2377486676))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2594734927))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2544078150))))),
};
pub const Tks3: [256]ulong32 = [256]ulong32{
    0,
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 151849742))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 303699484))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 454499602))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 607398968))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 758720310))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 908999204))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1059270954))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1214797936))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1097159550))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1517440620))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1400849762))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1817998408))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1699839814))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2118541908))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2001430874))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2429595872))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2581445614))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2194319100))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2345119218))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3034881240))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3186202582))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2801699524))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2951971274))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3635996816))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3518358430))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3399679628))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3283088770))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4237083816))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4118925222))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4002861748))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3885750714))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1002142683))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 850817237))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 698445255))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 548169417))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 529487843))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 377642221))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 227885567))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 77089521))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1943217067))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2061379749))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1640576439))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1757691577))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1474760595))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1592394909))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1174215055))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1290801793))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2875968315))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2724642869))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3111247143))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2960971305))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2405426947))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2253581325))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2638606623))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2487810577))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3808662347))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3926825029))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4044981591))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4162096729))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3342319475))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3459953789))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3576539503))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3693126241))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1986918061))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2137062819))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1685577905))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1836772287))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1381620373))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1532285339))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1078185097))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1229899655))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1040559837))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 923313619))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 740276417))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 621982671))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 439452389))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 322734571))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 137073913))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 19308535))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3871163981))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4021308739))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4104605777))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4255800159))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3263785589))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3414450555))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3499326569))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3651041127))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2933202493))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2815956275))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3167684641))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3049390895))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2330014213))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2213296395))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2566595609))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2448830231))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1305906550))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1155237496))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1607244650))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1455525988))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1776460110))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1626319424))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2079897426))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1928707164))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 96392454))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 213114376))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 396673818))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 514443284))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 562755902))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 679998000))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 865136418))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 983426092))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3708173718))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3557504664))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3474729866))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3323011204))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4180808110))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4030667424))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3945269170))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3794078908))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2507040230))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2623762152))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2272556026))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2390325492))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2975484382))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3092726480))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2738905026))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2857194700))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3973773121))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3856137295))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4274053469))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4157467219))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3371096953))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3252932727))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3673476453))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3556361835))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2763173681))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2915017791))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3064510765))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3215307299))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2156299017))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2307622919))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2459735317))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2610011675))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2081048481))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1963412655))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1846563261))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1729977011))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1480485785))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1362321559))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1243905413))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1126790795))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 878845905))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1030690015))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 645401037))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 796197571))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 274084841))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 425408743))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 38544885))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 188821243))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3613494426))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3731654548))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3313212038))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3430322568))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4082475170))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4200115116))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3780097726))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3896688048))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2668221674))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2516901860))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2366882550))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2216610296))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3141400786))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2989552604))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2837966542))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2687165888))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1202797690))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1320957812))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1437280870))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1554391400))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1669664834))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1787304780))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1906247262))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2022837584))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 265905162))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 114585348))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 499347990))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 349075736))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 736970802))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 585122620))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 972512814))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 821712160))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2595684844))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2478443234))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2293045232))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2174754046))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3196267988))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3079546586))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2895723464))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2777952454))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3537852828))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3687994002))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3234156416))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3385345166))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4142626212))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4293295786))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3841024952))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3992742070))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 174567692))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 57326082))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 410887952))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 292596766))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 777231668))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 660510266))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1011452712))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 893681702))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1108339068))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1258480242))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1343618912))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1494807662))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1715193156))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1865862730))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1948373848))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2100090966))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2701949495))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2818666809))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3004591147))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3122358053))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2235061775))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2352307457))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2535604243))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2653899549))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3915653703))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3764988233))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4219352155))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 4067639125))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3444575871))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3294430577))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3746175075))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 3594982253))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 836553431))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 953270745))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 600235211))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 718002117))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 367585007))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 484830689))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 133361907))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 251657213))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2041877159))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1891211689))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1806599355))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1654886325))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1568718495))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1418573201))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1335535747))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1184342925))))),
};
pub const rcon: [10]ulong32 = [10]ulong32{
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 16777216))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 33554432))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 67108864))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 134217728))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 268435456))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 536870912))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 1073741824))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 2147483648))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 452984832))))),
    @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, 905969664))))),
};
pub fn setup_mix(arg_temp: ulong32) callconv(.c) ulong32 {
    var temp = arg_temp;
    _ = &temp;
    return ((Te4_3[(temp >> @intCast(@as(c_int, 8) * @as(c_int, 2))) & @as(ulong32, @bitCast(@as(c_int, 255)))] ^ Te4_2[(temp >> @intCast(@as(c_int, 8) * @as(c_int, 1))) & @as(ulong32, @bitCast(@as(c_int, 255)))]) ^ Te4_1[(temp >> @intCast(@as(c_int, 8) * @as(c_int, 0))) & @as(ulong32, @bitCast(@as(c_int, 255)))]) ^ Te4_0[(temp >> @intCast(@as(c_int, 8) * @as(c_int, 3))) & @as(ulong32, @bitCast(@as(c_int, 255)))];
}
pub fn md5_compress(arg_md: [*c]hash_state, arg_buf: [*c]u8) callconv(.c) c_int {
    var md = arg_md;
    _ = &md;
    var buf = arg_buf;
    _ = &buf;
    var i: ulong32 = undefined;
    _ = &i;
    var W: [16]ulong32 = undefined;
    _ = &W;
    var a: ulong32 = undefined;
    _ = &a;
    var b: ulong32 = undefined;
    _ = &b;
    var c: ulong32 = undefined;
    _ = &c;
    var d: ulong32 = undefined;
    _ = &d;
    {
        i = 0;
        while (i < @as(ulong32, @bitCast(@as(c_int, 16)))) : (i +%= 1) {
            {
                _ = memcpy(@as(?*anyopaque, @ptrCast(&W[i])), @as(?*const anyopaque, @ptrCast(buf + (@as(ulong32, @bitCast(@as(c_int, 4))) *% i))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4)))));
                W[i] &= @as(ulong32, @bitCast(@as(c_uint, 4294967295)));
            }
        }
    }
    a = md.*.md5.state[@as(c_uint, @intCast(@as(c_int, 0)))];
    b = md.*.md5.state[@as(c_uint, @intCast(@as(c_int, 1)))];
    c = md.*.md5.state[@as(c_uint, @intCast(@as(c_int, 2)))];
    d = md.*.md5.state[@as(c_uint, @intCast(@as(c_int, 3)))];
    a = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (a +% (d ^ (b & (c ^ d)))) +% W[@as(c_uint, @intCast(@as(c_int, 0)))]))) +% @as(c_ulong, 3614090360)))));
    a = ROL(a, @as(c_int, 7)) +% b;
    d = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (d +% (c ^ (a & (b ^ c)))) +% W[@as(c_uint, @intCast(@as(c_int, 1)))]))) +% @as(c_ulong, 3905402710)))));
    d = ROL(d, @as(c_int, 12)) +% a;
    c = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (c +% (b ^ (d & (a ^ b)))) +% W[@as(c_uint, @intCast(@as(c_int, 2)))]))) +% @as(c_ulong, 606105819)))));
    c = ROL(c, @as(c_int, 17)) +% d;
    b = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (b +% (a ^ (c & (d ^ a)))) +% W[@as(c_uint, @intCast(@as(c_int, 3)))]))) +% @as(c_ulong, 3250441966)))));
    b = ROL(b, @as(c_int, 22)) +% c;
    a = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (a +% (d ^ (b & (c ^ d)))) +% W[@as(c_uint, @intCast(@as(c_int, 4)))]))) +% @as(c_ulong, 4118548399)))));
    a = ROL(a, @as(c_int, 7)) +% b;
    d = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (d +% (c ^ (a & (b ^ c)))) +% W[@as(c_uint, @intCast(@as(c_int, 5)))]))) +% @as(c_ulong, 1200080426)))));
    d = ROL(d, @as(c_int, 12)) +% a;
    c = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (c +% (b ^ (d & (a ^ b)))) +% W[@as(c_uint, @intCast(@as(c_int, 6)))]))) +% @as(c_ulong, 2821735955)))));
    c = ROL(c, @as(c_int, 17)) +% d;
    b = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (b +% (a ^ (c & (d ^ a)))) +% W[@as(c_uint, @intCast(@as(c_int, 7)))]))) +% @as(c_ulong, 4249261313)))));
    b = ROL(b, @as(c_int, 22)) +% c;
    a = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (a +% (d ^ (b & (c ^ d)))) +% W[@as(c_uint, @intCast(@as(c_int, 8)))]))) +% @as(c_ulong, 1770035416)))));
    a = ROL(a, @as(c_int, 7)) +% b;
    d = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (d +% (c ^ (a & (b ^ c)))) +% W[@as(c_uint, @intCast(@as(c_int, 9)))]))) +% @as(c_ulong, 2336552879)))));
    d = ROL(d, @as(c_int, 12)) +% a;
    c = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (c +% (b ^ (d & (a ^ b)))) +% W[@as(c_uint, @intCast(@as(c_int, 10)))]))) +% @as(c_ulong, 4294925233)))));
    c = ROL(c, @as(c_int, 17)) +% d;
    b = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (b +% (a ^ (c & (d ^ a)))) +% W[@as(c_uint, @intCast(@as(c_int, 11)))]))) +% @as(c_ulong, 2304563134)))));
    b = ROL(b, @as(c_int, 22)) +% c;
    a = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (a +% (d ^ (b & (c ^ d)))) +% W[@as(c_uint, @intCast(@as(c_int, 12)))]))) +% @as(c_ulong, 1804603682)))));
    a = ROL(a, @as(c_int, 7)) +% b;
    d = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (d +% (c ^ (a & (b ^ c)))) +% W[@as(c_uint, @intCast(@as(c_int, 13)))]))) +% @as(c_ulong, 4254626195)))));
    d = ROL(d, @as(c_int, 12)) +% a;
    c = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (c +% (b ^ (d & (a ^ b)))) +% W[@as(c_uint, @intCast(@as(c_int, 14)))]))) +% @as(c_ulong, 2792965006)))));
    c = ROL(c, @as(c_int, 17)) +% d;
    b = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (b +% (a ^ (c & (d ^ a)))) +% W[@as(c_uint, @intCast(@as(c_int, 15)))]))) +% @as(c_ulong, 1236535329)))));
    b = ROL(b, @as(c_int, 22)) +% c;
    a = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (a +% (c ^ (d & (c ^ b)))) +% W[@as(c_uint, @intCast(@as(c_int, 1)))]))) +% @as(c_ulong, 4129170786)))));
    a = ROL(a, @as(c_int, 5)) +% b;
    d = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (d +% (b ^ (c & (b ^ a)))) +% W[@as(c_uint, @intCast(@as(c_int, 6)))]))) +% @as(c_ulong, 3225465664)))));
    d = ROL(d, @as(c_int, 9)) +% a;
    c = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (c +% (a ^ (b & (a ^ d)))) +% W[@as(c_uint, @intCast(@as(c_int, 11)))]))) +% @as(c_ulong, 643717713)))));
    c = ROL(c, @as(c_int, 14)) +% d;
    b = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (b +% (d ^ (a & (d ^ c)))) +% W[@as(c_uint, @intCast(@as(c_int, 0)))]))) +% @as(c_ulong, 3921069994)))));
    b = ROL(b, @as(c_int, 20)) +% c;
    a = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (a +% (c ^ (d & (c ^ b)))) +% W[@as(c_uint, @intCast(@as(c_int, 5)))]))) +% @as(c_ulong, 3593408605)))));
    a = ROL(a, @as(c_int, 5)) +% b;
    d = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (d +% (b ^ (c & (b ^ a)))) +% W[@as(c_uint, @intCast(@as(c_int, 10)))]))) +% @as(c_ulong, 38016083)))));
    d = ROL(d, @as(c_int, 9)) +% a;
    c = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (c +% (a ^ (b & (a ^ d)))) +% W[@as(c_uint, @intCast(@as(c_int, 15)))]))) +% @as(c_ulong, 3634488961)))));
    c = ROL(c, @as(c_int, 14)) +% d;
    b = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (b +% (d ^ (a & (d ^ c)))) +% W[@as(c_uint, @intCast(@as(c_int, 4)))]))) +% @as(c_ulong, 3889429448)))));
    b = ROL(b, @as(c_int, 20)) +% c;
    a = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (a +% (c ^ (d & (c ^ b)))) +% W[@as(c_uint, @intCast(@as(c_int, 9)))]))) +% @as(c_ulong, 568446438)))));
    a = ROL(a, @as(c_int, 5)) +% b;
    d = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (d +% (b ^ (c & (b ^ a)))) +% W[@as(c_uint, @intCast(@as(c_int, 14)))]))) +% @as(c_ulong, 3275163606)))));
    d = ROL(d, @as(c_int, 9)) +% a;
    c = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (c +% (a ^ (b & (a ^ d)))) +% W[@as(c_uint, @intCast(@as(c_int, 3)))]))) +% @as(c_ulong, 4107603335)))));
    c = ROL(c, @as(c_int, 14)) +% d;
    b = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (b +% (d ^ (a & (d ^ c)))) +% W[@as(c_uint, @intCast(@as(c_int, 8)))]))) +% @as(c_ulong, 1163531501)))));
    b = ROL(b, @as(c_int, 20)) +% c;
    a = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (a +% (c ^ (d & (c ^ b)))) +% W[@as(c_uint, @intCast(@as(c_int, 13)))]))) +% @as(c_ulong, 2850285829)))));
    a = ROL(a, @as(c_int, 5)) +% b;
    d = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (d +% (b ^ (c & (b ^ a)))) +% W[@as(c_uint, @intCast(@as(c_int, 2)))]))) +% @as(c_ulong, 4243563512)))));
    d = ROL(d, @as(c_int, 9)) +% a;
    c = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (c +% (a ^ (b & (a ^ d)))) +% W[@as(c_uint, @intCast(@as(c_int, 7)))]))) +% @as(c_ulong, 1735328473)))));
    c = ROL(c, @as(c_int, 14)) +% d;
    b = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (b +% (d ^ (a & (d ^ c)))) +% W[@as(c_uint, @intCast(@as(c_int, 12)))]))) +% @as(c_ulong, 2368359562)))));
    b = ROL(b, @as(c_int, 20)) +% c;
    a = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (a +% ((b ^ c) ^ d)) +% W[@as(c_uint, @intCast(@as(c_int, 5)))]))) +% @as(c_ulong, 4294588738)))));
    a = ROL(a, @as(c_int, 4)) +% b;
    d = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (d +% ((a ^ b) ^ c)) +% W[@as(c_uint, @intCast(@as(c_int, 8)))]))) +% @as(c_ulong, 2272392833)))));
    d = ROL(d, @as(c_int, 11)) +% a;
    c = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (c +% ((d ^ a) ^ b)) +% W[@as(c_uint, @intCast(@as(c_int, 11)))]))) +% @as(c_ulong, 1839030562)))));
    c = ROL(c, @as(c_int, 16)) +% d;
    b = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (b +% ((c ^ d) ^ a)) +% W[@as(c_uint, @intCast(@as(c_int, 14)))]))) +% @as(c_ulong, 4259657740)))));
    b = ROL(b, @as(c_int, 23)) +% c;
    a = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (a +% ((b ^ c) ^ d)) +% W[@as(c_uint, @intCast(@as(c_int, 1)))]))) +% @as(c_ulong, 2763975236)))));
    a = ROL(a, @as(c_int, 4)) +% b;
    d = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (d +% ((a ^ b) ^ c)) +% W[@as(c_uint, @intCast(@as(c_int, 4)))]))) +% @as(c_ulong, 1272893353)))));
    d = ROL(d, @as(c_int, 11)) +% a;
    c = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (c +% ((d ^ a) ^ b)) +% W[@as(c_uint, @intCast(@as(c_int, 7)))]))) +% @as(c_ulong, 4139469664)))));
    c = ROL(c, @as(c_int, 16)) +% d;
    b = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (b +% ((c ^ d) ^ a)) +% W[@as(c_uint, @intCast(@as(c_int, 10)))]))) +% @as(c_ulong, 3200236656)))));
    b = ROL(b, @as(c_int, 23)) +% c;
    a = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (a +% ((b ^ c) ^ d)) +% W[@as(c_uint, @intCast(@as(c_int, 13)))]))) +% @as(c_ulong, 681279174)))));
    a = ROL(a, @as(c_int, 4)) +% b;
    d = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (d +% ((a ^ b) ^ c)) +% W[@as(c_uint, @intCast(@as(c_int, 0)))]))) +% @as(c_ulong, 3936430074)))));
    d = ROL(d, @as(c_int, 11)) +% a;
    c = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (c +% ((d ^ a) ^ b)) +% W[@as(c_uint, @intCast(@as(c_int, 3)))]))) +% @as(c_ulong, 3572445317)))));
    c = ROL(c, @as(c_int, 16)) +% d;
    b = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (b +% ((c ^ d) ^ a)) +% W[@as(c_uint, @intCast(@as(c_int, 6)))]))) +% @as(c_ulong, 76029189)))));
    b = ROL(b, @as(c_int, 23)) +% c;
    a = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (a +% ((b ^ c) ^ d)) +% W[@as(c_uint, @intCast(@as(c_int, 9)))]))) +% @as(c_ulong, 3654602809)))));
    a = ROL(a, @as(c_int, 4)) +% b;
    d = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (d +% ((a ^ b) ^ c)) +% W[@as(c_uint, @intCast(@as(c_int, 12)))]))) +% @as(c_ulong, 3873151461)))));
    d = ROL(d, @as(c_int, 11)) +% a;
    c = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (c +% ((d ^ a) ^ b)) +% W[@as(c_uint, @intCast(@as(c_int, 15)))]))) +% @as(c_ulong, 530742520)))));
    c = ROL(c, @as(c_int, 16)) +% d;
    b = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (b +% ((c ^ d) ^ a)) +% W[@as(c_uint, @intCast(@as(c_int, 2)))]))) +% @as(c_ulong, 3299628645)))));
    b = ROL(b, @as(c_int, 23)) +% c;
    a = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (a +% (c ^ (b | ~d))) +% W[@as(c_uint, @intCast(@as(c_int, 0)))]))) +% @as(c_ulong, 4096336452)))));
    a = ROL(a, @as(c_int, 6)) +% b;
    d = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (d +% (b ^ (a | ~c))) +% W[@as(c_uint, @intCast(@as(c_int, 7)))]))) +% @as(c_ulong, 1126891415)))));
    d = ROL(d, @as(c_int, 10)) +% a;
    c = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (c +% (a ^ (d | ~b))) +% W[@as(c_uint, @intCast(@as(c_int, 14)))]))) +% @as(c_ulong, 2878612391)))));
    c = ROL(c, @as(c_int, 15)) +% d;
    b = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (b +% (d ^ (c | ~a))) +% W[@as(c_uint, @intCast(@as(c_int, 5)))]))) +% @as(c_ulong, 4237533241)))));
    b = ROL(b, @as(c_int, 21)) +% c;
    a = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (a +% (c ^ (b | ~d))) +% W[@as(c_uint, @intCast(@as(c_int, 12)))]))) +% @as(c_ulong, 1700485571)))));
    a = ROL(a, @as(c_int, 6)) +% b;
    d = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (d +% (b ^ (a | ~c))) +% W[@as(c_uint, @intCast(@as(c_int, 3)))]))) +% @as(c_ulong, 2399980690)))));
    d = ROL(d, @as(c_int, 10)) +% a;
    c = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (c +% (a ^ (d | ~b))) +% W[@as(c_uint, @intCast(@as(c_int, 10)))]))) +% @as(c_ulong, 4293915773)))));
    c = ROL(c, @as(c_int, 15)) +% d;
    b = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (b +% (d ^ (c | ~a))) +% W[@as(c_uint, @intCast(@as(c_int, 1)))]))) +% @as(c_ulong, 2240044497)))));
    b = ROL(b, @as(c_int, 21)) +% c;
    a = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (a +% (c ^ (b | ~d))) +% W[@as(c_uint, @intCast(@as(c_int, 8)))]))) +% @as(c_ulong, 1873313359)))));
    a = ROL(a, @as(c_int, 6)) +% b;
    d = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (d +% (b ^ (a | ~c))) +% W[@as(c_uint, @intCast(@as(c_int, 15)))]))) +% @as(c_ulong, 4264355552)))));
    d = ROL(d, @as(c_int, 10)) +% a;
    c = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (c +% (a ^ (d | ~b))) +% W[@as(c_uint, @intCast(@as(c_int, 6)))]))) +% @as(c_ulong, 2734768916)))));
    c = ROL(c, @as(c_int, 15)) +% d;
    b = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (b +% (d ^ (c | ~a))) +% W[@as(c_uint, @intCast(@as(c_int, 13)))]))) +% @as(c_ulong, 1309151649)))));
    b = ROL(b, @as(c_int, 21)) +% c;
    a = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (a +% (c ^ (b | ~d))) +% W[@as(c_uint, @intCast(@as(c_int, 4)))]))) +% @as(c_ulong, 4149444226)))));
    a = ROL(a, @as(c_int, 6)) +% b;
    d = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (d +% (b ^ (a | ~c))) +% W[@as(c_uint, @intCast(@as(c_int, 11)))]))) +% @as(c_ulong, 3174756917)))));
    d = ROL(d, @as(c_int, 10)) +% a;
    c = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (c +% (a ^ (d | ~b))) +% W[@as(c_uint, @intCast(@as(c_int, 2)))]))) +% @as(c_ulong, 718787259)))));
    c = ROL(c, @as(c_int, 15)) +% d;
    b = @as(ulong32, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_ulong, (b +% (d ^ (c | ~a))) +% W[@as(c_uint, @intCast(@as(c_int, 9)))]))) +% @as(c_ulong, 3951481745)))));
    b = ROL(b, @as(c_int, 21)) +% c;
    md.*.md5.state[@as(c_uint, @intCast(@as(c_int, 0)))] = md.*.md5.state[@as(c_uint, @intCast(@as(c_int, 0)))] +% a;
    md.*.md5.state[@as(c_uint, @intCast(@as(c_int, 1)))] = md.*.md5.state[@as(c_uint, @intCast(@as(c_int, 1)))] +% b;
    md.*.md5.state[@as(c_uint, @intCast(@as(c_int, 2)))] = md.*.md5.state[@as(c_uint, @intCast(@as(c_int, 2)))] +% c;
    md.*.md5.state[@as(c_uint, @intCast(@as(c_int, 3)))] = md.*.md5.state[@as(c_uint, @intCast(@as(c_int, 3)))] +% d;
    return CRYPT_OK;
}
pub const @"u8" = u8;
pub const @"u32" = ulong32;
pub const @"u64" = ulong64;
pub const @"i64" = long64;
pub const gf = [16]@"i64";
pub const nine: [32]@"u8" = [1]@"u8"{
    9,
} ++ [1]@"u8"{@import("std").mem.zeroes(@"u8")} ** 31;
pub const gf0: gf = [1]@"i64"{
    0,
} ++ [1]@"i64"{@import("std").mem.zeroes(@"i64")} ** 15;
pub const gf1: gf = [1]@"i64"{
    1,
} ++ [1]@"i64"{@import("std").mem.zeroes(@"i64")} ** 15;
pub const gf121665: gf = [2]@"i64"{
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 56129)))),
    1,
} ++ [1]@"i64"{@import("std").mem.zeroes(@"i64")} ** 14;
pub const D: gf = [16]@"i64"{
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 30883)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 4953)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 19914)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 30187)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 55467)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 16705)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 2637)))),
    112,
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 59544)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 30585)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 16505)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 36039)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 65139)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 11119)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 27886)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 20995)))),
};
pub const D2: gf = [16]@"i64"{
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 61785)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 9906)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 39828)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 60374)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 45398)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 33411)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 5274)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 224)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 53552)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 61171)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 33010)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 6542)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 64743)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 22239)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 55772)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 9222)))),
};
pub const X: gf = [16]@"i64"{
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 54554)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 36645)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 11616)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 51542)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 42930)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 38181)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 51040)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 26924)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 56412)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 64982)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 57905)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 49316)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 21502)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 52590)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 14035)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 8553)))),
};
pub const Y: gf = [16]@"i64"{
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 26200)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 26214)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 26214)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 26214)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 26214)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 26214)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 26214)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 26214)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 26214)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 26214)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 26214)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 26214)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 26214)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 26214)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 26214)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 26214)))),
};
pub const I: gf = [16]@"i64"{
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 41136)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 18958)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 6951)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 50414)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 58488)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 44335)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 6150)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 12099)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 55207)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 15867)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 153)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 11085)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 57099)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 20417)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 9344)))),
    @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 11139)))),
};
pub fn vn(arg_x: [*c]const @"u8", arg_y: [*c]const @"u8", arg_n: c_int) callconv(.c) c_int {
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    var n = arg_n;
    _ = &n;
    var i: c_int = undefined;
    _ = &i;
    var d: @"u32" = 0;
    _ = &d;
    {
        i = 0;
        while (i < n) : (i += 1) {
            d |= @as(@"u32", @bitCast(@as(c_int, @bitCast(@as(c_uint, (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk x + @as(usize, @intCast(tmp)) else break :blk x - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))) ^ @as(c_int, @bitCast(@as(c_uint, (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk y + @as(usize, @intCast(tmp)) else break :blk y - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*)))));
        }
    }
    return @as(c_int, @bitCast((@as(@"u32", @bitCast(@as(c_int, 1))) & ((d -% @as(@"u32", @bitCast(@as(c_int, 1)))) >> @intCast(8))) -% @as(@"u32", @bitCast(@as(c_int, 1)))));
}
pub fn tweetnacl_crypto_verify_32(arg_x: [*c]const @"u8", arg_y: [*c]const @"u8") callconv(.c) c_int {
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    return vn(x, y, @as(c_int, 32));
}
pub fn set25519(arg_r: [*c]@"i64", a: [*c]const @"i64") callconv(.c) void {
    var r = arg_r;
    _ = &r;
    _ = &a;
    var i: c_int = undefined;
    _ = &i;
    {
        i = 0;
        while (i < @as(c_int, 16)) : (i += 1) {
            (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk r + @as(usize, @intCast(tmp)) else break :blk r - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk a + @as(usize, @intCast(tmp)) else break :blk a - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
        }
    }
}
pub fn car25519(arg_o: [*c]@"i64") callconv(.c) void {
    var o = arg_o;
    _ = &o;
    var i: c_int = undefined;
    _ = &i;
    var c: @"i64" = undefined;
    _ = &c;
    {
        i = 0;
        while (i < @as(c_int, 16)) : (i += 1) {
            (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk o + @as(usize, @intCast(tmp)) else break :blk o - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* += @as(@"i64", @bitCast(@as(c_longlong, 1) << @intCast(16)));
            c = (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk o + @as(usize, @intCast(tmp)) else break :blk o - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* >> @intCast(16);
            (blk: {
                const tmp = (i + @as(c_int, 1)) * @intFromBool(i < @as(c_int, 15));
                if (tmp >= 0) break :blk o + @as(usize, @intCast(tmp)) else break :blk o - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* += (c - @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 1))))) + ((@as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 37)))) * (c - @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 1)))))) * @as(@"i64", @intFromBool(i == @as(c_int, 15))));
            (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk o + @as(usize, @intCast(tmp)) else break :blk o - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* -= c << @intCast(16);
        }
    }
}
pub fn sel25519(arg_p: [*c]@"i64", arg_q: [*c]@"i64", arg_b: c_int) callconv(.c) void {
    var p = arg_p;
    _ = &p;
    var q = arg_q;
    _ = &q;
    var b = arg_b;
    _ = &b;
    var t: @"i64" = undefined;
    _ = &t;
    var i: @"i64" = undefined;
    _ = &i;
    var c: @"i64" = @as(@"i64", @bitCast(@as(c_longlong, ~(b - @as(c_int, 1)))));
    _ = &c;
    {
        i = 0;
        while (i < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 16))))) : (i += 1) {
            t = c & ((blk: {
                const tmp = i;
                if (tmp >= 0) break :blk p + @as(usize, @intCast(tmp)) else break :blk p - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* ^ (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk q + @as(usize, @intCast(tmp)) else break :blk q - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*);
            (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk p + @as(usize, @intCast(tmp)) else break :blk p - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* ^= t;
            (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk q + @as(usize, @intCast(tmp)) else break :blk q - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* ^= t;
        }
    }
}
pub fn pack25519(arg_o: [*c]@"u8", n: [*c]const @"i64") callconv(.c) void {
    var o = arg_o;
    _ = &o;
    _ = &n;
    var i: c_int = undefined;
    _ = &i;
    var j: c_int = undefined;
    _ = &j;
    var b: c_int = undefined;
    _ = &b;
    var m: gf = undefined;
    _ = &m;
    var t: gf = undefined;
    _ = &t;
    {
        i = 0;
        while (i < @as(c_int, 16)) : (i += 1) {
            t[@as(c_uint, @intCast(i))] = (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk n + @as(usize, @intCast(tmp)) else break :blk n - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
        }
    }
    car25519(@as([*c]@"i64", @ptrCast(@alignCast(&t))));
    car25519(@as([*c]@"i64", @ptrCast(@alignCast(&t))));
    car25519(@as([*c]@"i64", @ptrCast(@alignCast(&t))));
    {
        j = 0;
        while (j < @as(c_int, 2)) : (j += 1) {
            m[@as(c_uint, @intCast(@as(c_int, 0)))] = t[@as(c_uint, @intCast(@as(c_int, 0)))] - @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 65517))));
            {
                i = 1;
                while (i < @as(c_int, 15)) : (i += 1) {
                    m[@as(c_uint, @intCast(i))] = (t[@as(c_uint, @intCast(i))] - @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 65535))))) - ((m[@as(c_uint, @intCast(i - @as(c_int, 1)))] >> @intCast(16)) & @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 1)))));
                    m[@as(c_uint, @intCast(i - @as(c_int, 1)))] &= @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 65535))));
                }
            }
            m[@as(c_uint, @intCast(@as(c_int, 15)))] = (t[@as(c_uint, @intCast(@as(c_int, 15)))] - @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 32767))))) - ((m[@as(c_uint, @intCast(@as(c_int, 14)))] >> @intCast(16)) & @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 1)))));
            b = @as(c_int, @bitCast(@as(c_int, @truncate((m[@as(c_uint, @intCast(@as(c_int, 15)))] >> @intCast(16)) & @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 1))))))));
            m[@as(c_uint, @intCast(@as(c_int, 14)))] &= @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 65535))));
            sel25519(@as([*c]@"i64", @ptrCast(@alignCast(&t))), @as([*c]@"i64", @ptrCast(@alignCast(&m))), @as(c_int, 1) - b);
        }
    }
    {
        i = 0;
        while (i < @as(c_int, 16)) : (i += 1) {
            (blk: {
                const tmp = @as(c_int, 2) * i;
                if (tmp >= 0) break :blk o + @as(usize, @intCast(tmp)) else break :blk o - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = @as(@"u8", @bitCast(@as(i8, @truncate(t[@as(c_uint, @intCast(i))] & @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 255))))))));
            (blk: {
                const tmp = (@as(c_int, 2) * i) + @as(c_int, 1);
                if (tmp >= 0) break :blk o + @as(usize, @intCast(tmp)) else break :blk o - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = @as(@"u8", @bitCast(@as(i8, @truncate(t[@as(c_uint, @intCast(i))] >> @intCast(8)))));
        }
    }
}
pub fn neq25519(a: [*c]const @"i64", b: [*c]const @"i64") callconv(.c) c_int {
    _ = &a;
    _ = &b;
    var c: [32]@"u8" = undefined;
    _ = &c;
    var d: [32]@"u8" = undefined;
    _ = &d;
    pack25519(@as([*c]@"u8", @ptrCast(@alignCast(&c))), a);
    pack25519(@as([*c]@"u8", @ptrCast(@alignCast(&d))), b);
    return tweetnacl_crypto_verify_32(@as([*c]@"u8", @ptrCast(@alignCast(&c))), @as([*c]@"u8", @ptrCast(@alignCast(&d))));
}
pub fn par25519(a: [*c]const @"i64") callconv(.c) @"u8" {
    _ = &a;
    var d: [32]@"u8" = undefined;
    _ = &d;
    pack25519(@as([*c]@"u8", @ptrCast(@alignCast(&d))), a);
    return @as(@"u8", @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, d[@as(c_uint, @intCast(@as(c_int, 0)))]))) & @as(c_int, 1)))));
}
pub fn unpack25519(arg_o: [*c]@"i64", arg_n: [*c]const @"u8") callconv(.c) void {
    var o = arg_o;
    _ = &o;
    var n = arg_n;
    _ = &n;
    var i: c_int = undefined;
    _ = &i;
    {
        i = 0;
        while (i < @as(c_int, 16)) : (i += 1) {
            (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk o + @as(usize, @intCast(tmp)) else break :blk o - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = @as(@"i64", @bitCast(@as(c_ulonglong, (blk: {
                const tmp = @as(c_int, 2) * i;
                if (tmp >= 0) break :blk n + @as(usize, @intCast(tmp)) else break :blk n - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))) + (@as(@"i64", @bitCast(@as(c_ulonglong, (blk: {
                const tmp = (@as(c_int, 2) * i) + @as(c_int, 1);
                if (tmp >= 0) break :blk n + @as(usize, @intCast(tmp)) else break :blk n - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))) << @intCast(8));
        }
    }
    o[@as(c_uint, @intCast(@as(c_int, 15)))] &= @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 32767))));
}
pub fn A(arg_o: [*c]@"i64", a: [*c]const @"i64", b: [*c]const @"i64") callconv(.c) void {
    var o = arg_o;
    _ = &o;
    _ = &a;
    _ = &b;
    var i: c_int = undefined;
    _ = &i;
    {
        i = 0;
        while (i < @as(c_int, 16)) : (i += 1) {
            (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk o + @as(usize, @intCast(tmp)) else break :blk o - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk a + @as(usize, @intCast(tmp)) else break :blk a - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* + (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk b + @as(usize, @intCast(tmp)) else break :blk b - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
        }
    }
}
pub fn Z(arg_o: [*c]@"i64", a: [*c]const @"i64", b: [*c]const @"i64") callconv(.c) void {
    var o = arg_o;
    _ = &o;
    _ = &a;
    _ = &b;
    var i: c_int = undefined;
    _ = &i;
    {
        i = 0;
        while (i < @as(c_int, 16)) : (i += 1) {
            (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk o + @as(usize, @intCast(tmp)) else break :blk o - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk a + @as(usize, @intCast(tmp)) else break :blk a - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* - (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk b + @as(usize, @intCast(tmp)) else break :blk b - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
        }
    }
}
pub fn M(arg_o: [*c]@"i64", a: [*c]const @"i64", b: [*c]const @"i64") callconv(.c) void {
    var o = arg_o;
    _ = &o;
    _ = &a;
    _ = &b;
    var i: @"i64" = undefined;
    _ = &i;
    var j: @"i64" = undefined;
    _ = &j;
    var t: [31]@"i64" = undefined;
    _ = &t;
    {
        i = 0;
        while (i < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 31))))) : (i += 1) {
            t[@as(usize, @intCast(i))] = 0;
        }
    }
    {
        i = 0;
        while (i < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 16))))) : (i += 1) {
            j = 0;
            while (j < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 16))))) : (j += 1) {
                t[@as(usize, @intCast(i + j))] += (blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk a + @as(usize, @intCast(tmp)) else break :blk a - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).* * (blk: {
                    const tmp = j;
                    if (tmp >= 0) break :blk b + @as(usize, @intCast(tmp)) else break :blk b - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*;
            }
        }
    }
    {
        i = 0;
        while (i < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 15))))) : (i += 1) {
            t[@as(usize, @intCast(i))] += @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 38)))) * t[@as(usize, @intCast(i + @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 16))))))];
        }
    }
    {
        i = 0;
        while (i < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 16))))) : (i += 1) {
            (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk o + @as(usize, @intCast(tmp)) else break :blk o - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = t[@as(usize, @intCast(i))];
        }
    }
    car25519(o);
    car25519(o);
}
pub fn S(arg_o: [*c]@"i64", a: [*c]const @"i64") callconv(.c) void {
    var o = arg_o;
    _ = &o;
    _ = &a;
    M(o, a, a);
}
pub fn inv25519(arg_o: [*c]@"i64", i: [*c]const @"i64") callconv(.c) void {
    var o = arg_o;
    _ = &o;
    _ = &i;
    var c: gf = undefined;
    _ = &c;
    var a: c_int = undefined;
    _ = &a;
    {
        a = 0;
        while (a < @as(c_int, 16)) : (a += 1) {
            c[@as(c_uint, @intCast(a))] = (blk: {
                const tmp = a;
                if (tmp >= 0) break :blk i + @as(usize, @intCast(tmp)) else break :blk i - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
        }
    }
    {
        a = 253;
        while (a >= @as(c_int, 0)) : (a -= 1) {
            S(@as([*c]@"i64", @ptrCast(@alignCast(&c))), @as([*c]@"i64", @ptrCast(@alignCast(&c))));
            if ((a != @as(c_int, 2)) and (a != @as(c_int, 4))) {
                M(@as([*c]@"i64", @ptrCast(@alignCast(&c))), @as([*c]@"i64", @ptrCast(@alignCast(&c))), i);
            }
        }
    }
    {
        a = 0;
        while (a < @as(c_int, 16)) : (a += 1) {
            (blk: {
                const tmp = a;
                if (tmp >= 0) break :blk o + @as(usize, @intCast(tmp)) else break :blk o - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = c[@as(c_uint, @intCast(a))];
        }
    }
}
pub fn pow2523(arg_o: [*c]@"i64", i: [*c]const @"i64") callconv(.c) void {
    var o = arg_o;
    _ = &o;
    _ = &i;
    var c: gf = undefined;
    _ = &c;
    var a: c_int = undefined;
    _ = &a;
    {
        a = 0;
        while (a < @as(c_int, 16)) : (a += 1) {
            c[@as(c_uint, @intCast(a))] = (blk: {
                const tmp = a;
                if (tmp >= 0) break :blk i + @as(usize, @intCast(tmp)) else break :blk i - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
        }
    }
    {
        a = 250;
        while (a >= @as(c_int, 0)) : (a -= 1) {
            S(@as([*c]@"i64", @ptrCast(@alignCast(&c))), @as([*c]@"i64", @ptrCast(@alignCast(&c))));
            if (a != @as(c_int, 1)) {
                M(@as([*c]@"i64", @ptrCast(@alignCast(&c))), @as([*c]@"i64", @ptrCast(@alignCast(&c))), i);
            }
        }
    }
    {
        a = 0;
        while (a < @as(c_int, 16)) : (a += 1) {
            (blk: {
                const tmp = a;
                if (tmp >= 0) break :blk o + @as(usize, @intCast(tmp)) else break :blk o - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = c[@as(c_uint, @intCast(a))];
        }
    }
}
pub export fn tweetnacl_crypto_scalarmult(arg_q: [*c]@"u8", arg_n: [*c]const @"u8", arg_p: [*c]const @"u8") c_int {
    var q = arg_q;
    _ = &q;
    var n = arg_n;
    _ = &n;
    var p = arg_p;
    _ = &p;
    var z: [32]@"u8" = undefined;
    _ = &z;
    var x: [80]@"i64" = undefined;
    _ = &x;
    var r: @"i64" = undefined;
    _ = &r;
    var i: @"i64" = undefined;
    _ = &i;
    var a: gf = undefined;
    _ = &a;
    var b: gf = undefined;
    _ = &b;
    var c: gf = undefined;
    _ = &c;
    var d: gf = undefined;
    _ = &d;
    var e: gf = undefined;
    _ = &e;
    var f: gf = undefined;
    _ = &f;
    {
        i = 0;
        while (i < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 31))))) : (i += 1) {
            z[@as(usize, @intCast(i))] = (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk n + @as(usize, @intCast(tmp)) else break :blk n - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
        }
    }
    z[@as(c_uint, @intCast(@as(c_int, 31)))] = @as(@"u8", @bitCast(@as(i8, @truncate((@as(c_int, @bitCast(@as(c_uint, n[@as(c_uint, @intCast(@as(c_int, 31)))]))) & @as(c_int, 127)) | @as(c_int, 64)))));
    z[@as(c_uint, @intCast(@as(c_int, 0)))] &= @as(@"u8", @bitCast(@as(i8, @truncate(@as(c_int, 248)))));
    unpack25519(@as([*c]@"i64", @ptrCast(@alignCast(&x))), p);
    {
        i = 0;
        while (i < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 16))))) : (i += 1) {
            b[@as(usize, @intCast(i))] = x[@as(usize, @intCast(i))];
            d[@as(usize, @intCast(i))] = blk: {
                const tmp = blk_1: {
                    const tmp_2 = @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 0))));
                    c[@as(usize, @intCast(i))] = tmp_2;
                    break :blk_1 tmp_2;
                };
                a[@as(usize, @intCast(i))] = tmp;
                break :blk tmp;
            };
        }
    }
    a[@as(c_uint, @intCast(@as(c_int, 0)))] = blk: {
        const tmp = @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 1))));
        d[@as(c_uint, @intCast(@as(c_int, 0)))] = tmp;
        break :blk tmp;
    };
    {
        i = @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 254))));
        while (i >= @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 0))))) : (i -= 1) {
            r = @as(@"i64", @bitCast(@as(c_longlong, (@as(c_int, @bitCast(@as(c_uint, z[@as(usize, @intCast(i >> @intCast(3)))]))) >> @intCast(i & @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 7)))))) & @as(c_int, 1))));
            sel25519(@as([*c]@"i64", @ptrCast(@alignCast(&a))), @as([*c]@"i64", @ptrCast(@alignCast(&b))), @as(c_int, @bitCast(@as(c_int, @truncate(r)))));
            sel25519(@as([*c]@"i64", @ptrCast(@alignCast(&c))), @as([*c]@"i64", @ptrCast(@alignCast(&d))), @as(c_int, @bitCast(@as(c_int, @truncate(r)))));
            A(@as([*c]@"i64", @ptrCast(@alignCast(&e))), @as([*c]@"i64", @ptrCast(@alignCast(&a))), @as([*c]@"i64", @ptrCast(@alignCast(&c))));
            Z(@as([*c]@"i64", @ptrCast(@alignCast(&a))), @as([*c]@"i64", @ptrCast(@alignCast(&a))), @as([*c]@"i64", @ptrCast(@alignCast(&c))));
            A(@as([*c]@"i64", @ptrCast(@alignCast(&c))), @as([*c]@"i64", @ptrCast(@alignCast(&b))), @as([*c]@"i64", @ptrCast(@alignCast(&d))));
            Z(@as([*c]@"i64", @ptrCast(@alignCast(&b))), @as([*c]@"i64", @ptrCast(@alignCast(&b))), @as([*c]@"i64", @ptrCast(@alignCast(&d))));
            S(@as([*c]@"i64", @ptrCast(@alignCast(&d))), @as([*c]@"i64", @ptrCast(@alignCast(&e))));
            S(@as([*c]@"i64", @ptrCast(@alignCast(&f))), @as([*c]@"i64", @ptrCast(@alignCast(&a))));
            M(@as([*c]@"i64", @ptrCast(@alignCast(&a))), @as([*c]@"i64", @ptrCast(@alignCast(&c))), @as([*c]@"i64", @ptrCast(@alignCast(&a))));
            M(@as([*c]@"i64", @ptrCast(@alignCast(&c))), @as([*c]@"i64", @ptrCast(@alignCast(&b))), @as([*c]@"i64", @ptrCast(@alignCast(&e))));
            A(@as([*c]@"i64", @ptrCast(@alignCast(&e))), @as([*c]@"i64", @ptrCast(@alignCast(&a))), @as([*c]@"i64", @ptrCast(@alignCast(&c))));
            Z(@as([*c]@"i64", @ptrCast(@alignCast(&a))), @as([*c]@"i64", @ptrCast(@alignCast(&a))), @as([*c]@"i64", @ptrCast(@alignCast(&c))));
            S(@as([*c]@"i64", @ptrCast(@alignCast(&b))), @as([*c]@"i64", @ptrCast(@alignCast(&a))));
            Z(@as([*c]@"i64", @ptrCast(@alignCast(&c))), @as([*c]@"i64", @ptrCast(@alignCast(&d))), @as([*c]@"i64", @ptrCast(@alignCast(&f))));
            M(@as([*c]@"i64", @ptrCast(@alignCast(&a))), @as([*c]@"i64", @ptrCast(@alignCast(&c))), @as([*c]const @"i64", @ptrCast(@alignCast(&gf121665))));
            A(@as([*c]@"i64", @ptrCast(@alignCast(&a))), @as([*c]@"i64", @ptrCast(@alignCast(&a))), @as([*c]@"i64", @ptrCast(@alignCast(&d))));
            M(@as([*c]@"i64", @ptrCast(@alignCast(&c))), @as([*c]@"i64", @ptrCast(@alignCast(&c))), @as([*c]@"i64", @ptrCast(@alignCast(&a))));
            M(@as([*c]@"i64", @ptrCast(@alignCast(&a))), @as([*c]@"i64", @ptrCast(@alignCast(&d))), @as([*c]@"i64", @ptrCast(@alignCast(&f))));
            M(@as([*c]@"i64", @ptrCast(@alignCast(&d))), @as([*c]@"i64", @ptrCast(@alignCast(&b))), @as([*c]@"i64", @ptrCast(@alignCast(&x))));
            S(@as([*c]@"i64", @ptrCast(@alignCast(&b))), @as([*c]@"i64", @ptrCast(@alignCast(&e))));
            sel25519(@as([*c]@"i64", @ptrCast(@alignCast(&a))), @as([*c]@"i64", @ptrCast(@alignCast(&b))), @as(c_int, @bitCast(@as(c_int, @truncate(r)))));
            sel25519(@as([*c]@"i64", @ptrCast(@alignCast(&c))), @as([*c]@"i64", @ptrCast(@alignCast(&d))), @as(c_int, @bitCast(@as(c_int, @truncate(r)))));
        }
    }
    {
        i = 0;
        while (i < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 16))))) : (i += 1) {
            x[@as(usize, @intCast(i + @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 16))))))] = a[@as(usize, @intCast(i))];
            x[@as(usize, @intCast(i + @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 32))))))] = c[@as(usize, @intCast(i))];
            x[@as(usize, @intCast(i + @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 48))))))] = b[@as(usize, @intCast(i))];
            x[@as(usize, @intCast(i + @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 64))))))] = d[@as(usize, @intCast(i))];
        }
    }
    inv25519(@as([*c]@"i64", @ptrCast(@alignCast(&x))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))), @as([*c]@"i64", @ptrCast(@alignCast(&x))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&x))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))), @as([*c]@"i64", @ptrCast(@alignCast(&x))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))), @as([*c]@"i64", @ptrCast(@alignCast(&x))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))));
    pack25519(q, @as([*c]@"i64", @ptrCast(@alignCast(&x))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))));
    return 0;
}
pub export fn tweetnacl_crypto_scalarmult_base(arg_q: [*c]@"u8", arg_n: [*c]const @"u8") c_int {
    var q = arg_q;
    _ = &q;
    var n = arg_n;
    _ = &n;
    return tweetnacl_crypto_scalarmult(q, n, @as([*c]const @"u8", @ptrCast(@alignCast(&nine))));
}
pub fn tweetnacl_crypto_hash_ctx(arg_out: [*c]@"u8", arg_m: [*c]const @"u8", arg_n: @"u64", arg_ctx: [*c]const @"u8", arg_cs: @"u32") callconv(.c) c_int {
    var out = arg_out;
    _ = &out;
    var m = arg_m;
    _ = &m;
    var n = arg_n;
    _ = &n;
    var ctx = arg_ctx;
    _ = &ctx;
    var cs = arg_cs;
    _ = &cs;
    var len: c_ulong = 64;
    _ = &len;
    var hash_idx: c_int = find_hash("sha512");
    _ = &hash_idx;
    if (n > @as(@"u64", @bitCast(@as(c_ulonglong, (@as(c_ulong, @bitCast(@as(c_long, 9223372036854775807))) *% @as(c_ulong, 2)) +% @as(c_ulong, 1))))) return CRYPT_OVERFLOW;
    if (cs == @as(@"u32", @bitCast(@as(c_int, 0)))) return hash_memory(hash_idx, m, @as(c_ulong, @bitCast(@as(c_ulong, @truncate(n)))), out, &len);
    return hash_memory_multi(hash_idx, out, &len, ctx, @as(c_ulong, @bitCast(@as(c_ulong, cs))), m, n, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
}
pub fn tweetnacl_crypto_hash(arg_out: [*c]@"u8", arg_m: [*c]const @"u8", arg_n: @"u64") callconv(.c) c_int {
    var out = arg_out;
    _ = &out;
    var m = arg_m;
    _ = &m;
    var n = arg_n;
    _ = &n;
    return tweetnacl_crypto_hash_ctx(out, m, n, null, @as(@"u32", @bitCast(@as(c_int, 0))));
}
pub fn add_(arg_p: [*c]gf, arg_q: [*c]gf) callconv(.c) void {
    var p = arg_p;
    _ = &p;
    var q = arg_q;
    _ = &q;
    var a: gf = undefined;
    _ = &a;
    var b: gf = undefined;
    _ = &b;
    var c: gf = undefined;
    _ = &c;
    var d: gf = undefined;
    _ = &d;
    var t: gf = undefined;
    _ = &t;
    var e: gf = undefined;
    _ = &e;
    var f: gf = undefined;
    _ = &f;
    var g: gf = undefined;
    _ = &g;
    var h: gf = undefined;
    _ = &h;
    Z(@as([*c]@"i64", @ptrCast(@alignCast(&a))), @as([*c]@"i64", @ptrCast(@alignCast(&p[@as(c_uint, @intCast(@as(c_int, 1)))]))), @as([*c]@"i64", @ptrCast(@alignCast(&p[@as(c_uint, @intCast(@as(c_int, 0)))]))));
    Z(@as([*c]@"i64", @ptrCast(@alignCast(&t))), @as([*c]@"i64", @ptrCast(@alignCast(&q[@as(c_uint, @intCast(@as(c_int, 1)))]))), @as([*c]@"i64", @ptrCast(@alignCast(&q[@as(c_uint, @intCast(@as(c_int, 0)))]))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&a))), @as([*c]@"i64", @ptrCast(@alignCast(&a))), @as([*c]@"i64", @ptrCast(@alignCast(&t))));
    A(@as([*c]@"i64", @ptrCast(@alignCast(&b))), @as([*c]@"i64", @ptrCast(@alignCast(&p[@as(c_uint, @intCast(@as(c_int, 0)))]))), @as([*c]@"i64", @ptrCast(@alignCast(&p[@as(c_uint, @intCast(@as(c_int, 1)))]))));
    A(@as([*c]@"i64", @ptrCast(@alignCast(&t))), @as([*c]@"i64", @ptrCast(@alignCast(&q[@as(c_uint, @intCast(@as(c_int, 0)))]))), @as([*c]@"i64", @ptrCast(@alignCast(&q[@as(c_uint, @intCast(@as(c_int, 1)))]))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&b))), @as([*c]@"i64", @ptrCast(@alignCast(&b))), @as([*c]@"i64", @ptrCast(@alignCast(&t))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&c))), @as([*c]@"i64", @ptrCast(@alignCast(&p[@as(c_uint, @intCast(@as(c_int, 3)))]))), @as([*c]@"i64", @ptrCast(@alignCast(&q[@as(c_uint, @intCast(@as(c_int, 3)))]))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&c))), @as([*c]@"i64", @ptrCast(@alignCast(&c))), @as([*c]const @"i64", @ptrCast(@alignCast(&D2))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&d))), @as([*c]@"i64", @ptrCast(@alignCast(&p[@as(c_uint, @intCast(@as(c_int, 2)))]))), @as([*c]@"i64", @ptrCast(@alignCast(&q[@as(c_uint, @intCast(@as(c_int, 2)))]))));
    A(@as([*c]@"i64", @ptrCast(@alignCast(&d))), @as([*c]@"i64", @ptrCast(@alignCast(&d))), @as([*c]@"i64", @ptrCast(@alignCast(&d))));
    Z(@as([*c]@"i64", @ptrCast(@alignCast(&e))), @as([*c]@"i64", @ptrCast(@alignCast(&b))), @as([*c]@"i64", @ptrCast(@alignCast(&a))));
    Z(@as([*c]@"i64", @ptrCast(@alignCast(&f))), @as([*c]@"i64", @ptrCast(@alignCast(&d))), @as([*c]@"i64", @ptrCast(@alignCast(&c))));
    A(@as([*c]@"i64", @ptrCast(@alignCast(&g))), @as([*c]@"i64", @ptrCast(@alignCast(&d))), @as([*c]@"i64", @ptrCast(@alignCast(&c))));
    A(@as([*c]@"i64", @ptrCast(@alignCast(&h))), @as([*c]@"i64", @ptrCast(@alignCast(&b))), @as([*c]@"i64", @ptrCast(@alignCast(&a))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&p[@as(c_uint, @intCast(@as(c_int, 0)))]))), @as([*c]@"i64", @ptrCast(@alignCast(&e))), @as([*c]@"i64", @ptrCast(@alignCast(&f))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&p[@as(c_uint, @intCast(@as(c_int, 1)))]))), @as([*c]@"i64", @ptrCast(@alignCast(&h))), @as([*c]@"i64", @ptrCast(@alignCast(&g))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&p[@as(c_uint, @intCast(@as(c_int, 2)))]))), @as([*c]@"i64", @ptrCast(@alignCast(&g))), @as([*c]@"i64", @ptrCast(@alignCast(&f))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&p[@as(c_uint, @intCast(@as(c_int, 3)))]))), @as([*c]@"i64", @ptrCast(@alignCast(&e))), @as([*c]@"i64", @ptrCast(@alignCast(&h))));
}
pub fn cswap(arg_p: [*c]gf, arg_q: [*c]gf, arg_b: @"u8") callconv(.c) void {
    var p = arg_p;
    _ = &p;
    var q = arg_q;
    _ = &q;
    var b = arg_b;
    _ = &b;
    var i: c_int = undefined;
    _ = &i;
    {
        i = 0;
        while (i < @as(c_int, 4)) : (i += 1) {
            sel25519(@as([*c]@"i64", @ptrCast(@alignCast(&(blk: {
                const tmp = i;
                if (tmp >= 0) break :blk p + @as(usize, @intCast(tmp)) else break :blk p - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))), @as([*c]@"i64", @ptrCast(@alignCast(&(blk: {
                const tmp = i;
                if (tmp >= 0) break :blk q + @as(usize, @intCast(tmp)) else break :blk q - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))), @as(c_int, @bitCast(@as(c_uint, b))));
        }
    }
}
pub fn pack(arg_r: [*c]@"u8", arg_p: [*c]gf) callconv(.c) void {
    var r = arg_r;
    _ = &r;
    var p = arg_p;
    _ = &p;
    var tx: gf = undefined;
    _ = &tx;
    var ty: gf = undefined;
    _ = &ty;
    var zi: gf = undefined;
    _ = &zi;
    inv25519(@as([*c]@"i64", @ptrCast(@alignCast(&zi))), @as([*c]@"i64", @ptrCast(@alignCast(&p[@as(c_uint, @intCast(@as(c_int, 2)))]))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&tx))), @as([*c]@"i64", @ptrCast(@alignCast(&p[@as(c_uint, @intCast(@as(c_int, 0)))]))), @as([*c]@"i64", @ptrCast(@alignCast(&zi))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&ty))), @as([*c]@"i64", @ptrCast(@alignCast(&p[@as(c_uint, @intCast(@as(c_int, 1)))]))), @as([*c]@"i64", @ptrCast(@alignCast(&zi))));
    pack25519(r, @as([*c]@"i64", @ptrCast(@alignCast(&ty))));
    r[@as(c_uint, @intCast(@as(c_int, 31)))] ^= @as(@"u8", @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, par25519(@as([*c]@"i64", @ptrCast(@alignCast(&tx))))))) << @intCast(7)))));
}
pub fn scalarmult(arg_p: [*c]gf, arg_q: [*c]gf, arg_s: [*c]const @"u8") callconv(.c) void {
    var p = arg_p;
    _ = &p;
    var q = arg_q;
    _ = &q;
    var s = arg_s;
    _ = &s;
    var i: c_int = undefined;
    _ = &i;
    set25519(@as([*c]@"i64", @ptrCast(@alignCast(&p[@as(c_uint, @intCast(@as(c_int, 0)))]))), @as([*c]const @"i64", @ptrCast(@alignCast(&gf0))));
    set25519(@as([*c]@"i64", @ptrCast(@alignCast(&p[@as(c_uint, @intCast(@as(c_int, 1)))]))), @as([*c]const @"i64", @ptrCast(@alignCast(&gf1))));
    set25519(@as([*c]@"i64", @ptrCast(@alignCast(&p[@as(c_uint, @intCast(@as(c_int, 2)))]))), @as([*c]const @"i64", @ptrCast(@alignCast(&gf1))));
    set25519(@as([*c]@"i64", @ptrCast(@alignCast(&p[@as(c_uint, @intCast(@as(c_int, 3)))]))), @as([*c]const @"i64", @ptrCast(@alignCast(&gf0))));
    {
        i = 255;
        while (i >= @as(c_int, 0)) : (i -= 1) {
            var b: @"u8" = @as(@"u8", @bitCast(@as(i8, @truncate((@as(c_int, @bitCast(@as(c_uint, (blk: {
                const tmp = @divTrunc(i, @as(c_int, 8));
                if (tmp >= 0) break :blk s + @as(usize, @intCast(tmp)) else break :blk s - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))) >> @intCast(i & @as(c_int, 7))) & @as(c_int, 1)))));
            _ = &b;
            cswap(p, q, b);
            add_(q, p);
            add_(p, p);
            cswap(p, q, b);
        }
    }
}
pub fn scalarbase(arg_p: [*c]gf, arg_s: [*c]const @"u8") callconv(.c) void {
    var p = arg_p;
    _ = &p;
    var s = arg_s;
    _ = &s;
    var q: [4]gf = undefined;
    _ = &q;
    set25519(@as([*c]@"i64", @ptrCast(@alignCast(&q[@as(c_uint, @intCast(@as(c_int, 0)))]))), @as([*c]const @"i64", @ptrCast(@alignCast(&X))));
    set25519(@as([*c]@"i64", @ptrCast(@alignCast(&q[@as(c_uint, @intCast(@as(c_int, 1)))]))), @as([*c]const @"i64", @ptrCast(@alignCast(&Y))));
    set25519(@as([*c]@"i64", @ptrCast(@alignCast(&q[@as(c_uint, @intCast(@as(c_int, 2)))]))), @as([*c]const @"i64", @ptrCast(@alignCast(&gf1))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&q[@as(c_uint, @intCast(@as(c_int, 3)))]))), @as([*c]const @"i64", @ptrCast(@alignCast(&X))), @as([*c]const @"i64", @ptrCast(@alignCast(&Y))));
    scalarmult(p, @as([*c]gf, @ptrCast(@alignCast(&q))), s);
}
pub export fn tweetnacl_crypto_sk_to_pk(arg_pk: [*c]@"u8", arg_sk: [*c]const @"u8") c_int {
    var pk = arg_pk;
    _ = &pk;
    var sk = arg_sk;
    _ = &sk;
    var d: [64]@"u8" = undefined;
    _ = &d;
    var p: [4]gf = undefined;
    _ = &p;
    _ = tweetnacl_crypto_hash(@as([*c]@"u8", @ptrCast(@alignCast(&d))), sk, @as(@"u64", @bitCast(@as(c_longlong, @as(c_int, 32)))));
    d[@as(c_uint, @intCast(@as(c_int, 0)))] &= @as(@"u8", @bitCast(@as(i8, @truncate(@as(c_int, 248)))));
    d[@as(c_uint, @intCast(@as(c_int, 31)))] &= @as(@"u8", @bitCast(@as(i8, @truncate(@as(c_int, 127)))));
    d[@as(c_uint, @intCast(@as(c_int, 31)))] |= @as(@"u8", @bitCast(@as(i8, @truncate(@as(c_int, 64)))));
    scalarbase(@as([*c]gf, @ptrCast(@alignCast(&p))), @as([*c]@"u8", @ptrCast(@alignCast(&d))));
    pack(pk, @as([*c]gf, @ptrCast(@alignCast(&p))));
    return 0;
}
pub export fn tweetnacl_crypto_sign_keypair(arg_prng: [*c]prng_state, arg_wprng: c_int, arg_pk: [*c]@"u8", arg_sk: [*c]@"u8") c_int {
    var prng = arg_prng;
    _ = &prng;
    var wprng = arg_wprng;
    _ = &wprng;
    var pk = arg_pk;
    _ = &pk;
    var sk = arg_sk;
    _ = &sk;
    var err: c_int = undefined;
    _ = &err;
    if ((blk: {
        const tmp = prng_is_valid(wprng);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    if (prng_descriptor[@as(c_uint, @intCast(wprng))].read.?(sk, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))), prng) != @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32))))) {
        return CRYPT_ERROR_READPRNG;
    }
    if ((blk: {
        const tmp = tweetnacl_crypto_sk_to_pk(pk, sk);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        return err;
    }
    return CRYPT_OK;
}
pub const L: [32]@"u64" = [32]@"u64"{
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16,
};
pub fn modL(arg_r: [*c]@"u8", arg_x: [*c]@"i64") callconv(.c) void {
    var r = arg_r;
    _ = &r;
    var x = arg_x;
    _ = &x;
    var carry: @"i64" = undefined;
    _ = &carry;
    var i: @"i64" = undefined;
    _ = &i;
    var j: @"i64" = undefined;
    _ = &j;
    {
        i = 63;
        while (i >= @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 32))))) : (i -= 1) {
            carry = 0;
            {
                j = i - @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 32))));
                while (j < (i - @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 12)))))) : (j += 1) {
                    (blk: {
                        const tmp = j;
                        if (tmp >= 0) break :blk x + @as(usize, @intCast(tmp)) else break :blk x - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).* += @as(@"i64", @bitCast(@as(@"u64", @bitCast(carry)) -% (@as(@"u64", @bitCast(@as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 16)))) * (blk: {
                        const tmp = i;
                        if (tmp >= 0) break :blk x + @as(usize, @intCast(tmp)) else break :blk x - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).*)) *% L[@as(usize, @intCast(j - (i - @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 32)))))))])));
                    carry = ((blk: {
                        const tmp = j;
                        if (tmp >= 0) break :blk x + @as(usize, @intCast(tmp)) else break :blk x - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).* + @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 128))))) >> @intCast(8);
                    (blk: {
                        const tmp = j;
                        if (tmp >= 0) break :blk x + @as(usize, @intCast(tmp)) else break :blk x - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).* -= carry << @intCast(8);
                }
            }
            (blk: {
                const tmp = j;
                if (tmp >= 0) break :blk x + @as(usize, @intCast(tmp)) else break :blk x - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* += carry;
            (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk x + @as(usize, @intCast(tmp)) else break :blk x - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = 0;
        }
    }
    carry = 0;
    {
        j = 0;
        while (j < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 32))))) : (j += 1) {
            (blk: {
                const tmp = j;
                if (tmp >= 0) break :blk x + @as(usize, @intCast(tmp)) else break :blk x - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* += @as(@"i64", @bitCast(@as(@"u64", @bitCast(carry)) -% (@as(@"u64", @bitCast(x[@as(c_uint, @intCast(@as(c_int, 31)))] >> @intCast(4))) *% L[@as(usize, @intCast(j))])));
            carry = (blk: {
                const tmp = j;
                if (tmp >= 0) break :blk x + @as(usize, @intCast(tmp)) else break :blk x - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* >> @intCast(8);
            (blk: {
                const tmp = j;
                if (tmp >= 0) break :blk x + @as(usize, @intCast(tmp)) else break :blk x - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* &= @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 255))));
        }
    }
    {
        j = 0;
        while (j < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 32))))) : (j += 1) {
            (blk: {
                const tmp = j;
                if (tmp >= 0) break :blk x + @as(usize, @intCast(tmp)) else break :blk x - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* -= @as(@"i64", @bitCast(@as(@"u64", @bitCast(carry)) *% L[@as(usize, @intCast(j))]));
        }
    }
    {
        i = 0;
        while (i < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 32))))) : (i += 1) {
            (blk: {
                const tmp = i + @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 1))));
                if (tmp >= 0) break :blk x + @as(usize, @intCast(tmp)) else break :blk x - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* += (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk x + @as(usize, @intCast(tmp)) else break :blk x - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* >> @intCast(8);
            (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk r + @as(usize, @intCast(tmp)) else break :blk r - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = @as(@"u8", @bitCast(@as(i8, @truncate((blk: {
                const tmp = i;
                if (tmp >= 0) break :blk x + @as(usize, @intCast(tmp)) else break :blk x - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* & @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 255))))))));
        }
    }
}
pub fn reduce(arg_r: [*c]@"u8") callconv(.c) void {
    var r = arg_r;
    _ = &r;
    var x: [64]@"i64" = undefined;
    _ = &x;
    var i: @"i64" = undefined;
    _ = &i;
    {
        i = 0;
        while (i < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 64))))) : (i += 1) {
            x[@as(usize, @intCast(i))] = @as(@"i64", @bitCast(@as(@"u64", @bitCast(@as(c_ulonglong, (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk r + @as(usize, @intCast(tmp)) else break :blk r - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*)))));
        }
    }
    {
        i = 0;
        while (i < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 64))))) : (i += 1) {
            (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk r + @as(usize, @intCast(tmp)) else break :blk r - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = 0;
        }
    }
    modL(r, @as([*c]@"i64", @ptrCast(@alignCast(&x))));
}
pub export fn tweetnacl_crypto_sign(arg_sm: [*c]@"u8", arg_smlen: [*c]@"u64", arg_m: [*c]const @"u8", arg_mlen: @"u64", arg_sk: [*c]const @"u8", arg_pk: [*c]const @"u8", arg_ctx: [*c]const @"u8", arg_cs: @"u64") c_int {
    var sm = arg_sm;
    _ = &sm;
    var smlen = arg_smlen;
    _ = &smlen;
    var m = arg_m;
    _ = &m;
    var mlen = arg_mlen;
    _ = &mlen;
    var sk = arg_sk;
    _ = &sk;
    var pk = arg_pk;
    _ = &pk;
    var ctx = arg_ctx;
    _ = &ctx;
    var cs = arg_cs;
    _ = &cs;
    var d: [64]@"u8" = undefined;
    _ = &d;
    var h: [64]@"u8" = undefined;
    _ = &h;
    var r: [64]@"u8" = undefined;
    _ = &r;
    var i: @"i64" = undefined;
    _ = &i;
    var j: @"i64" = undefined;
    _ = &j;
    var x: [64]@"i64" = undefined;
    _ = &x;
    var p: [4]gf = undefined;
    _ = &p;
    _ = tweetnacl_crypto_hash(@as([*c]@"u8", @ptrCast(@alignCast(&d))), sk, @as(@"u64", @bitCast(@as(c_longlong, @as(c_int, 32)))));
    d[@as(c_uint, @intCast(@as(c_int, 0)))] &= @as(@"u8", @bitCast(@as(i8, @truncate(@as(c_int, 248)))));
    d[@as(c_uint, @intCast(@as(c_int, 31)))] &= @as(@"u8", @bitCast(@as(i8, @truncate(@as(c_int, 127)))));
    d[@as(c_uint, @intCast(@as(c_int, 31)))] |= @as(@"u8", @bitCast(@as(i8, @truncate(@as(c_int, 64)))));
    smlen.* = mlen +% @as(@"u64", @bitCast(@as(c_longlong, @as(c_int, 64))));
    {
        i = 0;
        while (i < @as(@"i64", @bitCast(mlen))) : (i += 1) {
            (blk: {
                const tmp = @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 64)))) + i;
                if (tmp >= 0) break :blk sm + @as(usize, @intCast(tmp)) else break :blk sm - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk m + @as(usize, @intCast(tmp)) else break :blk m - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
        }
    }
    {
        i = 0;
        while (i < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 32))))) : (i += 1) {
            (blk: {
                const tmp = @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 32)))) + i;
                if (tmp >= 0) break :blk sm + @as(usize, @intCast(tmp)) else break :blk sm - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = d[@as(usize, @intCast(@as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 32)))) + i))];
        }
    }
    _ = tweetnacl_crypto_hash_ctx(@as([*c]@"u8", @ptrCast(@alignCast(&r))), sm + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))), mlen +% @as(@"u64", @bitCast(@as(c_longlong, @as(c_int, 32)))), ctx, @as(@"u32", @bitCast(@as(c_uint, @truncate(cs)))));
    reduce(@as([*c]@"u8", @ptrCast(@alignCast(&r))));
    scalarbase(@as([*c]gf, @ptrCast(@alignCast(&p))), @as([*c]@"u8", @ptrCast(@alignCast(&r))));
    pack(sm, @as([*c]gf, @ptrCast(@alignCast(&p))));
    {
        i = 0;
        while (i < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 32))))) : (i += 1) {
            (blk: {
                const tmp = i + @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 32))));
                if (tmp >= 0) break :blk sm + @as(usize, @intCast(tmp)) else break :blk sm - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk pk + @as(usize, @intCast(tmp)) else break :blk pk - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
        }
    }
    _ = tweetnacl_crypto_hash_ctx(@as([*c]@"u8", @ptrCast(@alignCast(&h))), sm, mlen +% @as(@"u64", @bitCast(@as(c_longlong, @as(c_int, 64)))), ctx, @as(@"u32", @bitCast(@as(c_uint, @truncate(cs)))));
    reduce(@as([*c]@"u8", @ptrCast(@alignCast(&h))));
    {
        i = 0;
        while (i < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 64))))) : (i += 1) {
            x[@as(usize, @intCast(i))] = 0;
        }
    }
    {
        i = 0;
        while (i < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 32))))) : (i += 1) {
            x[@as(usize, @intCast(i))] = @as(@"i64", @bitCast(@as(@"u64", @bitCast(@as(c_ulonglong, r[@as(usize, @intCast(i))])))));
        }
    }
    {
        i = 0;
        while (i < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 32))))) : (i += 1) {
            j = 0;
            while (j < @as(@"i64", @bitCast(@as(c_longlong, @as(c_int, 32))))) : (j += 1) {
                x[@as(usize, @intCast(i + j))] += @as(@"i64", @bitCast(@as(@"u64", @bitCast(@as(c_ulonglong, h[@as(usize, @intCast(i))]))) *% @as(@"u64", @bitCast(@as(c_ulonglong, d[@as(usize, @intCast(j))])))));
            }
        }
    }
    modL(sm + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))), @as([*c]@"i64", @ptrCast(@alignCast(&x))));
    return 0;
}
pub fn unpackneg(arg_r: [*c]gf, p: [*c]const @"u8") callconv(.c) c_int {
    var r = arg_r;
    _ = &r;
    _ = &p;
    var t: gf = undefined;
    _ = &t;
    var chk: gf = undefined;
    _ = &chk;
    var num: gf = undefined;
    _ = &num;
    var den: gf = undefined;
    _ = &den;
    var den2: gf = undefined;
    _ = &den2;
    var den4: gf = undefined;
    _ = &den4;
    var den6: gf = undefined;
    _ = &den6;
    set25519(@as([*c]@"i64", @ptrCast(@alignCast(&r[@as(c_uint, @intCast(@as(c_int, 2)))]))), @as([*c]const @"i64", @ptrCast(@alignCast(&gf1))));
    unpack25519(@as([*c]@"i64", @ptrCast(@alignCast(&r[@as(c_uint, @intCast(@as(c_int, 1)))]))), p);
    S(@as([*c]@"i64", @ptrCast(@alignCast(&num))), @as([*c]@"i64", @ptrCast(@alignCast(&r[@as(c_uint, @intCast(@as(c_int, 1)))]))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&den))), @as([*c]@"i64", @ptrCast(@alignCast(&num))), @as([*c]const @"i64", @ptrCast(@alignCast(&D))));
    Z(@as([*c]@"i64", @ptrCast(@alignCast(&num))), @as([*c]@"i64", @ptrCast(@alignCast(&num))), @as([*c]@"i64", @ptrCast(@alignCast(&r[@as(c_uint, @intCast(@as(c_int, 2)))]))));
    A(@as([*c]@"i64", @ptrCast(@alignCast(&den))), @as([*c]@"i64", @ptrCast(@alignCast(&r[@as(c_uint, @intCast(@as(c_int, 2)))]))), @as([*c]@"i64", @ptrCast(@alignCast(&den))));
    S(@as([*c]@"i64", @ptrCast(@alignCast(&den2))), @as([*c]@"i64", @ptrCast(@alignCast(&den))));
    S(@as([*c]@"i64", @ptrCast(@alignCast(&den4))), @as([*c]@"i64", @ptrCast(@alignCast(&den2))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&den6))), @as([*c]@"i64", @ptrCast(@alignCast(&den4))), @as([*c]@"i64", @ptrCast(@alignCast(&den2))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&t))), @as([*c]@"i64", @ptrCast(@alignCast(&den6))), @as([*c]@"i64", @ptrCast(@alignCast(&num))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&t))), @as([*c]@"i64", @ptrCast(@alignCast(&t))), @as([*c]@"i64", @ptrCast(@alignCast(&den))));
    pow2523(@as([*c]@"i64", @ptrCast(@alignCast(&t))), @as([*c]@"i64", @ptrCast(@alignCast(&t))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&t))), @as([*c]@"i64", @ptrCast(@alignCast(&t))), @as([*c]@"i64", @ptrCast(@alignCast(&num))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&t))), @as([*c]@"i64", @ptrCast(@alignCast(&t))), @as([*c]@"i64", @ptrCast(@alignCast(&den))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&t))), @as([*c]@"i64", @ptrCast(@alignCast(&t))), @as([*c]@"i64", @ptrCast(@alignCast(&den))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&r[@as(c_uint, @intCast(@as(c_int, 0)))]))), @as([*c]@"i64", @ptrCast(@alignCast(&t))), @as([*c]@"i64", @ptrCast(@alignCast(&den))));
    S(@as([*c]@"i64", @ptrCast(@alignCast(&chk))), @as([*c]@"i64", @ptrCast(@alignCast(&r[@as(c_uint, @intCast(@as(c_int, 0)))]))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&chk))), @as([*c]@"i64", @ptrCast(@alignCast(&chk))), @as([*c]@"i64", @ptrCast(@alignCast(&den))));
    if (neq25519(@as([*c]@"i64", @ptrCast(@alignCast(&chk))), @as([*c]@"i64", @ptrCast(@alignCast(&num)))) != 0) {
        M(@as([*c]@"i64", @ptrCast(@alignCast(&r[@as(c_uint, @intCast(@as(c_int, 0)))]))), @as([*c]@"i64", @ptrCast(@alignCast(&r[@as(c_uint, @intCast(@as(c_int, 0)))]))), @as([*c]const @"i64", @ptrCast(@alignCast(&I))));
    }
    S(@as([*c]@"i64", @ptrCast(@alignCast(&chk))), @as([*c]@"i64", @ptrCast(@alignCast(&r[@as(c_uint, @intCast(@as(c_int, 0)))]))));
    M(@as([*c]@"i64", @ptrCast(@alignCast(&chk))), @as([*c]@"i64", @ptrCast(@alignCast(&chk))), @as([*c]@"i64", @ptrCast(@alignCast(&den))));
    if (neq25519(@as([*c]@"i64", @ptrCast(@alignCast(&chk))), @as([*c]@"i64", @ptrCast(@alignCast(&num)))) != 0) return -@as(c_int, 1);
    if (@as(c_int, @bitCast(@as(c_uint, par25519(@as([*c]@"i64", @ptrCast(@alignCast(&r[@as(c_uint, @intCast(@as(c_int, 0)))]))))))) == (@as(c_int, @bitCast(@as(c_uint, p[@as(c_uint, @intCast(@as(c_int, 31)))]))) >> @intCast(7))) {
        Z(@as([*c]@"i64", @ptrCast(@alignCast(&r[@as(c_uint, @intCast(@as(c_int, 0)))]))), @as([*c]const @"i64", @ptrCast(@alignCast(&gf0))), @as([*c]@"i64", @ptrCast(@alignCast(&r[@as(c_uint, @intCast(@as(c_int, 0)))]))));
    }
    M(@as([*c]@"i64", @ptrCast(@alignCast(&r[@as(c_uint, @intCast(@as(c_int, 3)))]))), @as([*c]@"i64", @ptrCast(@alignCast(&r[@as(c_uint, @intCast(@as(c_int, 0)))]))), @as([*c]@"i64", @ptrCast(@alignCast(&r[@as(c_uint, @intCast(@as(c_int, 1)))]))));
    return 0;
}
pub export fn tweetnacl_crypto_sign_open(arg_stat: [*c]c_int, arg_m: [*c]@"u8", arg_mlen: [*c]@"u64", arg_sm: [*c]const @"u8", arg_smlen: @"u64", arg_ctx: [*c]const @"u8", arg_cs: @"u64", arg_pk: [*c]const @"u8") c_int {
    var stat = arg_stat;
    _ = &stat;
    var m = arg_m;
    _ = &m;
    var mlen = arg_mlen;
    _ = &mlen;
    var sm = arg_sm;
    _ = &sm;
    var smlen = arg_smlen;
    _ = &smlen;
    var ctx = arg_ctx;
    _ = &ctx;
    var cs = arg_cs;
    _ = &cs;
    var pk = arg_pk;
    _ = &pk;
    var i: @"u64" = undefined;
    _ = &i;
    var s: [32]@"u8" = undefined;
    _ = &s;
    var t: [32]@"u8" = undefined;
    _ = &t;
    var h: [64]@"u8" = undefined;
    _ = &h;
    var p: [4]gf = undefined;
    _ = &p;
    var q: [4]gf = undefined;
    _ = &q;
    stat.* = 0;
    if (mlen.* < smlen) return CRYPT_BUFFER_OVERFLOW;
    mlen.* = @as(@"u64", @bitCast(@as(c_longlong, -@as(c_int, 1))));
    if (smlen < @as(@"u64", @bitCast(@as(c_longlong, @as(c_int, 64))))) return CRYPT_INVALID_ARG;
    if (unpackneg(@as([*c]gf, @ptrCast(@alignCast(&q))), pk) != 0) return CRYPT_ERROR;
    _ = memmove(@as(?*anyopaque, @ptrCast(m)), @as(?*const anyopaque, @ptrCast(sm)), @as(c_ulong, @bitCast(@as(c_ulong, @truncate(smlen)))));
    _ = memmove(@as(?*anyopaque, @ptrCast(@as([*c]@"u8", @ptrCast(@alignCast(&s))))), @as(?*const anyopaque, @ptrCast(m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))));
    _ = memmove(@as(?*anyopaque, @ptrCast(m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))))), @as(?*const anyopaque, @ptrCast(pk)), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))));
    _ = tweetnacl_crypto_hash_ctx(@as([*c]@"u8", @ptrCast(@alignCast(&h))), m, smlen, ctx, @as(@"u32", @bitCast(@as(c_uint, @truncate(cs)))));
    reduce(@as([*c]@"u8", @ptrCast(@alignCast(&h))));
    scalarmult(@as([*c]gf, @ptrCast(@alignCast(&p))), @as([*c]gf, @ptrCast(@alignCast(&q))), @as([*c]@"u8", @ptrCast(@alignCast(&h))));
    scalarbase(@as([*c]gf, @ptrCast(@alignCast(&q))), @as([*c]@"u8", @ptrCast(@alignCast(&s))));
    add_(@as([*c]gf, @ptrCast(@alignCast(&p))), @as([*c]gf, @ptrCast(@alignCast(&q))));
    pack(@as([*c]@"u8", @ptrCast(@alignCast(&t))), @as([*c]gf, @ptrCast(@alignCast(&p))));
    smlen -%= @as(@"u64", @bitCast(@as(c_longlong, @as(c_int, 64))));
    if (tweetnacl_crypto_verify_32(sm, @as([*c]@"u8", @ptrCast(@alignCast(&t)))) != 0) {
        {
            i = 0;
            while (i < smlen) : (i +%= 1) {
                m[@as(usize, @intCast(i))] = 0;
            }
        }
        zeromem(@as(?*anyopaque, @ptrCast(m)), @as(usize, @bitCast(@as(c_ulong, @truncate(smlen)))));
        return CRYPT_OK;
    }
    stat.* = 1;
    _ = memmove(@as(?*anyopaque, @ptrCast(m)), @as(?*const anyopaque, @ptrCast(m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 64))))))), @as(c_ulong, @bitCast(@as(c_ulong, @truncate(smlen)))));
    mlen.* = smlen;
    return CRYPT_OK;
}
pub export fn tweetnacl_crypto_ph(arg_out: [*c]@"u8", arg_msg: [*c]const @"u8", arg_msglen: @"u64") c_int {
    var out = arg_out;
    _ = &out;
    var msg = arg_msg;
    _ = &msg;
    var msglen = arg_msglen;
    _ = &msglen;
    return tweetnacl_crypto_hash(out, msg, msglen);
}
pub const close_notify: c_int = 0;
pub const unexpected_message: c_int = 10;
pub const bad_record_mac: c_int = 20;
pub const decryption_failed_RESERVED: c_int = 21;
pub const record_overflow: c_int = 22;
pub const decompression_failure: c_int = 30;
pub const handshake_failure: c_int = 40;
pub const no_certificate_RESERVED: c_int = 41;
pub const bad_certificate: c_int = 42;
pub const unsupported_certificate: c_int = 43;
pub const certificate_revoked: c_int = 44;
pub const certificate_expired: c_int = 45;
pub const certificate_unknown: c_int = 46;
pub const illegal_parameter: c_int = 47;
pub const unknown_ca: c_int = 48;
pub const access_denied: c_int = 49;
pub const decode_error: c_int = 50;
pub const decrypt_error: c_int = 51;
pub const export_restriction_RESERVED: c_int = 60;
pub const protocol_version: c_int = 70;
pub const insufficient_security: c_int = 71;
pub const internal_error: c_int = 80;
pub const inappropriate_fallback: c_int = 86;
pub const user_canceled: c_int = 90;
pub const no_renegotiation: c_int = 100;
pub const unsupported_extension: c_int = 110;
pub const no_error: c_int = 255;
pub const TLSAlertDescription = c_uint;
pub const struct_TLSCertificate = extern struct {
    version: c_ushort = @import("std").mem.zeroes(c_ushort),
    algorithm: c_uint = @import("std").mem.zeroes(c_uint),
    key_algorithm: c_uint = @import("std").mem.zeroes(c_uint),
    ec_algorithm: c_uint = @import("std").mem.zeroes(c_uint),
    exponent: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    exponent_len: c_uint = @import("std").mem.zeroes(c_uint),
    pk: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    pk_len: c_uint = @import("std").mem.zeroes(c_uint),
    priv: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    priv_len: c_uint = @import("std").mem.zeroes(c_uint),
    issuer_country: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    issuer_state: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    issuer_location: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    issuer_entity: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    issuer_subject: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    not_before: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    not_after: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    country: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    state: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    location: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    entity: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    subject: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    san: [*c][*c]u8 = @import("std").mem.zeroes([*c][*c]u8),
    san_length: c_ushort = @import("std").mem.zeroes(c_ushort),
    ocsp: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    serial_number: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    serial_len: c_uint = @import("std").mem.zeroes(c_uint),
    sign_key: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    sign_len: c_uint = @import("std").mem.zeroes(c_uint),
    fingerprint: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    der_bytes: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    der_len: c_uint = @import("std").mem.zeroes(c_uint),
    bytes: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    len: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const struct_ECCCurveParameters = extern struct {
    size: c_int = @import("std").mem.zeroes(c_int),
    iana: c_int = @import("std").mem.zeroes(c_int),
    name: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    P: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    A: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    B: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    Gx: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    Gy: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    order: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    oid: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    dp: ltc_ecc_set_type = @import("std").mem.zeroes(ltc_ecc_set_type),
};
pub const struct_TLSHandshakeList = extern struct {
    connection_status: u8 = @import("std").mem.zeroes(u8),
    direction: u8 = @import("std").mem.zeroes(u8),
    msg: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    len: c_uint = @import("std").mem.zeroes(c_uint),
    next: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const struct_DTLSFragment = extern struct {
    buffer: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    len: c_int = @import("std").mem.zeroes(c_int),
    written: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct_DTLSData = extern struct {
    dtls_handshake_list: [*c]struct_TLSHandshakeList = @import("std").mem.zeroes([*c]struct_TLSHandshakeList),
    fragment: [*c]struct_DTLSFragment = @import("std").mem.zeroes([*c]struct_DTLSFragment),
    key_exchange: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    key_exchange_len: c_uint = @import("std").mem.zeroes(c_uint),
    has_random: u8 = @import("std").mem.zeroes(u8),
    remote_fingerprint: [*c]u8 = @import("std").mem.zeroes([*c]u8),
};
pub const struct_TLSContext = extern struct {
    remote_random: [32]u8 = @import("std").mem.zeroes([32]u8),
    local_random: [32]u8 = @import("std").mem.zeroes([32]u8),
    session: [32]u8 = @import("std").mem.zeroes([32]u8),
    session_size: u8 = @import("std").mem.zeroes(u8),
    cipher: c_ushort = @import("std").mem.zeroes(c_ushort),
    version: c_ushort = @import("std").mem.zeroes(c_ushort),
    is_server: u8 = @import("std").mem.zeroes(u8),
    certificates: [*c][*c]struct_TLSCertificate = @import("std").mem.zeroes([*c][*c]struct_TLSCertificate),
    private_key: [*c]struct_TLSCertificate = @import("std").mem.zeroes([*c]struct_TLSCertificate),
    ec_private_key: [*c]struct_TLSCertificate = @import("std").mem.zeroes([*c]struct_TLSCertificate),
    dhe: [*c]DHKey = @import("std").mem.zeroes([*c]DHKey),
    ecc_dhe: [*c]ecc_key = @import("std").mem.zeroes([*c]ecc_key),
    default_dhe_p: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    default_dhe_g: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    curve: [*c]const struct_ECCCurveParameters = @import("std").mem.zeroes([*c]const struct_ECCCurveParameters),
    client_certificates: [*c][*c]struct_TLSCertificate = @import("std").mem.zeroes([*c][*c]struct_TLSCertificate),
    certificates_count: c_uint = @import("std").mem.zeroes(c_uint),
    client_certificates_count: c_uint = @import("std").mem.zeroes(c_uint),
    master_key: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    master_key_len: c_uint = @import("std").mem.zeroes(c_uint),
    premaster_key: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    premaster_key_len: c_uint = @import("std").mem.zeroes(c_uint),
    cipher_spec_set: u8 = @import("std").mem.zeroes(u8),
    crypto: TLSCipher = @import("std").mem.zeroes(TLSCipher),
    handshake_hash: [*c]TLSHash = @import("std").mem.zeroes([*c]TLSHash),
    message_buffer: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    message_buffer_len: c_uint = @import("std").mem.zeroes(c_uint),
    remote_sequence_number: u64 = @import("std").mem.zeroes(u64),
    local_sequence_number: u64 = @import("std").mem.zeroes(u64),
    connection_status: u8 = @import("std").mem.zeroes(u8),
    critical_error: u8 = @import("std").mem.zeroes(u8),
    error_code: u8 = @import("std").mem.zeroes(u8),
    tls_buffer: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    tls_buffer_len: c_uint = @import("std").mem.zeroes(c_uint),
    application_buffer: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    application_buffer_len: c_uint = @import("std").mem.zeroes(c_uint),
    is_child: u8 = @import("std").mem.zeroes(u8),
    exportable: u8 = @import("std").mem.zeroes(u8),
    exportable_keys: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    exportable_size: u8 = @import("std").mem.zeroes(u8),
    sni: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    request_client_certificate: u8 = @import("std").mem.zeroes(u8),
    dtls: u8 = @import("std").mem.zeroes(u8),
    dtls_epoch_local: c_ushort = @import("std").mem.zeroes(c_ushort),
    dtls_epoch_remote: c_ushort = @import("std").mem.zeroes(c_ushort),
    dtls_cookie: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    dtls_cookie_len: u8 = @import("std").mem.zeroes(u8),
    dtls_seq: u8 = @import("std").mem.zeroes(u8),
    cached_handshake: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    cached_handshake_len: c_uint = @import("std").mem.zeroes(c_uint),
    client_verified: u8 = @import("std").mem.zeroes(u8),
    hs_messages: [11]u8 = @import("std").mem.zeroes([11]u8),
    user_data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    root_certificates: [*c][*c]struct_TLSCertificate = @import("std").mem.zeroes([*c][*c]struct_TLSCertificate),
    root_count: c_uint = @import("std").mem.zeroes(c_uint),
    finished_key: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    remote_finished_key: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    server_finished_hash: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    client_secret: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    alpn: [*c][*c]u8 = @import("std").mem.zeroes([*c][*c]u8),
    alpn_count: u8 = @import("std").mem.zeroes(u8),
    negotiated_alpn: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    sleep_until: c_uint = @import("std").mem.zeroes(c_uint),
    tls13_version: c_ushort = @import("std").mem.zeroes(c_ushort),
    dtls_data: [*c]struct_DTLSData = @import("std").mem.zeroes([*c]struct_DTLSData),
};
pub const struct_TLSPacket = extern struct {
    buf: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    len: c_uint = @import("std").mem.zeroes(c_uint),
    size: c_uint = @import("std").mem.zeroes(c_uint),
    broken: u8 = @import("std").mem.zeroes(u8),
    context: [*c]struct_TLSContext = @import("std").mem.zeroes([*c]struct_TLSContext),
};
pub const TLS = struct_TLSContext;
pub const Certificate = struct_TLSCertificate;
pub const tls_validation_function = ?*const fn ([*c]struct_TLSContext, [*c][*c]struct_TLSCertificate, c_int) callconv(.c) c_int;
pub const struct_TLSRTCPeerBuffer = extern struct {
    buf: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    len: c_uint = @import("std").mem.zeroes(c_uint),
    next: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const struct_TLSRTCPeerConnection = extern struct {
    context: [*c]struct_TLSContext = @import("std").mem.zeroes([*c]struct_TLSContext),
    stun_transcation_id: [12]u8 = @import("std").mem.zeroes([12]u8),
    local_user: [5]u8 = @import("std").mem.zeroes([5]u8),
    local_pwd: [25]u8 = @import("std").mem.zeroes([25]u8),
    remote_user: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    remote_user_len: c_int = @import("std").mem.zeroes(c_int),
    remote_pwd: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    remote_pwd_len: c_int = @import("std").mem.zeroes(c_int),
    certificate_verify: tls_validation_function = @import("std").mem.zeroes(tls_validation_function),
    userdata: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    local_state: u8 = @import("std").mem.zeroes(u8),
    remote_state: u8 = @import("std").mem.zeroes(u8),
    active: u8 = @import("std").mem.zeroes(u8),
    write_buffer: [*c]struct_TLSRTCPeerBuffer = @import("std").mem.zeroes([*c]struct_TLSRTCPeerBuffer),
    read_buffer: [*c]struct_TLSRTCPeerBuffer = @import("std").mem.zeroes([*c]struct_TLSRTCPeerBuffer),
};
pub export fn tls_init() void {
    if (dependecies_loaded != 0) return;
    dependecies_loaded = 1;
    ltc_mp = ltm_desc;
    _ = register_prng(&sprng_desc);
    _ = register_hash(&sha224_desc);
    _ = register_hash(&sha256_desc);
    _ = register_hash(&sha1_desc);
    _ = register_hash(&sha384_desc);
    _ = register_hash(&sha512_desc);
    _ = register_hash(&md5_desc);
    _ = register_cipher(&aes_desc);
    init_curves();
    dtls_reset_cookie_secret();
}
pub export fn tls_pem_decode(arg_data_in: [*c]const u8, arg_input_length: c_uint, arg_cert_index: c_int, arg_output_len: [*c]c_uint) [*c]u8 {
    var data_in = arg_data_in;
    _ = &data_in;
    var input_length = arg_input_length;
    _ = &input_length;
    var cert_index = arg_cert_index;
    _ = &cert_index;
    var output_len = arg_output_len;
    _ = &output_len;
    var i: c_uint = undefined;
    _ = &i;
    output_len.* = 0;
    var alloc_len: c_int = @as(c_int, @bitCast((input_length / @as(c_uint, @bitCast(@as(c_int, 4)))) *% @as(c_uint, @bitCast(@as(c_int, 3)))));
    _ = &alloc_len;
    var output: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, alloc_len)))))));
    _ = &output;
    if (!(output != null)) return null;
    var start_at: c_uint = 0;
    _ = &start_at;
    var idx: c_uint = 0;
    _ = &idx;
    {
        i = 0;
        while (i < input_length) : (i +%= 1) {
            if ((@as(c_int, @bitCast(@as(c_uint, data_in[i]))) == @as(c_int, '\n')) or (@as(c_int, @bitCast(@as(c_uint, data_in[i]))) == @as(c_int, '\r'))) continue;
            if (@as(c_int, @bitCast(@as(c_uint, data_in[i]))) != @as(c_int, '-')) {
                while ((i < input_length) and (@as(c_int, @bitCast(@as(c_uint, data_in[i]))) != @as(c_int, '\n'))) {
                    i +%= 1;
                }
                continue;
            }
            if (@as(c_int, @bitCast(@as(c_uint, data_in[i]))) == @as(c_int, '-')) {
                var end_idx: c_uint = i;
                _ = &end_idx;
                while ((i < input_length) and (@as(c_int, @bitCast(@as(c_uint, data_in[i]))) != @as(c_int, '\n'))) {
                    i +%= 1;
                }
                if (start_at != 0) {
                    if (cert_index > @as(c_int, 0)) {
                        cert_index -= 1;
                        start_at = 0;
                    } else {
                        idx = @as(c_uint, @bitCast(_private_b64_decode(@as([*c]const u8, @ptrCast(@alignCast(&data_in[start_at]))), @as(c_int, @bitCast(end_idx -% start_at)), output)));
                        break;
                    }
                } else {
                    start_at = i +% @as(c_uint, @bitCast(@as(c_int, 1)));
                }
            }
        }
    }
    output_len.* = idx;
    if (!(idx != 0)) {
        if (output != null) {
            free(@as(?*anyopaque, @ptrCast(output)));
        }
        return null;
    }
    return output;
}
pub export fn tls_create_certificate() [*c]struct_TLSCertificate {
    var cert: [*c]struct_TLSCertificate = @as([*c]struct_TLSCertificate, @ptrCast(@alignCast(malloc(@sizeOf(struct_TLSCertificate)))));
    _ = &cert;
    if (cert != null) {
        _ = memset(@as(?*anyopaque, @ptrCast(cert)), @as(c_int, 0), @sizeOf(struct_TLSCertificate));
    }
    return cert;
}
pub export fn tls_certificate_valid_subject(arg_cert: [*c]struct_TLSCertificate, arg_subject: [*c]const u8) c_int {
    var cert = arg_cert;
    _ = &cert;
    var subject = arg_subject;
    _ = &subject;
    var i: c_int = undefined;
    _ = &i;
    if (!(cert != null)) return certificate_unknown;
    var err: c_int = tls_certificate_valid_subject_name(cert.*.subject, subject);
    _ = &err;
    if ((err != 0) and (cert.*.san != null)) {
        {
            i = 0;
            while (i < @as(c_int, @bitCast(@as(c_uint, cert.*.san_length)))) : (i += 1) {
                err = tls_certificate_valid_subject_name((blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk cert.*.san + @as(usize, @intCast(tmp)) else break :blk cert.*.san - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*, subject);
                if (!(err != 0)) return err;
            }
        }
    }
    return err;
}
pub export fn tls_certificate_valid_subject_name(arg_cert_subject: [*c]const u8, arg_subject: [*c]const u8) c_int {
    var cert_subject = arg_cert_subject;
    _ = &cert_subject;
    var subject = arg_subject;
    _ = &subject;
    if ((!(cert_subject != null) or !(cert_subject[@as(c_uint, @intCast(@as(c_int, 0)))] != 0)) and (!(subject != null) or !(subject[@as(c_uint, @intCast(@as(c_int, 0)))] != 0))) return 0;
    if (!(subject != null) or !(subject[@as(c_uint, @intCast(@as(c_int, 0)))] != 0)) return bad_certificate;
    if (!(cert_subject != null) or !(cert_subject[@as(c_uint, @intCast(@as(c_int, 0)))] != 0)) return bad_certificate;
    if (!(strcmp(@as([*c]const u8, @ptrCast(@alignCast(cert_subject))), subject) != 0)) return 0;
    var wildcard: [*c]const u8 = strchr(@as([*c]const u8, @ptrCast(@alignCast(cert_subject))), @as(c_int, '*'));
    _ = &wildcard;
    if (wildcard != null) {
        if (!(wildcard[@as(c_uint, @intCast(@as(c_int, 1)))] != 0)) {
            return bad_certificate;
        }
        wildcard += 1;
        var match: [*c]const u8 = strstr(subject, wildcard);
        _ = &match;
        if (!(match != null) and (@as(c_int, @bitCast(@as(c_uint, wildcard[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, '.'))) {
            wildcard += 1;
            if (!(strcasecmp(subject, wildcard) != 0)) return 0;
        }
        if (match != null) {
            var offset: usize = @as(usize, @intCast(@intFromPtr(match))) -% @as(usize, @intCast(@intFromPtr(subject)));
            _ = &offset;
            if (offset != 0) {
                if (memchr(@as(?*const anyopaque, @ptrCast(subject)), @as(c_int, '.'), offset) != null) return bad_certificate;
            }
            if (!(strcasecmp(match, wildcard) != 0)) return 0;
        }
    }
    return bad_certificate;
}
pub export fn tls_certificate_is_valid(arg_cert: [*c]struct_TLSCertificate) c_int {
    var cert = arg_cert;
    _ = &cert;
    if (!(cert != null)) return certificate_unknown;
    if (!(cert.*.not_before != null)) return certificate_unknown;
    if (!(cert.*.not_after != null)) return certificate_unknown;
    var current_time: [16]u8 = undefined;
    _ = &current_time;
    var t: time_t = time(null);
    _ = &t;
    var utct: [*c]struct_tm = gmtime(&t);
    _ = &utct;
    if (utct != null) {
        current_time[@as(c_uint, @intCast(@as(c_int, 0)))] = 0;
        _ = snprintf(@as([*c]u8, @ptrCast(@alignCast(&current_time))), @sizeOf([16]u8), "%04hu%02hhu%02hhu%02hhu%02hhu%02hhuZ", @as(c_int, @bitCast(@as(c_uint, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 1900) + utct.*.tm_year))))))), @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(utct.*.tm_mon + @as(c_int, 1)))))))), @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(utct.*.tm_mday))))))), @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(utct.*.tm_hour))))))), @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(utct.*.tm_min))))))), @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(utct.*.tm_sec))))))));
        if (strcasecmp(@as([*c]u8, @ptrCast(@alignCast(cert.*.not_before))), @as([*c]u8, @ptrCast(@alignCast(&current_time)))) > @as(c_int, 0)) {
            return certificate_expired;
        }
        if (strcasecmp(@as([*c]u8, @ptrCast(@alignCast(cert.*.not_after))), @as([*c]u8, @ptrCast(@alignCast(&current_time)))) < @as(c_int, 0)) {
            return certificate_expired;
        }
    }
    return 0;
}
pub export fn tls_certificate_set_copy(arg_member: [*c][*c]u8, arg_val: [*c]const u8, arg_len: c_int) void {
    var member = arg_member;
    _ = &member;
    var val = arg_val;
    _ = &val;
    var len = arg_len;
    _ = &len;
    if (!(member != null)) return;
    if (member.* != null) {
        free(@as(?*anyopaque, @ptrCast(member.*)));
    }
    if (len != 0) {
        member.* = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, len + @as(c_int, 1))))))));
        if (member.* != null) {
            _ = memcpy(@as(?*anyopaque, @ptrCast(member.*)), @as(?*const anyopaque, @ptrCast(val)), @as(c_ulong, @bitCast(@as(c_long, len))));
            (blk: {
                const tmp = len;
                if (tmp >= 0) break :blk member.* + @as(usize, @intCast(tmp)) else break :blk member.* - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = 0;
        }
    } else {
        member.* = null;
    }
}
pub export fn tls_certificate_set_copy_date(arg_member: [*c][*c]u8, arg_val: [*c]const u8, arg_len: c_int) void {
    var member = arg_member;
    _ = &member;
    var val = arg_val;
    _ = &val;
    var len = arg_len;
    _ = &len;
    if (!(member != null)) return;
    if (member.* != null) {
        free(@as(?*anyopaque, @ptrCast(member.*)));
    }
    if (len > @as(c_int, 4)) {
        member.* = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, len + @as(c_int, 3))))))));
        if (member.* != null) {
            if (@as(c_int, @bitCast(@as(c_uint, val[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, '9')) {
                member.*[@as(c_uint, @intCast(@as(c_int, 0)))] = '1';
                member.*[@as(c_uint, @intCast(@as(c_int, 1)))] = '9';
            } else {
                member.*[@as(c_uint, @intCast(@as(c_int, 0)))] = '2';
                member.*[@as(c_uint, @intCast(@as(c_int, 1)))] = '0';
            }
            _ = memcpy(@as(?*anyopaque, @ptrCast(member.* + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 2))))))), @as(?*const anyopaque, @ptrCast(val)), @as(c_ulong, @bitCast(@as(c_long, len))));
            (blk: {
                const tmp = len;
                if (tmp >= 0) break :blk member.* + @as(usize, @intCast(tmp)) else break :blk member.* - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = 0;
        }
    } else {
        member.* = null;
    }
}
pub export fn tls_certificate_set_key(arg_cert: [*c]struct_TLSCertificate, arg_val: [*c]const u8, arg_len: c_int) void {
    var cert = arg_cert;
    _ = &cert;
    var val = arg_val;
    _ = &val;
    var len = arg_len;
    _ = &len;
    if (!(val[@as(c_uint, @intCast(@as(c_int, 0)))] != 0) and (@import("std").zig.c_translation.signedRemainder(len, @as(c_int, 2)) != 0)) {
        val += 1;
        len -= 1;
    }
    tls_certificate_set_copy(&cert.*.pk, val, len);
    if (cert.*.pk != null) {
        cert.*.pk_len = @as(c_uint, @bitCast(len));
    }
}
pub export fn tls_certificate_set_priv(arg_cert: [*c]struct_TLSCertificate, arg_val: [*c]const u8, arg_len: c_int) void {
    var cert = arg_cert;
    _ = &cert;
    var val = arg_val;
    _ = &val;
    var len = arg_len;
    _ = &len;
    tls_certificate_set_copy(&cert.*.priv, val, len);
    if (cert.*.priv != null) {
        cert.*.priv_len = @as(c_uint, @bitCast(len));
    }
}
pub export fn tls_certificate_set_sign_key(arg_cert: [*c]struct_TLSCertificate, arg_val: [*c]const u8, arg_len: c_int) void {
    var cert = arg_cert;
    _ = &cert;
    var val = arg_val;
    _ = &val;
    var len = arg_len;
    _ = &len;
    if (!(val[@as(c_uint, @intCast(@as(c_int, 0)))] != 0) and (@import("std").zig.c_translation.signedRemainder(len, @as(c_int, 2)) != 0)) {
        val += 1;
        len -= 1;
    }
    tls_certificate_set_copy(&cert.*.sign_key, val, len);
    if (cert.*.sign_key != null) {
        cert.*.sign_len = @as(c_uint, @bitCast(len));
    }
}
pub export fn tls_certificate_to_string(arg_cert: [*c]struct_TLSCertificate, arg_buffer: [*c]u8, arg_len: c_int) [*c]u8 {
    var cert = arg_cert;
    _ = &cert;
    var buffer = arg_buffer;
    _ = &buffer;
    var len = arg_len;
    _ = &len;
    var i: c_uint = undefined;
    _ = &i;
    if (!(buffer != null)) return null;
    buffer[@as(c_uint, @intCast(@as(c_int, 0)))] = 0;
    if (cert.*.version != 0) {
        var res: c_int = snprintf(buffer, @as(c_ulong, @bitCast(@as(c_long, len))), "X.509v%i certificate\n  Issued by: [%s]%s (%s)\n  Issued to: [%s]%s (%s, %s)\n  Subject: %s\n  Validity: %s - %s\n  OCSP: %s\n  Serial number: ", @as(c_int, @bitCast(@as(c_uint, cert.*.version))), cert.*.issuer_country, cert.*.issuer_entity, cert.*.issuer_subject, cert.*.country, cert.*.entity, cert.*.state, cert.*.location, cert.*.subject, cert.*.not_before, cert.*.not_after, cert.*.ocsp);
        _ = &res;
        if (res > @as(c_int, 0)) {
            {
                i = 0;
                while (i < cert.*.serial_len) : (i +%= 1) {
                    res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "%02x", @as(c_int, @bitCast(@as(c_uint, cert.*.serial_number[i]))));
                }
            }
        }
        if ((cert.*.san != null) and (@as(c_int, @bitCast(@as(c_uint, cert.*.san_length))) != 0)) {
            res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "\n  Alternative subjects: ");
            {
                i = 0;
                while (i < @as(c_uint, @bitCast(@as(c_uint, cert.*.san_length)))) : (i +%= 1) {
                    if (i != 0) {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), ", %s", cert.*.san[i]);
                    } else {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "%s", cert.*.san[i]);
                    }
                }
            }
        }
        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "\n  Key (%i bits, ", cert.*.pk_len *% @as(c_uint, @bitCast(@as(c_int, 8))));
        if (res > @as(c_int, 0)) {
            while (true) {
                switch (cert.*.key_algorithm) {
                    @as(c_uint, @bitCast(@as(c_int, 1))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "RSA_SIGN_RSA");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 4))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "RSA_SIGN_MD5");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 5))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "RSA_SIGN_SHA1");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 10))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "RSA_SIGN_SHA224");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 11))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "RSA_SIGN_SHA256");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 12))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "RSA_SIGN_SHA384");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 13))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "RSA_SIGN_SHA512");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 15))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "ECDSA_SIGN_SHA224");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 14))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "ECDSA_SIGN_SHA256");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 16))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "ECDSA_SIGN_SHA384");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 26))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "ECDSA_SIGN_SHA512");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 17))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "EC_PUBLIC_KEY");
                        break;
                    },
                    else => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "not supported (%i)", @as(c_int, @bitCast(cert.*.key_algorithm)));
                    },
                }
                break;
            }
        }
        if ((res > @as(c_int, 0)) and (cert.*.ec_algorithm != 0)) {
            while (true) {
                switch (cert.*.ec_algorithm) {
                    @as(c_uint, @bitCast(@as(c_int, 18))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), " prime192v1");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 19))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), " prime192v2");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 20))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), " prime192v3");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 22))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), " prime239v2");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 23))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), " EC_secp256r1");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 21))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), " EC_secp224r1");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 24))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), " EC_secp384r1");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 25))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), " EC_secp521r1");
                        break;
                    },
                    else => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), " unknown(%i)", @as(c_int, @bitCast(cert.*.ec_algorithm)));
                    },
                }
                break;
            }
        }
        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "):\n");
        if (res > @as(c_int, 0)) {
            {
                i = 0;
                while (i < cert.*.pk_len) : (i +%= 1) {
                    res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "%02x", @as(c_int, @bitCast(@as(c_uint, cert.*.pk[i]))));
                }
            }
            res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "\n  Signature (%i bits, ", cert.*.sign_len *% @as(c_uint, @bitCast(@as(c_int, 8))));
            while (true) {
                switch (cert.*.algorithm) {
                    @as(c_uint, @bitCast(@as(c_int, 1))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "RSA_SIGN_RSA):\n");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 4))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "RSA_SIGN_MD5):\n");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 5))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "RSA_SIGN_SHA1):\n");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 10))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "RSA_SIGN_SHA224):\n");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 11))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "RSA_SIGN_SHA256):\n");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 12))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "RSA_SIGN_SHA384):\n");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 13))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "RSA_SIGN_SHA512):\n");
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 17))) => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "EC_PUBLIC_KEY):\n");
                        break;
                    },
                    else => {
                        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "not supported):\n");
                    },
                }
                break;
            }
            {
                i = 0;
                while (i < cert.*.sign_len) : (i +%= 1) {
                    res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "%02x", @as(c_int, @bitCast(@as(c_uint, cert.*.sign_key[i]))));
                }
            }
        }
    } else if ((cert.*.priv != null) and (cert.*.priv_len != 0)) {
        var res: c_int = snprintf(buffer, @as(c_ulong, @bitCast(@as(c_long, len))), "X.509 private key\n");
        _ = &res;
        res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "  Private Key: ");
        if (res > @as(c_int, 0)) {
            {
                i = 0;
                while (i < cert.*.priv_len) : (i +%= 1) {
                    res += snprintf(buffer + @as(usize, @bitCast(@as(isize, @intCast(res)))), @as(c_ulong, @bitCast(@as(c_long, len - res))), "%02x", @as(c_int, @bitCast(@as(c_uint, cert.*.priv[i]))));
                }
            }
        }
    } else {
        _ = snprintf(buffer, @as(c_ulong, @bitCast(@as(c_long, len))), "Empty ASN1 file");
    }
    return buffer;
}
pub export fn tls_certificate_set_exponent(arg_cert: [*c]struct_TLSCertificate, arg_val: [*c]const u8, arg_len: c_int) void {
    var cert = arg_cert;
    _ = &cert;
    var val = arg_val;
    _ = &val;
    var len = arg_len;
    _ = &len;
    tls_certificate_set_copy(&cert.*.exponent, val, len);
    if (cert.*.exponent != null) {
        cert.*.exponent_len = @as(c_uint, @bitCast(len));
    }
}
pub export fn tls_certificate_set_serial(arg_cert: [*c]struct_TLSCertificate, arg_val: [*c]const u8, arg_len: c_int) void {
    var cert = arg_cert;
    _ = &cert;
    var val = arg_val;
    _ = &val;
    var len = arg_len;
    _ = &len;
    tls_certificate_set_copy(&cert.*.serial_number, val, len);
    if (cert.*.serial_number != null) {
        cert.*.serial_len = @as(c_uint, @bitCast(len));
    }
}
// tlse_amalgamated.c:3837:9: warning: TODO implement translation of stmt class GotoStmtClass

// tlse_amalgamated.c:3771:6: warning: unable to translate function, demoted to extern
pub extern fn tls_certificate_set_algorithm(arg_context: [*c]struct_TLSContext, arg_algorithm: [*c]c_uint, arg_val: [*c]const u8, arg_len: c_int) void;
pub export fn tls_destroy_certificate(arg_cert: [*c]struct_TLSCertificate) void {
    var cert = arg_cert;
    _ = &cert;
    if (cert != null) {
        var i: c_int = undefined;
        _ = &i;
        if (cert.*.exponent != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.exponent)));
        }
        if (cert.*.pk != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.pk)));
        }
        if (cert.*.issuer_country != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.issuer_country)));
        }
        if (cert.*.issuer_state != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.issuer_state)));
        }
        if (cert.*.issuer_location != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.issuer_location)));
        }
        if (cert.*.issuer_entity != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.issuer_entity)));
        }
        if (cert.*.issuer_subject != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.issuer_subject)));
        }
        if (cert.*.country != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.country)));
        }
        if (cert.*.state != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.state)));
        }
        if (cert.*.location != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.location)));
        }
        if (cert.*.subject != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.subject)));
        }
        {
            i = 0;
            while (i < @as(c_int, @bitCast(@as(c_uint, cert.*.san_length)))) : (i += 1) {
                if ((blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk cert.*.san + @as(usize, @intCast(tmp)) else break :blk cert.*.san - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).* != null) {
                    free(@as(?*anyopaque, @ptrCast((blk: {
                        const tmp = i;
                        if (tmp >= 0) break :blk cert.*.san + @as(usize, @intCast(tmp)) else break :blk cert.*.san - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).*)));
                }
            }
        }
        if (cert.*.san != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.san)));
        }
        if (cert.*.ocsp != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.ocsp)));
        }
        if (cert.*.serial_number != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.serial_number)));
        }
        if (cert.*.entity != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.entity)));
        }
        if (cert.*.not_before != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.not_before)));
        }
        if (cert.*.not_after != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.not_after)));
        }
        if (cert.*.sign_key != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.sign_key)));
        }
        if (cert.*.priv != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.priv)));
        }
        if (cert.*.der_bytes != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.der_bytes)));
        }
        if (cert.*.bytes != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.bytes)));
        }
        if (cert.*.fingerprint != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.fingerprint)));
        }
        if (cert != null) {
            free(@as(?*anyopaque, @ptrCast(cert)));
        }
    }
}
pub export fn tls_create_packet(arg_context: [*c]struct_TLSContext, arg_type: u8, arg_version: c_ushort, arg_payload_size_hint: c_int) [*c]struct_TLSPacket {
    var context = arg_context;
    _ = &context;
    var @"type" = arg_type;
    _ = &@"type";
    var version = arg_version;
    _ = &version;
    var payload_size_hint = arg_payload_size_hint;
    _ = &payload_size_hint;
    var packet: [*c]struct_TLSPacket = @as([*c]struct_TLSPacket, @ptrCast(@alignCast(malloc(@sizeOf(struct_TLSPacket)))));
    _ = &packet;
    if (!(packet != null)) return null;
    packet.*.broken = 0;
    if (payload_size_hint > @as(c_int, 0)) {
        packet.*.size = @as(c_uint, @bitCast(payload_size_hint + @as(c_int, 10)));
    } else {
        packet.*.size = @as(c_uint, @bitCast(@as(c_int, 4095)));
    }
    packet.*.buf = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, packet.*.size)))))));
    packet.*.context = context;
    if (!(packet.*.buf != null)) {
        if (packet != null) {
            free(@as(?*anyopaque, @ptrCast(packet)));
        }
        return null;
    }
    if ((context != null) and (@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) != 0)) {
        packet.*.len = 13;
    } else {
        packet.*.len = 5;
    }
    packet.*.buf[@as(c_uint, @intCast(@as(c_int, 0)))] = @"type";
    while (true) {
        switch (@as(c_int, @bitCast(@as(c_uint, version)))) {
            @as(c_int, 772) => {
                if (context != null) {
                    @as([*c]c_ushort, @ptrCast(@alignCast(packet.*.buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1)))))))).* = @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 771)))));
                } else {
                    @as([*c]c_ushort, @ptrCast(@alignCast(packet.*.buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1)))))))).* = htons(version);
                }
                break;
            },
            @as(c_int, 65276) => {
                @as([*c]c_ushort, @ptrCast(@alignCast(packet.*.buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1)))))))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(@as(c_int, 65276))))));
                break;
            },
            else => {
                @as([*c]c_ushort, @ptrCast(@alignCast(packet.*.buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1)))))))).* = htons(version);
            },
        }
        break;
    }
    return packet;
}
pub export fn tls_destroy_packet(arg_packet: [*c]struct_TLSPacket) void {
    var packet = arg_packet;
    _ = &packet;
    if (packet != null) {
        if (packet.*.buf != null) if (packet.*.buf != null) {
            free(@as(?*anyopaque, @ptrCast(packet.*.buf)));
        };
        if (packet != null) {
            free(@as(?*anyopaque, @ptrCast(packet)));
        }
    }
}
pub const djb_u8 = u8;
pub export fn tls_packet_update(arg_packet: [*c]struct_TLSPacket) void {
    var packet = arg_packet;
    _ = &packet;
    if ((packet != null) and !(packet.*.broken != 0)) {
        var footer_size: c_int = 0;
        _ = &footer_size;
        if ((((packet.*.context != null) and ((@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.version))) == @as(c_int, 65276)))) and (@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.cipher_spec_set))) != 0)) and (@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.crypto.created))) != 0)) {
            _ = tls_packet_uint8(packet, packet.*.buf[@as(c_uint, @intCast(@as(c_int, 0)))]);
            footer_size = 1;
        }
        var header_size: c_uint = 5;
        _ = &header_size;
        if ((packet.*.context != null) and (@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.dtls))) != 0)) {
            header_size = 13;
            @as([*c]c_ushort, @ptrCast(@alignCast(packet.*.buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 3)))))))).* = htons(packet.*.context.*.dtls_epoch_local);
            var sequence_number: u64 = packet.*.context.*.local_sequence_number;
            _ = &sequence_number;
            packet.*.buf[@as(c_uint, @intCast(@as(c_int, 5)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_ulonglong, @bitCast(@as(c_ulonglong, sequence_number))) / @as(c_ulonglong, @bitCast(@as(c_longlong, 1099511627776)))))));
            sequence_number %= @as(u64, @bitCast(@as(c_ulong, @truncate(@as(c_ulonglong, @bitCast(@as(c_longlong, 1099511627776)))))));
            packet.*.buf[@as(c_uint, @intCast(@as(c_int, 6)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_ulonglong, @bitCast(@as(c_ulonglong, sequence_number))) / @as(c_ulonglong, @bitCast(@as(c_longlong, 4294967296)))))));
            sequence_number %= @as(u64, @bitCast(@as(c_ulong, @truncate(@as(c_ulonglong, @bitCast(@as(c_longlong, 4294967296)))))));
            packet.*.buf[@as(c_uint, @intCast(@as(c_int, 7)))] = @as(u8, @bitCast(@as(u8, @truncate(sequence_number / @as(u64, @bitCast(@as(c_long, @as(c_int, 16777216))))))));
            sequence_number %= @as(u64, @bitCast(@as(c_long, @as(c_int, 16777216))));
            packet.*.buf[@as(c_uint, @intCast(@as(c_int, 8)))] = @as(u8, @bitCast(@as(u8, @truncate(sequence_number / @as(u64, @bitCast(@as(c_long, @as(c_int, 65536))))))));
            sequence_number %= @as(u64, @bitCast(@as(c_long, @as(c_int, 65536))));
            packet.*.buf[@as(c_uint, @intCast(@as(c_int, 9)))] = @as(u8, @bitCast(@as(u8, @truncate(sequence_number / @as(u64, @bitCast(@as(c_long, @as(c_int, 256))))))));
            sequence_number %= @as(u64, @bitCast(@as(c_long, @as(c_int, 256))));
            packet.*.buf[@as(c_uint, @intCast(@as(c_int, 10)))] = @as(u8, @bitCast(@as(u8, @truncate(sequence_number))));
            @as([*c]c_ushort, @ptrCast(@alignCast(packet.*.buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 11)))))))).* = htons(@as(u16, @bitCast(@as(c_ushort, @truncate(packet.*.len -% header_size)))));
        } else {
            @as([*c]c_ushort, @ptrCast(@alignCast(packet.*.buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 3)))))))).* = htons(@as(u16, @bitCast(@as(c_ushort, @truncate(packet.*.len -% header_size)))));
        }
        if (packet.*.context != null) {
            if (@as(c_int, @bitCast(@as(c_uint, packet.*.buf[@as(c_uint, @intCast(@as(c_int, 0)))]))) != @as(c_int, 20)) {
                if ((@as(c_int, @bitCast(@as(c_uint, packet.*.buf[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 22)) and (packet.*.len > header_size)) {
                    var handshake_type: u8 = packet.*.buf[header_size];
                    _ = &handshake_type;
                    if ((@as(c_int, @bitCast(@as(c_uint, handshake_type))) != @as(c_int, 0)) and (@as(c_int, @bitCast(@as(c_uint, handshake_type))) != @as(c_int, 3))) {
                        _ = _private_tls_update_hash(packet.*.context, packet.*.buf + header_size, (packet.*.len -% header_size) -% @as(c_uint, @bitCast(footer_size)), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
                    }
                }
                if ((@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.cipher_spec_set))) != 0) and (@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.crypto.created))) != 0)) {
                    var block_size: c_int = 16;
                    _ = &block_size;
                    var mac_size: c_int = 0;
                    _ = &mac_size;
                    var length: c_uint = 0;
                    _ = &length;
                    var padding: u8 = 0;
                    _ = &padding;
                    var pt_length: c_uint = packet.*.len -% header_size;
                    _ = &pt_length;
                    if (@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.crypto.created))) == @as(c_int, 1)) {
                        mac_size = @as(c_int, @bitCast(_private_tls_mac_length(packet.*.context)));
                        if (@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.version))) == @as(c_int, 769)) {
                            length = (packet.*.len -% header_size) +% @as(c_uint, @bitCast(mac_size));
                        } else {
                            length = ((packet.*.len -% header_size) +% @as(c_uint, @bitCast(@as(c_int, 16)))) +% @as(c_uint, @bitCast(mac_size));
                        }
                        padding = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(block_size)) -% (length % @as(c_uint, @bitCast(block_size)))))));
                        length +%= @as(c_uint, @bitCast(@as(c_uint, padding)));
                    } else if (@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.crypto.created))) == @as(c_int, 3)) {
                        mac_size = 16;
                        length = (packet.*.len -% header_size) +% @as(c_uint, @bitCast(mac_size));
                    } else {
                        mac_size = 16;
                        length = ((packet.*.len -% header_size) +% @as(c_uint, @bitCast(@as(c_int, 8)))) +% @as(c_uint, @bitCast(mac_size));
                    }
                    if (@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.crypto.created))) == @as(c_int, 1)) {
                        var buf: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, length)))))));
                        _ = &buf;
                        if (buf != null) {
                            var ct: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, length +% header_size)))))));
                            _ = &ct;
                            if (ct != null) {
                                var buf_pos: c_uint = 0;
                                _ = &buf_pos;
                                _ = memcpy(@as(?*anyopaque, @ptrCast(ct)), @as(?*const anyopaque, @ptrCast(packet.*.buf)), @as(c_ulong, @bitCast(@as(c_ulong, header_size -% @as(c_uint, @bitCast(@as(c_int, 2)))))));
                                @as([*c]c_ushort, @ptrCast(@alignCast(&ct[header_size -% @as(c_uint, @bitCast(@as(c_int, 2)))]))).* = htons(@as(u16, @bitCast(@as(c_ushort, @truncate(length)))));
                                if (@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.version))) != @as(c_int, 769)) {
                                    _ = tls_random(buf, @as(c_int, 16));
                                    buf_pos +%= @as(c_uint, @bitCast(@as(c_int, 16)));
                                }
                                _ = memcpy(@as(?*anyopaque, @ptrCast(buf + buf_pos)), @as(?*const anyopaque, @ptrCast(packet.*.buf + header_size)), @as(c_ulong, @bitCast(@as(c_ulong, packet.*.len -% header_size))));
                                buf_pos +%= packet.*.len -% header_size;
                                if (packet.*.context.*.dtls != 0) {
                                    var temp_buf: [5]u8 = undefined;
                                    _ = &temp_buf;
                                    _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&temp_buf))))), @as(?*const anyopaque, @ptrCast(packet.*.buf)), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3)))));
                                    @as([*c]c_ushort, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&temp_buf))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 3)))))))).* = @as([*c]c_ushort, @ptrCast(@alignCast(&packet.*.buf[header_size -% @as(c_uint, @bitCast(@as(c_int, 2)))]))).*;
                                    var dtls_sequence_number: u64 = if (@as(u32, @bitCast(@as(c_int, 1))) == ntohl(@as(u32, @bitCast(@as(c_int, 1))))) @as([*c]u64, @ptrCast(@alignCast(&packet.*.buf[@as(c_uint, @intCast(@as(c_int, 3)))]))).* else (@as(u64, @bitCast(@as(c_ulong, ntohl(@as(u32, @bitCast(@as(c_uint, @truncate(@as([*c]u64, @ptrCast(@alignCast(&packet.*.buf[@as(c_uint, @intCast(@as(c_int, 3)))]))).* & @as(u64, @bitCast(@as(c_ulong, @as(c_uint, 4294967295)))))))))))) << @intCast(32)) | @as(u64, @bitCast(@as(c_ulong, ntohl(@as(u32, @bitCast(@as(c_uint, @truncate(@as([*c]u64, @ptrCast(@alignCast(&packet.*.buf[@as(c_uint, @intCast(@as(c_int, 3)))]))).* >> @intCast(32)))))))));
                                    _ = &dtls_sequence_number;
                                    _ = _private_tls_hmac_message(@as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), packet.*.context, @as([*c]u8, @ptrCast(@alignCast(&temp_buf))), @as(c_int, 5), packet.*.buf + header_size, @as(c_int, @bitCast(packet.*.len -% header_size)), buf + buf_pos, @as(c_uint, @bitCast(mac_size)), dtls_sequence_number);
                                } else {
                                    _ = _private_tls_hmac_message(@as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), packet.*.context, packet.*.buf, @as(c_int, @bitCast(packet.*.len)), null, @as(c_int, 0), buf + buf_pos, @as(c_uint, @bitCast(mac_size)), @as(u64, @bitCast(@as(c_long, @as(c_int, 0)))));
                                }
                                buf_pos +%= @as(c_uint, @bitCast(mac_size));
                                _ = memset(@as(?*anyopaque, @ptrCast(buf + buf_pos)), @as(c_int, @bitCast(@as(c_uint, padding))) - @as(c_int, 1), @as(c_ulong, @bitCast(@as(c_ulong, padding))));
                                buf_pos +%= @as(c_uint, @bitCast(@as(c_uint, padding)));
                                _ = _private_tls_crypto_encrypt(packet.*.context, buf, ct + header_size, length);
                                if (packet.*.buf != null) {
                                    free(@as(?*anyopaque, @ptrCast(packet.*.buf)));
                                }
                                packet.*.buf = ct;
                                packet.*.len = length +% header_size;
                                packet.*.size = packet.*.len;
                            } else {
                                _ = memset(@as(?*anyopaque, @ptrCast(packet.*.buf)), @as(c_int, 0), @as(c_ulong, @bitCast(@as(c_ulong, packet.*.len))));
                            }
                            if (buf != null) {
                                free(@as(?*anyopaque, @ptrCast(buf)));
                            }
                        } else {
                            _ = memset(@as(?*anyopaque, @ptrCast(packet.*.buf)), @as(c_int, 0), @as(c_ulong, @bitCast(@as(c_ulong, packet.*.len))));
                        }
                    } else if (@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.crypto.created))) >= @as(c_int, 2)) {
                        var ct_size: c_int = @as(c_int, @bitCast((((length +% header_size) +% @as(c_uint, @bitCast(@as(c_int, 12)))) +% @as(c_uint, @bitCast(@as(c_int, 16)))) +% @as(c_uint, @bitCast(@as(c_int, 1)))));
                        _ = &ct_size;
                        var ct: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, ct_size)))))));
                        _ = &ct;
                        if (ct != null) {
                            _ = memset(@as(?*anyopaque, @ptrCast(ct)), @as(c_int, 0), @as(c_ulong, @bitCast(@as(c_long, ct_size))));
                            var aad: [13]u8 = undefined;
                            _ = &aad;
                            var aad_size: c_int = @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([13]u8)))));
                            _ = &aad_size;
                            var sequence: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(&aad)));
                            _ = &sequence;
                            if ((@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.version))) == @as(c_int, 65276))) {
                                aad[@as(c_uint, @intCast(@as(c_int, 0)))] = 23;
                                aad[@as(c_uint, @intCast(@as(c_int, 1)))] = packet.*.buf[@as(c_uint, @intCast(@as(c_int, 1)))];
                                aad[@as(c_uint, @intCast(@as(c_int, 2)))] = packet.*.buf[@as(c_uint, @intCast(@as(c_int, 2)))];
                                if (@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.crypto.created))) == @as(c_int, 3)) {
                                    @as([*c]c_ushort, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&aad))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 3)))))))).* = htons(@as(u16, @bitCast(@as(c_ushort, @truncate((packet.*.len +% @as(c_uint, @bitCast(@as(c_int, 16)))) -% header_size)))));
                                } else {
                                    @as([*c]c_ushort, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&aad))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 3)))))))).* = htons(@as(u16, @bitCast(@as(c_ushort, @truncate((packet.*.len +% @as(c_uint, @bitCast(@as(c_int, 16)))) -% header_size)))));
                                }
                                aad_size = 5;
                                sequence = @as([*c]u8, @ptrCast(@alignCast(&aad))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 5)))));
                                if (packet.*.context.*.dtls != 0) {
                                    @as([*c]u64, @ptrCast(@alignCast(sequence))).* = @as([*c]u64, @ptrCast(@alignCast(&packet.*.buf[@as(c_uint, @intCast(@as(c_int, 3)))]))).*;
                                } else {
                                    @as([*c]u64, @ptrCast(@alignCast(sequence))).* = if (@as(u32, @bitCast(@as(c_int, 1))) == htonl(@as(u32, @bitCast(@as(c_int, 1))))) packet.*.context.*.local_sequence_number else (@as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(packet.*.context.*.local_sequence_number & @as(u64, @bitCast(@as(c_ulong, @as(c_uint, 4294967295)))))))))))) << @intCast(32)) | @as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(packet.*.context.*.local_sequence_number >> @intCast(32)))))))));
                                }
                            } else {
                                if (packet.*.context.*.dtls != 0) {
                                    @as([*c]u64, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&aad)))))).* = @as([*c]u64, @ptrCast(@alignCast(&packet.*.buf[@as(c_uint, @intCast(@as(c_int, 3)))]))).*;
                                } else {
                                    @as([*c]u64, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&aad)))))).* = if (@as(u32, @bitCast(@as(c_int, 1))) == htonl(@as(u32, @bitCast(@as(c_int, 1))))) packet.*.context.*.local_sequence_number else (@as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(packet.*.context.*.local_sequence_number & @as(u64, @bitCast(@as(c_ulong, @as(c_uint, 4294967295)))))))))))) << @intCast(32)) | @as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(packet.*.context.*.local_sequence_number >> @intCast(32)))))))));
                                }
                                aad[@as(c_uint, @intCast(@as(c_int, 8)))] = packet.*.buf[@as(c_uint, @intCast(@as(c_int, 0)))];
                                aad[@as(c_uint, @intCast(@as(c_int, 9)))] = packet.*.buf[@as(c_uint, @intCast(@as(c_int, 1)))];
                                aad[@as(c_uint, @intCast(@as(c_int, 10)))] = packet.*.buf[@as(c_uint, @intCast(@as(c_int, 2)))];
                                @as([*c]c_ushort, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&aad))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 11)))))))).* = htons(@as(u16, @bitCast(@as(c_ushort, @truncate(packet.*.len -% header_size)))));
                            }
                            var ct_pos: c_int = @as(c_int, @bitCast(header_size));
                            _ = &ct_pos;
                            if (@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.crypto.created))) == @as(c_int, 3)) {
                                var counter: c_uint = 1;
                                _ = &counter;
                                var poly1305_key: [32]u8 = undefined;
                                _ = &poly1305_key;
                                chacha_ivupdate(&packet.*.context.*.crypto.ctx_local.chacha_local, @as([*c]u8, @ptrCast(@alignCast(&packet.*.context.*.crypto.ctx_local_mac.local_aead_iv))), sequence, @as([*c]djb_u8, @ptrCast(@alignCast(&counter))));
                                chacha20_poly1305_key(&packet.*.context.*.crypto.ctx_local.chacha_local, @as([*c]u8, @ptrCast(@alignCast(&poly1305_key))));
                                ct_pos += chacha20_poly1305_aead(&packet.*.context.*.crypto.ctx_local.chacha_local, packet.*.buf + header_size, pt_length, @as([*c]u8, @ptrCast(@alignCast(&aad))), @as(c_uint, @bitCast(aad_size)), @as([*c]u8, @ptrCast(@alignCast(&poly1305_key))), ct + @as(usize, @bitCast(@as(isize, @intCast(ct_pos)))));
                            } else {
                                var iv: [12]u8 = undefined;
                                _ = &iv;
                                if ((@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.version))) == @as(c_int, 65276))) {
                                    _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&iv))))), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&packet.*.context.*.crypto.ctx_local_mac.local_iv))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 12)))));
                                    var i: c_int = undefined;
                                    _ = &i;
                                    var offset: c_int = @as(c_int, 12) - @as(c_int, 8);
                                    _ = &offset;
                                    {
                                        i = 0;
                                        while (i < @as(c_int, 8)) : (i += 1) {
                                            iv[@as(c_uint, @intCast(offset + i))] = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.crypto.ctx_local_mac.local_iv[@as(c_uint, @intCast(offset + i))]))) ^ @as(c_int, @bitCast(@as(c_uint, (blk: {
                                                const tmp = i;
                                                if (tmp >= 0) break :blk sequence + @as(usize, @intCast(tmp)) else break :blk sequence - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                                            }).*)))))));
                                        }
                                    }
                                } else {
                                    _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&iv))))), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&packet.*.context.*.crypto.ctx_local_mac.local_aead_iv))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4)))));
                                    _ = tls_random(@as([*c]u8, @ptrCast(@alignCast(&iv))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))), @as(c_int, 8));
                                    _ = memcpy(@as(?*anyopaque, @ptrCast(ct + @as(usize, @bitCast(@as(isize, @intCast(ct_pos)))))), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&iv))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))));
                                    ct_pos += @as(c_int, 8);
                                }
                                _ = gcm_reset(&packet.*.context.*.crypto.ctx_local.aes_gcm_local);
                                _ = gcm_add_iv(&packet.*.context.*.crypto.ctx_local.aes_gcm_local, @as([*c]u8, @ptrCast(@alignCast(&iv))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 12)))));
                                _ = gcm_add_aad(&packet.*.context.*.crypto.ctx_local.aes_gcm_local, @as([*c]u8, @ptrCast(@alignCast(&aad))), @as(c_ulong, @bitCast(@as(c_long, aad_size))));
                                _ = gcm_process(&packet.*.context.*.crypto.ctx_local.aes_gcm_local, packet.*.buf + header_size, @as(c_ulong, @bitCast(@as(c_ulong, pt_length))), ct + @as(usize, @bitCast(@as(isize, @intCast(ct_pos)))), @as(c_int, 0));
                                ct_pos += @as(c_int, @bitCast(pt_length));
                                var taglen: c_ulong = 16;
                                _ = &taglen;
                                _ = gcm_done(&packet.*.context.*.crypto.ctx_local.aes_gcm_local, ct + @as(usize, @bitCast(@as(isize, @intCast(ct_pos)))), &taglen);
                                ct_pos += @as(c_int, @bitCast(@as(c_uint, @truncate(taglen))));
                            }
                            if ((@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.version))) == @as(c_int, 65276))) {
                                ct[@as(c_uint, @intCast(@as(c_int, 0)))] = 23;
                                @as([*c]c_ushort, @ptrCast(@alignCast(&ct[@as(c_uint, @intCast(@as(c_int, 1)))]))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(if (@as(c_int, @bitCast(@as(c_uint, packet.*.context.*.version))) == @as(c_int, 772)) @as(c_int, 771) else @as(c_int, 65277))))));
                                if (header_size != @as(c_uint, @bitCast(@as(c_int, 5)))) {
                                    _ = memcpy(@as(?*anyopaque, @ptrCast(ct)), @as(?*const anyopaque, @ptrCast(packet.*.buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 3))))))), @as(c_ulong, @bitCast(@as(c_ulong, header_size -% @as(c_uint, @bitCast(@as(c_int, 2)))))));
                                }
                            } else {
                                _ = memcpy(@as(?*anyopaque, @ptrCast(ct)), @as(?*const anyopaque, @ptrCast(packet.*.buf)), @as(c_ulong, @bitCast(@as(c_ulong, header_size -% @as(c_uint, @bitCast(@as(c_int, 2)))))));
                            }
                            @as([*c]c_ushort, @ptrCast(@alignCast(&ct[header_size -% @as(c_uint, @bitCast(@as(c_int, 2)))]))).* = htons(@as(u16, @bitCast(@as(c_ushort, @truncate(@as(c_uint, @bitCast(ct_pos)) -% header_size)))));
                            if (packet.*.buf != null) {
                                free(@as(?*anyopaque, @ptrCast(packet.*.buf)));
                            }
                            packet.*.buf = ct;
                            packet.*.len = @as(c_uint, @bitCast(ct_pos));
                            packet.*.size = @as(c_uint, @bitCast(ct_pos));
                        } else {
                            _ = memset(@as(?*anyopaque, @ptrCast(packet.*.buf)), @as(c_int, 0), @as(c_ulong, @bitCast(@as(c_ulong, packet.*.len))));
                        }
                    } else {
                        _ = memset(@as(?*anyopaque, @ptrCast(packet.*.buf)), @as(c_int, 0), @as(c_ulong, @bitCast(@as(c_ulong, packet.*.len))));
                    }
                }
            } else {
                packet.*.context.*.dtls_epoch_local +%= 1;
            }
            packet.*.context.*.local_sequence_number +%= 1;
        }
    }
}
pub export fn tls_packet_append(arg_packet: [*c]struct_TLSPacket, arg_buf: [*c]const u8, arg_len: c_uint) c_int {
    var packet = arg_packet;
    _ = &packet;
    var buf = arg_buf;
    _ = &buf;
    var len = arg_len;
    _ = &len;
    if (!(packet != null) or (@as(c_int, @bitCast(@as(c_uint, packet.*.broken))) != 0)) return -@as(c_int, 1);
    if (!(len != 0)) return 0;
    var new_len: c_uint = packet.*.len +% len;
    _ = &new_len;
    if (new_len > packet.*.size) {
        packet.*.size = ((new_len / @as(c_uint, @bitCast(@as(c_int, 4095)))) +% @as(c_uint, @bitCast(@as(c_int, 1)))) *% @as(c_uint, @bitCast(@as(c_int, 4095)));
        packet.*.buf = @as([*c]u8, @ptrCast(@alignCast(realloc(@as(?*anyopaque, @ptrCast(packet.*.buf)), @as(c_ulong, @bitCast(@as(c_ulong, packet.*.size)))))));
        if (!(packet.*.buf != null)) {
            packet.*.size = 0;
            packet.*.len = 0;
            packet.*.broken = 1;
            return -@as(c_int, 1);
        }
    }
    if (buf != null) {
        _ = memcpy(@as(?*anyopaque, @ptrCast(packet.*.buf + packet.*.len)), @as(?*const anyopaque, @ptrCast(buf)), @as(c_ulong, @bitCast(@as(c_ulong, len))));
    }
    packet.*.len = new_len;
    return @as(c_int, @bitCast(new_len));
}
pub export fn tls_packet_uint8(arg_packet: [*c]struct_TLSPacket, arg_i: u8) c_int {
    var packet = arg_packet;
    _ = &packet;
    var i = arg_i;
    _ = &i;
    return tls_packet_append(packet, &i, @as(c_uint, @bitCast(@as(c_int, 1))));
}
pub export fn tls_packet_uint16(arg_packet: [*c]struct_TLSPacket, arg_i: c_ushort) c_int {
    var packet = arg_packet;
    _ = &packet;
    var i = arg_i;
    _ = &i;
    var ni: c_ushort = htons(i);
    _ = &ni;
    return tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&ni))), @as(c_uint, @bitCast(@as(c_int, 2))));
}
pub export fn tls_packet_uint32(arg_packet: [*c]struct_TLSPacket, arg_i: c_uint) c_int {
    var packet = arg_packet;
    _ = &packet;
    var i = arg_i;
    _ = &i;
    var ni: c_uint = htonl(i);
    _ = &ni;
    return tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&ni))), @as(c_uint, @bitCast(@as(c_int, 4))));
}
pub export fn tls_packet_uint24(arg_packet: [*c]struct_TLSPacket, arg_i: c_uint) c_int {
    var packet = arg_packet;
    _ = &packet;
    var i = arg_i;
    _ = &i;
    var buf: [3]u8 = undefined;
    _ = &buf;
    buf[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(i / @as(c_uint, @bitCast(@as(c_int, 65536)))))));
    i %= @as(c_uint, @bitCast(@as(c_int, 65536)));
    buf[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(i / @as(c_uint, @bitCast(@as(c_int, 256)))))));
    i %= @as(c_uint, @bitCast(@as(c_int, 256)));
    buf[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(i))));
    return tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&buf))), @as(c_uint, @bitCast(@as(c_int, 3))));
}
pub export fn tls_random(arg_key: [*c]u8, arg_len: c_int) c_int {
    var key = arg_key;
    _ = &key;
    var len = arg_len;
    _ = &len;
    var fp: [*c]FILE = fopen("/dev/urandom", "r");
    _ = &fp;
    if (fp != null) {
        var key_len: c_int = @as(c_int, @bitCast(@as(c_uint, @truncate(fread(@as(?*anyopaque, @ptrCast(key)), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))), @as(c_ulong, @bitCast(@as(c_long, len))), fp)))));
        _ = &key_len;
        _ = fclose(fp);
        if (key_len == len) return 1;
    }
    return 0;
}
pub export fn tls_get_write_buffer(arg_context: [*c]struct_TLSContext, arg_outlen: [*c]c_uint) [*c]const u8 {
    var context = arg_context;
    _ = &context;
    var outlen = arg_outlen;
    _ = &outlen;
    if (!(outlen != null)) return null;
    if (!(context != null)) {
        outlen.* = 0;
        return null;
    }
    if (context.*.sleep_until != 0) {
        if (@as(time_t, @bitCast(@as(c_ulong, context.*.sleep_until))) < time(null)) {
            outlen.* = 0;
            return null;
        }
        context.*.sleep_until = 0;
    }
    outlen.* = context.*.tls_buffer_len;
    return context.*.tls_buffer;
}
pub export fn tls_buffer_clear(arg_context: [*c]struct_TLSContext) void {
    var context = arg_context;
    _ = &context;
    if ((context != null) and (context.*.tls_buffer != null)) {
        if (context.*.tls_buffer != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.tls_buffer)));
        }
        context.*.tls_buffer = null;
        context.*.tls_buffer_len = 0;
    }
}
pub export fn tls_established(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    if (context != null) {
        if (context.*.critical_error != 0) return -@as(c_int, 1);
        if (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) == @as(c_int, 255)) return 1;
    }
    return 0;
}
pub export fn tls_read_clear(arg_context: [*c]struct_TLSContext) void {
    var context = arg_context;
    _ = &context;
    if ((context != null) and (context.*.application_buffer != null)) {
        if (context.*.application_buffer != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.application_buffer)));
        }
        context.*.application_buffer = null;
        context.*.application_buffer_len = 0;
    }
}
pub export fn tls_read(arg_context: [*c]struct_TLSContext, arg_buf: [*c]u8, arg_size: c_uint) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var size = arg_size;
    _ = &size;
    if (!(context != null)) return -@as(c_int, 1);
    if ((context.*.application_buffer != null) and (context.*.application_buffer_len != 0)) {
        if (context.*.application_buffer_len < size) {
            size = context.*.application_buffer_len;
        }
        _ = memcpy(@as(?*anyopaque, @ptrCast(buf)), @as(?*const anyopaque, @ptrCast(context.*.application_buffer)), @as(c_ulong, @bitCast(@as(c_ulong, size))));
        if (context.*.application_buffer_len == size) {
            if (context.*.application_buffer != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.application_buffer)));
            }
            context.*.application_buffer = null;
            context.*.application_buffer_len = 0;
            return @as(c_int, @bitCast(size));
        }
        context.*.application_buffer_len -%= size;
        _ = memmove(@as(?*anyopaque, @ptrCast(context.*.application_buffer)), @as(?*const anyopaque, @ptrCast(context.*.application_buffer + size)), @as(c_ulong, @bitCast(@as(c_ulong, context.*.application_buffer_len))));
        return @as(c_int, @bitCast(size));
    }
    return 0;
}
pub export fn tls_create_context(arg_is_server: u8, arg_version: c_ushort) [*c]struct_TLSContext {
    var is_server = arg_is_server;
    _ = &is_server;
    var version = arg_version;
    _ = &version;
    var context: [*c]struct_TLSContext = @as([*c]struct_TLSContext, @ptrCast(@alignCast(malloc(@sizeOf(struct_TLSContext)))));
    _ = &context;
    if (context != null) {
        _ = memset(@as(?*anyopaque, @ptrCast(context)), @as(c_int, 0), @sizeOf(struct_TLSContext));
        context.*.is_server = is_server;
        if (((@as(c_int, @bitCast(@as(c_uint, version))) == @as(c_int, 65276)) or (@as(c_int, @bitCast(@as(c_uint, version))) == @as(c_int, 65277))) or (@as(c_int, @bitCast(@as(c_uint, version))) == @as(c_int, 65279))) {
            context.*.dtls = 1;
            context.*.dtls_data = @as([*c]struct_DTLSData, @ptrCast(@alignCast(malloc(@sizeOf(struct_DTLSData)))));
            if (!(context.*.dtls_data != null)) {
                if (context != null) {
                    free(@as(?*anyopaque, @ptrCast(context)));
                }
                return null;
            }
            _ = memset(@as(?*anyopaque, @ptrCast(context.*.dtls_data)), @as(c_int, 0), @sizeOf(struct_DTLSData));
        }
        context.*.version = version;
    }
    return context;
}
pub export fn tls_set_curve(arg_context: [*c]struct_TLSContext, arg_curve: [*c]const struct_ECCCurveParameters) [*c]const struct_ECCCurveParameters {
    var context = arg_context;
    _ = &context;
    var curve = arg_curve;
    _ = &curve;
    if (!(context.*.is_server != 0)) return null;
    var old_curve: [*c]const struct_ECCCurveParameters = context.*.curve;
    _ = &old_curve;
    context.*.curve = curve;
    return old_curve;
}
pub export fn tls_accept(arg_context: [*c]struct_TLSContext) [*c]struct_TLSContext {
    var context = arg_context;
    _ = &context;
    if (!(context != null) or !(context.*.is_server != 0)) return null;
    var child: [*c]struct_TLSContext = @as([*c]struct_TLSContext, @ptrCast(@alignCast(malloc(@sizeOf(struct_TLSContext)))));
    _ = &child;
    if (child != null) {
        _ = memset(@as(?*anyopaque, @ptrCast(child)), @as(c_int, 0), @sizeOf(struct_TLSContext));
        child.*.is_server = 1;
        child.*.is_child = 1;
        child.*.dtls = context.*.dtls;
        if (context.*.dtls != 0) {
            child.*.dtls_data = @as([*c]struct_DTLSData, @ptrCast(@alignCast(malloc(@sizeOf(struct_DTLSData)))));
            if (!(child.*.dtls_data != null)) {
                if (child != null) {
                    free(@as(?*anyopaque, @ptrCast(child)));
                }
                return null;
            }
            _ = memset(@as(?*anyopaque, @ptrCast(child.*.dtls_data)), @as(c_int, 0), @sizeOf(struct_DTLSData));
        }
        child.*.version = context.*.version;
        child.*.certificates = context.*.certificates;
        child.*.certificates_count = context.*.certificates_count;
        child.*.private_key = context.*.private_key;
        child.*.ec_private_key = context.*.ec_private_key;
        child.*.exportable = context.*.exportable;
        child.*.root_certificates = context.*.root_certificates;
        child.*.root_count = context.*.root_count;
        child.*.default_dhe_p = context.*.default_dhe_p;
        child.*.default_dhe_g = context.*.default_dhe_g;
        child.*.curve = context.*.curve;
        child.*.alpn = context.*.alpn;
        child.*.alpn_count = context.*.alpn_count;
        child.*.request_client_certificate = context.*.request_client_certificate;
    }
    return child;
}
pub export fn tls_set_default_dhe_pg(arg_context: [*c]struct_TLSContext, arg_p_hex_str: [*c]const u8, arg_g_hex_str: [*c]const u8) c_int {
    var context = arg_context;
    _ = &context;
    var p_hex_str = arg_p_hex_str;
    _ = &p_hex_str;
    var g_hex_str = arg_g_hex_str;
    _ = &g_hex_str;
    if ((((!(context != null) or (@as(c_int, @bitCast(@as(c_uint, context.*.is_child))) != 0)) or !(context.*.is_server != 0)) or !(p_hex_str != null)) or !(g_hex_str != null)) return 0;
    if (context.*.default_dhe_p != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.default_dhe_p)));
    }
    if (context.*.default_dhe_g != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.default_dhe_g)));
    }
    context.*.default_dhe_p = null;
    context.*.default_dhe_g = null;
    var p_len: usize = strlen(p_hex_str);
    _ = &p_len;
    var g_len: usize = strlen(g_hex_str);
    _ = &g_len;
    if ((p_len <= @as(usize, @bitCast(@as(c_long, @as(c_int, 0))))) or (g_len <= @as(usize, @bitCast(@as(c_long, @as(c_int, 0)))))) return 0;
    context.*.default_dhe_p = @as([*c]u8, @ptrCast(@alignCast(malloc(p_len +% @as(usize, @bitCast(@as(c_long, @as(c_int, 1))))))));
    if (!(context.*.default_dhe_p != null)) return 0;
    context.*.default_dhe_g = @as([*c]u8, @ptrCast(@alignCast(malloc(g_len +% @as(usize, @bitCast(@as(c_long, @as(c_int, 1))))))));
    if (!(context.*.default_dhe_g != null)) return 0;
    _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.default_dhe_p)), @as(?*const anyopaque, @ptrCast(p_hex_str)), p_len);
    context.*.default_dhe_p[p_len] = 0;
    _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.default_dhe_g)), @as(?*const anyopaque, @ptrCast(g_hex_str)), g_len);
    context.*.default_dhe_g[g_len] = 0;
    return 1;
}
pub export fn tls_destroy_context(arg_context: [*c]struct_TLSContext) void {
    var context = arg_context;
    _ = &context;
    var i: c_uint = undefined;
    _ = &i;
    if (!(context != null)) return;
    if (!(context.*.is_child != 0)) {
        if (context.*.certificates != null) {
            {
                i = 0;
                while (i < context.*.certificates_count) : (i +%= 1) {
                    tls_destroy_certificate(context.*.certificates[i]);
                }
            }
        }
        if (context.*.root_certificates != null) {
            {
                i = 0;
                while (i < context.*.root_count) : (i +%= 1) {
                    tls_destroy_certificate(context.*.root_certificates[i]);
                }
            }
            if (context.*.root_certificates != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.root_certificates)));
            }
            context.*.root_certificates = null;
        }
        if (context.*.private_key != null) {
            tls_destroy_certificate(context.*.private_key);
        }
        if (context.*.ec_private_key != null) {
            tls_destroy_certificate(context.*.ec_private_key);
        }
        if (context.*.certificates != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.certificates)));
        }
        if (context.*.default_dhe_p != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.default_dhe_p)));
        }
        if (context.*.default_dhe_g != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.default_dhe_g)));
        }
        if (context.*.alpn != null) {
            {
                i = 0;
                while (i < @as(c_uint, @bitCast(@as(c_uint, context.*.alpn_count)))) : (i +%= 1) if (context.*.alpn[i] != null) {
                    free(@as(?*anyopaque, @ptrCast(context.*.alpn[i])));
                };
            }
            if (context.*.alpn != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.alpn)));
            }
        }
    }
    if (context.*.client_certificates != null) {
        {
            i = 0;
            while (i < context.*.client_certificates_count) : (i +%= 1) {
                tls_destroy_certificate(context.*.client_certificates[i]);
            }
        }
        if (context.*.client_certificates != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.client_certificates)));
        }
    }
    context.*.client_certificates = null;
    if (context.*.master_key != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.master_key)));
    }
    if (context.*.premaster_key != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.premaster_key)));
    }
    if (context.*.crypto.created != 0) {
        _private_tls_crypto_done(context);
    }
    if (context.*.message_buffer != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.message_buffer)));
    }
    _ = _private_tls_done_hash(context, null);
    _private_tls_destroy_hash(context);
    if (context.*.tls_buffer != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.tls_buffer)));
    }
    if (context.*.application_buffer != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.application_buffer)));
    }
    if ((context.*.exportable_keys != null) and (@as(c_int, @bitCast(@as(c_uint, context.*.exportable_size))) != 0)) {
        _ = memset(@as(?*anyopaque, @ptrCast(context.*.exportable_keys)), @as(c_int, 0), @as(c_ulong, @bitCast(@as(c_ulong, context.*.exportable_size))));
    }
    if (context.*.exportable_keys != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.exportable_keys)));
    }
    if (context.*.sni != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.sni)));
    }
    if (context.*.dtls_cookie != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.dtls_cookie)));
    }
    if (context.*.cached_handshake != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.cached_handshake)));
    }
    _private_tls_dhe_free(context);
    _private_tls_ecc_dhe_free(context);
    if (context.*.negotiated_alpn != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.negotiated_alpn)));
    }
    if (context.*.finished_key != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.finished_key)));
    }
    if (context.*.remote_finished_key != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.remote_finished_key)));
    }
    if (context.*.server_finished_hash != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.server_finished_hash)));
    }
    if (context.*.client_secret != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.client_secret)));
    }
    if (context.*.dtls_data != null) {
        if (context.*.dtls_data.*.fragment != null) {
            if (context.*.dtls_data.*.fragment.*.buffer != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.dtls_data.*.fragment.*.buffer)));
            }
            if (context.*.dtls_data.*.fragment != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.dtls_data.*.fragment)));
            }
        }
        while (context.*.dtls_data.*.dtls_handshake_list != null) {
            var next: [*c]struct_TLSHandshakeList = @as([*c]struct_TLSHandshakeList, @ptrCast(@alignCast(context.*.dtls_data.*.dtls_handshake_list.*.next)));
            _ = &next;
            if (context.*.dtls_data.*.dtls_handshake_list.*.msg != null) {
                if (context.*.dtls_data.*.dtls_handshake_list.*.msg != null) {
                    free(@as(?*anyopaque, @ptrCast(context.*.dtls_data.*.dtls_handshake_list.*.msg)));
                }
            }
            if (context.*.dtls_data.*.dtls_handshake_list != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.dtls_data.*.dtls_handshake_list)));
            }
            context.*.dtls_data.*.dtls_handshake_list = next;
        }
        if (context.*.dtls_data.*.key_exchange != null) {
            if (context.*.dtls_data.*.key_exchange != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.dtls_data.*.key_exchange)));
            }
        }
        if (context.*.dtls_data.*.remote_fingerprint != null) {
            if (context.*.dtls_data.*.remote_fingerprint != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.dtls_data.*.remote_fingerprint)));
            }
        }
        if (context.*.dtls_data != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.dtls_data)));
        }
    }
    if (context != null) {
        free(@as(?*anyopaque, @ptrCast(context)));
    }
}
pub export fn tls_cipher_supported(arg_context: [*c]struct_TLSContext, arg_cipher: c_ushort) c_int {
    var context = arg_context;
    _ = &context;
    var cipher = arg_cipher;
    _ = &cipher;
    if (!(context != null)) return 0;
    while (true) {
        switch (@as(c_int, @bitCast(@as(c_uint, cipher)))) {
            @as(c_int, 4865), @as(c_int, 4866), @as(c_int, 4867) => {
                if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) return 1;
                return 0;
            },
            @as(c_int, 49161), @as(c_int, 49162) => {
                if ((context != null) and ((((context.*.certificates != null) and (context.*.certificates_count != 0)) and (context.*.ec_private_key != null)) or !(context.*.is_server != 0))) return 1;
                return 0;
            },
            @as(c_int, 49187), @as(c_int, 49188), @as(c_int, 49195), @as(c_int, 49196), @as(c_int, 52393) => {
                if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65277))) {
                    if ((context != null) and ((((context.*.certificates != null) and (context.*.certificates_count != 0)) and (context.*.ec_private_key != null)) or !(context.*.is_server != 0))) return 1;
                }
                return 0;
            },
            @as(c_int, 51), @as(c_int, 57), @as(c_int, 49171), @as(c_int, 49172), @as(c_int, 47), @as(c_int, 53) => return 1,
            @as(c_int, 103), @as(c_int, 107), @as(c_int, 158), @as(c_int, 159), @as(c_int, 49199), @as(c_int, 49191), @as(c_int, 49200), @as(c_int, 52394), @as(c_int, 52392), @as(c_int, 156), @as(c_int, 60), @as(c_int, 61), @as(c_int, 157) => {
                if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65277))) return 1;
                return 0;
            },
            else => {},
        }
        break;
    }
    return 0;
}
pub export fn tls_cipher_is_fs(arg_context: [*c]struct_TLSContext, arg_cipher: c_ushort) c_int {
    var context = arg_context;
    _ = &context;
    var cipher = arg_cipher;
    _ = &cipher;
    if (!(context != null)) return 0;
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
        while (true) {
            switch (@as(c_int, @bitCast(@as(c_uint, cipher)))) {
                @as(c_int, 4865), @as(c_int, 4866), @as(c_int, 4867) => return 1,
                else => {},
            }
            break;
        }
        return 0;
    }
    while (true) {
        switch (@as(c_int, @bitCast(@as(c_uint, cipher)))) {
            @as(c_int, 49161), @as(c_int, 49162), @as(c_int, 52393) => {
                if ((((context != null) and (context.*.certificates != null)) and (context.*.certificates_count != 0)) and (context.*.ec_private_key != null)) return 1;
                return 0;
            },
            @as(c_int, 49187), @as(c_int, 49188), @as(c_int, 49195), @as(c_int, 49196) => {
                if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65277))) {
                    if ((((context != null) and (context.*.certificates != null)) and (context.*.certificates_count != 0)) and (context.*.ec_private_key != null)) return 1;
                }
                return 0;
            },
            @as(c_int, 51), @as(c_int, 57), @as(c_int, 49171), @as(c_int, 49172) => return 1,
            @as(c_int, 103), @as(c_int, 107), @as(c_int, 158), @as(c_int, 159), @as(c_int, 49199), @as(c_int, 49191), @as(c_int, 49200), @as(c_int, 52394), @as(c_int, 52392) => {
                if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65277))) return 1;
                break;
            },
            else => {},
        }
        break;
    }
    return 0;
}
pub export fn tls_choose_cipher(arg_context: [*c]struct_TLSContext, arg_buf: [*c]const u8, arg_buf_len: c_int, arg_scsv_set: [*c]c_int) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var scsv_set = arg_scsv_set;
    _ = &scsv_set;
    var i: c_int = undefined;
    _ = &i;
    if (scsv_set != null) {
        scsv_set.* = 0;
    }
    if (!(context != null)) return 0;
    var selected_cipher: c_int = -@as(c_int, 5);
    _ = &selected_cipher;
    if (selected_cipher == -@as(c_int, 5)) {
        {
            i = 0;
            while (i < buf_len) : (i += @as(c_int, 2)) {
                var cipher: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*))).*);
                _ = &cipher;
                if (tls_cipher_is_fs(context, cipher) != 0) {
                    selected_cipher = @as(c_int, @bitCast(@as(c_uint, cipher)));
                    break;
                }
            }
        }
    }
    {
        i = 0;
        while (i < buf_len) : (i += @as(c_int, 2)) {
            var cipher: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
                const tmp = i;
                if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))).*);
            _ = &cipher;
            if (@as(c_int, @bitCast(@as(c_uint, cipher))) == @as(c_int, 22016)) {
                if (scsv_set != null) {
                    scsv_set.* = 1;
                }
                if (selected_cipher != -@as(c_int, 5)) break;
            }
        }
    }
    return selected_cipher;
}
pub export fn tls_cipher_is_ephemeral(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    if (context != null) {
        while (true) {
            switch (@as(c_int, @bitCast(@as(c_uint, context.*.cipher)))) {
                @as(c_int, 51), @as(c_int, 57), @as(c_int, 103), @as(c_int, 107), @as(c_int, 158), @as(c_int, 159), @as(c_int, 52394) => return 1,
                @as(c_int, 49171), @as(c_int, 49172), @as(c_int, 49191), @as(c_int, 49199), @as(c_int, 49200), @as(c_int, 52392), @as(c_int, 49161), @as(c_int, 49162), @as(c_int, 49187), @as(c_int, 49188), @as(c_int, 49195), @as(c_int, 49196), @as(c_int, 52393) => return 2,
                @as(c_int, 4865), @as(c_int, 4867), @as(c_int, 4868), @as(c_int, 4869), @as(c_int, 4866) => {
                    if (context.*.dhe != null) return 1;
                    return 2;
                },
                else => {},
            }
            break;
        }
    }
    return 0;
}
pub export fn tls_cipher_name(arg_context: [*c]struct_TLSContext) [*c]const u8 {
    var context = arg_context;
    _ = &context;
    if (context != null) {
        while (true) {
            switch (@as(c_int, @bitCast(@as(c_uint, context.*.cipher)))) {
                @as(c_int, 47) => return "RSA-AES128CBC-SHA",
                @as(c_int, 53) => return "RSA-AES256CBC-SHA",
                @as(c_int, 60) => return "RSA-AES128CBC-SHA256",
                @as(c_int, 61) => return "RSA-AES256CBC-SHA256",
                @as(c_int, 156) => return "RSA-AES128GCM-SHA256",
                @as(c_int, 157) => return "RSA-AES256GCM-SHA384",
                @as(c_int, 51) => return "DHE-RSA-AES128CBC-SHA",
                @as(c_int, 57) => return "DHE-RSA-AES256CBC-SHA",
                @as(c_int, 103) => return "DHE-RSA-AES128CBC-SHA256",
                @as(c_int, 107) => return "DHE-RSA-AES256CBC-SHA256",
                @as(c_int, 158) => return "DHE-RSA-AES128GCM-SHA256",
                @as(c_int, 159) => return "DHE-RSA-AES256GCM-SHA384",
                @as(c_int, 49171) => return "ECDHE-RSA-AES128CBC-SHA",
                @as(c_int, 49172) => return "ECDHE-RSA-AES256CBC-SHA",
                @as(c_int, 49191) => return "ECDHE-RSA-AES128CBC-SHA256",
                @as(c_int, 49199) => return "ECDHE-RSA-AES128GCM-SHA256",
                @as(c_int, 49200) => return "ECDHE-RSA-AES256GCM-SHA384",
                @as(c_int, 49161) => return "ECDHE-ECDSA-AES128CBC-SHA",
                @as(c_int, 49162) => return "ECDHE-ECDSA-AES256CBC-SHA",
                @as(c_int, 49187) => return "ECDHE-ECDSA-AES128CBC-SHA256",
                @as(c_int, 49188) => return "ECDHE-ECDSA-AES256CBC-SHA384",
                @as(c_int, 49195) => return "ECDHE-ECDSA-AES128GCM-SHA256",
                @as(c_int, 49196) => return "ECDHE-ECDSA-AES256GCM-SHA384",
                @as(c_int, 52392) => return "ECDHE-RSA-CHACHA20-POLY1305-SHA256",
                @as(c_int, 52393) => return "ECDHE-ECDSA-CHACHA20-POLY1305-SHA256",
                @as(c_int, 52394) => return "ECDHE-DHE-CHACHA20-POLY1305-SHA256",
                @as(c_int, 4865) => return "TLS-AES-128-GCM-SHA256",
                @as(c_int, 4866) => return "TLS-AES-256-GCM-SHA384",
                @as(c_int, 4867) => return "TLS-CHACHA20-POLY1305-SHA256",
                @as(c_int, 4868) => return "TLS-AES-128-CCM-SHA256",
                @as(c_int, 4869) => return "TLS-AES-128-CCM-8-SHA256",
                else => {},
            }
            break;
        }
    }
    return "UNKNOWN";
}
pub export fn tls_is_ecdsa(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    if (!(context != null)) return 0;
    while (true) {
        switch (@as(c_int, @bitCast(@as(c_uint, context.*.cipher)))) {
            @as(c_int, 49161), @as(c_int, 49162), @as(c_int, 49187), @as(c_int, 49188), @as(c_int, 49195), @as(c_int, 49196), @as(c_int, 52393) => return 1,
            else => {},
        }
        break;
    }
    if (context.*.ec_private_key != null) return 1;
    return 0;
}
pub export fn tls_build_client_key_exchange(arg_context: [*c]struct_TLSContext) [*c]struct_TLSPacket {
    var context = arg_context;
    _ = &context;
    if (context.*.is_server != 0) {
        return null;
    }
    var packet: [*c]struct_TLSPacket = tls_create_packet(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 22))))), context.*.version, @as(c_int, 0));
    _ = &packet;
    _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 16))))));
    var ephemeral: c_int = tls_cipher_is_ephemeral(context);
    _ = &ephemeral;
    if (((ephemeral != 0) and (context.*.premaster_key != null)) and (context.*.premaster_key_len != 0)) {
        if (ephemeral == @as(c_int, 1)) {
            var dh_Ys: [4095]u8 = undefined;
            _ = &dh_Ys;
            var dh_p: [4095]u8 = undefined;
            _ = &dh_p;
            var dh_g: [4095]u8 = undefined;
            _ = &dh_g;
            var dh_p_len: c_ulong = @sizeOf([4095]u8);
            _ = &dh_p_len;
            var dh_g_len: c_ulong = @sizeOf([4095]u8);
            _ = &dh_g_len;
            var dh_Ys_len: c_ulong = @sizeOf([4095]u8);
            _ = &dh_Ys_len;
            if (_private_tls_dh_export_pqY(@as([*c]u8, @ptrCast(@alignCast(&dh_p))), &dh_p_len, @as([*c]u8, @ptrCast(@alignCast(&dh_g))), &dh_g_len, @as([*c]u8, @ptrCast(@alignCast(&dh_Ys))), &dh_Ys_len, context.*.dhe) != 0) {
                if (packet != null) {
                    free(@as(?*anyopaque, @ptrCast(packet)));
                }
                _private_tls_dhe_free(context);
                return null;
            }
            _private_tls_dhe_free(context);
            _ = tls_packet_uint24(packet, @as(c_uint, @bitCast(@as(c_uint, @truncate(dh_Ys_len +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2)))))))));
            if (context.*.dtls != 0) {
                _private_dtls_handshake_data(context, packet, @as(c_uint, @bitCast(@as(c_uint, @truncate(dh_Ys_len +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2)))))))));
            }
            _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_ushort, @truncate(dh_Ys_len)))));
            _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&dh_Ys))), @as(c_uint, @bitCast(@as(c_uint, @truncate(dh_Ys_len)))));
        } else if (context.*.ecc_dhe != null) {
            var out: [2048]u8 = undefined;
            _ = &out;
            var out_len: c_ulong = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2048))));
            _ = &out_len;
            if (ecc_ansi_x963_export(context.*.ecc_dhe, @as([*c]u8, @ptrCast(@alignCast(&out))), &out_len) != 0) {
                if (packet != null) {
                    free(@as(?*anyopaque, @ptrCast(packet)));
                }
                return null;
            }
            _private_tls_ecc_dhe_free(context);
            _ = tls_packet_uint24(packet, @as(c_uint, @bitCast(@as(c_uint, @truncate(out_len +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))))))));
            if (context.*.dtls != 0) {
                _private_dtls_handshake_data(context, packet, @as(c_uint, @bitCast(@as(c_uint, @truncate(out_len +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))))))));
                context.*.dtls_seq +%= 1;
            }
            _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(u8, @truncate(out_len)))));
            _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&out))), @as(c_uint, @bitCast(@as(c_uint, @truncate(out_len)))));
        } else if ((context.*.curve == @as([*c]const struct_ECCCurveParameters, @ptrCast(@alignCast(&x25519)))) and (context.*.client_secret != null)) {
            var key: curve25519_key = undefined;
            _ = &key;
            _ = x25519_import_raw(context.*.client_secret, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))), PK_PRIVATE, &key);
            _ = tls_packet_uint24(packet, @as(c_uint, @bitCast(@as(c_int, 32) + @as(c_int, 1))));
            _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 32))))));
            _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&key.@"pub"))), @as(c_uint, @bitCast(@as(c_int, 32))));
            if (context.*.client_secret != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.client_secret)));
            }
            context.*.client_secret = null;
        }
        _ = _private_tls_compute_key(context, @as(c_uint, @bitCast(@as(c_int, 48))));
    } else {
        _ = _private_tls_build_random(packet);
    }
    context.*.connection_status = 2;
    tls_packet_update(packet);
    return packet;
}
pub export fn tls_build_server_key_exchange(arg_context: [*c]struct_TLSContext, arg_method: c_int) [*c]struct_TLSPacket {
    var context = arg_context;
    _ = &context;
    var method = arg_method;
    _ = &method;
    if (!(context.*.is_server != 0)) {
        return null;
    }
    var packet: [*c]struct_TLSPacket = tls_create_packet(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 22))))), context.*.version, @as(c_int, 0));
    _ = &packet;
    if (((@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) != 0) and (context.*.dtls_data.*.key_exchange != null)) and (context.*.dtls_data.*.key_exchange_len > packet.*.len)) {
        _ = tls_packet_append(packet, context.*.dtls_data.*.key_exchange, context.*.dtls_data.*.key_exchange_len);
        tls_packet_update(packet);
        context.*.dtls_seq +%= 1;
        return packet;
    }
    var packet_offset: c_int = @as(c_int, @bitCast(packet.*.len));
    _ = &packet_offset;
    _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 12))))));
    _ = tls_packet_append(packet, null, @as(c_uint, @bitCast(@as(c_int, 3))));
    if (context.*.dtls != 0) {
        _private_dtls_handshake_data(context, packet, @as(c_uint, @bitCast(@as(c_int, 0))));
    }
    var start_len: c_int = @as(c_int, @bitCast(packet.*.len));
    _ = &start_len;
    if (method == KEA_dhe_rsa) {
        if (!(context.*.dhe != null)) {
            tls_init();
            _private_tls_dhe_create(context);
            var default_dhe_p: [*c]const u8 = context.*.default_dhe_p;
            _ = &default_dhe_p;
            var default_dhe_g: [*c]const u8 = context.*.default_dhe_g;
            _ = &default_dhe_g;
            var key_size: c_int = undefined;
            _ = &key_size;
            if (!(default_dhe_p != null) or !(default_dhe_g != null)) {
                default_dhe_p = "87A8E61DB4B6663CFFBBD19C651959998CEEF608660DD0F25D2CEED4435E3B00E00DF8F1D61957D4FAF7DF4561B2AA3016C3D91134096FAA3BF4296D830E9A7C209E0C6497517ABD5A8A9D306BCF67ED91F9E6725B4758C022E0B1EF4275BF7B6C5BFC11D45F9088B941F54EB1E59BB8BC39A0BF12307F5C4FDB70C581B23F76B63ACAE1CAA6B7902D52526735488A0EF13C6D9A51BFA4AB3AD8347796524D8EF6A167B5A41825D967E144E5140564251CCACB83E6B486F6B3CA3F7971506026C0B857F689962856DED4010ABD0BE621C3A3960A54E710C375F26375D7014103A4B54330C198AF126116D2276E11715F693877FAD7EF09CADB094AE91E1A1597";
                default_dhe_g = "3FB32C9B73134D0B2E77506660EDBD484CA7B18F21EF205407F4793A1A0BA12510DBC15077BE463FFF4FED4AAC0BB555BE3A6C1B0C6B47B1BC3773BF7E8C6F62901228F8C28CBB18A55AE31341000A650196F931C77A57F2DDF463E5E9EC144B777DE62AAAB8A8628AC376D282D6ED3864E67982428EBC831D14348F6F2F9193B5045AF2767164E1DFC967C1FB3F2E55A4BD1BFFE83B9C80D052B985D182EA0ADB2A3B7313D3FE14C8484B1E052588B9B7D2BBD2DF016199ECD06E1557CD0915B3353BBB64E0EC377FD028370DF92B52C7891428CDC67EB6184B523D1DB246C32F63078490F00EF8D647D148D47954515E2327CFEF98C582664B4C0F6CC41659";
                key_size = @divTrunc(@as(c_int, 2048), @as(c_int, 8));
            } else {
                key_size = @as(c_int, @bitCast(@as(c_uint, @truncate(strlen(default_dhe_p)))));
            }
            if (_private_tls_dh_make_key(key_size, context.*.dhe, default_dhe_p, default_dhe_g, @as(c_int, 0), @as(c_int, 0)) != 0) {
                if (packet != null) {
                    free(@as(?*anyopaque, @ptrCast(packet)));
                }
                if (context.*.dhe != null) {
                    free(@as(?*anyopaque, @ptrCast(context.*.dhe)));
                }
                context.*.dhe = null;
                return null;
            }
        }
        var dh_Ys: [4095]u8 = undefined;
        _ = &dh_Ys;
        var dh_p: [4095]u8 = undefined;
        _ = &dh_p;
        var dh_g: [4095]u8 = undefined;
        _ = &dh_g;
        var dh_p_len: c_ulong = @sizeOf([4095]u8);
        _ = &dh_p_len;
        var dh_g_len: c_ulong = @sizeOf([4095]u8);
        _ = &dh_g_len;
        var dh_Ys_len: c_ulong = @sizeOf([4095]u8);
        _ = &dh_Ys_len;
        if (_private_tls_dh_export_pqY(@as([*c]u8, @ptrCast(@alignCast(&dh_p))), &dh_p_len, @as([*c]u8, @ptrCast(@alignCast(&dh_g))), &dh_g_len, @as([*c]u8, @ptrCast(@alignCast(&dh_Ys))), &dh_Ys_len, context.*.dhe) != 0) {
            if (packet != null) {
                free(@as(?*anyopaque, @ptrCast(packet)));
            }
            return null;
        }
        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_ushort, @truncate(dh_p_len)))));
        _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&dh_p))), @as(c_uint, @bitCast(@as(c_uint, @truncate(dh_p_len)))));
        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_ushort, @truncate(dh_g_len)))));
        _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&dh_g))), @as(c_uint, @bitCast(@as(c_uint, @truncate(dh_g_len)))));
        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_ushort, @truncate(dh_Ys_len)))));
        _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&dh_Ys))), @as(c_uint, @bitCast(@as(c_uint, @truncate(dh_Ys_len)))));
    } else if (method == KEA_ec_diffie_hellman) {
        if (!(context.*.curve != null)) {
            context.*.curve = default_curve;
        }
        _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 3))))));
        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(context.*.curve.*.iana)))));
        if (!(context.*.ecc_dhe != null)) {
            tls_init();
            _private_tls_ecc_dhe_create(context);
            var dp: [*c]const ltc_ecc_set_type = &context.*.curve.*.dp;
            _ = &dp;
            if (ecc_make_key_ex(null, find_prng("sprng"), context.*.ecc_dhe, dp) != 0) {
                if (context.*.ecc_dhe != null) {
                    free(@as(?*anyopaque, @ptrCast(context.*.ecc_dhe)));
                }
                context.*.ecc_dhe = null;
                if (packet != null) {
                    free(@as(?*anyopaque, @ptrCast(packet)));
                }
                return null;
            }
        }
        var out: [2048]u8 = undefined;
        _ = &out;
        var out_len: c_ulong = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2048))));
        _ = &out_len;
        if (ecc_ansi_x963_export(context.*.ecc_dhe, @as([*c]u8, @ptrCast(@alignCast(&out))), &out_len) != 0) {
            if (packet != null) {
                free(@as(?*anyopaque, @ptrCast(packet)));
            }
            return null;
        }
        _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(u8, @truncate(out_len)))));
        _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&out))), @as(c_uint, @bitCast(@as(c_uint, @truncate(out_len)))));
    } else {
        if (packet != null) {
            free(@as(?*anyopaque, @ptrCast(packet)));
        }
        return null;
    }
    var params_len: c_uint = packet.*.len -% @as(c_uint, @bitCast(start_len));
    _ = &params_len;
    var message_len: c_uint = (params_len +% @as(c_uint, @bitCast(@as(c_int, 32)))) +% @as(c_uint, @bitCast(@as(c_int, 32)));
    _ = &message_len;
    var message: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, message_len)))))));
    _ = &message;
    if (message != null) {
        var out: [2048]u8 = undefined;
        _ = &out;
        var out_len: c_ulong = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2048))));
        _ = &out_len;
        var hash_algorithm: c_int = undefined;
        _ = &hash_algorithm;
        if ((((@as(c_int, @bitCast(@as(c_uint, context.*.version))) != @as(c_int, 772)) and (@as(c_int, @bitCast(@as(c_uint, context.*.version))) != @as(c_int, 65276))) and (@as(c_int, @bitCast(@as(c_uint, context.*.version))) != @as(c_int, 771))) and (@as(c_int, @bitCast(@as(c_uint, context.*.version))) != @as(c_int, 65277))) {
            hash_algorithm = _md5_sha1;
        } else {
            if ((((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65277))) {
                hash_algorithm = sha256;
            } else {
                hash_algorithm = sha1;
            }
            if (tls_is_ecdsa(context) != 0) {
                if (((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771))) {
                    hash_algorithm = sha512;
                }
                _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(hash_algorithm)))));
                _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(ecdsa)))));
            } else {
                _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(hash_algorithm)))));
                _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(rsa_sign)))));
            }
        }
        _ = memcpy(@as(?*anyopaque, @ptrCast(message)), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.remote_random))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))));
        _ = memcpy(@as(?*anyopaque, @ptrCast(message + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))))), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.local_random))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))));
        _ = memcpy(@as(?*anyopaque, @ptrCast((message + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32)))))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))))), @as(?*const anyopaque, @ptrCast(packet.*.buf + @as(usize, @bitCast(@as(isize, @intCast(start_len)))))), @as(c_ulong, @bitCast(@as(c_ulong, params_len))));
        if (tls_is_ecdsa(context) != 0) {
            if (_private_tls_sign_ecdsa(context, @as(c_uint, @bitCast(hash_algorithm)), message, message_len, @as([*c]u8, @ptrCast(@alignCast(&out))), &out_len) == @as(c_int, 1)) {
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_ushort, @truncate(out_len)))));
                _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&out))), @as(c_uint, @bitCast(@as(c_uint, @truncate(out_len)))));
            }
        } else if (_private_tls_sign_rsa(context, @as(c_uint, @bitCast(hash_algorithm)), message, message_len, @as([*c]u8, @ptrCast(@alignCast(&out))), &out_len) == @as(c_int, 1)) {
            _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_ushort, @truncate(out_len)))));
            _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&out))), @as(c_uint, @bitCast(@as(c_uint, @truncate(out_len)))));
        }
        if (message != null) {
            free(@as(?*anyopaque, @ptrCast(message)));
        }
    }
    if (!(packet.*.broken != 0) and (packet.*.buf != null)) {
        var remaining: c_int = @as(c_int, @bitCast(packet.*.len -% @as(c_uint, @bitCast(start_len))));
        _ = &remaining;
        var payload_pos: c_int = 6;
        _ = &payload_pos;
        if (context.*.dtls != 0) {
            payload_pos = 14;
        }
        (blk: {
            const tmp = payload_pos;
            if (tmp >= 0) break :blk packet.*.buf + @as(usize, @intCast(tmp)) else break :blk packet.*.buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = @as(u8, @bitCast(@as(i8, @truncate(@divTrunc(remaining, @as(c_int, 65536))))));
        remaining = @import("std").zig.c_translation.signedRemainder(remaining, @as(c_int, 65536));
        (blk: {
            const tmp = payload_pos + @as(c_int, 1);
            if (tmp >= 0) break :blk packet.*.buf + @as(usize, @intCast(tmp)) else break :blk packet.*.buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = @as(u8, @bitCast(@as(i8, @truncate(@divTrunc(remaining, @as(c_int, 256))))));
        remaining = @import("std").zig.c_translation.signedRemainder(remaining, @as(c_int, 256));
        (blk: {
            const tmp = payload_pos + @as(c_int, 2);
            if (tmp >= 0) break :blk packet.*.buf + @as(usize, @intCast(tmp)) else break :blk packet.*.buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = @as(u8, @bitCast(@as(i8, @truncate(remaining))));
        if (context.*.dtls != 0) {
            _private_dtls_handshake_copyframesize(packet);
            context.*.dtls_seq +%= 1;
        }
    }
    tls_packet_update(packet);
    if (context.*.dtls_data != null) {
        if (context.*.dtls_data.*.key_exchange != null) {
            if (context.*.dtls_data.*.key_exchange != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.dtls_data.*.key_exchange)));
            }
        }
        context.*.dtls_data.*.key_exchange = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, packet.*.len -% @as(c_uint, @bitCast(packet_offset)))))))));
        if (context.*.dtls_data.*.key_exchange != null) {
            context.*.dtls_data.*.key_exchange_len = packet.*.len -% @as(c_uint, @bitCast(packet_offset));
            _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.dtls_data.*.key_exchange)), @as(?*const anyopaque, @ptrCast(packet.*.buf + @as(usize, @bitCast(@as(isize, @intCast(packet_offset)))))), @as(c_ulong, @bitCast(@as(c_ulong, context.*.dtls_data.*.key_exchange_len))));
        }
    }
    return packet;
}
pub export fn tls_build_hello(arg_context: [*c]struct_TLSContext, arg_tls13_downgrade: c_int) [*c]struct_TLSPacket {
    var context = arg_context;
    _ = &context;
    var tls13_downgrade = arg_tls13_downgrade;
    _ = &tls13_downgrade;
    tls_init();
    if (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) == @as(c_int, 4)) {
        const sha256_helloretryrequest = struct {
            var static: [32]u8 = [32]u8{
                207,
                33,
                173,
                116,
                229,
                154,
                97,
                17,
                190,
                29,
                140,
                2,
                30,
                101,
                184,
                145,
                194,
                162,
                17,
                22,
                122,
                187,
                140,
                94,
                7,
                158,
                9,
                226,
                200,
                168,
                51,
                156,
            };
        };
        _ = &sha256_helloretryrequest;
        _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.local_random))))), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&sha256_helloretryrequest.static))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))));
        var header: [4]u8 = [4]u8{
            254,
            0,
            0,
            0,
        };
        _ = &header;
        var hash: [48]u8 = undefined;
        _ = &hash;
        var hash_len: c_int = _private_tls_done_hash(context, @as([*c]u8, @ptrCast(@alignCast(&hash))));
        _ = &hash_len;
        header[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(i8, @truncate(hash_len))));
        _ = _private_tls_update_hash(context, @as([*c]u8, @ptrCast(@alignCast(&header))), @as(c_uint, @bitCast(@as(c_uint, @truncate(@sizeOf([4]u8))))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
        _ = _private_tls_update_hash(context, @as([*c]u8, @ptrCast(@alignCast(&hash))), @as(c_uint, @bitCast(hash_len)), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
    } else if (!(context.*.is_server != 0) or ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) != @as(c_int, 772)) and (@as(c_int, @bitCast(@as(c_uint, context.*.version))) != @as(c_int, 65276)))) if (!(context.*.dtls != 0) or !(context.*.dtls_data.*.has_random != 0)) {
        if (!(tls_random(@as([*c]u8, @ptrCast(@alignCast(&context.*.local_random))), if (@as(c_int, @bitCast(@as(c_uint, context.*.is_server))) != 0) @as(c_int, 32) else @as(c_int, 32)) != 0)) return null;
        @as([*c]c_uint, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.local_random)))))).* = htonl(@as(c_uint, @bitCast(@as(c_int, @truncate(time(null))))));
        if (context.*.dtls != 0) {
            context.*.dtls_data.*.has_random = 1;
        }
    };
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.is_server))) != 0) and (tls13_downgrade != 0)) {
        if ((tls13_downgrade == @as(c_int, 771)) or (tls13_downgrade == @as(c_int, 65277))) {
            _ = memcpy(@as(?*anyopaque, @ptrCast((@as([*c]u8, @ptrCast(@alignCast(&context.*.local_random))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32)))))) - @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))), @as(?*const anyopaque, @ptrCast("DOWNGRD\x01")), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))));
        } else {
            _ = memcpy(@as(?*anyopaque, @ptrCast((@as([*c]u8, @ptrCast(@alignCast(&context.*.local_random))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32)))))) - @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))), @as(?*const anyopaque, @ptrCast("DOWNGRD\x00")), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))));
        }
    }
    var packet_version: c_ushort = context.*.version;
    _ = &packet_version;
    var version: c_ushort = context.*.version;
    _ = &version;
    if (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) {
        version = @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 771)))));
    } else if (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276)) {
        version = @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 65277)))));
    }
    var packet: [*c]struct_TLSPacket = tls_create_packet(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 22))))), version, @as(c_int, 0));
    _ = &packet;
    if (packet != null) {
        if (context.*.is_server != 0) {
            _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 2))))));
        } else {
            _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))));
        }
        _ = tls_packet_append(packet, null, @as(c_uint, @bitCast(@as(c_int, 3))));
        if (context.*.dtls != 0) {
            _private_dtls_handshake_data(context, packet, @as(c_uint, @bitCast(@as(c_int, 0))));
        }
        var start_len: c_int = @as(c_int, @bitCast(packet.*.len));
        _ = &start_len;
        _ = tls_packet_uint16(packet, version);
        if (context.*.is_server != 0) {
            _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&context.*.local_random))), @as(c_uint, @bitCast(@as(c_int, 32))));
        } else {
            _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&context.*.local_random))), @as(c_uint, @bitCast(@as(c_int, 32))));
        }
        if (!(context.*.dtls != 0) or !(context.*.session_size != 0)) {
            _private_tls_set_session_id(context);
        }
        _ = tls_packet_uint8(packet, context.*.session_size);
        if (context.*.session_size != 0) {
            _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&context.*.session))), @as(c_uint, @bitCast(@as(c_uint, context.*.session_size))));
        }
        var extension_len: c_int = 0;
        _ = &extension_len;
        var alpn_len: c_int = 0;
        _ = &alpn_len;
        var alpn_negotiated_len: c_int = 0;
        _ = &alpn_negotiated_len;
        var i: c_int = undefined;
        _ = &i;
        var shared_key: [2048]u8 = undefined;
        _ = &shared_key;
        var shared_key_len: c_ulong = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2048))));
        _ = &shared_key_len;
        var shared_key_short: c_ushort = 0;
        _ = &shared_key_short;
        var selected_group: c_int = 0;
        _ = &selected_group;
        if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
            if (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) == @as(c_int, 4)) {
                extension_len += @as(c_int, 6);
            } else if (context.*.is_server != 0) {
                if (context.*.curve == @as([*c]const struct_ECCCurveParameters, @ptrCast(@alignCast(&x25519)))) {
                    extension_len += @as(c_int, 8) + @as(c_int, 32);
                    shared_key_short = @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 32)))));
                    if (context.*.finished_key != null) {
                        _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&shared_key))))), @as(?*const anyopaque, @ptrCast(context.*.finished_key)), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))));
                        if (context.*.finished_key != null) {
                            free(@as(?*anyopaque, @ptrCast(context.*.finished_key)));
                        }
                        context.*.finished_key = null;
                    }
                    selected_group = context.*.curve.*.iana;
                    context.*.curve = null;
                } else if (context.*.ecc_dhe != null) {
                    if (ecc_ansi_x963_export(context.*.ecc_dhe, @as([*c]u8, @ptrCast(@alignCast(&shared_key))), &shared_key_len) != 0) {
                        tls_destroy_packet(packet);
                        return tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(internal_error)))));
                    }
                    _private_tls_ecc_dhe_free(context);
                    extension_len += @as(c_int, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))) +% shared_key_len))));
                    shared_key_short = @as(c_ushort, @bitCast(@as(c_ushort, @truncate(shared_key_len))));
                    if (context.*.curve != null) {
                        selected_group = context.*.curve.*.iana;
                    }
                } else if (context.*.dhe != null) {
                    selected_group = context.*.dhe.*.iana;
                    _ = _private_tls_dh_export_Y(@as([*c]u8, @ptrCast(@alignCast(&shared_key))), &shared_key_len, context.*.dhe);
                    _private_tls_dhe_free(context);
                    extension_len += @as(c_int, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))) +% shared_key_len))));
                    shared_key_short = @as(c_ushort, @bitCast(@as(c_ushort, @truncate(shared_key_len))));
                }
            }
            if (context.*.is_server != 0) {
                extension_len += @as(c_int, 6);
            } else {
                extension_len += @as(c_int, 9);
            }
        }
        if ((((@as(c_int, @bitCast(@as(c_uint, context.*.is_server))) != 0) and (context.*.negotiated_alpn != null)) and (@as(c_int, @bitCast(@as(c_uint, context.*.version))) != @as(c_int, 772))) and (@as(c_int, @bitCast(@as(c_uint, context.*.version))) != @as(c_int, 65276))) {
            alpn_negotiated_len = @as(c_int, @bitCast(@as(c_uint, @truncate(strlen(context.*.negotiated_alpn)))));
            alpn_len = alpn_negotiated_len + @as(c_int, 1);
            extension_len += alpn_len + @as(c_int, 6);
        } else if (!(context.*.is_server != 0) and (@as(c_int, @bitCast(@as(c_uint, context.*.alpn_count))) != 0)) {
            {
                i = 0;
                while (i < @as(c_int, @bitCast(@as(c_uint, context.*.alpn_count)))) : (i += 1) {
                    if ((blk: {
                        const tmp = i;
                        if (tmp >= 0) break :blk context.*.alpn + @as(usize, @intCast(tmp)) else break :blk context.*.alpn - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).* != null) {
                        var len: c_int = @as(c_int, @bitCast(@as(c_uint, @truncate(strlen((blk: {
                            const tmp = i;
                            if (tmp >= 0) break :blk context.*.alpn + @as(usize, @intCast(tmp)) else break :blk context.*.alpn - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                        }).*)))));
                        _ = &len;
                        if (len != 0) {
                            alpn_len += len + @as(c_int, 1);
                        }
                    }
                }
            }
            if (alpn_len != 0) {
                extension_len += alpn_len + @as(c_int, 6);
            }
        }
        if (context.*.is_server != 0) {
            if (!(context.*.cipher != 0)) {
                context.*.cipher = 51;
            }
            _ = tls_packet_uint16(packet, context.*.cipher);
            _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
            if ((((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65277))) {
                if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(extension_len)))));
                } else {
                    if (@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) == @as(c_int, 4)) {
                        extension_len += @as(c_int, 9);
                    }
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 5) + extension_len)))));
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 65281))))));
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 1))))));
                    _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
                }
                if (alpn_len != 0) {
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 16))))));
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(alpn_len + @as(c_int, 2))))));
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(alpn_len)))));
                    _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(alpn_negotiated_len)))));
                    _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(context.*.negotiated_alpn))), @as(c_uint, @bitCast(alpn_negotiated_len)));
                }
                if (@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) == @as(c_int, 4)) {
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 14))))));
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 5))))));
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 2))))));
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 1))))));
                    _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
                }
            }
        } else {
            if (context.*.dtls != 0) {
                _ = tls_packet_uint8(packet, context.*.dtls_cookie_len);
                if (context.*.dtls_cookie_len != 0) {
                    _ = tls_packet_append(packet, context.*.dtls_cookie, @as(c_uint, @bitCast(@as(c_uint, context.*.dtls_cookie_len))));
                }
            }
            if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 9) * @as(c_int, 2))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 4865))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 4866))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 4867))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 49195))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 52393))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 49199))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 52392))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 158))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 52394))))));
            } else if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65277))) {
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 16) * @as(c_int, 2))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 49195))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 52393))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 49187))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 49162))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 49161))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 49199))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 49171))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 49172))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 49191))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 52392))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 158))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 107))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 103))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 57))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 51))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 52394))))));
            } else {
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 5) * @as(c_int, 2))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 49171))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 49172))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 57))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 57))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 51))))));
            }
            _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))));
            _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
            if ((((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65277))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
                if (@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) == @as(c_int, 4)) {
                    extension_len += @as(c_int, 9);
                }
                var sni_len: c_int = 0;
                _ = &sni_len;
                if (context.*.sni != null) {
                    sni_len = @as(c_int, @bitCast(@as(c_uint, @truncate(strlen(context.*.sni)))));
                }
                extension_len += @as(c_int, 12);
                if (sni_len != 0) {
                    extension_len += sni_len + @as(c_int, 9);
                }
                if (!(context.*.is_server != 0) and ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276)))) {
                    extension_len += @as(c_int, 48) + ((@as(c_int, 2) * ((sha512 - sha256) + @as(c_int, 1))) * @as(c_int, 3));
                }
                if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65277))) {
                    extension_len += @as(c_int, 6) + ((@as(c_int, 2) * ((sha512 - sha256) + @as(c_int, 1))) * @as(c_int, 3));
                }
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(extension_len)))));
                if (sni_len != 0) {
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 0))))));
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(sni_len + @as(c_int, 5))))));
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(sni_len + @as(c_int, 3))))));
                    _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(sni_len)))));
                    _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(context.*.sni))), @as(c_uint, @bitCast(sni_len)));
                }
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 10))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 8))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 6))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(secp256r1.iana)))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(secp384r1.iana)))));
                if (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) {
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(x25519.iana)))));
                } else {
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(secp224r1.iana)))));
                }
                if (alpn_len != 0) {
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 16))))));
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(alpn_len + @as(c_int, 2))))));
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(alpn_len)))));
                    {
                        i = 0;
                        while (i < @as(c_int, @bitCast(@as(c_uint, context.*.alpn_count)))) : (i += 1) {
                            if ((blk: {
                                const tmp = i;
                                if (tmp >= 0) break :blk context.*.alpn + @as(usize, @intCast(tmp)) else break :blk context.*.alpn - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                            }).* != null) {
                                var len: c_int = @as(c_int, @bitCast(@as(c_uint, @truncate(strlen((blk: {
                                    const tmp = i;
                                    if (tmp >= 0) break :blk context.*.alpn + @as(usize, @intCast(tmp)) else break :blk context.*.alpn - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                                }).*)))));
                                _ = &len;
                                if (len != 0) {
                                    _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(len)))));
                                    _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast((blk: {
                                        const tmp = i;
                                        if (tmp >= 0) break :blk context.*.alpn + @as(usize, @intCast(tmp)) else break :blk context.*.alpn - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                                    }).*))), @as(c_uint, @bitCast(len)));
                                }
                            }
                        }
                    }
                }
                if (@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) == @as(c_int, 4)) {
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 14))))));
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 5))))));
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 2))))));
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 1))))));
                    _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
                }
            }
        }
        if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
            _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 43))))));
            if (context.*.is_server != 0) {
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 2))))));
                if (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) {
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(if (@as(c_int, @bitCast(@as(c_uint, context.*.tls13_version))) != 0) @as(c_int, @bitCast(@as(c_uint, context.*.tls13_version))) else @as(c_int, 772))))));
                } else {
                    _ = tls_packet_uint16(packet, context.*.version);
                }
            } else {
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 5))))));
                _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 4))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 772))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 32540))))));
            }
            if (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) == @as(c_int, 4)) {
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 51))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 2))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(secp256r1.iana)))));
            }
            if (((@as(c_int, @bitCast(@as(c_uint, shared_key_short))) != 0) and (selected_group != 0)) or !(context.*.is_server != 0)) {
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 51))))));
                if (context.*.is_server != 0) {
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_uint, shared_key_short))) + @as(c_int, 4))))));
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(selected_group)))));
                    _ = tls_packet_uint16(packet, shared_key_short);
                    _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&shared_key))), @as(c_uint, @bitCast(@as(c_uint, shared_key_short))));
                } else {
                    shared_key_short = 32;
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_uint, shared_key_short))) + @as(c_int, 6))))));
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_uint, shared_key_short))) + @as(c_int, 4))))));
                    if (context.*.client_secret != null) {
                        free(@as(?*anyopaque, @ptrCast(context.*.client_secret)));
                    }
                    context.*.client_secret = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32))))))));
                    if (!(context.*.client_secret != null)) {
                        if (packet != null) {
                            free(@as(?*anyopaque, @ptrCast(packet)));
                        }
                        return null;
                    }
                    _ = tls_random(context.*.client_secret, @as(c_int, 32));
                    context.*.client_secret[@as(c_uint, @intCast(@as(c_int, 0)))] &= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 248)))));
                    context.*.client_secret[@as(c_uint, @intCast(@as(c_int, 31)))] &= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 127)))));
                    context.*.client_secret[@as(c_uint, @intCast(@as(c_int, 31)))] |= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 64)))));
                    var key: curve25519_key = undefined;
                    _ = &key;
                    _ = x25519_import_raw(context.*.client_secret, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))), PK_PRIVATE, &key);
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(x25519.iana)))));
                    _ = tls_packet_uint16(packet, shared_key_short);
                    _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&key.@"pub"))), @as(c_uint, @bitCast(@as(c_uint, shared_key_short))));
                }
            }
        }
        if (((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
            if (!(context.*.is_server != 0)) {
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 13))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 2) + ((@as(c_int, 2) * ((sha512 - sha256) + @as(c_int, 1))) * @as(c_int, 3)))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate((@as(c_int, 2) * ((sha512 - sha256) + @as(c_int, 1))) * @as(c_int, 3))))));
                {
                    var hash: TLSHashAlgorithm = @as(c_uint, @bitCast(sha256));
                    _ = &hash;
                    while (!(hash > @as(c_uint, @bitCast(sha512)))) : (hash = @as(c_uint, @bitCast(@as(c_int, @bitCast(hash)) + @as(c_int, 1)))) {
                        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate((@as(c_int, @bitCast(@as(c_uint, @as(u16, @bitCast(@as(c_ushort, @truncate(hash))))))) << @intCast(8)) | ecdsa)))));
                        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate((@as(c_int, @bitCast(@as(c_uint, @as(u16, @bitCast(@as(c_ushort, @truncate(hash))))))) << @intCast(8)) | rsa_pkcs1)))));
                        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate((rsa_pss << @intCast(8)) | @as(c_int, @bitCast(@as(c_uint, @as(u16, @bitCast(@as(c_ushort, @truncate(hash))))))))))));
                    }
                }
            }
        }
        if (!(packet.*.broken != 0) and (packet.*.buf != null)) {
            var remaining: c_int = @as(c_int, @bitCast(packet.*.len -% @as(c_uint, @bitCast(start_len))));
            _ = &remaining;
            var payload_pos: c_int = 6;
            _ = &payload_pos;
            if (context.*.dtls != 0) {
                payload_pos = 14;
            }
            (blk: {
                const tmp = payload_pos;
                if (tmp >= 0) break :blk packet.*.buf + @as(usize, @intCast(tmp)) else break :blk packet.*.buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = @as(u8, @bitCast(@as(i8, @truncate(@divTrunc(remaining, @as(c_int, 65536))))));
            remaining = @import("std").zig.c_translation.signedRemainder(remaining, @as(c_int, 65536));
            (blk: {
                const tmp = payload_pos + @as(c_int, 1);
                if (tmp >= 0) break :blk packet.*.buf + @as(usize, @intCast(tmp)) else break :blk packet.*.buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = @as(u8, @bitCast(@as(i8, @truncate(@divTrunc(remaining, @as(c_int, 256))))));
            remaining = @import("std").zig.c_translation.signedRemainder(remaining, @as(c_int, 256));
            (blk: {
                const tmp = payload_pos + @as(c_int, 2);
                if (tmp >= 0) break :blk packet.*.buf + @as(usize, @intCast(tmp)) else break :blk packet.*.buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = @as(u8, @bitCast(@as(i8, @truncate(remaining))));
            if (context.*.dtls != 0) {
                _private_dtls_handshake_copyframesize(packet);
                context.*.dtls_seq +%= 1;
            }
        }
        tls_packet_update(packet);
    }
    return packet;
}
pub export fn tls_certificate_request(arg_context: [*c]struct_TLSContext) [*c]struct_TLSPacket {
    var context = arg_context;
    _ = &context;
    if (!(context != null) or !(context.*.is_server != 0)) return null;
    var packet_version: c_ushort = context.*.version;
    _ = &packet_version;
    var packet: [*c]struct_TLSPacket = tls_create_packet(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 22))))), packet_version, @as(c_int, 0));
    _ = &packet;
    if (packet != null) {
        _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 13))))));
        _ = tls_packet_append(packet, null, @as(c_uint, @bitCast(@as(c_int, 3))));
        if (context.*.dtls != 0) {
            _private_dtls_handshake_data(context, packet, @as(c_uint, @bitCast(@as(c_int, 0))));
        }
        var start_len: c_int = @as(c_int, @bitCast(packet.*.len));
        _ = &start_len;
        if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
            _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
            _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 18))))));
            _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 13))))));
            _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 14))))));
            _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 12))))));
            _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 1027))))));
            _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 1283))))));
            _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 1540))))));
            _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 2052))))));
            _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 2053))))));
            _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 2054))))));
        } else {
            _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 2))))));
            _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(rsa_sign)))));
            _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(ecdsa_sign)))));
            if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65277))) {
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 14))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 1027))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 1283))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 1025))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 513))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 1281))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 1537))))));
                _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 257))))));
            }
            _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 0))))));
        }
        if (!(packet.*.broken != 0)) {
            var remaining: c_int = @as(c_int, @bitCast(packet.*.len -% @as(c_uint, @bitCast(start_len))));
            _ = &remaining;
            var payload_pos: c_int = 6;
            _ = &payload_pos;
            if (context.*.dtls != 0) {
                payload_pos = 14;
            }
            (blk: {
                const tmp = payload_pos;
                if (tmp >= 0) break :blk packet.*.buf + @as(usize, @intCast(tmp)) else break :blk packet.*.buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = @as(u8, @bitCast(@as(i8, @truncate(@divTrunc(remaining, @as(c_int, 65536))))));
            remaining = @import("std").zig.c_translation.signedRemainder(remaining, @as(c_int, 65536));
            (blk: {
                const tmp = payload_pos + @as(c_int, 1);
                if (tmp >= 0) break :blk packet.*.buf + @as(usize, @intCast(tmp)) else break :blk packet.*.buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = @as(u8, @bitCast(@as(i8, @truncate(@divTrunc(remaining, @as(c_int, 256))))));
            remaining = @import("std").zig.c_translation.signedRemainder(remaining, @as(c_int, 256));
            (blk: {
                const tmp = payload_pos + @as(c_int, 2);
                if (tmp >= 0) break :blk packet.*.buf + @as(usize, @intCast(tmp)) else break :blk packet.*.buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = @as(u8, @bitCast(@as(i8, @truncate(remaining))));
            if (context.*.dtls != 0) {
                _private_dtls_handshake_copyframesize(packet);
                context.*.dtls_seq +%= 1;
            }
        }
        tls_packet_update(packet);
    }
    return packet;
}
pub export fn tls_build_verify_request(arg_context: [*c]struct_TLSContext) [*c]struct_TLSPacket {
    var context = arg_context;
    _ = &context;
    if (!(context.*.is_server != 0) or !(context.*.dtls != 0)) return null;
    if (!(context.*.dtls_cookie != null) or !(context.*.dtls_cookie_len != 0)) {
        if (!(_private_dtls_build_cookie(context) != 0)) return null;
    }
    var packet_version: c_ushort = context.*.version;
    _ = &packet_version;
    var packet: [*c]struct_TLSPacket = tls_create_packet(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 22))))), packet_version, @as(c_int, 0));
    _ = &packet;
    if (packet != null) {
        _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 3))))));
        _ = tls_packet_uint24(packet, @as(c_uint, @bitCast(@as(c_int, @bitCast(@as(c_uint, context.*.dtls_cookie_len))) + @as(c_int, 3))));
        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 0))))));
        _ = tls_packet_uint24(packet, @as(c_uint, @bitCast(@as(c_int, 0))));
        _ = tls_packet_uint24(packet, @as(c_uint, @bitCast(@as(c_int, @bitCast(@as(c_uint, context.*.dtls_cookie_len))) + @as(c_int, 3))));
        _ = tls_packet_uint16(packet, context.*.version);
        _ = tls_packet_uint8(packet, context.*.dtls_cookie_len);
        _ = tls_packet_append(packet, context.*.dtls_cookie, @as(c_uint, @bitCast(@as(c_uint, context.*.dtls_cookie_len))));
        tls_packet_update(packet);
    }
    return packet;
}
pub export fn tls_parse_hello(arg_context: [*c]struct_TLSContext, arg_buf: [*c]const u8, arg_buf_len: c_int, arg_write_packets: [*c]c_uint, arg_dtls_verified: [*c]c_uint) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var write_packets = arg_write_packets;
    _ = &write_packets;
    var dtls_verified = arg_dtls_verified;
    _ = &dtls_verified;
    write_packets.* = 0;
    dtls_verified.* = 0;
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) != @as(c_int, 0)) and (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) != @as(c_int, 4))) {
        if (context.*.dtls != 0) {
            return 1;
        }
        return -@as(c_int, 6);
    }
    var res: c_int = 0;
    _ = &res;
    var downgraded: c_int = 0;
    _ = &downgraded;
    var hello_min_size: c_int = if (@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) != 0) @as(c_int, 41) + @as(c_int, 8) else @as(c_int, 41);
    _ = &hello_min_size;
    if ((hello_min_size > buf_len) or (buf_len < @as(c_int, 0))) {
        return 0;
    }
    var bytes_to_follow: c_uint = @as(c_uint, @bitCast(((@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 0)))]))) * @as(c_int, 65536)) + (@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 1)))]))) * @as(c_int, 256))) + @as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 2)))])))));
    _ = &bytes_to_follow;
    res += @as(c_int, 3);
    if (context.*.dtls != 0) {
        var dtls_check: c_int = _private_dtls_check_packet(context, buf, buf_len);
        _ = &dtls_check;
        if (dtls_check < @as(c_int, 0)) return dtls_check;
        res += @as(c_int, 8);
    }
    if ((@as(c_int, @bitCast(bytes_to_follow)) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
        return 0;
    }
    if ((@as(c_int, 2) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
        return 0;
    }
    var version: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
        const tmp = res;
        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*))).*);
    _ = &version;
    var cipher: c_ushort = 0;
    _ = &cipher;
    res += @as(c_int, 2);
    if (((((((@as(c_int, @bitCast(@as(c_uint, version))) != @as(c_int, 772)) and (@as(c_int, @bitCast(@as(c_uint, version))) != @as(c_int, 771))) and (@as(c_int, @bitCast(@as(c_uint, version))) != @as(c_int, 770))) and (@as(c_int, @bitCast(@as(c_uint, version))) != @as(c_int, 769))) and (@as(c_int, @bitCast(@as(c_uint, version))) != @as(c_int, 65276))) and (@as(c_int, @bitCast(@as(c_uint, version))) != @as(c_int, 65277))) and (@as(c_int, @bitCast(@as(c_uint, version))) != @as(c_int, 65279))) {
        if ((@as(c_int, @bitCast(@as(c_uint, version))) == @as(c_int, 768)) and (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) == @as(c_int, 0))) {
            version = @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 771)))));
        } else {
            return -@as(c_int, 4);
        }
    }
    if (context.*.dtls != 0) {
        if (@as(c_int, @bitCast(@as(c_uint, context.*.version))) < @as(c_int, @bitCast(@as(c_uint, version)))) {
            downgraded = 1;
        }
    } else {
        if (@as(c_int, @bitCast(@as(c_uint, context.*.version))) > @as(c_int, @bitCast(@as(c_uint, version)))) {
            downgraded = 1;
        }
    }
    if (downgraded != 0) {
        context.*.version = version;
        if (!(context.*.is_server != 0)) {
            _ = _private_tls_change_hash_type(context);
        }
    }
    _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.remote_random))))), @as(?*const anyopaque, @ptrCast(&(blk: {
        const tmp = res;
        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*)), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))));
    res += @as(c_int, 32);
    var session_len: u8 = (blk: {
        const tmp = blk_1: {
            const ref = &res;
            const tmp_2 = ref.*;
            ref.* += 1;
            break :blk_1 tmp_2;
        };
        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    _ = &session_len;
    if ((@as(c_int, @bitCast(@as(c_uint, session_len))) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
        return 0;
    }
    if ((@as(c_int, @bitCast(@as(c_uint, session_len))) != 0) and (@as(c_int, @bitCast(@as(c_uint, session_len))) <= @as(c_int, 32))) {
        _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.session))))), @as(?*const anyopaque, @ptrCast(&(blk: {
            const tmp = res;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*)), @as(c_ulong, @bitCast(@as(c_ulong, session_len))));
        context.*.session_size = session_len;
    } else if (!(context.*.dtls != 0)) {
        context.*.session_size = 0;
    }
    res += @as(c_int, @bitCast(@as(c_uint, session_len)));
    var cipher_buffer: [*c]const u8 = null;
    _ = &cipher_buffer;
    var cipher_len: c_ushort = 0;
    _ = &cipher_len;
    var scsv_set: c_int = 0;
    _ = &scsv_set;
    if (context.*.is_server != 0) {
        if (context.*.dtls != 0) {
            if ((@as(c_int, 1) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
                return 0;
            }
            var tls_cookie_len: u8 = (blk: {
                const tmp = blk_1: {
                    const ref = &res;
                    const tmp_2 = ref.*;
                    ref.* += 1;
                    break :blk_1 tmp_2;
                };
                if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
            _ = &tls_cookie_len;
            if (tls_cookie_len != 0) {
                if ((@as(c_int, @bitCast(@as(c_uint, tls_cookie_len))) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
                    return 0;
                }
                if (!(context.*.dtls_cookie_len != 0) or !(context.*.dtls_cookie != null)) {
                    _ = _private_dtls_build_cookie(context);
                }
                if ((@as(c_int, @bitCast(@as(c_uint, context.*.dtls_cookie_len))) != @as(c_int, @bitCast(@as(c_uint, tls_cookie_len)))) or !(context.*.dtls_cookie != null)) {
                    dtls_verified.* = 2;
                    return -@as(c_int, 2);
                }
                if (memcmp(@as(?*const anyopaque, @ptrCast(context.*.dtls_cookie)), @as(?*const anyopaque, @ptrCast(&(blk: {
                    const tmp = res;
                    if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*)), @as(c_ulong, @bitCast(@as(c_ulong, tls_cookie_len)))) != 0) {
                    dtls_verified.* = 3;
                    return -@as(c_int, 2);
                }
                context.*.dtls_seq +%= 1;
                dtls_verified.* = 1;
                res += @as(c_int, @bitCast(@as(c_uint, tls_cookie_len)));
            } else {
                write_packets.* = 2;
                return buf_len;
            }
        }
        if ((@as(c_int, 2) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
            return 0;
        }
        cipher_len = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
            const tmp = res;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).*);
        res += @as(c_int, 2);
        if ((@as(c_int, @bitCast(@as(c_uint, cipher_len))) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
            return 0;
        }
        if ((@as(c_int, @bitCast(@as(c_uint, cipher_len))) & @as(c_int, 1)) != 0) return -@as(c_int, 2);
        cipher_buffer = &(blk: {
            const tmp = res;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*;
        res += @as(c_int, @bitCast(@as(c_uint, cipher_len)));
        if ((@as(c_int, 1) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
            return 0;
        }
        var compression_list_size: u8 = (blk: {
            const tmp = blk_1: {
                const ref = &res;
                const tmp_2 = ref.*;
                ref.* += 1;
                break :blk_1 tmp_2;
            };
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*;
        _ = &compression_list_size;
        if ((@as(c_int, @bitCast(@as(c_uint, compression_list_size))) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
            return 0;
        }
        res += @as(c_int, @bitCast(@as(c_uint, compression_list_size)));
    } else {
        if ((@as(c_int, 2) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
            return 0;
        }
        cipher = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
            const tmp = res;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).*);
        res += @as(c_int, 2);
        context.*.cipher = cipher;
        if ((@as(c_int, 1) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
            return 0;
        }
        var compression: u8 = (blk: {
            const tmp = blk_1: {
                const ref = &res;
                const tmp_2 = ref.*;
                ref.* += 1;
                break :blk_1 tmp_2;
            };
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*;
        _ = &compression;
        if (@as(c_int, @bitCast(@as(c_uint, compression))) != @as(c_int, 0)) {
            return -@as(c_int, 8);
        }
    }
    if (res > @as(c_int, 0)) {
        if (context.*.is_server != 0) {
            write_packets.* = 2;
        }
        if (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) != @as(c_int, 4)) {
            context.*.connection_status = 1;
        }
    }
    if (res > @as(c_int, 2)) {
        res += @as(c_int, 2);
    }
    var key_share: [*c]const u8 = null;
    _ = &key_share;
    var key_size: c_ushort = 0;
    _ = &key_size;
    while ((buf_len - res) >= @as(c_int, 4)) {
        var extension_type: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
            const tmp = res;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).*);
        _ = &extension_type;
        res += @as(c_int, 2);
        var extension_len: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
            const tmp = res;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).*);
        _ = &extension_len;
        res += @as(c_int, 2);
        if ((@as(c_int, @bitCast(@as(c_uint, extension_len))) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
            return 0;
        }
        if (@as(c_int, @bitCast(@as(c_uint, extension_type))) == @as(c_int, 0)) {
            var sni_host_len: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
                const tmp = res + @as(c_int, 3);
                if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))).*);
            _ = &sni_host_len;
            if ((@as(c_int, @bitCast(@as(c_uint, sni_host_len))) > ((buf_len - res) - @as(c_int, 5))) or (((buf_len - res) - @as(c_int, 5)) < @as(c_int, 0))) {
                return 0;
            }
            if (sni_host_len != 0) {
                if (context.*.sni != null) {
                    free(@as(?*anyopaque, @ptrCast(context.*.sni)));
                }
                context.*.sni = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, sni_host_len))) + @as(c_int, 1))))))));
                if (context.*.sni != null) {
                    _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.sni)), @as(?*const anyopaque, @ptrCast(&(blk: {
                        const tmp = res + @as(c_int, 5);
                        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).*)), @as(c_ulong, @bitCast(@as(c_ulong, sni_host_len))));
                    context.*.sni[sni_host_len] = 0;
                }
            }
        } else if (@as(c_int, @bitCast(@as(c_uint, extension_type))) == @as(c_int, 10)) {
            if ((buf_len - res) > @as(c_int, 2)) {
                var group_len: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
                    const tmp = res;
                    if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*))).*);
                _ = &group_len;
                if ((buf_len - res) >= (@as(c_int, @bitCast(@as(c_uint, group_len))) + @as(c_int, 2))) {
                    var i: c_int = undefined;
                    _ = &i;
                    var selected: c_int = 0;
                    _ = &selected;
                    {
                        i = 0;
                        while (i < @as(c_int, @bitCast(@as(c_uint, group_len)))) : (i += @as(c_int, 2)) {
                            var iana_n: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
                                const tmp = (res + @as(c_int, 2)) + i;
                                if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                            }).*))).*);
                            _ = &iana_n;
                            while (true) {
                                switch (@as(c_int, @bitCast(@as(c_uint, iana_n)))) {
                                    @as(c_int, 23) => {
                                        context.*.curve = &secp256r1;
                                        selected = 1;
                                        break;
                                    },
                                    @as(c_int, 24) => {
                                        context.*.curve = &secp384r1;
                                        selected = 1;
                                        break;
                                    },
                                    else => {},
                                }
                                break;
                            }
                            if (selected != 0) {
                                break;
                            }
                        }
                    }
                }
            }
        } else if (((@as(c_int, @bitCast(@as(c_uint, extension_type))) == @as(c_int, 16)) and (context.*.alpn != null)) and (@as(c_int, @bitCast(@as(c_uint, context.*.alpn_count))) != 0)) {
            if ((buf_len - res) > @as(c_int, 2)) {
                var alpn_len: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
                    const tmp = res;
                    if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*))).*);
                _ = &alpn_len;
                if ((@as(c_int, @bitCast(@as(c_uint, alpn_len))) != 0) and (@as(c_int, @bitCast(@as(c_uint, alpn_len))) <= (@as(c_int, @bitCast(@as(c_uint, extension_len))) - @as(c_int, 2)))) {
                    var alpn: [*c]const u8 = &(blk: {
                        const tmp = res + @as(c_int, 2);
                        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).*;
                    _ = &alpn;
                    var alpn_pos: c_int = 0;
                    _ = &alpn_pos;
                    while (alpn_pos < @as(c_int, @bitCast(@as(c_uint, alpn_len)))) {
                        var alpn_size: u8 = (blk: {
                            const tmp = blk_1: {
                                const ref = &alpn_pos;
                                const tmp_2 = ref.*;
                                ref.* += 1;
                                break :blk_1 tmp_2;
                            };
                            if (tmp >= 0) break :blk alpn + @as(usize, @intCast(tmp)) else break :blk alpn - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                        }).*;
                        _ = &alpn_size;
                        if ((@as(c_int, @bitCast(@as(c_uint, alpn_size))) + alpn_pos) >= @as(c_int, @bitCast(@as(c_uint, extension_len)))) break;
                        if ((@as(c_int, @bitCast(@as(c_uint, alpn_size))) != 0) and (tls_alpn_contains(context, @as([*c]const u8, @ptrCast(@alignCast(&(blk: {
                            const tmp = alpn_pos;
                            if (tmp >= 0) break :blk alpn + @as(usize, @intCast(tmp)) else break :blk alpn - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                        }).*))), alpn_size) != 0)) {
                            if (context.*.negotiated_alpn != null) {
                                free(@as(?*anyopaque, @ptrCast(context.*.negotiated_alpn)));
                            }
                            context.*.negotiated_alpn = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, alpn_size))) + @as(c_int, 1))))))));
                            if (context.*.negotiated_alpn != null) {
                                _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.negotiated_alpn)), @as(?*const anyopaque, @ptrCast(&(blk: {
                                    const tmp = alpn_pos;
                                    if (tmp >= 0) break :blk alpn + @as(usize, @intCast(tmp)) else break :blk alpn - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                                }).*)), @as(c_ulong, @bitCast(@as(c_ulong, alpn_size))));
                                context.*.negotiated_alpn[alpn_size] = 0;
                            }
                            break;
                        }
                        alpn_pos += @as(c_int, @bitCast(@as(c_uint, alpn_size)));
                        if (!(context.*.is_server != 0)) break;
                    }
                }
            }
        } else if (@as(c_int, @bitCast(@as(c_uint, extension_type))) == @as(c_int, 13)) {} else if (@as(c_int, @bitCast(@as(c_uint, extension_type))) == @as(c_int, 11)) {} else if ((@as(c_int, @bitCast(@as(c_uint, extension_type))) == @as(c_int, 14)) and (@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) != 0)) {
            context.*.dtls = 4;
        } else if ((@as(c_int, @bitCast(@as(c_uint, extension_type))) == @as(c_int, 23)) and (@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) != 0)) {} else if (@as(c_int, @bitCast(@as(c_uint, extension_type))) == @as(c_int, 43)) {
            if ((@as(c_int, @bitCast(@as(c_uint, context.*.is_server))) != 0) and (@as(c_int, @bitCast(@as(c_uint, (blk: {
                const tmp = res;
                if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))) == (@as(c_int, @bitCast(@as(c_uint, extension_len))) - @as(c_int, 1)))) {
                if (@as(c_int, @bitCast(@as(c_uint, extension_len))) > @as(c_int, 2)) {
                    var i: c_int = undefined;
                    _ = &i;
                    var limit: c_int = @as(c_int, @bitCast(@as(c_uint, (blk: {
                        const tmp = res;
                        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).*)));
                    _ = &limit;
                    if (limit == (@as(c_int, @bitCast(@as(c_uint, extension_len))) - @as(c_int, 1))) {
                        {
                            i = 1;
                            while (i < limit) : (i += @as(c_int, 2)) {
                                if ((@as(c_int, @bitCast(@as(c_uint, ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
                                    const tmp = res + i;
                                    if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                                }).*))).*)))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
                                    const tmp = res + i;
                                    if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                                }).*))).*)))) == @as(c_int, 32540))) {
                                    context.*.version = @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 772)))));
                                    context.*.tls13_version = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
                                        const tmp = res + i;
                                        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                                    }).*))).*);
                                    break;
                                }
                            }
                        }
                    }
                }
            } else if (!(context.*.is_server != 0) and (@as(c_int, @bitCast(@as(c_uint, extension_len))) == @as(c_int, 2))) {
                if ((@as(c_int, @bitCast(@as(c_uint, ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
                    const tmp = res;
                    if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*))).*)))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
                    const tmp = res;
                    if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*))).*)))) == @as(c_int, 32540))) {
                    context.*.version = @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 772)))));
                    context.*.tls13_version = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
                        const tmp = res;
                        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).*))).*);
                }
            }
        } else if (@as(c_int, @bitCast(@as(c_uint, extension_type))) == @as(c_int, 42)) {} else if (@as(c_int, @bitCast(@as(c_uint, extension_type))) == @as(c_int, 41)) {} else if (@as(c_int, @bitCast(@as(c_uint, extension_type))) == @as(c_int, 51)) {
            if (context.*.is_server != 0) {
                key_size = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
                    const tmp = res;
                    if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*))).*);
                if ((@as(c_int, @bitCast(@as(c_uint, context.*.is_server))) != 0) and (@as(c_int, @bitCast(@as(c_uint, key_size))) > (@as(c_int, @bitCast(@as(c_uint, extension_len))) - @as(c_int, 2)))) {
                    return -@as(c_int, 2);
                }
            } else {
                key_size = extension_len;
            }
            if (context.*.is_server != 0) {
                key_share = &(blk: {
                    const tmp = res + @as(c_int, 2);
                    if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*;
            } else {
                key_share = &(blk: {
                    const tmp = res;
                    if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*;
            }
        } else if (@as(c_int, @bitCast(@as(c_uint, extension_type))) == @as(c_int, 13)) {} else if (@as(c_int, @bitCast(@as(c_uint, extension_type))) == @as(c_int, 45)) {}
        res += @as(c_int, @bitCast(@as(c_uint, extension_len)));
    }
    if (buf_len != res) return 0;
    if (((@as(c_int, @bitCast(@as(c_uint, context.*.is_server))) != 0) and (cipher_buffer != null)) and (@as(c_int, @bitCast(@as(c_uint, cipher_len))) != 0)) {
        var ret_cipher: c_int = tls_choose_cipher(context, cipher_buffer, @as(c_int, @bitCast(@as(c_uint, cipher_len))), &scsv_set);
        _ = &ret_cipher;
        if (ret_cipher < @as(c_int, 0)) {
            return ret_cipher;
        }
        if ((downgraded != 0) and (scsv_set != 0)) {
            _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(inappropriate_fallback))))));
            context.*.critical_error = 1;
            return -@as(c_int, 4);
        }
        context.*.cipher = @as(c_ushort, @bitCast(@as(c_short, @truncate(ret_cipher))));
    }
    if (!(context.*.is_server != 0)) {
        if (!(tls_cipher_supported(context, cipher) != 0)) {
            context.*.cipher = 0;
            return -@as(c_int, 5);
        }
    }
    if (((key_share != null) and (@as(c_int, @bitCast(@as(c_uint, key_size))) != 0)) and ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276)))) {
        var key_share_err: c_int = _private_tls_parse_key_share(context, key_share, @as(c_int, @bitCast(@as(c_uint, key_size))));
        _ = &key_share_err;
        if (key_share_err != 0) {
            if (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) != @as(c_int, 4)) {
                write_packets.* = 5;
                context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 1)))] = 0;
                context.*.connection_status = 4;
                return res;
            } else return key_share_err;
        }
        if (context.*.is_server != 0) {
            context.*.connection_status = 3;
        } else {
            context.*.connection_status = 2;
        }
    }
    return res;
}
pub export fn tls_parse_certificate(arg_context: [*c]struct_TLSContext, arg_buf: [*c]const u8, arg_buf_len: c_int, arg_is_server: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var is_server = arg_is_server;
    _ = &is_server;
    var res: c_int = 0;
    _ = &res;
    if ((@as(c_int, 3) > buf_len) or (buf_len < @as(c_int, 0))) {
        return 0;
    }
    var size_of_all_certificates: c_uint = @as(c_uint, @bitCast(((@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 0)))]))) * @as(c_int, 65536)) + (@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 1)))]))) * @as(c_int, 256))) + @as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 2)))])))));
    _ = &size_of_all_certificates;
    if (size_of_all_certificates <= @as(c_uint, @bitCast(@as(c_int, 4)))) return @as(c_int, @bitCast(@as(c_uint, @bitCast(@as(c_int, 3))) +% size_of_all_certificates));
    res += @as(c_int, 3);
    if (context.*.dtls != 0) {
        var dtls_check: c_int = _private_dtls_check_packet(context, buf, buf_len);
        _ = &dtls_check;
        if (dtls_check < @as(c_int, 0)) return dtls_check;
        res += @as(c_int, 8);
    }
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
        var context_size: c_int = @as(c_int, @bitCast(@as(c_uint, (blk: {
            const tmp = res;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*)));
        _ = &context_size;
        res += 1;
        if (context_size != 0) {
            res += context_size;
        }
        size_of_all_certificates -%= 1;
    }
    if ((@as(c_int, @bitCast(size_of_all_certificates)) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
        return 0;
    }
    var size: c_int = @as(c_int, @bitCast(size_of_all_certificates));
    _ = &size;
    var idx: c_int = 0;
    _ = &idx;
    var valid_certificate: c_int = 0;
    _ = &valid_certificate;
    while (size > @as(c_int, 0)) {
        idx += 1;
        if ((@as(c_int, 3) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
            return 0;
        }
        var certificate_size: c_uint = @as(c_uint, @bitCast(((@as(c_int, @bitCast(@as(c_uint, (blk: {
            const tmp = res;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))) * @as(c_int, 65536)) + (@as(c_int, @bitCast(@as(c_uint, (blk: {
            const tmp = res + @as(c_int, 1);
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))) * @as(c_int, 256))) + @as(c_int, @bitCast(@as(c_uint, (blk: {
            const tmp = res + @as(c_int, 2);
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*)))));
        _ = &certificate_size;
        res += @as(c_int, 3);
        if ((@as(c_int, @bitCast(certificate_size)) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
            return 0;
        }
        var certificates_in_chain: c_int = 0;
        _ = &certificates_in_chain;
        var res2: c_int = res;
        _ = &res2;
        var remaining: c_uint = certificate_size;
        _ = &remaining;
        while (true) {
            if ((res2 > buf_len) or (buf_len < @as(c_int, 0))) {
                return 0;
            }
            if (remaining <= @as(c_uint, @bitCast(@as(c_int, 3)))) break;
            certificates_in_chain += 1;
            var certificate_size2: c_uint = @as(c_uint, @bitCast(((@as(c_int, @bitCast(@as(c_uint, (blk: {
                const tmp = res2;
                if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))) * @as(c_int, 65536)) + (@as(c_int, @bitCast(@as(c_uint, (blk: {
                const tmp = res2 + @as(c_int, 1);
                if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))) * @as(c_int, 256))) + @as(c_int, @bitCast(@as(c_uint, (blk: {
                const tmp = res2 + @as(c_int, 2);
                if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*)))));
            _ = &certificate_size2;
            res2 += @as(c_int, 3);
            remaining -%= @as(c_uint, @bitCast(@as(c_int, 3)));
            if (certificate_size2 > remaining) {
                break;
            }
            remaining -%= certificate_size2;
            var cert: [*c]struct_TLSCertificate = asn1_parse(context, &(blk: {
                const tmp = res2;
                if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*, certificate_size2, is_server);
            _ = &cert;
            if (cert != null) {
                if (certificate_size2 != 0) {
                    cert.*.bytes = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, certificate_size2)))))));
                    if (cert.*.bytes != null) {
                        cert.*.len = certificate_size2;
                        _ = memcpy(@as(?*anyopaque, @ptrCast(cert.*.bytes)), @as(?*const anyopaque, @ptrCast(&(blk: {
                            const tmp = res2;
                            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                        }).*)), @as(c_ulong, @bitCast(@as(c_ulong, certificate_size2))));
                    }
                }
                if ((context.*.dtls_data != null) and (context.*.dtls_data.*.remote_fingerprint != null)) {
                    var hash: [32]u8 = undefined;
                    _ = &hash;
                    var state: hash_state = undefined;
                    _ = &state;
                    _ = sha256_init(&state);
                    _ = sha256_process(&state, cert.*.bytes, @as(c_ulong, @bitCast(@as(c_ulong, cert.*.len))));
                    _ = sha256_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                    var i: c_int = undefined;
                    _ = &i;
                    var buffer_data: [100]u8 = undefined;
                    _ = &buffer_data;
                    var buffer: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(&buffer_data)));
                    _ = &buffer;
                    var buf_len_: c_int = @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([100]u8)))));
                    _ = &buf_len_;
                    buffer[@as(c_uint, @intCast(@as(c_int, 0)))] = 0;
                    {
                        i = 0;
                        while (i < @as(c_int, 32)) : (i += 1) {
                            if (buf_len_ <= @as(c_int, 1)) break;
                            if (i != 0) {
                                _ = snprintf(buffer, @as(c_ulong, @bitCast(@as(c_long, buf_len_))), ":");
                                buffer += 1;
                                buf_len_ -= 1;
                            }
                            if (buf_len_ <= @as(c_int, 2)) break;
                            _ = snprintf(buffer, @as(c_ulong, @bitCast(@as(c_long, buf_len_))), "%02X", @as(c_uint, @bitCast(@as(c_uint, hash[@as(c_uint, @intCast(i))]))));
                            buffer += @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 2)))));
                            buf_len -= @as(c_int, 2);
                        }
                    }
                    if (strcmp(@as([*c]u8, @ptrCast(@alignCast(&buffer_data))), context.*.dtls_data.*.remote_fingerprint) != 0) {
                        return -@as(c_int, 15);
                    }
                }
                if (is_server != 0) {
                    valid_certificate = 1;
                    context.*.client_certificates = @as([*c][*c]struct_TLSCertificate, @ptrCast(@alignCast(realloc(@as(?*anyopaque, @ptrCast(context.*.client_certificates)), @as(c_ulong, @bitCast(@as(c_ulong, context.*.client_certificates_count +% @as(c_uint, @bitCast(@as(c_int, 1)))))) *% @sizeOf([*c]struct_TLSCertificate)))));
                    context.*.client_certificates[context.*.client_certificates_count] = cert;
                    context.*.client_certificates_count +%= 1;
                } else {
                    context.*.certificates = @as([*c][*c]struct_TLSCertificate, @ptrCast(@alignCast(realloc(@as(?*anyopaque, @ptrCast(context.*.certificates)), @as(c_ulong, @bitCast(@as(c_ulong, context.*.certificates_count +% @as(c_uint, @bitCast(@as(c_int, 1)))))) *% @sizeOf([*c]struct_TLSCertificate)))));
                    context.*.certificates[context.*.certificates_count] = cert;
                    context.*.certificates_count +%= 1;
                    if ((cert.*.pk != null) or (cert.*.priv != null)) {
                        valid_certificate = 1;
                    } else if (!(context.*.is_server != 0)) {
                        valid_certificate = 1;
                    }
                }
            }
            res2 += @as(c_int, @bitCast(certificate_size2));
            if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
                if (remaining >= @as(c_uint, @bitCast(@as(c_int, 2)))) {
                    remaining -%= @as(c_uint, @bitCast(@as(c_int, 2)));
                    var size_: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
                        const tmp = res2;
                        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).*))).*);
                    _ = &size_;
                    if ((@as(c_int, @bitCast(@as(c_uint, size_))) != 0) and (@as(c_uint, @bitCast(@as(c_uint, size_))) <= remaining)) {
                        res2 += @as(c_int, @bitCast(@as(c_uint, size_)));
                        remaining -%= @as(c_uint, @bitCast(@as(c_uint, size_)));
                    }
                    res2 += @as(c_int, 2);
                }
            }
            if (!(remaining > @as(c_uint, @bitCast(@as(c_int, 0))))) break;
        }
        if (remaining != 0) {}
        size -= @as(c_int, @bitCast(certificate_size +% @as(c_uint, @bitCast(@as(c_int, 3)))));
        res += @as(c_int, @bitCast(certificate_size));
    }
    if (!(valid_certificate != 0)) return -@as(c_int, 15);
    if (res != buf_len) {}
    return res;
}
pub export fn tls_parse_server_key_exchange(arg_context: [*c]struct_TLSContext, arg_buf: [*c]const u8, arg_buf_len: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var res: c_int = 0;
    _ = &res;
    var dh_res: c_int = 0;
    _ = &dh_res;
    if ((@as(c_int, 3) > buf_len) or (buf_len < @as(c_int, 0))) {
        return 0;
    }
    var size: c_uint = @as(c_uint, @bitCast(((@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 0)))]))) * @as(c_int, 65536)) + (@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 1)))]))) * @as(c_int, 256))) + @as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 2)))])))));
    _ = &size;
    res += @as(c_int, 3);
    if (context.*.dtls != 0) {
        var dtls_check: c_int = _private_dtls_check_packet(context, buf, buf_len);
        _ = &dtls_check;
        if (dtls_check < @as(c_int, 0)) return dtls_check;
        res += @as(c_int, 8);
    }
    var packet_ref: [*c]const u8 = buf + @as(usize, @bitCast(@as(isize, @intCast(res))));
    _ = &packet_ref;
    if ((@as(c_int, @bitCast(size)) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
        return 0;
    }
    if (!(size != 0)) return res;
    var has_ds_params: u8 = 0;
    _ = &has_ds_params;
    var key_size: c_uint = 0;
    _ = &key_size;
    var curve: [*c]const struct_ECCCurveParameters = null;
    _ = &curve;
    var pk_key: [*c]const u8 = null;
    _ = &pk_key;
    var ephemeral: c_int = tls_cipher_is_ephemeral(context);
    _ = &ephemeral;
    if (ephemeral != 0) {
        if (ephemeral == @as(c_int, 1)) {
            has_ds_params = 1;
        } else {
            if (@as(c_int, @bitCast(@as(c_uint, (blk: {
                const tmp = blk_1: {
                    const ref = &res;
                    const tmp_2 = ref.*;
                    ref.* += 1;
                    break :blk_1 tmp_2;
                };
                if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))) != @as(c_int, 3)) {
                return 0;
            }
            if ((@as(c_int, 3) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
                return 0;
            }
            var iana_n: c_int = @as(c_int, @bitCast(@as(c_uint, ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
                const tmp = res;
                if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))).*))));
            _ = &iana_n;
            res += @as(c_int, 2);
            key_size = @as(c_uint, @bitCast(@as(c_uint, (blk: {
                const tmp = res;
                if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*)));
            res += 1;
            if ((@as(c_int, @bitCast(key_size)) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
                return 0;
            }
            while (true) {
                switch (iana_n) {
                    @as(c_int, 19) => {
                        curve = &secp192r1;
                        break;
                    },
                    @as(c_int, 20) => {
                        curve = &secp224k1;
                        break;
                    },
                    @as(c_int, 21) => {
                        curve = &secp224r1;
                        break;
                    },
                    @as(c_int, 22) => {
                        curve = &secp256k1;
                        break;
                    },
                    @as(c_int, 23) => {
                        curve = &secp256r1;
                        break;
                    },
                    @as(c_int, 24) => {
                        curve = &secp384r1;
                        break;
                    },
                    @as(c_int, 25) => {
                        curve = &secp521r1;
                        break;
                    },
                    @as(c_int, 29) => {
                        curve = &x25519;
                        break;
                    },
                    else => {
                        {}
                        return -@as(c_int, 1);
                    },
                }
                break;
            }
            pk_key = &(blk: {
                const tmp = res;
                if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
            res += @as(c_int, @bitCast(key_size));
            context.*.curve = curve;
        }
    }
    var dh_p: [*c]const u8 = null;
    _ = &dh_p;
    var dh_p_len: c_int = 0;
    _ = &dh_p_len;
    var dh_g: [*c]const u8 = null;
    _ = &dh_g;
    var dh_g_len: c_int = 0;
    _ = &dh_g_len;
    var dh_Ys: [*c]const u8 = null;
    _ = &dh_Ys;
    var dh_Ys_len: c_int = 0;
    _ = &dh_Ys_len;
    if (has_ds_params != 0) {
        dh_res = _private_tls_parse_dh(&(blk: {
            const tmp = res;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*, buf_len - res, &dh_p, &dh_p_len);
        if (dh_res <= @as(c_int, 0)) return -@as(c_int, 2);
        res += dh_res;
        dh_res = _private_tls_parse_dh(&(blk: {
            const tmp = res;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*, buf_len - res, &dh_g, &dh_g_len);
        if (dh_res <= @as(c_int, 0)) return -@as(c_int, 2);
        res += dh_res;
        dh_res = _private_tls_parse_dh(&(blk: {
            const tmp = res;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*, buf_len - res, &dh_Ys, &dh_Ys_len);
        if (dh_res <= @as(c_int, 0)) return -@as(c_int, 2);
        res += dh_res;
    }
    var sign_size: c_int = undefined;
    _ = &sign_size;
    var hash_algorithm: c_int = undefined;
    _ = &hash_algorithm;
    var sign_algorithm: c_int = undefined;
    _ = &sign_algorithm;
    var packet_size: c_int = res - @as(c_int, 3);
    _ = &packet_size;
    if (context.*.dtls != 0) {
        packet_size -= @as(c_int, 8);
    }
    var offset: c_int = 0;
    _ = &offset;
    var signature: [*c]const u8 = _private_tls_parse_signature(context, &(blk: {
        const tmp = res;
        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*, buf_len - res, &hash_algorithm, &sign_algorithm, &sign_size, &offset);
    _ = &signature;
    if ((sign_size <= @as(c_int, 0)) or !(signature != null)) return -@as(c_int, 2);
    res += offset;
    var message_len: c_uint = @as(c_uint, @bitCast((packet_size + @as(c_int, 32)) + @as(c_int, 32)));
    _ = &message_len;
    var message: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, message_len)))))));
    _ = &message;
    if (message != null) {
        _ = memcpy(@as(?*anyopaque, @ptrCast(message)), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.local_random))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))));
        _ = memcpy(@as(?*anyopaque, @ptrCast(message + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))))), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.remote_random))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))));
        _ = memcpy(@as(?*anyopaque, @ptrCast((message + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32)))))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))))), @as(?*const anyopaque, @ptrCast(packet_ref)), @as(c_ulong, @bitCast(@as(c_long, packet_size))));
        if (tls_is_ecdsa(context) != 0) {
            if (_private_tls_verify_ecdsa(context, @as(c_uint, @bitCast(hash_algorithm)), signature, @as(c_uint, @bitCast(sign_size)), message, message_len, null) != @as(c_int, 1)) {
                if (message != null) {
                    free(@as(?*anyopaque, @ptrCast(message)));
                }
                return -@as(c_int, 2);
            }
        } else {
            if (_private_tls_verify_rsa(context, @as(c_uint, @bitCast(hash_algorithm)), signature, @as(c_uint, @bitCast(sign_size)), message, message_len) != @as(c_int, 1)) {
                if (message != null) {
                    free(@as(?*anyopaque, @ptrCast(message)));
                }
                return -@as(c_int, 2);
            }
        }
        if (message != null) {
            free(@as(?*anyopaque, @ptrCast(message)));
        }
    }
    if ((buf_len - res) != 0) {}
    if (ephemeral == @as(c_int, 1)) {
        _private_tls_dhe_create(context);
        var dhe_key_size: c_int = dh_p_len;
        _ = &dhe_key_size;
        if (dh_g_len > dh_p_len) {
            dhe_key_size = dh_g_len;
        }
        if (_private_tls_dh_make_key(dhe_key_size, context.*.dhe, @as([*c]const u8, @ptrCast(@alignCast(dh_p))), @as([*c]const u8, @ptrCast(@alignCast(dh_g))), dh_p_len, dh_g_len) != 0) {
            if (context.*.dhe != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.dhe)));
            }
            context.*.dhe = null;
            return -@as(c_int, 1);
        }
        var dh_key_size: c_uint = 0;
        _ = &dh_key_size;
        var key: [*c]u8 = _private_tls_decrypt_dhe(context, dh_Ys, @as(c_uint, @bitCast(dh_Ys_len)), &dh_key_size, @as(c_int, 0));
        _ = &key;
        if ((key != null) and (dh_key_size != 0)) {
            if (context.*.premaster_key != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.premaster_key)));
            }
            context.*.premaster_key = key;
            context.*.premaster_key_len = dh_key_size;
        }
    } else if ((((ephemeral == @as(c_int, 2)) and (curve != null)) and (pk_key != null)) and (key_size != 0)) {
        if (curve == @as([*c]const struct_ECCCurveParameters, @ptrCast(@alignCast(&x25519)))) {
            if (key_size != @as(c_uint, @bitCast(@as(c_int, 32)))) {
                return -@as(c_int, 1);
            }
            if (context.*.client_secret != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.client_secret)));
            }
            context.*.client_secret = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32))))))));
            if (!(context.*.client_secret != null)) {
                return -@as(c_int, 1);
            }
            _ = tls_random(context.*.client_secret, @as(c_int, 32));
            context.*.client_secret[@as(c_uint, @intCast(@as(c_int, 0)))] &= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 248)))));
            context.*.client_secret[@as(c_uint, @intCast(@as(c_int, 31)))] &= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 127)))));
            context.*.client_secret[@as(c_uint, @intCast(@as(c_int, 31)))] |= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 64)))));
            if (context.*.premaster_key != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.premaster_key)));
            }
            context.*.premaster_key = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32))))))));
            if (!(context.*.premaster_key != null)) return -@as(c_int, 1);
            var secret_key: curve25519_key = undefined;
            _ = &secret_key;
            _ = x25519_import_raw(context.*.client_secret, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))), PK_PRIVATE, &secret_key);
            var public_key: curve25519_key = undefined;
            _ = &public_key;
            _ = x25519_import_raw(pk_key, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))), PK_PUBLIC, &public_key);
            context.*.premaster_key_len = 32;
            _ = x25519_shared_secret(&secret_key, &public_key, context.*.premaster_key, @as([*c]c_ulong, @ptrCast(@alignCast(&context.*.premaster_key_len))));
        } else {
            tls_init();
            _private_tls_ecc_dhe_create(context);
            var dp: [*c]const ltc_ecc_set_type = &curve.*.dp;
            _ = &dp;
            if (ecc_make_key_ex(null, find_prng("sprng"), context.*.ecc_dhe, dp) != 0) {
                if (context.*.ecc_dhe != null) {
                    free(@as(?*anyopaque, @ptrCast(context.*.ecc_dhe)));
                }
                context.*.ecc_dhe = null;
                return -@as(c_int, 1);
            }
            if (context.*.premaster_key != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.premaster_key)));
            }
            context.*.premaster_key_len = 0;
            var out_len: c_uint = 0;
            _ = &out_len;
            context.*.premaster_key = _private_tls_decrypt_ecc_dhe(context, pk_key, key_size, &out_len, @as(c_int, 0));
            if (context.*.premaster_key != null) {
                context.*.premaster_key_len = out_len;
            }
        }
    }
    return res;
}
pub export fn tls_parse_client_key_exchange(arg_context: [*c]struct_TLSContext, arg_buf: [*c]const u8, arg_buf_len: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) != @as(c_int, 1)) and !(context.*.dtls != 0)) {
        return -@as(c_int, 6);
    }
    var res: c_int = 0;
    _ = &res;
    var dh_res: c_int = 0;
    _ = &dh_res;
    if ((@as(c_int, 3) > buf_len) or (buf_len < @as(c_int, 0))) {
        return 0;
    }
    var size: c_uint = @as(c_uint, @bitCast(((@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 0)))]))) * @as(c_int, 65536)) + (@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 1)))]))) * @as(c_int, 256))) + @as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 2)))])))));
    _ = &size;
    res += @as(c_int, 3);
    if (context.*.dtls != 0) {
        var dtls_check: c_int = _private_dtls_check_packet(context, buf, buf_len);
        _ = &dtls_check;
        if (dtls_check < @as(c_int, 0)) return dtls_check;
        res += @as(c_int, 8);
    }
    if ((@as(c_int, @bitCast(size)) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
        return 0;
    }
    if (!(size != 0)) return res;
    dh_res = _private_tls_parse_random(context, &(blk: {
        const tmp = res;
        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*, @as(c_int, @bitCast(size)));
    if (dh_res <= @as(c_int, 0)) {
        return -@as(c_int, 2);
    }
    res += @as(c_int, @bitCast(size));
    context.*.connection_status = 2;
    return res;
}
pub export fn tls_parse_server_hello_done(arg_context: [*c]struct_TLSContext, arg_buf: [*c]const u8, arg_buf_len: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var res: c_int = 0;
    _ = &res;
    if ((@as(c_int, 3) > buf_len) or (buf_len < @as(c_int, 0))) {
        return 0;
    }
    var size: c_uint = @as(c_uint, @bitCast(((@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 0)))]))) * @as(c_int, 65536)) + (@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 1)))]))) * @as(c_int, 256))) + @as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 2)))])))));
    _ = &size;
    res += @as(c_int, 3);
    if (context.*.dtls != 0) {
        var dtls_check: c_int = _private_dtls_check_packet(context, buf, buf_len);
        _ = &dtls_check;
        if (dtls_check < @as(c_int, 0)) return dtls_check;
        res += @as(c_int, 8);
    }
    if ((@as(c_int, @bitCast(size)) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
        return 0;
    }
    res += @as(c_int, @bitCast(size));
    return res;
}
pub export fn tls_parse_finished(arg_context: [*c]struct_TLSContext, arg_buf: [*c]const u8, arg_buf_len: c_int, arg_write_packets: [*c]c_uint) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var write_packets = arg_write_packets;
    _ = &write_packets;
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) < @as(c_int, 2)) or (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) == @as(c_int, 255))) {
        return -@as(c_int, 6);
    }
    var res: c_int = 0;
    _ = &res;
    write_packets.* = 0;
    if ((@as(c_int, 3) > buf_len) or (buf_len < @as(c_int, 0))) {
        return 0;
    }
    var size: c_uint = @as(c_uint, @bitCast(((@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 0)))]))) * @as(c_int, 65536)) + (@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 1)))]))) * @as(c_int, 256))) + @as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 2)))])))));
    _ = &size;
    res += @as(c_int, 3);
    if (context.*.dtls != 0) {
        var dtls_check: c_int = _private_dtls_check_packet(context, buf, buf_len);
        _ = &dtls_check;
        if (dtls_check < @as(c_int, 0)) return dtls_check;
        res += @as(c_int, 8);
    }
    if (size < @as(c_uint, @bitCast(@as(c_int, 12)))) {
        return -@as(c_int, 2);
    }
    if ((@as(c_int, @bitCast(size)) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
        return 0;
    }
    var hash: [48]u8 = undefined;
    _ = &hash;
    var hash_len: c_uint = @as(c_uint, @bitCast(_private_tls_get_hash(context, @as([*c]u8, @ptrCast(@alignCast(&hash))))));
    _ = &hash_len;
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
        var hash_out: [48]u8 = undefined;
        _ = &hash_out;
        var out_size: c_ulong = 48;
        _ = &out_size;
        if (!(context.*.remote_finished_key != null) or !(hash_len != 0)) {
            return -@as(c_int, 10);
        }
        out_size = @as(c_ulong, @bitCast(@as(c_ulong, hash_len)));
        var hmac: hmac_state = undefined;
        _ = &hmac;
        _ = hmac_init(&hmac, _private_tls_get_hash_idx(context), context.*.remote_finished_key, @as(c_ulong, @bitCast(@as(c_ulong, hash_len))));
        _ = hmac_process(&hmac, @as([*c]u8, @ptrCast(@alignCast(&hash))), @as(c_ulong, @bitCast(@as(c_ulong, hash_len))));
        _ = hmac_done(&hmac, @as([*c]u8, @ptrCast(@alignCast(&hash_out))), &out_size);
        if ((@as(c_ulong, @bitCast(@as(c_ulong, size))) != out_size) or (memcmp(@as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&hash_out))))), @as(?*const anyopaque, @ptrCast(&(blk: {
            const tmp = res;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*)), @as(c_ulong, @bitCast(@as(c_ulong, size)))) != 0)) {
            return -@as(c_int, 10);
        }
        if (context.*.is_server != 0) {
            context.*.connection_status = 255;
            res += @as(c_int, @bitCast(size));
            _ = _private_tls13_key(context, @as(c_int, 0));
            context.*.local_sequence_number = 0;
            context.*.remote_sequence_number = 0;
            return res;
        }
    } else {
        var out: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, size)))))));
        _ = &out;
        if (!(out != null)) {
            return -@as(c_int, 9);
        }
        if (context.*.is_server != 0) {
            _private_tls_prf(context, out, size, context.*.master_key, context.*.master_key_len, @as([*c]u8, @ptrCast(@alignCast("client finished"))), @as(c_uint, @bitCast(@as(c_int, 15))), @as([*c]u8, @ptrCast(@alignCast(&hash))), hash_len, null, @as(c_uint, @bitCast(@as(c_int, 0))));
        } else {
            _private_tls_prf(context, out, size, context.*.master_key, context.*.master_key_len, @as([*c]u8, @ptrCast(@alignCast("server finished"))), @as(c_uint, @bitCast(@as(c_int, 15))), @as([*c]u8, @ptrCast(@alignCast(&hash))), hash_len, null, @as(c_uint, @bitCast(@as(c_int, 0))));
        }
        if (memcmp(@as(?*const anyopaque, @ptrCast(out)), @as(?*const anyopaque, @ptrCast(&(blk: {
            const tmp = res;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*)), @as(c_ulong, @bitCast(@as(c_ulong, size)))) != 0) {
            if (out != null) {
                free(@as(?*anyopaque, @ptrCast(out)));
            }
            return -@as(c_int, 10);
        }
        if (out != null) {
            free(@as(?*anyopaque, @ptrCast(out)));
        }
    }
    if (context.*.is_server != 0) {
        write_packets.* = 3;
    } else {
        context.*.connection_status = 255;
    }
    res += @as(c_int, @bitCast(size));
    return res;
}
pub export fn tls_parse_verify(arg_context: [*c]struct_TLSContext, arg_buf: [*c]const u8, arg_buf_len: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) return tls_parse_verify_tls13(context, buf, buf_len);
    if ((@as(c_int, 7) > buf_len) or (buf_len < @as(c_int, 0))) {
        return -@as(c_int, 14);
    }
    var bytes_to_follow: c_uint = @as(c_uint, @bitCast(((@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 0)))]))) * @as(c_int, 65536)) + (@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 1)))]))) * @as(c_int, 256))) + @as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 2)))])))));
    _ = &bytes_to_follow;
    if ((@as(c_int, @bitCast(bytes_to_follow)) > (buf_len - @as(c_int, 3))) or ((buf_len - @as(c_int, 3)) < @as(c_int, 0))) {
        return -@as(c_int, 14);
    }
    var res: c_int = -@as(c_int, 1);
    _ = &res;
    if ((((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65277))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
        var hash: c_uint = @as(c_uint, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 3)))])));
        _ = &hash;
        var algorithm: c_uint = @as(c_uint, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 4)))])));
        _ = &algorithm;
        if ((algorithm != @as(c_uint, @bitCast(rsa_pkcs1))) and (algorithm != @as(c_uint, @bitCast(ecdsa)))) {
            if (@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) == @as(c_int, 4)) {
                context.*.client_verified = 1;
                return 1;
            }
            return -@as(c_int, 15);
        }
        var size: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&buf[@as(c_uint, @intCast(@as(c_int, 5)))]))).*);
        _ = &size;
        if ((@as(c_int, @bitCast(@as(c_uint, size))) > @as(c_int, @bitCast(bytes_to_follow -% @as(c_uint, @bitCast(@as(c_int, 4)))))) or (@as(c_int, @bitCast(bytes_to_follow -% @as(c_uint, @bitCast(@as(c_int, 4))))) < @as(c_int, 0))) {
            return -@as(c_int, 14);
        }
        if (algorithm == @as(c_uint, @bitCast(rsa_pkcs1))) {
            res = _private_tls_verify_rsa(context, hash, &buf[@as(c_uint, @intCast(@as(c_int, 7)))], @as(c_uint, @bitCast(@as(c_uint, size))), context.*.cached_handshake, context.*.cached_handshake_len);
        } else {
            res = _private_tls_verify_ecdsa(context, hash, &buf[@as(c_uint, @intCast(@as(c_int, 7)))], @as(c_uint, @bitCast(@as(c_uint, size))), context.*.cached_handshake, context.*.cached_handshake_len, null);
        }
    } else {
        var size: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&buf[@as(c_uint, @intCast(@as(c_int, 3)))]))).*);
        _ = &size;
        if ((@as(c_int, @bitCast(@as(c_uint, size))) > @as(c_int, @bitCast(bytes_to_follow -% @as(c_uint, @bitCast(@as(c_int, 2)))))) or (@as(c_int, @bitCast(bytes_to_follow -% @as(c_uint, @bitCast(@as(c_int, 2))))) < @as(c_int, 0))) {
            return -@as(c_int, 14);
        }
        res = _private_tls_verify_rsa(context, @as(c_uint, @bitCast(md5)), &buf[@as(c_uint, @intCast(@as(c_int, 5)))], @as(c_uint, @bitCast(@as(c_uint, size))), context.*.cached_handshake, context.*.cached_handshake_len);
    }
    if (context.*.cached_handshake != null) {
        if (context.*.cached_handshake != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.cached_handshake)));
        }
        context.*.cached_handshake = null;
        context.*.cached_handshake_len = 0;
    }
    if (res == @as(c_int, 1)) {
        context.*.client_verified = 1;
    } else {
        context.*.client_verified = 0;
    }
    return 1;
}
pub export fn tls_parse_payload(arg_context: [*c]struct_TLSContext, arg_buf: [*c]const u8, arg_buf_len: c_int, arg_certificate_verify: tls_validation_function) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var certificate_verify = arg_certificate_verify;
    _ = &certificate_verify;
    var orig_len: c_int = buf_len;
    _ = &orig_len;
    if (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) == @as(c_int, 255)) {
        if (context.*.dtls != 0) return orig_len;
        _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))), @as(u8, @bitCast(@as(i8, @truncate(no_renegotiation))))));
        return 1;
    }
    var local_buffer: [262156]u8 = undefined;
    _ = &local_buffer;
    while ((buf_len >= @as(c_int, 4)) and !(context.*.critical_error != 0)) {
        var payload_res: c_int = 0;
        _ = &payload_res;
        var update_hash: u8 = 1;
        _ = &update_hash;
        if ((@as(c_int, 1) > buf_len) or (buf_len < @as(c_int, 0))) {
            return 0;
        }
        var @"type": u8 = buf[@as(c_uint, @intCast(@as(c_int, 0)))];
        _ = &@"type";
        var write_packets: c_uint = 0;
        _ = &write_packets;
        var dtls_cookie_verified: c_uint = 0;
        _ = &dtls_cookie_verified;
        var certificate_verify_alert: c_int = no_error;
        _ = &certificate_verify_alert;
        var payload_size: c_uint = @as(c_uint, @bitCast((((@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 1)))]))) * @as(c_int, 65536)) + (@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 2)))]))) * @as(c_int, 256))) + @as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 3)))])))) + @as(c_int, 3)));
        _ = &payload_size;
        if (context.*.dtls != 0) {
            payload_size +%= @as(c_uint, @bitCast(@as(c_int, 8)));
            if (context.*.dtls_data.*.fragment != null) {
                if ((@as(c_int, @bitCast(payload_size -% @as(c_uint, @bitCast(@as(c_int, 11))))) > context.*.dtls_data.*.fragment.*.written) or (context.*.dtls_data.*.fragment.*.written < @as(c_int, 0))) {
                    return 0;
                }
                local_buffer[@as(c_uint, @intCast(@as(c_int, 0)))] = @"type";
                {
                    var u_val: c_uint = @as(c_uint, @bitCast(context.*.dtls_data.*.fragment.*.written));
                    _ = &u_val;
                    local_buffer[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(u_val / @as(c_uint, @bitCast(@as(c_int, 65536)))))));
                    u_val %= @as(c_uint, @bitCast(@as(c_int, 65536)));
                    local_buffer[@as(c_uint, @intCast(@as(c_int, 1) + @as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(u_val / @as(c_uint, @bitCast(@as(c_int, 256)))))));
                    u_val %= @as(c_uint, @bitCast(@as(c_int, 256)));
                    local_buffer[@as(c_uint, @intCast(@as(c_int, 1) + @as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(u_val))));
                }
                local_buffer[@as(c_uint, @intCast(@as(c_int, 4)))] = buf[@as(c_uint, @intCast(@as(c_int, 4)))];
                local_buffer[@as(c_uint, @intCast(@as(c_int, 5)))] = buf[@as(c_uint, @intCast(@as(c_int, 5)))];
                local_buffer[@as(c_uint, @intCast(@as(c_int, 6)))] = 0;
                local_buffer[@as(c_uint, @intCast(@as(c_int, 7)))] = 0;
                local_buffer[@as(c_uint, @intCast(@as(c_int, 8)))] = 0;
                {
                    var u_val: c_uint = @as(c_uint, @bitCast(context.*.dtls_data.*.fragment.*.written));
                    _ = &u_val;
                    local_buffer[@as(c_uint, @intCast(@as(c_int, 9)))] = @as(u8, @bitCast(@as(u8, @truncate(u_val / @as(c_uint, @bitCast(@as(c_int, 65536)))))));
                    u_val %= @as(c_uint, @bitCast(@as(c_int, 65536)));
                    local_buffer[@as(c_uint, @intCast(@as(c_int, 9) + @as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(u_val / @as(c_uint, @bitCast(@as(c_int, 256)))))));
                    u_val %= @as(c_uint, @bitCast(@as(c_int, 256)));
                    local_buffer[@as(c_uint, @intCast(@as(c_int, 9) + @as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(u_val))));
                }
                _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&local_buffer))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))), @as(?*const anyopaque, @ptrCast(context.*.dtls_data.*.fragment.*.buffer)), @as(c_ulong, @bitCast(@as(c_long, context.*.dtls_data.*.fragment.*.written))));
                buf = @as([*c]u8, @ptrCast(@alignCast(&local_buffer)));
                buf_len = context.*.dtls_data.*.fragment.*.written + @as(c_int, 12);
                if (context.*.dtls_data.*.fragment.*.buffer != null) {
                    free(@as(?*anyopaque, @ptrCast(context.*.dtls_data.*.fragment.*.buffer)));
                }
                if (context.*.dtls_data.*.fragment != null) {
                    free(@as(?*anyopaque, @ptrCast(context.*.dtls_data.*.fragment)));
                }
                context.*.dtls_data.*.fragment = null;
            } else {
                if ((@as(c_int, @bitCast(payload_size +% @as(c_uint, @bitCast(@as(c_int, 1))))) > buf_len) or (buf_len < @as(c_int, 0))) {
                    return 0;
                }
            }
        } else {
            if ((@as(c_int, @bitCast(payload_size +% @as(c_uint, @bitCast(@as(c_int, 1))))) > buf_len) or (buf_len < @as(c_int, 0))) {
                return 0;
            }
        }
        while (true) {
            switch (@as(c_int, @bitCast(@as(c_uint, @"type")))) {
                @as(c_int, 0) => {
                    {}
                    {
                        if (@as(c_int, @bitCast(@as(c_uint, context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 0)))]))) >= @as(c_int, 1)) {
                            if (context.*.dtls != 0) {
                                _private_dtls_rehash(context, @"type");
                                context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 0)))] +%= 1;
                            } else {
                                payload_res = -@as(c_int, 6);
                                break;
                            }
                        }
                        context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 0)))] +%= 1;
                    }
                    if (context.*.dtls != 0) {
                        context.*.dtls_seq = 0;
                    }
                    if (context.*.is_server != 0) {
                        payload_res = -@as(c_int, 6);
                    } else {
                        if (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) == @as(c_int, 255)) {
                            payload_res = -@as(c_int, 16);
                        } else {
                            payload_res = -@as(c_int, 6);
                        }
                    }
                    break;
                },
                @as(c_int, 1) => {
                    {}
                    if (context.*.dtls != 0) {
                        _private_dtls_reset_handshake(context);
                    } else {
                        {
                            if (@as(c_int, @bitCast(@as(c_uint, context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 1)))]))) >= (if (@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) != 0) @as(c_int, 2) else @as(c_int, 1))) {
                                if (context.*.dtls != 0) {
                                    _private_dtls_rehash(context, @"type");
                                    context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 1)))] +%= 1;
                                } else {
                                    payload_res = -@as(c_int, 6);
                                    break;
                                }
                            }
                            context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 1)))] +%= 1;
                        }
                    }
                    if (((@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) == @as(c_int, 4)) and !(context.*.is_server != 0)) and (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) == @as(c_int, 0))) {
                        context.*.is_server = 1;
                        context.*.certificates = context.*.client_certificates;
                        context.*.certificates_count = context.*.client_certificates_count;
                        context.*.request_client_certificate = 1;
                        context.*.client_certificates = null;
                        context.*.client_certificates_count = 0;
                    }
                    if (context.*.is_server != 0) {
                        payload_res = tls_parse_hello(context, buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))), @as(c_int, @bitCast(payload_size)), &write_packets, &dtls_cookie_verified);
                        if (((@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) != 0) and (payload_res > @as(c_int, 0))) and !(dtls_cookie_verified != 0)) {
                            context.*.connection_status = 3;
                            update_hash = 0;
                        }
                    } else {
                        payload_res = -@as(c_int, 6);
                    }
                    break;
                },
                @as(c_int, 2) => {
                    {}
                    {
                        if (@as(c_int, @bitCast(@as(c_uint, context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 2)))]))) >= @as(c_int, 1)) {
                            if (context.*.dtls != 0) {
                                _private_dtls_rehash(context, @"type");
                                context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 2)))] +%= 1;
                            } else {
                                payload_res = -@as(c_int, 6);
                                break;
                            }
                        }
                        context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 2)))] +%= 1;
                    }
                    if (context.*.is_server != 0) {
                        payload_res = -@as(c_int, 6);
                    } else {
                        payload_res = tls_parse_hello(context, buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))), @as(c_int, @bitCast(payload_size)), &write_packets, &dtls_cookie_verified);
                    }
                    break;
                },
                @as(c_int, 3) => {
                    {}
                    {
                        if (@as(c_int, @bitCast(@as(c_uint, context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 3)))]))) >= @as(c_int, 1)) {
                            if (context.*.dtls != 0) {
                                _private_dtls_rehash(context, @"type");
                                context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 3)))] +%= 1;
                            } else {
                                payload_res = -@as(c_int, 6);
                                break;
                            }
                        }
                        context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 3)))] +%= 1;
                    }
                    if ((@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) != 0) and !(context.*.is_server != 0)) {
                        payload_res = tls_parse_verify_request(context, buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))), @as(c_int, @bitCast(payload_size)), &write_packets);
                        update_hash = 0;
                    } else {
                        payload_res = -@as(c_int, 6);
                    }
                    break;
                },
                @as(c_int, 11) => {
                    {}
                    {
                        if (@as(c_int, @bitCast(@as(c_uint, context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 4)))]))) >= @as(c_int, 1)) {
                            if (context.*.dtls != 0) {
                                _private_dtls_rehash(context, @"type");
                                context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 4)))] +%= 1;
                            } else {
                                payload_res = -@as(c_int, 6);
                                break;
                            }
                        }
                        context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 4)))] +%= 1;
                    }
                    if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
                        if (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) == @as(c_int, 2)) {
                            payload_res = tls_parse_certificate(context, buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))), @as(c_int, @bitCast(payload_size)), @as(c_int, @bitCast(@as(c_uint, context.*.is_server))));
                            if (context.*.is_server != 0) {
                                if ((certificate_verify != null) and (context.*.client_certificates_count != 0)) {
                                    certificate_verify_alert = certificate_verify.?(context, context.*.client_certificates, @as(c_int, @bitCast(context.*.client_certificates_count)));
                                }
                                if (payload_res == @as(c_int, 0)) {
                                    payload_res = 1;
                                }
                            } else {
                                if ((certificate_verify != null) and (context.*.certificates_count != 0)) {
                                    certificate_verify_alert = certificate_verify.?(context, context.*.certificates, @as(c_int, @bitCast(context.*.certificates_count)));
                                }
                            }
                        } else {
                            payload_res = -@as(c_int, 6);
                        }
                    } else if (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) == @as(c_int, 1)) {
                        if (context.*.is_server != 0) {
                            payload_res = tls_parse_certificate(context, buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))), @as(c_int, @bitCast(payload_size)), @as(c_int, 1));
                            if ((certificate_verify != null) and (context.*.client_certificates_count != 0)) {
                                certificate_verify_alert = certificate_verify.?(context, context.*.client_certificates, @as(c_int, @bitCast(context.*.client_certificates_count)));
                            }
                            if (payload_res == @as(c_int, 0)) {
                                payload_res = 1;
                            }
                        } else {
                            payload_res = tls_parse_certificate(context, buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))), @as(c_int, @bitCast(payload_size)), @as(c_int, 0));
                            if ((certificate_verify != null) and (context.*.certificates_count != 0)) {
                                certificate_verify_alert = certificate_verify.?(context, context.*.certificates, @as(c_int, @bitCast(context.*.certificates_count)));
                            }
                        }
                    } else {
                        payload_res = -@as(c_int, 6);
                    }
                    break;
                },
                @as(c_int, 12) => {
                    {}
                    {
                        if (@as(c_int, @bitCast(@as(c_uint, context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 5)))]))) >= @as(c_int, 1)) {
                            if (context.*.dtls != 0) {
                                _private_dtls_rehash(context, @"type");
                                context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 5)))] +%= 1;
                            } else {
                                payload_res = -@as(c_int, 6);
                                break;
                            }
                        }
                        context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 5)))] +%= 1;
                    }
                    if (context.*.is_server != 0) {
                        payload_res = -@as(c_int, 6);
                    } else {
                        payload_res = tls_parse_server_key_exchange(context, buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))), @as(c_int, @bitCast(payload_size)));
                    }
                    break;
                },
                @as(c_int, 13) => {
                    {}
                    {
                        if (@as(c_int, @bitCast(@as(c_uint, context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 6)))]))) >= @as(c_int, 1)) {
                            if (context.*.dtls != 0) {
                                _private_dtls_rehash(context, @"type");
                                context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 6)))] +%= 1;
                            } else {
                                payload_res = -@as(c_int, 6);
                                break;
                            }
                        }
                        context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 6)))] +%= 1;
                    }
                    if (context.*.is_server != 0) {
                        payload_res = -@as(c_int, 6);
                    } else {
                        context.*.client_verified = 2;
                    }
                    break;
                },
                @as(c_int, 14) => {
                    {}
                    {
                        if (@as(c_int, @bitCast(@as(c_uint, context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 7)))]))) >= @as(c_int, 1)) {
                            if (context.*.dtls != 0) {
                                _private_dtls_rehash(context, @"type");
                                context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 7)))] +%= 1;
                            } else {
                                payload_res = -@as(c_int, 6);
                                break;
                            }
                        }
                        context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 7)))] +%= 1;
                    }
                    if (context.*.is_server != 0) {
                        payload_res = -@as(c_int, 6);
                    } else {
                        payload_res = tls_parse_server_hello_done(context, buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))), @as(c_int, @bitCast(payload_size)));
                        if (payload_res > @as(c_int, 0)) {
                            write_packets = 1;
                        }
                    }
                    break;
                },
                @as(c_int, 15) => {
                    {}
                    {
                        if (@as(c_int, @bitCast(@as(c_uint, context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 8)))]))) >= @as(c_int, 1)) {
                            if (context.*.dtls != 0) {
                                _private_dtls_rehash(context, @"type");
                                context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 8)))] +%= 1;
                            } else {
                                payload_res = -@as(c_int, 6);
                                break;
                            }
                        }
                        context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 8)))] +%= 1;
                    }
                    if (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) == @as(c_int, 2)) {
                        payload_res = tls_parse_verify(context, buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))), @as(c_int, @bitCast(payload_size)));
                    } else {
                        payload_res = -@as(c_int, 6);
                    }
                    break;
                },
                @as(c_int, 16) => {
                    {}
                    {
                        if (@as(c_int, @bitCast(@as(c_uint, context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 9)))]))) >= @as(c_int, 1)) {
                            if (context.*.dtls != 0) {
                                _private_dtls_rehash(context, @"type");
                                context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 9)))] +%= 1;
                            } else {
                                payload_res = -@as(c_int, 6);
                                break;
                            }
                        }
                        context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 9)))] +%= 1;
                    }
                    if (context.*.is_server != 0) {
                        _ = _private_tls_update_hash(context, buf, payload_size +% @as(c_uint, @bitCast(@as(c_int, 1))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
                        payload_res = tls_parse_client_key_exchange(context, buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))), @as(c_int, @bitCast(payload_size)));
                        update_hash = 0;
                    } else {
                        payload_res = -@as(c_int, 6);
                    }
                    break;
                },
                @as(c_int, 20) => {
                    {}
                    if (context.*.cached_handshake != null) {
                        if (context.*.cached_handshake != null) {
                            free(@as(?*anyopaque, @ptrCast(context.*.cached_handshake)));
                        }
                        context.*.cached_handshake = null;
                        context.*.cached_handshake_len = 0;
                    }
                    {
                        if (@as(c_int, @bitCast(@as(c_uint, context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 10)))]))) >= @as(c_int, 1)) {
                            if (context.*.dtls != 0) {
                                _private_dtls_rehash(context, @"type");
                                context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 10)))] +%= 1;
                            } else {
                                payload_res = -@as(c_int, 6);
                                break;
                            }
                        }
                        context.*.hs_messages[@as(c_uint, @intCast(@as(c_int, 10)))] +%= 1;
                    }
                    payload_res = tls_parse_finished(context, buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))), @as(c_int, @bitCast(payload_size)), &write_packets);
                    if (payload_res > @as(c_int, 0)) {
                        _ = memset(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.hs_messages))))), @as(c_int, 0), @sizeOf([11]u8));
                    }
                    if (!(context.*.is_server != 0) and ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276)))) {
                        update_hash = 0;
                        _ = _private_tls_update_hash(context, buf, payload_size +% @as(c_uint, @bitCast(@as(c_int, 1))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 255))))));
                        _ = _private_tls_write_packet(tls_build_finished(context));
                        _ = _private_tls13_key(context, @as(c_int, 0));
                        context.*.connection_status = 255;
                        context.*.local_sequence_number = 0;
                        context.*.remote_sequence_number = 0;
                    }
                    break;
                },
                @as(c_int, 8) => break,
                else => {
                    {}
                    return -@as(c_int, 3);
                },
            }
            break;
        }
        if (((@as(c_int, @bitCast(@as(c_uint, @"type"))) != @as(c_int, 0)) and (@as(c_int, @bitCast(@as(c_uint, update_hash))) != 0)) and (payload_res != -@as(c_int, 6))) {
            _ = _private_tls_update_hash(context, buf, payload_size +% @as(c_uint, @bitCast(@as(c_int, 1))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
        }
        if (certificate_verify_alert != no_error) {
            _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(certificate_verify_alert))))));
            context.*.critical_error = 1;
        }
        if (payload_res < @as(c_int, 0)) {
            while (true) {
                switch (payload_res) {
                    @as(c_int, -6) => {
                        if (context.*.dtls != 0) return orig_len else {
                            _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(unexpected_message))))));
                        }
                        break;
                    },
                    @as(c_int, -8) => {
                        _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(decompression_failure))))));
                        break;
                    },
                    @as(c_int, -2) => {
                        _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(decode_error))))));
                        break;
                    },
                    @as(c_int, -9) => {
                        _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(internal_error))))));
                        break;
                    },
                    @as(c_int, -10) => {
                        _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(bad_record_mac))))));
                        break;
                    },
                    @as(c_int, -14) => {
                        if (context.*.is_server != 0) {
                            _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))), @as(u8, @bitCast(@as(i8, @truncate(bad_certificate))))));
                            payload_res = 0;
                        } else {
                            _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(bad_certificate))))));
                        }
                        break;
                    },
                    @as(c_int, -15) => {
                        _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(unsupported_certificate))))));
                        break;
                    },
                    @as(c_int, -5) => {
                        _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(insufficient_security))))));
                        break;
                    },
                    @as(c_int, -3) => {
                        _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(internal_error))))));
                        break;
                    },
                    @as(c_int, -16) => {
                        _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))), @as(u8, @bitCast(@as(i8, @truncate(no_renegotiation))))));
                        payload_res = 0;
                        break;
                    },
                    @as(c_int, -20) => {
                        _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(decryption_failed_RESERVED))))));
                        break;
                    },
                    else => {},
                }
                break;
            }
            if (payload_res < @as(c_int, 0)) return payload_res;
        }
        if (certificate_verify_alert != no_error) {
            payload_res = -@as(c_int, 14);
        }
        while (true) {
            switch (write_packets) {
                @as(c_uint, @bitCast(@as(c_int, 1))) => {
                    if (@as(c_int, @bitCast(@as(c_uint, context.*.client_verified))) == @as(c_int, 2)) {
                        _ = _private_tls_write_packet(tls_build_certificate(context));
                        context.*.client_verified = 0;
                    }
                    {}
                    _ = _private_tls_write_packet(tls_build_client_key_exchange(context));
                    {}
                    _ = _private_tls_write_packet(tls_build_change_cipher_spec(context));
                    context.*.cipher_spec_set = 1;
                    context.*.local_sequence_number = 0;
                    {}
                    _ = _private_tls_write_packet(tls_build_finished(context));
                    context.*.cipher_spec_set = 0;
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 2))) => {
                    if ((@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) != 0) and (dtls_cookie_verified == @as(c_uint, @bitCast(@as(c_int, 0))))) {
                        _ = _private_tls_write_packet(tls_build_verify_request(context));
                        _private_dtls_reset(context);
                    } else {
                        if (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) == @as(c_int, 3)) {
                            context.*.connection_status = 2;
                            _ = _private_tls_write_packet(tls_build_hello(context, @as(c_int, 0)));
                            _ = _private_tls_write_packet(tls_build_change_cipher_spec(context));
                            _ = _private_tls13_key(context, @as(c_int, 1));
                            context.*.cipher_spec_set = 1;
                            _ = _private_tls_write_packet(tls_build_encrypted_extensions(context));
                            if (context.*.request_client_certificate != 0) {
                                _ = _private_tls_write_packet(tls_certificate_request(context));
                            }
                            _ = _private_tls_write_packet(tls_build_certificate(context));
                            _ = _private_tls_write_packet(tls_build_certificate_verify(context));
                            _ = _private_tls_write_packet(tls_build_finished(context));
                            if (context.*.server_finished_hash != null) {
                                free(@as(?*anyopaque, @ptrCast(context.*.server_finished_hash)));
                            }
                            context.*.server_finished_hash = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, _private_tls_mac_length(context))))))));
                            if (context.*.server_finished_hash != null) {
                                _ = _private_tls_get_hash(context, context.*.server_finished_hash);
                            }
                            break;
                        }
                        _ = _private_tls_write_packet(tls_build_hello(context, @as(c_int, 0)));
                        _ = _private_tls_write_packet(tls_build_certificate(context));
                        var ephemeral_cipher: c_int = tls_cipher_is_ephemeral(context);
                        _ = &ephemeral_cipher;
                        if (ephemeral_cipher != 0) {
                            _ = _private_tls_write_packet(tls_build_server_key_exchange(context, if (ephemeral_cipher == @as(c_int, 1)) KEA_dhe_rsa else KEA_ec_diffie_hellman));
                        }
                        if (context.*.request_client_certificate != 0) {
                            _ = _private_tls_write_packet(tls_certificate_request(context));
                        }
                        _ = _private_tls_write_packet(tls_build_done(context));
                    }
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 3))) => {
                    _ = _private_tls_write_packet(tls_build_change_cipher_spec(context));
                    _ = _private_tls_write_packet(tls_build_finished(context));
                    context.*.connection_status = 255;
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 4))) => {
                    context.*.dtls_seq = 1;
                    _ = _private_tls_write_packet(tls_build_hello(context, @as(c_int, 0)));
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 5))) => {
                    {}
                    _ = _private_tls_write_packet(tls_build_hello(context, @as(c_int, 0)));
                    break;
                },
                else => {},
            }
            break;
        }
        payload_size +%= 1;
        buf += payload_size;
        buf_len -= @as(c_int, @bitCast(payload_size));
    }
    return orig_len;
}
pub const struct_poly1305_state_internal_t = extern struct {
    r: [5]c_ulong = @import("std").mem.zeroes([5]c_ulong),
    h: [5]c_ulong = @import("std").mem.zeroes([5]c_ulong),
    pad: [4]c_ulong = @import("std").mem.zeroes([4]c_ulong),
    leftover: usize = @import("std").mem.zeroes(usize),
    buffer: [16]u8 = @import("std").mem.zeroes([16]u8),
    final: u8 = @import("std").mem.zeroes(u8),
};
pub const poly1305_state_internal_t = struct_poly1305_state_internal_t;
pub export fn tls_parse_message(arg_context: [*c]struct_TLSContext, arg_buf: [*c]u8, arg_buf_len: c_int, arg_certificate_verify: tls_validation_function) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var certificate_verify = arg_certificate_verify;
    _ = &certificate_verify;
    var res: c_int = 5;
    _ = &res;
    if (context.*.dtls != 0) {
        res = 13;
    }
    var header_size: c_int = res;
    _ = &header_size;
    var payload_res: c_int = 0;
    _ = &payload_res;
    if ((res > buf_len) or (buf_len < @as(c_int, 0))) {
        return 0;
    }
    var @"type": u8 = buf.*;
    _ = &@"type";
    var buf_pos: c_int = 1;
    _ = &buf_pos;
    var version: c_ushort = ntohs(@as([*c]c_ushort, @ptrCast(@alignCast(&(blk: {
        const tmp = buf_pos;
        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*))).*);
    _ = &version;
    buf_pos += @as(c_int, 2);
    var dtls_sequence_number: u64 = 0;
    _ = &dtls_sequence_number;
    var dtls_epoch: c_ushort = 0;
    _ = &dtls_epoch;
    if (context.*.dtls != 0) {
        if (((buf_pos + @as(c_int, 8)) > buf_len) or (buf_len < @as(c_int, 0))) {
            return 0;
        }
        dtls_epoch = ntohs(@as([*c]c_ushort, @ptrCast(@alignCast(&(blk: {
            const tmp = buf_pos;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).*);
        dtls_sequence_number = if (@as(u32, @bitCast(@as(c_int, 1))) == ntohl(@as(u32, @bitCast(@as(c_int, 1))))) @as([*c]u64, @ptrCast(@alignCast(&(blk: {
            const tmp = buf_pos;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).* else (@as(u64, @bitCast(@as(c_ulong, ntohl(@as(u32, @bitCast(@as(c_uint, @truncate(@as([*c]u64, @ptrCast(@alignCast(&(blk: {
            const tmp = buf_pos;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).* & @as(u64, @bitCast(@as(c_ulong, @as(c_uint, 4294967295)))))))))))) << @intCast(32)) | @as(u64, @bitCast(@as(c_ulong, ntohl(@as(u32, @bitCast(@as(c_uint, @truncate(@as([*c]u64, @ptrCast(@alignCast(&(blk: {
            const tmp = buf_pos;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).* >> @intCast(32)))))))));
        buf_pos += @as(c_int, 8);
    }
    if (((((((@as(c_int, @bitCast(@as(c_uint, version))) != @as(c_int, 772)) and (@as(c_int, @bitCast(@as(c_uint, version))) != @as(c_int, 771))) and (@as(c_int, @bitCast(@as(c_uint, version))) != @as(c_int, 770))) and (@as(c_int, @bitCast(@as(c_uint, version))) != @as(c_int, 769))) and (@as(c_int, @bitCast(@as(c_uint, version))) != @as(c_int, 65276))) and (@as(c_int, @bitCast(@as(c_uint, version))) != @as(c_int, 65277))) and (@as(c_int, @bitCast(@as(c_uint, version))) != @as(c_int, 65279))) {
        if ((@as(c_int, @bitCast(@as(c_uint, version))) == @as(c_int, 768)) and (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) == @as(c_int, 0))) {
            version = @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 771)))));
        } else {
            return -@as(c_int, 4);
        }
    }
    var length: c_ushort = undefined;
    _ = &length;
    length = ntohs(@as([*c]c_ushort, @ptrCast(@alignCast(&(blk: {
        const tmp = buf_pos;
        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*))).*);
    buf_pos += @as(c_int, 2);
    var pt: [*c]u8 = null;
    _ = &pt;
    var ptr: [*c]const u8 = buf + @as(usize, @bitCast(@as(isize, @intCast(buf_pos))));
    _ = &ptr;
    if (((buf_pos + @as(c_int, @bitCast(@as(c_uint, length)))) > buf_len) or (buf_len < @as(c_int, 0))) {
        return 0;
    }
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) != 0) and (@as(c_int, @bitCast(@as(c_uint, @"type"))) == @as(c_int, 22))) {
        if (!(dtls_epoch != 0)) {
            context.*.cipher_spec_set = 0;
        }
    }
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.cipher_spec_set))) != 0) and (@as(c_int, @bitCast(@as(c_uint, @"type"))) != @as(c_int, 20))) {
        if (!(context.*.crypto.created != 0)) {
            _private_random_sleep(context, @as(c_int, 1000000));
            return -@as(c_int, 2);
        }
        pt = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, length)))))));
        if (!(pt != null)) {
            _private_random_sleep(context, @as(c_int, 1000000));
            return -@as(c_int, 9);
        }
        var aad: [16]u8 = undefined;
        _ = &aad;
        var aad_size: c_int = @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([16]u8)))));
        _ = &aad_size;
        var sequence: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(&aad)));
        _ = &sequence;
        if (@as(c_int, @bitCast(@as(c_uint, context.*.crypto.created))) == @as(c_int, 2)) {
            var delta: c_int = 8;
            _ = &delta;
            var pt_length: c_int = undefined;
            _ = &pt_length;
            var iv: [12]u8 = undefined;
            _ = &iv;
            _ = gcm_reset(&context.*.crypto.ctx_remote.aes_gcm_remote);
            if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
                aad[@as(c_uint, @intCast(@as(c_int, 0)))] = 23;
                aad[@as(c_uint, @intCast(@as(c_int, 1)))] = 3;
                aad[@as(c_uint, @intCast(@as(c_int, 2)))] = 3;
                @as([*c]c_ushort, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&aad))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 3)))))))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(buf_len - header_size)))));
                aad_size = 5;
                sequence = @as([*c]u8, @ptrCast(@alignCast(&aad))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 5)))));
                if (context.*.dtls != 0) {
                    @as([*c]u64, @ptrCast(@alignCast(sequence))).* = @as([*c]u64, @ptrCast(@alignCast(buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 3)))))))).*;
                } else {
                    @as([*c]u64, @ptrCast(@alignCast(sequence))).* = if (@as(u32, @bitCast(@as(c_int, 1))) == htonl(@as(u32, @bitCast(@as(c_int, 1))))) context.*.remote_sequence_number else (@as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(context.*.remote_sequence_number & @as(u64, @bitCast(@as(c_ulong, @as(c_uint, 4294967295)))))))))))) << @intCast(32)) | @as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(context.*.remote_sequence_number >> @intCast(32)))))))));
                }
                _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&iv))))), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_iv))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 12)))));
                var i: c_int = undefined;
                _ = &i;
                var offset: c_int = @as(c_int, 12) - @as(c_int, 8);
                _ = &offset;
                {
                    i = 0;
                    while (i < @as(c_int, 8)) : (i += 1) {
                        iv[@as(c_uint, @intCast(offset + i))] = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, context.*.crypto.ctx_remote_mac.remote_iv[@as(c_uint, @intCast(offset + i))]))) ^ @as(c_int, @bitCast(@as(c_uint, (blk: {
                            const tmp = i;
                            if (tmp >= 0) break :blk sequence + @as(usize, @intCast(tmp)) else break :blk sequence - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                        }).*)))))));
                    }
                }
                pt_length = (buf_len - header_size) - @as(c_int, 16);
                delta = 0;
            } else {
                aad_size = 13;
                pt_length = (@as(c_int, @bitCast(@as(c_uint, length))) - @as(c_int, 8)) - @as(c_int, 16);
                if (context.*.dtls != 0) {
                    @as([*c]u64, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&aad)))))).* = if (@as(u32, @bitCast(@as(c_int, 1))) == htonl(@as(u32, @bitCast(@as(c_int, 1))))) dtls_sequence_number else (@as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(dtls_sequence_number & @as(u64, @bitCast(@as(c_ulong, @as(c_uint, 4294967295)))))))))))) << @intCast(32)) | @as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(dtls_sequence_number >> @intCast(32)))))))));
                } else {
                    @as([*c]u64, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&aad)))))).* = if (@as(u32, @bitCast(@as(c_int, 1))) == htonl(@as(u32, @bitCast(@as(c_int, 1))))) context.*.remote_sequence_number else (@as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(context.*.remote_sequence_number & @as(u64, @bitCast(@as(c_ulong, @as(c_uint, 4294967295)))))))))))) << @intCast(32)) | @as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(context.*.remote_sequence_number >> @intCast(32)))))))));
                }
                aad[@as(c_uint, @intCast(@as(c_int, 8)))] = buf[@as(c_uint, @intCast(@as(c_int, 0)))];
                aad[@as(c_uint, @intCast(@as(c_int, 9)))] = buf[@as(c_uint, @intCast(@as(c_int, 1)))];
                aad[@as(c_uint, @intCast(@as(c_int, 10)))] = buf[@as(c_uint, @intCast(@as(c_int, 2)))];
                _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&iv))))), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_aead_iv))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 4)))));
                _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&iv))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))), @as(?*const anyopaque, @ptrCast(buf + @as(usize, @bitCast(@as(isize, @intCast(header_size)))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8)))));
                @as([*c]c_ushort, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&aad))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 11)))))))).* = htons(@as(c_ushort, @bitCast(@as(c_short, @truncate(pt_length)))));
            }
            if (pt_length < @as(c_int, 0)) {
                if (pt != null) {
                    free(@as(?*anyopaque, @ptrCast(pt)));
                }
                _private_random_sleep(context, @as(c_int, 1000000));
                return -@as(c_int, 2);
            }
            var res0: c_int = gcm_add_iv(&context.*.crypto.ctx_remote.aes_gcm_remote, @as([*c]u8, @ptrCast(@alignCast(&iv))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 12)))));
            _ = &res0;
            var res1: c_int = gcm_add_aad(&context.*.crypto.ctx_remote.aes_gcm_remote, @as([*c]u8, @ptrCast(@alignCast(&aad))), @as(c_ulong, @bitCast(@as(c_long, aad_size))));
            _ = &res1;
            _ = memset(@as(?*anyopaque, @ptrCast(pt)), @as(c_int, 0), @as(c_ulong, @bitCast(@as(c_ulong, length))));
            var res2: c_int = gcm_process(&context.*.crypto.ctx_remote.aes_gcm_remote, pt, @as(c_ulong, @bitCast(@as(c_long, pt_length))), (buf + @as(usize, @bitCast(@as(isize, @intCast(header_size))))) + @as(usize, @bitCast(@as(isize, @intCast(delta)))), @as(c_int, 1));
            _ = &res2;
            var tag: [32]u8 = undefined;
            _ = &tag;
            var taglen: c_ulong = 32;
            _ = &taglen;
            var res3: c_int = gcm_done(&context.*.crypto.ctx_remote.aes_gcm_remote, @as([*c]u8, @ptrCast(@alignCast(&tag))), &taglen);
            _ = &res3;
            if (((((res0 != 0) or (res1 != 0)) or (res2 != 0)) or (res3 != 0)) or (taglen != @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16)))))) {
                _private_random_sleep(context, @as(c_int, 1000000));
                return -@as(c_int, 2);
            }
            if (memcmp(@as(?*const anyopaque, @ptrCast(((buf + @as(usize, @bitCast(@as(isize, @intCast(header_size))))) + @as(usize, @bitCast(@as(isize, @intCast(delta))))) + @as(usize, @bitCast(@as(isize, @intCast(pt_length)))))), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&tag))))), taglen) != 0) {
                if (pt != null) {
                    free(@as(?*anyopaque, @ptrCast(pt)));
                }
                if (context.*.dtls != 0) return header_size + @as(c_int, @bitCast(@as(c_uint, length)));
                _private_random_sleep(context, @as(c_int, 1000000));
                _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(bad_record_mac))))));
                return -@as(c_int, 11);
            }
            ptr = pt;
            length = @as(c_ushort, @bitCast(@as(c_short, @truncate(pt_length))));
        } else if (@as(c_int, @bitCast(@as(c_uint, context.*.crypto.created))) == @as(c_int, 3)) {
            var pt_length: c_int = @as(c_int, @bitCast(@as(c_uint, length))) - @as(c_int, 16);
            _ = &pt_length;
            var counter: c_uint = 1;
            _ = &counter;
            var poly1305_key: [32]u8 = undefined;
            _ = &poly1305_key;
            var trail: [16]u8 = undefined;
            _ = &trail;
            var mac_tag: [16]u8 = undefined;
            _ = &mac_tag;
            aad_size = 16;
            if (pt_length < @as(c_int, 0)) {
                if (pt != null) {
                    free(@as(?*anyopaque, @ptrCast(pt)));
                }
                _private_random_sleep(context, @as(c_int, 1000000));
                return -@as(c_int, 2);
            }
            if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
                aad[@as(c_uint, @intCast(@as(c_int, 0)))] = 23;
                aad[@as(c_uint, @intCast(@as(c_int, 1)))] = 3;
                aad[@as(c_uint, @intCast(@as(c_int, 2)))] = 3;
                @as([*c]c_ushort, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&aad))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 3)))))))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(buf_len - header_size)))));
                aad_size = 5;
                sequence = @as([*c]u8, @ptrCast(@alignCast(&aad))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 5)))));
                if (context.*.dtls != 0) {
                    @as([*c]u64, @ptrCast(@alignCast(sequence))).* = @as([*c]u64, @ptrCast(@alignCast(buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 3)))))))).*;
                } else {
                    @as([*c]u64, @ptrCast(@alignCast(sequence))).* = if (@as(u32, @bitCast(@as(c_int, 1))) == htonl(@as(u32, @bitCast(@as(c_int, 1))))) context.*.remote_sequence_number else (@as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(context.*.remote_sequence_number & @as(u64, @bitCast(@as(c_ulong, @as(c_uint, 4294967295)))))))))))) << @intCast(32)) | @as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(context.*.remote_sequence_number >> @intCast(32)))))))));
                }
            } else {
                if (context.*.dtls != 0) {
                    @as([*c]u64, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&aad)))))).* = if (@as(u32, @bitCast(@as(c_int, 1))) == htonl(@as(u32, @bitCast(@as(c_int, 1))))) dtls_sequence_number else (@as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(dtls_sequence_number & @as(u64, @bitCast(@as(c_ulong, @as(c_uint, 4294967295)))))))))))) << @intCast(32)) | @as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(dtls_sequence_number >> @intCast(32)))))))));
                } else {
                    @as([*c]u64, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&aad)))))).* = if (@as(u32, @bitCast(@as(c_int, 1))) == htonl(@as(u32, @bitCast(@as(c_int, 1))))) context.*.remote_sequence_number else (@as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(context.*.remote_sequence_number & @as(u64, @bitCast(@as(c_ulong, @as(c_uint, 4294967295)))))))))))) << @intCast(32)) | @as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(context.*.remote_sequence_number >> @intCast(32)))))))));
                }
                aad[@as(c_uint, @intCast(@as(c_int, 8)))] = buf[@as(c_uint, @intCast(@as(c_int, 0)))];
                aad[@as(c_uint, @intCast(@as(c_int, 9)))] = buf[@as(c_uint, @intCast(@as(c_int, 1)))];
                aad[@as(c_uint, @intCast(@as(c_int, 10)))] = buf[@as(c_uint, @intCast(@as(c_int, 2)))];
                @as([*c]c_ushort, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&aad))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 11)))))))).* = htons(@as(c_ushort, @bitCast(@as(c_short, @truncate(pt_length)))));
                aad[@as(c_uint, @intCast(@as(c_int, 13)))] = 0;
                aad[@as(c_uint, @intCast(@as(c_int, 14)))] = 0;
                aad[@as(c_uint, @intCast(@as(c_int, 15)))] = 0;
            }
            chacha_ivupdate(&context.*.crypto.ctx_remote.chacha_remote, @as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_aead_iv))), sequence, @as([*c]u8, @ptrCast(@alignCast(&counter))));
            chacha_encrypt_bytes(&context.*.crypto.ctx_remote.chacha_remote, buf + @as(usize, @bitCast(@as(isize, @intCast(header_size)))), pt, @as(c_uint, @bitCast(pt_length)));
            ptr = pt;
            length = @as(c_ushort, @bitCast(@as(c_short, @truncate(pt_length))));
            chacha20_poly1305_key(&context.*.crypto.ctx_remote.chacha_remote, @as([*c]u8, @ptrCast(@alignCast(&poly1305_key))));
            var ctx: poly1305_state_internal_t = undefined;
            _ = &ctx;
            _private_tls_poly1305_init(&ctx, @as([*c]u8, @ptrCast(@alignCast(&poly1305_key))));
            _private_tls_poly1305_update(&ctx, @as([*c]u8, @ptrCast(@alignCast(&aad))), @as(usize, @bitCast(@as(c_long, aad_size))));
            const zeropad = struct {
                var static: [15]u8 = [15]u8{
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                };
            };
            _ = &zeropad;
            var rem: c_int = @import("std").zig.c_translation.signedRemainder(aad_size, @as(c_int, 16));
            _ = &rem;
            if (rem != 0) {
                _private_tls_poly1305_update(&ctx, @as([*c]u8, @ptrCast(@alignCast(&zeropad.static))), @as(usize, @bitCast(@as(c_long, @as(c_int, 16) - rem))));
            }
            _private_tls_poly1305_update(&ctx, buf + @as(usize, @bitCast(@as(isize, @intCast(header_size)))), @as(usize, @bitCast(@as(c_long, pt_length))));
            rem = @import("std").zig.c_translation.signedRemainder(pt_length, @as(c_int, 16));
            if (rem != 0) {
                _private_tls_poly1305_update(&ctx, @as([*c]u8, @ptrCast(@alignCast(&zeropad.static))), @as(usize, @bitCast(@as(c_long, @as(c_int, 16) - rem))));
            }
            _private_tls_U32TO8(&trail[@as(c_uint, @intCast(@as(c_int, 0)))], @as(c_ulong, @bitCast(@as(c_long, if (aad_size == @as(c_int, 5)) @as(c_int, 5) else @as(c_int, 13)))));
            @as([*c]c_int, @ptrCast(@alignCast(&trail[@as(c_uint, @intCast(@as(c_int, 4)))]))).* = 0;
            _private_tls_U32TO8(&trail[@as(c_uint, @intCast(@as(c_int, 8)))], @as(c_ulong, @bitCast(@as(c_long, pt_length))));
            @as([*c]c_int, @ptrCast(@alignCast(&trail[@as(c_uint, @intCast(@as(c_int, 12)))]))).* = 0;
            _private_tls_poly1305_update(&ctx, @as([*c]u8, @ptrCast(@alignCast(&trail))), @as(usize, @bitCast(@as(c_long, @as(c_int, 16)))));
            _private_tls_poly1305_finish(&ctx, @as([*c]u8, @ptrCast(@alignCast(&mac_tag))));
            if (memcmp(@as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&mac_tag))))), @as(?*const anyopaque, @ptrCast((buf + @as(usize, @bitCast(@as(isize, @intCast(header_size))))) + @as(usize, @bitCast(@as(isize, @intCast(pt_length)))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16))))) != 0) {
                if (pt != null) {
                    free(@as(?*anyopaque, @ptrCast(pt)));
                }
                if (context.*.dtls != 0) return header_size + @as(c_int, @bitCast(@as(c_uint, length)));
                _private_random_sleep(context, @as(c_int, 1000000));
                _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(bad_record_mac))))));
                return -@as(c_int, 11);
            }
        } else {
            var err: c_int = _private_tls_crypto_decrypt(context, buf + @as(usize, @bitCast(@as(isize, @intCast(header_size)))), pt, @as(c_uint, @bitCast(@as(c_uint, length))));
            _ = &err;
            if (err != 0) {
                if (pt != null) {
                    free(@as(?*anyopaque, @ptrCast(pt)));
                }
                _private_random_sleep(context, @as(c_int, 1000000));
                return -@as(c_int, 2);
            }
            var padding_byte: u8 = (blk: {
                const tmp = @as(c_int, @bitCast(@as(c_uint, length))) - @as(c_int, 1);
                if (tmp >= 0) break :blk pt + @as(usize, @intCast(tmp)) else break :blk pt - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
            _ = &padding_byte;
            var padding: u8 = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, padding_byte))) + @as(c_int, 1)))));
            _ = &padding;
            var padding_index: c_int = @as(c_int, @bitCast(@as(c_uint, length))) - @as(c_int, @bitCast(@as(c_uint, padding)));
            _ = &padding_index;
            if (padding_index > @as(c_int, 0)) {
                var i: c_int = undefined;
                _ = &i;
                var limit: c_int = @as(c_int, @bitCast(@as(c_uint, length))) - @as(c_int, 1);
                _ = &limit;
                {
                    i = @as(c_int, @bitCast(@as(c_uint, length))) - @as(c_int, @bitCast(@as(c_uint, padding)));
                    while (i < limit) : (i += 1) {
                        if (@as(c_int, @bitCast(@as(c_uint, (blk: {
                            const tmp = i;
                            if (tmp >= 0) break :blk pt + @as(usize, @intCast(tmp)) else break :blk pt - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                        }).*))) != @as(c_int, @bitCast(@as(c_uint, padding_byte)))) {
                            if (pt != null) {
                                free(@as(?*anyopaque, @ptrCast(pt)));
                            }
                            _private_random_sleep(context, @as(c_int, 1000000));
                            _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(decrypt_error))))));
                            return -@as(c_int, 2);
                        }
                    }
                }
            }
            var decrypted_length: c_uint = @as(c_uint, @bitCast(@as(c_uint, length)));
            _ = &decrypted_length;
            if (@as(c_uint, @bitCast(@as(c_uint, padding))) < decrypted_length) {
                decrypted_length -%= @as(c_uint, @bitCast(@as(c_uint, padding)));
            }
            ptr = pt;
            if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) != @as(c_int, 769)) and (decrypted_length > @as(c_uint, @bitCast(@as(c_int, 16))))) {
                decrypted_length -%= @as(c_uint, @bitCast(@as(c_int, 16)));
                ptr += @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16)))));
            }
            length = @as(c_ushort, @bitCast(@as(c_ushort, @truncate(decrypted_length))));
            var mac_size: c_uint = _private_tls_mac_length(context);
            _ = &mac_size;
            if ((@as(c_uint, @bitCast(@as(c_uint, length))) < mac_size) or !(mac_size != 0)) {
                if (pt != null) {
                    free(@as(?*anyopaque, @ptrCast(pt)));
                }
                _private_random_sleep(context, @as(c_int, 1000000));
                _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(decrypt_error))))));
                return -@as(c_int, 2);
            }
            length -%= @as(c_ushort, @bitCast(@as(c_ushort, @truncate(mac_size))));
            var message_hmac: [*c]const u8 = &ptr[length];
            _ = &message_hmac;
            var hmac_out: [48]u8 = undefined;
            _ = &hmac_out;
            var temp_buf: [5]u8 = undefined;
            _ = &temp_buf;
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&temp_buf))))), @as(?*const anyopaque, @ptrCast(buf)), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3)))));
            @as([*c]c_ushort, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&temp_buf))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 3)))))))).* = htons(length);
            var hmac_out_len: c_uint = _private_tls_hmac_message(@as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))), context, @as([*c]u8, @ptrCast(@alignCast(&temp_buf))), @as(c_int, 5), ptr, @as(c_int, @bitCast(@as(c_uint, length))), @as([*c]u8, @ptrCast(@alignCast(&hmac_out))), mac_size, dtls_sequence_number);
            _ = &hmac_out_len;
            if ((hmac_out_len != mac_size) or (memcmp(@as(?*const anyopaque, @ptrCast(message_hmac)), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&hmac_out))))), @as(c_ulong, @bitCast(@as(c_ulong, mac_size)))) != 0)) {
                if (pt != null) {
                    free(@as(?*anyopaque, @ptrCast(pt)));
                }
                if (context.*.dtls != 0) return header_size + @as(c_int, @bitCast(@as(c_uint, length)));
                _private_random_sleep(context, @as(c_int, 1000000));
                _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(bad_record_mac))))));
                return -@as(c_int, 11);
            }
        }
    }
    if (context.*.dtls != 0) {
        context.*.dtls_epoch_remote = dtls_epoch;
        context.*.remote_sequence_number = @as(u64, @bitCast(@as(c_ulong, @truncate(@as(c_ulonglong, @bitCast(@as(c_ulonglong, dtls_sequence_number))) & @as(c_ulonglong, @bitCast(@as(c_longlong, 281474976710655)))))));
    } else {
        context.*.remote_sequence_number +%= 1;
    }
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
        if ((@as(c_int, @bitCast(@as(c_uint, @"type"))) == @as(c_int, 23)) and (@as(c_int, @bitCast(@as(c_uint, context.*.crypto.created))) != 0)) {
            while (true) {
                length -%= 1;
                @"type" = ptr[length];
                if (!!(@"type" != 0)) break;
            }
        }
    }
    while (true) {
        switch (@as(c_int, @bitCast(@as(c_uint, @"type")))) {
            @as(c_int, 23) => {
                if (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) != @as(c_int, 255)) {
                    payload_res = -@as(c_int, 6);
                    _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(unexpected_message))))));
                } else {
                    _ = _private_tls_write_app_data(context, ptr, @as(c_uint, @bitCast(@as(c_uint, length))));
                }
                break;
            },
            @as(c_int, 22) => {
                {}
                payload_res = tls_parse_payload(context, ptr, @as(c_int, @bitCast(@as(c_uint, length))), certificate_verify);
                break;
            },
            @as(c_int, 20) => {
                context.*.dtls_epoch_remote +%= 1;
                if ((@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) != @as(c_int, 2)) and !(context.*.dtls != 0)) {
                    if (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) == @as(c_int, 4)) {
                        break;
                    }
                    _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))), @as(u8, @bitCast(@as(i8, @truncate(unexpected_message))))));
                    payload_res = -@as(c_int, 6);
                } else {
                    context.*.cipher_spec_set = 1;
                    context.*.remote_sequence_number = 0;
                }
                if (!(context.*.is_server != 0)) {
                    _ = _private_tls13_key(context, @as(c_int, 1));
                }
                break;
            },
            @as(c_int, 21) => {
                {}
                if (@as(c_int, @bitCast(@as(c_uint, length))) >= @as(c_int, 2)) {
                    var level: c_int = @as(c_int, @bitCast(@as(c_uint, ptr[@as(c_uint, @intCast(@as(c_int, 0)))])));
                    _ = &level;
                    var code: c_int = @as(c_int, @bitCast(@as(c_uint, ptr[@as(c_uint, @intCast(@as(c_int, 1)))])));
                    _ = &code;
                    if (level == @as(c_int, 2)) {
                        context.*.critical_error = 1;
                        res = -@as(c_int, 12);
                    }
                    context.*.error_code = @as(u8, @bitCast(@as(i8, @truncate(code))));
                }
                break;
            },
            else => {
                {}
                if (pt != null) {
                    free(@as(?*anyopaque, @ptrCast(pt)));
                }
                return -@as(c_int, 3);
            },
        }
        break;
    }
    if (pt != null) {
        free(@as(?*anyopaque, @ptrCast(pt)));
    }
    if (payload_res < @as(c_int, 0)) return payload_res;
    if (res > @as(c_int, 0)) return header_size + @as(c_int, @bitCast(@as(c_uint, length)));
    return res;
}
pub export fn tls_certificate_verify_signature(arg_cert: [*c]struct_TLSCertificate, arg_parent: [*c]struct_TLSCertificate) c_int {
    var cert = arg_cert;
    _ = &cert;
    var parent = arg_parent;
    _ = &parent;
    if ((((((!(cert != null) or !(parent != null)) or !(cert.*.sign_key != null)) or !(cert.*.fingerprint != null)) or !(cert.*.sign_len != 0)) or !(parent.*.der_bytes != null)) or !(parent.*.der_len != 0)) {
        return 0;
    }
    tls_init();
    var hash_len: c_int = _private_tls_hash_len(@as(c_int, @bitCast(cert.*.algorithm)));
    _ = &hash_len;
    if (hash_len <= @as(c_int, 0)) return 0;
    var hash_index: c_int = -@as(c_int, 1);
    _ = &hash_index;
    while (true) {
        switch (cert.*.algorithm) {
            @as(c_uint, @bitCast(@as(c_int, 4))) => {
                hash_index = find_hash("md5");
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 5))) => {
                hash_index = find_hash("sha1");
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 10))), @as(c_uint, @bitCast(@as(c_int, 15))) => {
                hash_index = find_hash("sha224");
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 11))), @as(c_uint, @bitCast(@as(c_int, 14))) => {
                hash_index = find_hash("sha256");
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 12))), @as(c_uint, @bitCast(@as(c_int, 16))) => {
                hash_index = find_hash("sha384");
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 13))), @as(c_uint, @bitCast(@as(c_int, 26))) => {
                hash_index = find_hash("sha512");
                break;
            },
            else => {
                {}
                return 0;
            },
        }
        break;
    }
    if ((((cert.*.algorithm == @as(c_uint, @bitCast(@as(c_int, 15)))) or (cert.*.algorithm == @as(c_uint, @bitCast(@as(c_int, 14))))) or (cert.*.algorithm == @as(c_uint, @bitCast(@as(c_int, 16))))) or (cert.*.algorithm == @as(c_uint, @bitCast(@as(c_int, 26))))) {
        var key: ecc_key = undefined;
        _ = &key;
        var err: c_int = ecc_import(parent.*.der_bytes, @as(c_ulong, @bitCast(@as(c_ulong, parent.*.der_len))), &key);
        _ = &err;
        if (err != 0) {
            return 0;
        }
        var ecc_stat: c_int = 0;
        _ = &ecc_stat;
        var signature: [*c]u8 = cert.*.sign_key;
        _ = &signature;
        var signature_len: c_int = @as(c_int, @bitCast(cert.*.sign_len));
        _ = &signature_len;
        if (!(signature[@as(c_uint, @intCast(@as(c_int, 0)))] != 0)) {
            signature += 1;
            signature_len -= 1;
        }
        err = ecc_verify_hash(signature, @as(c_ulong, @bitCast(@as(c_long, signature_len))), cert.*.fingerprint, @as(c_ulong, @bitCast(@as(c_long, hash_len))), &ecc_stat, &key);
        ecc_free(&key);
        if (err != 0) {
            return 0;
        }
        return ecc_stat;
    }
    var key: rsa_key = undefined;
    _ = &key;
    var err: c_int = rsa_import(parent.*.der_bytes, @as(c_ulong, @bitCast(@as(c_ulong, parent.*.der_len))), &key);
    _ = &err;
    if (err != 0) {
        return 0;
    }
    var rsa_stat: c_int = 0;
    _ = &rsa_stat;
    var signature: [*c]u8 = cert.*.sign_key;
    _ = &signature;
    var signature_len: c_int = @as(c_int, @bitCast(cert.*.sign_len));
    _ = &signature_len;
    if (!(signature[@as(c_uint, @intCast(@as(c_int, 0)))] != 0)) {
        signature += 1;
        signature_len -= 1;
    }
    err = rsa_verify_hash_ex(signature, @as(c_ulong, @bitCast(@as(c_long, signature_len))), cert.*.fingerprint, @as(c_ulong, @bitCast(@as(c_long, hash_len))), LTC_LTC_PKCS_1_V1_5, hash_index, @as(c_ulong, @bitCast(@as(c_long, hash_len))), &rsa_stat, &key);
    rsa_free(&key);
    if (err != 0) {
        return 0;
    }
    return rsa_stat;
}
pub export fn tls_certificate_chain_is_valid(arg_certificates: [*c][*c]struct_TLSCertificate, arg_len: c_int) c_int {
    var certificates = arg_certificates;
    _ = &certificates;
    var len = arg_len;
    _ = &len;
    if (!(certificates != null) or !(len != 0)) return bad_certificate;
    var i: c_int = undefined;
    _ = &i;
    len -= 1;
    if (tls_certificate_is_valid(certificates[@as(c_uint, @intCast(@as(c_int, 0)))]) != 0) return bad_certificate;
    {
        i = 0;
        while (i < len) : (i += 1) {
            if (tls_certificate_is_valid((blk: {
                const tmp = i + @as(c_int, 1);
                if (tmp >= 0) break :blk certificates + @as(usize, @intCast(tmp)) else break :blk certificates - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*) != 0) return bad_certificate;
            if (!((blk: {
                const tmp = i + @as(c_int, 1);
                if (tmp >= 0) break :blk certificates + @as(usize, @intCast(tmp)) else break :blk certificates - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* != null) or !((blk: {
                const tmp = i + @as(c_int, 1);
                if (tmp >= 0) break :blk certificates + @as(usize, @intCast(tmp)) else break :blk certificates - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*.*.fingerprint != null)) break;
            if (!(tls_certificate_verify_signature((blk: {
                const tmp = i;
                if (tmp >= 0) break :blk certificates + @as(usize, @intCast(tmp)) else break :blk certificates - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*, (blk: {
                const tmp = i + @as(c_int, 1);
                if (tmp >= 0) break :blk certificates + @as(usize, @intCast(tmp)) else break :blk certificates - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*) != 0)) return bad_certificate;
        }
    }
    return 0;
}
pub export fn tls_certificate_chain_is_valid_root(arg_context: [*c]struct_TLSContext, arg_certificates: [*c][*c]struct_TLSCertificate, arg_len: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var certificates = arg_certificates;
    _ = &certificates;
    var len = arg_len;
    _ = &len;
    if (((!(certificates != null) or !(len != 0)) or !(context.*.root_certificates != null)) or !(context.*.root_count != 0)) return bad_certificate;
    var i: c_int = undefined;
    _ = &i;
    var j: c_uint = undefined;
    _ = &j;
    {
        i = 0;
        while (i < len) : (i += 1) {
            {
                j = 0;
                while (j < context.*.root_count) : (j +%= 1) {
                    if (tls_certificate_is_valid(context.*.root_certificates[j]) != 0) continue;
                    if (tls_certificate_verify_signature((blk: {
                        const tmp = i;
                        if (tmp >= 0) break :blk certificates + @as(usize, @intCast(tmp)) else break :blk certificates - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).*, context.*.root_certificates[j]) != 0) return 0;
                }
            }
        }
    }
    return bad_certificate;
}
pub export fn tls_load_certificates(arg_context: [*c]struct_TLSContext, arg_pem_buffer: [*c]const u8, arg_pem_size: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var pem_buffer = arg_pem_buffer;
    _ = &pem_buffer;
    var pem_size = arg_pem_size;
    _ = &pem_size;
    if (!(context != null)) return -@as(c_int, 1);
    var len: c_uint = undefined;
    _ = &len;
    var idx: c_int = 0;
    _ = &idx;
    while (true) {
        var data: [*c]u8 = tls_pem_decode(pem_buffer, @as(c_uint, @bitCast(pem_size)), blk: {
            const ref = &idx;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }, &len);
        _ = &data;
        if (!(data != null) or !(len != 0)) break;
        var cert: [*c]struct_TLSCertificate = asn1_parse(context, data, len, @as(c_int, 0));
        _ = &cert;
        if (cert != null) {
            if ((@as(c_int, @bitCast(@as(c_uint, cert.*.version))) == @as(c_int, 2)) or (@as(c_int, @bitCast(@as(c_uint, cert.*.version))) == @as(c_int, 0))) {
                if (cert.*.der_bytes != null) {
                    free(@as(?*anyopaque, @ptrCast(cert.*.der_bytes)));
                }
                cert.*.der_bytes = data;
                cert.*.der_len = len;
                data = null;
                if (cert.*.priv != null) {
                    if (cert.*.priv != null) {
                        free(@as(?*anyopaque, @ptrCast(cert.*.priv)));
                    }
                    cert.*.priv = null;
                    cert.*.priv_len = 0;
                }
                if (context.*.is_server != 0) {
                    context.*.certificates = @as([*c][*c]struct_TLSCertificate, @ptrCast(@alignCast(realloc(@as(?*anyopaque, @ptrCast(context.*.certificates)), @as(c_ulong, @bitCast(@as(c_ulong, context.*.certificates_count +% @as(c_uint, @bitCast(@as(c_int, 1)))))) *% @sizeOf([*c]struct_TLSCertificate)))));
                    context.*.certificates[context.*.certificates_count] = cert;
                    context.*.certificates_count +%= 1;
                } else {
                    context.*.client_certificates = @as([*c][*c]struct_TLSCertificate, @ptrCast(@alignCast(realloc(@as(?*anyopaque, @ptrCast(context.*.client_certificates)), @as(c_ulong, @bitCast(@as(c_ulong, context.*.client_certificates_count +% @as(c_uint, @bitCast(@as(c_int, 1)))))) *% @sizeOf([*c]struct_TLSCertificate)))));
                    context.*.client_certificates[context.*.client_certificates_count] = cert;
                    context.*.client_certificates_count +%= 1;
                }
            } else {
                tls_destroy_certificate(cert);
            }
        }
        if (data != null) {
            free(@as(?*anyopaque, @ptrCast(data)));
        }
    }
    if (context.*.is_server != 0) return @as(c_int, @bitCast(context.*.certificates_count));
    return @as(c_int, @bitCast(context.*.client_certificates_count));
}
pub export fn tls_load_private_key(arg_context: [*c]struct_TLSContext, arg_pem_buffer: [*c]const u8, arg_pem_size: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var pem_buffer = arg_pem_buffer;
    _ = &pem_buffer;
    var pem_size = arg_pem_size;
    _ = &pem_size;
    if (!(context != null)) return -@as(c_int, 1);
    var len: c_uint = undefined;
    _ = &len;
    var idx: c_int = 0;
    _ = &idx;
    while (true) {
        var data: [*c]u8 = tls_pem_decode(pem_buffer, @as(c_uint, @bitCast(pem_size)), blk: {
            const ref = &idx;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }, &len);
        _ = &data;
        if (!(data != null) or !(len != 0)) break;
        var cert: [*c]struct_TLSCertificate = asn1_parse(context, data, len, -@as(c_int, 1));
        _ = &cert;
        if (cert != null) {
            if (!(cert.*.der_len != 0)) {
                if (cert.*.der_bytes != null) {
                    free(@as(?*anyopaque, @ptrCast(cert.*.der_bytes)));
                }
                cert.*.der_bytes = data;
                cert.*.der_len = len;
            } else if (data != null) {
                free(@as(?*anyopaque, @ptrCast(data)));
            }
            if (((cert != null) and (cert.*.priv != null)) and (cert.*.priv_len != 0)) {
                if (cert.*.ec_algorithm != 0) {
                    if (context.*.ec_private_key != null) {
                        tls_destroy_certificate(context.*.ec_private_key);
                    }
                    context.*.ec_private_key = cert;
                    return 1;
                } else {
                    if (context.*.private_key != null) {
                        tls_destroy_certificate(context.*.private_key);
                    }
                    context.*.private_key = cert;
                    return 1;
                }
            }
            tls_destroy_certificate(cert);
        } else if (data != null) {
            free(@as(?*anyopaque, @ptrCast(data)));
        }
    }
    return 0;
}
pub export fn tls_build_certificate(arg_context: [*c]struct_TLSContext) [*c]struct_TLSPacket {
    var context = arg_context;
    _ = &context;
    var i: c_int = undefined;
    _ = &i;
    var all_certificate_size: c_uint = 0;
    _ = &all_certificate_size;
    var certificates_count: c_int = undefined;
    _ = &certificates_count;
    var certificates: [*c][*c]struct_TLSCertificate = undefined;
    _ = &certificates;
    if (context.*.is_server != 0) {
        certificates_count = @as(c_int, @bitCast(context.*.certificates_count));
        certificates = context.*.certificates;
    } else {
        certificates_count = @as(c_int, @bitCast(context.*.client_certificates_count));
        certificates = context.*.client_certificates;
    }
    var delta: c_int = 3;
    _ = &delta;
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
        delta = 5;
    }
    var is_ecdsa: c_int = tls_is_ecdsa(context);
    _ = &is_ecdsa;
    if (is_ecdsa != 0) {
        {
            i = 0;
            while (i < certificates_count) : (i += 1) {
                var cert: [*c]struct_TLSCertificate = (blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk certificates + @as(usize, @intCast(tmp)) else break :blk certificates - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*;
                _ = &cert;
                if (((cert != null) and (cert.*.der_len != 0)) and (cert.*.ec_algorithm != 0)) {
                    all_certificate_size +%= cert.*.der_len +% @as(c_uint, @bitCast(delta));
                }
            }
        }
        if (!(all_certificate_size != 0)) {
            {
                i = 0;
                while (i < certificates_count) : (i += 1) {
                    var cert: [*c]struct_TLSCertificate = (blk: {
                        const tmp = i;
                        if (tmp >= 0) break :blk certificates + @as(usize, @intCast(tmp)) else break :blk certificates - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).*;
                    _ = &cert;
                    if ((cert != null) and (cert.*.der_len != 0)) {
                        all_certificate_size +%= cert.*.der_len +% @as(c_uint, @bitCast(delta));
                    }
                }
            }
        }
    } else {
        {
            i = 0;
            while (i < certificates_count) : (i += 1) {
                var cert: [*c]struct_TLSCertificate = (blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk certificates + @as(usize, @intCast(tmp)) else break :blk certificates - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*;
                _ = &cert;
                if (((cert != null) and (cert.*.der_len != 0)) and !(cert.*.ec_algorithm != 0)) {
                    all_certificate_size +%= cert.*.der_len +% @as(c_uint, @bitCast(delta));
                }
            }
        }
    }
    if (!(all_certificate_size != 0)) {}
    var packet: [*c]struct_TLSPacket = tls_create_packet(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 22))))), context.*.version, @as(c_int, 0));
    _ = &packet;
    _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 11))))));
    if (all_certificate_size != 0) {
        if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
            _ = tls_packet_uint24(packet, all_certificate_size +% @as(c_uint, @bitCast(@as(c_int, 4))));
            _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
        } else {
            _ = tls_packet_uint24(packet, all_certificate_size +% @as(c_uint, @bitCast(@as(c_int, 3))));
        }
        if (context.*.dtls != 0) {
            _private_dtls_handshake_data(context, packet, all_certificate_size +% @as(c_uint, @bitCast(@as(c_int, 3))));
        }
        _ = tls_packet_uint24(packet, all_certificate_size);
        {
            i = 0;
            while (i < certificates_count) : (i += 1) {
                var cert: [*c]struct_TLSCertificate = (blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk certificates + @as(usize, @intCast(tmp)) else break :blk certificates - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*;
                _ = &cert;
                if ((cert != null) and (cert.*.der_len != 0)) {
                    if ((is_ecdsa != 0) and !(cert.*.ec_algorithm != 0)) continue;
                    if (!(is_ecdsa != 0) and (cert.*.ec_algorithm != 0)) continue;
                    _ = tls_packet_uint24(packet, cert.*.der_len);
                    _ = tls_packet_append(packet, cert.*.der_bytes, cert.*.der_len);
                    if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
                        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 0))))));
                    }
                }
            }
        }
    } else {
        _ = tls_packet_uint24(packet, all_certificate_size);
        if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
            _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
        }
        if (context.*.dtls != 0) {
            _private_dtls_handshake_data(context, packet, all_certificate_size);
        }
    }
    tls_packet_update(packet);
    if (context.*.dtls != 0) {
        context.*.dtls_seq +%= 1;
    }
    return packet;
}
pub export fn tls_build_finished(arg_context: [*c]struct_TLSContext) [*c]struct_TLSPacket {
    var context = arg_context;
    _ = &context;
    var packet: [*c]struct_TLSPacket = tls_create_packet(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 22))))), context.*.version, @as(c_int, 12) + @as(c_int, 64));
    _ = &packet;
    _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 20))))));
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
        _ = tls_packet_uint24(packet, _private_tls_mac_length(context));
    } else {
        _ = tls_packet_uint24(packet, @as(c_uint, @bitCast(@as(c_int, 12))));
    }
    if (context.*.dtls != 0) {
        _private_dtls_handshake_data(context, packet, @as(c_uint, @bitCast(@as(c_int, 12))));
    }
    var hash: [48]u8 = undefined;
    _ = &hash;
    var out_size: c_ulong = 12;
    _ = &out_size;
    var out: [48]u8 = undefined;
    _ = &out;
    var hash_len: c_uint = undefined;
    _ = &hash_len;
    if (context.*.is_server != 0) {
        if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
            hash_len = @as(c_uint, @bitCast(_private_tls_get_hash(context, @as([*c]u8, @ptrCast(@alignCast(&hash))))));
            if (!(context.*.finished_key != null) or !(hash_len != 0)) {
                packet.*.broken = 1;
                return packet;
            }
            out_size = @as(c_ulong, @bitCast(@as(c_ulong, hash_len)));
            var hmac: hmac_state = undefined;
            _ = &hmac;
            _ = hmac_init(&hmac, _private_tls_get_hash_idx(context), context.*.finished_key, @as(c_ulong, @bitCast(@as(c_ulong, hash_len))));
            _ = hmac_process(&hmac, @as([*c]u8, @ptrCast(@alignCast(&hash))), @as(c_ulong, @bitCast(@as(c_ulong, hash_len))));
            _ = hmac_done(&hmac, @as([*c]u8, @ptrCast(@alignCast(&out))), &out_size);
        } else {
            hash_len = @as(c_uint, @bitCast(_private_tls_done_hash(context, @as([*c]u8, @ptrCast(@alignCast(&hash))))));
            _private_tls_prf(context, @as([*c]u8, @ptrCast(@alignCast(&out))), @as(c_uint, @bitCast(@as(c_int, 12))), context.*.master_key, context.*.master_key_len, @as([*c]u8, @ptrCast(@alignCast("server finished"))), @as(c_uint, @bitCast(@as(c_int, 15))), @as([*c]u8, @ptrCast(@alignCast(&hash))), hash_len, null, @as(c_uint, @bitCast(@as(c_int, 0))));
            _private_tls_destroy_hash(context);
        }
    } else {
        if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
            hash_len = @as(c_uint, @bitCast(_private_tls_get_hash(context, @as([*c]u8, @ptrCast(@alignCast(&hash))))));
            if (!(context.*.finished_key != null) or !(hash_len != 0)) {
                packet.*.broken = 1;
                return packet;
            }
            if (context.*.server_finished_hash != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.server_finished_hash)));
            }
            context.*.server_finished_hash = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, hash_len)))))));
            if (context.*.server_finished_hash != null) {
                _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.server_finished_hash)), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&hash))))), @as(c_ulong, @bitCast(@as(c_ulong, hash_len))));
            }
            out_size = @as(c_ulong, @bitCast(@as(c_ulong, hash_len)));
            var hmac: hmac_state = undefined;
            _ = &hmac;
            _ = hmac_init(&hmac, _private_tls_get_hash_idx(context), context.*.finished_key, @as(c_ulong, @bitCast(@as(c_ulong, hash_len))));
            _ = hmac_process(&hmac, @as([*c]u8, @ptrCast(@alignCast(&hash))), @as(c_ulong, @bitCast(@as(c_ulong, hash_len))));
            _ = hmac_done(&hmac, @as([*c]u8, @ptrCast(@alignCast(&out))), &out_size);
        } else {
            hash_len = @as(c_uint, @bitCast(_private_tls_get_hash(context, @as([*c]u8, @ptrCast(@alignCast(&hash))))));
            _private_tls_prf(context, @as([*c]u8, @ptrCast(@alignCast(&out))), @as(c_uint, @bitCast(@as(c_int, 12))), context.*.master_key, context.*.master_key_len, @as([*c]u8, @ptrCast(@alignCast("client finished"))), @as(c_uint, @bitCast(@as(c_int, 15))), @as([*c]u8, @ptrCast(@alignCast(&hash))), hash_len, null, @as(c_uint, @bitCast(@as(c_int, 0))));
        }
    }
    _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&out))), @as(c_uint, @bitCast(@as(c_uint, @truncate(out_size)))));
    tls_packet_update(packet);
    return packet;
}
pub export fn tls_build_change_cipher_spec(arg_context: [*c]struct_TLSContext) [*c]struct_TLSPacket {
    var context = arg_context;
    _ = &context;
    var packet: [*c]struct_TLSPacket = tls_create_packet(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 20))))), context.*.version, @as(c_int, 64));
    _ = &packet;
    _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))));
    tls_packet_update(packet);
    context.*.local_sequence_number = 0;
    return packet;
}
pub export fn tls_build_done(arg_context: [*c]struct_TLSContext) [*c]struct_TLSPacket {
    var context = arg_context;
    _ = &context;
    var packet: [*c]struct_TLSPacket = tls_create_packet(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 22))))), context.*.version, @as(c_int, 0));
    _ = &packet;
    _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 14))))));
    _ = tls_packet_uint24(packet, @as(c_uint, @bitCast(@as(c_int, 0))));
    if (context.*.dtls != 0) {
        _private_dtls_handshake_data(context, packet, @as(c_uint, @bitCast(@as(c_int, 0))));
        context.*.dtls_seq +%= 1;
    }
    tls_packet_update(packet);
    return packet;
}
pub export fn tls_build_message(arg_context: [*c]struct_TLSContext, arg_data: [*c]const u8, arg_len: c_uint) [*c]struct_TLSPacket {
    var context = arg_context;
    _ = &context;
    var data = arg_data;
    _ = &data;
    var len = arg_len;
    _ = &len;
    if (!(data != null) or !(len != 0)) return null;
    var packet: [*c]struct_TLSPacket = tls_create_packet(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 23))))), context.*.version, @as(c_int, @bitCast(len)));
    _ = &packet;
    _ = tls_packet_append(packet, data, len);
    tls_packet_update(packet);
    return packet;
}
pub export fn tls_client_connect(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.is_server))) != 0) or (@as(c_int, @bitCast(@as(c_uint, context.*.critical_error))) != 0)) return -@as(c_int, 6);
    return _private_tls_write_packet(tls_build_hello(context, @as(c_int, 0)));
}
pub export fn tls_write(arg_context: [*c]struct_TLSContext, arg_data: [*c]const u8, arg_len: c_uint) c_int {
    var context = arg_context;
    _ = &context;
    var data = arg_data;
    _ = &data;
    var len = arg_len;
    _ = &len;
    if (!(context != null)) return -@as(c_int, 1);
    if (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) != @as(c_int, 255)) return -@as(c_int, 6);
    if (len > @as(c_uint, @bitCast(@as(c_int, 16384)))) {
        len = @as(c_uint, @bitCast(@as(c_int, 16384)));
    }
    var actually_written: c_int = _private_tls_write_packet(tls_build_message(context, data, len));
    _ = &actually_written;
    if (actually_written <= @as(c_int, 0)) return actually_written;
    return @as(c_int, @bitCast(len));
}
pub export fn tls_build_alert(arg_context: [*c]struct_TLSContext, arg_critical: u8, arg_code: u8) [*c]struct_TLSPacket {
    var context = arg_context;
    _ = &context;
    var critical = arg_critical;
    _ = &critical;
    var code = arg_code;
    _ = &code;
    var packet: [*c]struct_TLSPacket = tls_create_packet(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 21))))), context.*.version, @as(c_int, 0));
    _ = &packet;
    _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(if (@as(c_int, @bitCast(@as(c_uint, critical))) != 0) @as(c_int, 2) else @as(c_int, 1))))));
    if (critical != 0) {
        context.*.critical_error = 1;
    }
    _ = tls_packet_uint8(packet, code);
    tls_packet_update(packet);
    return packet;
}
pub export fn tls_consume_stream(arg_context: [*c]struct_TLSContext, arg_buf: [*c]const u8, arg_buf_len: c_int, arg_certificate_verify: tls_validation_function) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var certificate_verify = arg_certificate_verify;
    _ = &certificate_verify;
    if (!(context != null)) return -@as(c_int, 1);
    if (context.*.critical_error != 0) return -@as(c_int, 13);
    if (buf_len <= @as(c_int, 0)) {
        return 0;
    }
    if (!(buf != null)) {
        context.*.critical_error = 1;
        return -@as(c_int, 9);
    }
    var orig_len: c_uint = context.*.message_buffer_len;
    _ = &orig_len;
    context.*.message_buffer_len +%= @as(c_uint, @bitCast(buf_len));
    context.*.message_buffer = @as([*c]u8, @ptrCast(@alignCast(realloc(@as(?*anyopaque, @ptrCast(context.*.message_buffer)), @as(c_ulong, @bitCast(@as(c_ulong, context.*.message_buffer_len)))))));
    if (!(context.*.message_buffer != null)) {
        context.*.message_buffer_len = 0;
        return -@as(c_int, 9);
    }
    _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.message_buffer + orig_len)), @as(?*const anyopaque, @ptrCast(buf)), @as(c_ulong, @bitCast(@as(c_long, buf_len))));
    var index_1: c_uint = 0;
    _ = &index_1;
    var tls_buffer_len: c_uint = context.*.message_buffer_len;
    _ = &tls_buffer_len;
    var err_flag: c_int = 0;
    _ = &err_flag;
    var tls_header_size: c_uint = undefined;
    _ = &tls_header_size;
    var tls_size_offset: c_uint = undefined;
    _ = &tls_size_offset;
    if (context.*.dtls != 0) {
        tls_size_offset = 11;
        tls_header_size = 13;
    } else {
        tls_size_offset = 3;
        tls_header_size = 5;
    }
    while (tls_buffer_len >= tls_header_size) {
        var length: c_uint = @as(c_uint, @bitCast(@as(c_uint, ntohs(@as([*c]c_ushort, @ptrCast(@alignCast(&context.*.message_buffer[index_1 +% tls_size_offset]))).*)))) +% tls_header_size;
        _ = &length;
        if (length > tls_buffer_len) {
            break;
        }
        var parse_message: c_int = 1;
        _ = &parse_message;
        var consumed: c_int = 0;
        _ = &consumed;
        if ((@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) != 0) and !(context.*.cipher_spec_set != 0)) {
            var buffer: [*c]u8 = &context.*.message_buffer[index_1];
            _ = &buffer;
            if ((@as(c_int, @bitCast(@as(c_uint, buffer[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 22)) and (length > @as(c_uint, @bitCast(@as(c_int, 13))))) {
                buffer += tls_header_size;
                var data_length: c_uint = @as(c_uint, @bitCast(((@as(c_int, @bitCast(@as(c_uint, buffer[@as(c_uint, @intCast(@as(c_int, 1)))]))) * @as(c_int, 65536)) + (@as(c_int, @bitCast(@as(c_uint, buffer[@as(c_uint, @intCast(@as(c_int, 2)))]))) * @as(c_int, 256))) + @as(c_int, @bitCast(@as(c_uint, buffer[@as(c_uint, @intCast(@as(c_int, 3)))])))));
                _ = &data_length;
                var fragment_offset: c_uint = @as(c_uint, @bitCast(((@as(c_int, @bitCast(@as(c_uint, buffer[@as(c_uint, @intCast(@as(c_int, 6)))]))) * @as(c_int, 65536)) + (@as(c_int, @bitCast(@as(c_uint, buffer[@as(c_uint, @intCast(@as(c_int, 7)))]))) * @as(c_int, 256))) + @as(c_int, @bitCast(@as(c_uint, buffer[@as(c_uint, @intCast(@as(c_int, 8)))])))));
                _ = &fragment_offset;
                var fragment_length: c_uint = @as(c_uint, @bitCast(((@as(c_int, @bitCast(@as(c_uint, buffer[@as(c_uint, @intCast(@as(c_int, 9)))]))) * @as(c_int, 65536)) + (@as(c_int, @bitCast(@as(c_uint, buffer[@as(c_uint, @intCast(@as(c_int, 10)))]))) * @as(c_int, 256))) + @as(c_int, @bitCast(@as(c_uint, buffer[@as(c_uint, @intCast(@as(c_int, 11)))])))));
                _ = &fragment_length;
                if ((data_length > @as(c_uint, @bitCast(@as(c_int, 262144)))) or ((fragment_offset +% fragment_length) > data_length)) {
                    return -@as(c_int, 2);
                }
                if (data_length != fragment_length) {
                    if (!(context.*.dtls_data.*.fragment != null)) {
                        context.*.dtls_data.*.fragment = @as([*c]struct_DTLSFragment, @ptrCast(@alignCast(malloc(@sizeOf(struct_DTLSFragment)))));
                        if (context.*.dtls_data.*.fragment != null) {
                            _ = memset(@as(?*anyopaque, @ptrCast(context.*.dtls_data.*.fragment)), @as(c_int, 0), @sizeOf(struct_DTLSFragment));
                        }
                    }
                    if (!(context.*.dtls_data.*.fragment != null)) return -@as(c_int, 9);
                    var fragment_buffer: [*c]u8 = context.*.dtls_data.*.fragment.*.buffer;
                    _ = &fragment_buffer;
                    fragment_buffer = @as([*c]u8, @ptrCast(@alignCast(realloc(@as(?*anyopaque, @ptrCast(fragment_buffer)), @as(c_ulong, @bitCast(@as(c_ulong, data_length))) *% @sizeOf([*c]u8)))));
                    if (!(fragment_buffer != null)) return -@as(c_int, 9);
                    _ = memcpy(@as(?*anyopaque, @ptrCast(fragment_buffer + fragment_offset)), @as(?*const anyopaque, @ptrCast(&buffer[@as(c_uint, @intCast(@as(c_int, 12)))])), @as(c_ulong, @bitCast(@as(c_ulong, fragment_length))));
                    context.*.dtls_data.*.fragment.*.buffer = fragment_buffer;
                    context.*.dtls_data.*.fragment.*.len = @as(c_int, @bitCast(data_length));
                    context.*.dtls_data.*.fragment.*.written += @as(c_int, @bitCast(fragment_length));
                    if (context.*.dtls_data.*.fragment.*.written != context.*.dtls_data.*.fragment.*.len) {
                        consumed = @as(c_int, @bitCast(length));
                        parse_message = 0;
                    }
                }
            }
        }
        if (parse_message != 0) {
            consumed = tls_parse_message(context, &context.*.message_buffer[index_1], @as(c_int, @bitCast(length)), certificate_verify);
        }
        if (consumed < @as(c_int, 0)) {
            if (!(context.*.critical_error != 0)) {
                context.*.critical_error = 1;
            }
            err_flag = consumed;
            break;
        }
        index_1 +%= length;
        tls_buffer_len -%= length;
        if (context.*.critical_error != 0) {
            err_flag = -@as(c_int, 13);
            break;
        }
    }
    if (err_flag != 0) {
        context.*.message_buffer_len = 0;
        if (context.*.message_buffer != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.message_buffer)));
        }
        context.*.message_buffer = null;
        return err_flag;
    }
    if (index_1 != 0) {
        context.*.message_buffer_len -%= index_1;
        if (context.*.message_buffer_len != 0) {
            _ = memmove(@as(?*anyopaque, @ptrCast(context.*.message_buffer)), @as(?*const anyopaque, @ptrCast(context.*.message_buffer + index_1)), @as(c_ulong, @bitCast(@as(c_ulong, context.*.message_buffer_len))));
        } else {
            if (context.*.message_buffer != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.message_buffer)));
            }
            context.*.message_buffer = null;
        }
    }
    return @as(c_int, @bitCast(index_1));
}
pub export fn tls_close_notify(arg_context: [*c]struct_TLSContext) void {
    var context = arg_context;
    _ = &context;
    if (!(context != null) or (@as(c_int, @bitCast(@as(c_uint, context.*.critical_error))) != 0)) return;
    context.*.critical_error = 1;
    _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))), @as(u8, @bitCast(@as(i8, @truncate(close_notify))))));
}
pub export fn tls_alert(arg_context: [*c]struct_TLSContext, arg_critical: u8, arg_code: c_int) void {
    var context = arg_context;
    _ = &context;
    var critical = arg_critical;
    _ = &critical;
    var code = arg_code;
    _ = &code;
    if (!(context != null)) return;
    if (!(context.*.critical_error != 0) and (@as(c_int, @bitCast(@as(c_uint, critical))) != 0)) {
        context.*.critical_error = 1;
    }
    _ = _private_tls_write_packet(tls_build_alert(context, @as(u8, @bitCast(critical)), @as(u8, @bitCast(@as(i8, @truncate(code))))));
}
pub export fn tls_pending(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    if (!(context.*.message_buffer != null)) return 0;
    return @as(c_int, @bitCast(context.*.message_buffer_len));
}
pub export fn tls_make_exportable(arg_context: [*c]struct_TLSContext, arg_exportable_flag: u8) void {
    var context = arg_context;
    _ = &context;
    var exportable_flag = arg_exportable_flag;
    _ = &exportable_flag;
    context.*.exportable = exportable_flag;
    if (!(exportable_flag != 0)) {
        if ((context.*.exportable_keys != null) and (@as(c_int, @bitCast(@as(c_uint, context.*.exportable_size))) != 0)) {
            _ = memset(@as(?*anyopaque, @ptrCast(context.*.exportable_keys)), @as(c_int, 0), @as(c_ulong, @bitCast(@as(c_ulong, context.*.exportable_size))));
        }
        if (context.*.exportable_keys != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.exportable_keys)));
        }
        context.*.exportable_size = 0;
    }
}
pub export fn tls_export_context(arg_context: [*c]struct_TLSContext, arg_buffer: [*c]u8, arg_buf_len: c_uint, arg_small_version: u8) c_int {
    var context = arg_context;
    _ = &context;
    var buffer = arg_buffer;
    _ = &buffer;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var small_version = arg_small_version;
    _ = &small_version;
    if ((((((!(context != null) or (@as(c_int, @bitCast(@as(c_uint, context.*.critical_error))) != 0)) or (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) != @as(c_int, 255))) or !(context.*.exportable != 0)) or !(context.*.exportable_keys != null)) or !(context.*.exportable_size != 0)) or !(context.*.crypto.created != 0)) {
        return 0;
    }
    var packet: [*c]struct_TLSPacket = tls_create_packet(null, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 254))))), context.*.version, @as(c_int, 0));
    _ = &packet;
    _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1))))));
    _ = tls_packet_uint8(packet, context.*.connection_status);
    _ = tls_packet_uint16(packet, context.*.cipher);
    if (context.*.is_child != 0) {
        _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 2))))));
    } else {
        _ = tls_packet_uint8(packet, context.*.is_server);
    }
    if (@as(c_int, @bitCast(@as(c_uint, context.*.crypto.created))) == @as(c_int, 2)) {
        if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
            _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 12))))));
            _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_iv))), @as(c_uint, @bitCast(@as(c_int, 12))));
            _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_iv))), @as(c_uint, @bitCast(@as(c_int, 12))));
        } else {
            _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 4))))));
            _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_aead_iv))), @as(c_uint, @bitCast(@as(c_int, 4))));
            _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_aead_iv))), @as(c_uint, @bitCast(@as(c_int, 4))));
        }
    } else if (@as(c_int, @bitCast(@as(c_uint, context.*.crypto.created))) == @as(c_int, 3)) {
        _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 12))))));
        _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_nonce))), @as(c_uint, @bitCast(@as(c_int, 12))));
        _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_nonce))), @as(c_uint, @bitCast(@as(c_int, 12))));
    } else {
        var iv: [16]u8 = undefined;
        _ = &iv;
        var len: c_ulong = 16;
        _ = &len;
        _ = memset(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&iv))))), @as(c_int, 0), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16)))));
        _ = cbc_getiv(@as([*c]u8, @ptrCast(@alignCast(&iv))), &len, &context.*.crypto.ctx_local.aes_local);
        _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 16))))));
        _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&iv))), @as(c_uint, @bitCast(@as(c_uint, @truncate(len)))));
        _ = memset(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&iv))))), @as(c_int, 0), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16)))));
        _ = cbc_getiv(@as([*c]u8, @ptrCast(@alignCast(&iv))), &len, &context.*.crypto.ctx_remote.aes_remote);
        _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&iv))), @as(c_uint, @bitCast(@as(c_int, 16))));
    }
    _ = tls_packet_uint8(packet, context.*.exportable_size);
    _ = tls_packet_append(packet, context.*.exportable_keys, @as(c_uint, @bitCast(@as(c_uint, context.*.exportable_size))));
    if (@as(c_int, @bitCast(@as(c_uint, context.*.crypto.created))) == @as(c_int, 2)) {
        _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
    } else if (@as(c_int, @bitCast(@as(c_uint, context.*.crypto.created))) == @as(c_int, 3)) {
        _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
        var i: c_uint = undefined;
        _ = &i;
        {
            i = 0;
            while (i < @as(c_uint, @bitCast(@as(c_int, 16)))) : (i +%= 1) {
                _ = tls_packet_uint32(packet, context.*.crypto.ctx_local.chacha_local.input[i]);
            }
        }
        {
            i = 0;
            while (i < @as(c_uint, @bitCast(@as(c_int, 16)))) : (i +%= 1) {
                _ = tls_packet_uint32(packet, context.*.crypto.ctx_remote.chacha_remote.input[i]);
            }
        }
        _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local.chacha_local.ks))), @as(c_uint, @bitCast(@as(c_int, 64))));
        _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote.chacha_remote.ks))), @as(c_uint, @bitCast(@as(c_int, 64))));
    } else {
        var mac_length: u8 = @as(u8, @bitCast(@as(u8, @truncate(_private_tls_mac_length(context)))));
        _ = &mac_length;
        _ = tls_packet_uint8(packet, mac_length);
        _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_mac))), @as(c_uint, @bitCast(@as(c_uint, mac_length))));
        _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_mac))), @as(c_uint, @bitCast(@as(c_uint, mac_length))));
    }
    if (small_version != 0) {
        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 0))))));
    } else {
        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_ushort, @truncate(context.*.master_key_len)))));
        _ = tls_packet_append(packet, context.*.master_key, context.*.master_key_len);
    }
    var sequence_number: u64 = if (@as(u32, @bitCast(@as(c_int, 1))) == htonl(@as(u32, @bitCast(@as(c_int, 1))))) context.*.local_sequence_number else (@as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(context.*.local_sequence_number & @as(u64, @bitCast(@as(c_ulong, @as(c_uint, 4294967295)))))))))))) << @intCast(32)) | @as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(context.*.local_sequence_number >> @intCast(32)))))))));
    _ = &sequence_number;
    _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&sequence_number))), @as(c_uint, @bitCast(@as(c_uint, @truncate(@sizeOf(u64))))));
    sequence_number = if (@as(u32, @bitCast(@as(c_int, 1))) == htonl(@as(u32, @bitCast(@as(c_int, 1))))) context.*.remote_sequence_number else (@as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(context.*.remote_sequence_number & @as(u64, @bitCast(@as(c_ulong, @as(c_uint, 4294967295)))))))))))) << @intCast(32)) | @as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(context.*.remote_sequence_number >> @intCast(32)))))))));
    _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&sequence_number))), @as(c_uint, @bitCast(@as(c_uint, @truncate(@sizeOf(u64))))));
    _ = tls_packet_uint32(packet, context.*.tls_buffer_len);
    _ = tls_packet_append(packet, context.*.tls_buffer, context.*.tls_buffer_len);
    _ = tls_packet_uint32(packet, context.*.message_buffer_len);
    _ = tls_packet_append(packet, context.*.message_buffer, context.*.message_buffer_len);
    _ = tls_packet_uint32(packet, context.*.application_buffer_len);
    _ = tls_packet_append(packet, context.*.application_buffer, context.*.application_buffer_len);
    _ = tls_packet_uint8(packet, context.*.dtls);
    if (context.*.dtls != 0) {
        _ = tls_packet_uint16(packet, context.*.dtls_epoch_local);
        _ = tls_packet_uint16(packet, context.*.dtls_epoch_remote);
    }
    tls_packet_update(packet);
    var size: c_uint = packet.*.len;
    _ = &size;
    if ((buffer != null) and (buf_len != 0)) {
        if (size > buf_len) {
            tls_destroy_packet(packet);
            return @as(c_int, @bitCast(buf_len)) - @as(c_int, @bitCast(size));
        }
        _ = memcpy(@as(?*anyopaque, @ptrCast(buffer)), @as(?*const anyopaque, @ptrCast(packet.*.buf)), @as(c_ulong, @bitCast(@as(c_ulong, size))));
    }
    tls_destroy_packet(packet);
    return @as(c_int, @bitCast(size));
}
pub export fn tls_import_context(arg_buffer: [*c]const u8, arg_buf_len: c_uint) [*c]struct_TLSContext {
    var buffer = arg_buffer;
    _ = &buffer;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    if (((!(buffer != null) or (buf_len < @as(c_uint, @bitCast(@as(c_int, 64))))) or (@as(c_int, @bitCast(@as(c_uint, buffer[@as(c_uint, @intCast(@as(c_int, 0)))]))) != @as(c_int, 254))) or (@as(c_int, @bitCast(@as(c_uint, buffer[@as(c_uint, @intCast(@as(c_int, 5)))]))) != @as(c_int, 1))) {
        return null;
    }
    var context: [*c]struct_TLSContext = tls_create_context(@as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))), @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 771))))));
    _ = &context;
    if (context != null) {
        var temp: [255]u8 = undefined;
        _ = &temp;
        context.*.version = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&buffer[@as(c_uint, @intCast(@as(c_int, 1)))]))).*);
        var length: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&buffer[@as(c_uint, @intCast(@as(c_int, 3)))]))).*);
        _ = &length;
        if (@as(c_uint, @bitCast(@as(c_uint, length))) != (buf_len -% @as(c_uint, @bitCast(@as(c_int, 5))))) {
            tls_destroy_context(context);
            return null;
        }
        context.*.connection_status = buffer[@as(c_uint, @intCast(@as(c_int, 6)))];
        context.*.cipher = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&buffer[@as(c_uint, @intCast(@as(c_int, 7)))]))).*);
        var server: u8 = buffer[@as(c_uint, @intCast(@as(c_int, 9)))];
        _ = &server;
        if (@as(c_int, @bitCast(@as(c_uint, server))) == @as(c_int, 2)) {
            context.*.is_server = 1;
            context.*.is_child = 1;
        } else {
            context.*.is_server = server;
        }
        var local_iv: [16]u8 = undefined;
        _ = &local_iv;
        var remote_iv: [16]u8 = undefined;
        _ = &remote_iv;
        var iv_len: u8 = buffer[@as(c_uint, @intCast(@as(c_int, 10)))];
        _ = &iv_len;
        if (@as(c_int, @bitCast(@as(c_uint, iv_len))) > @as(c_int, 16)) {
            tls_destroy_context(context);
            return null;
        }
        var buf_pos: c_int = 11;
        _ = &buf_pos;
        _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&local_iv))))), @as(?*const anyopaque, @ptrCast(&(blk: {
            const tmp = buf_pos;
            if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*)), @as(c_ulong, @bitCast(@as(c_ulong, iv_len))));
        buf_pos += @as(c_int, @bitCast(@as(c_uint, iv_len)));
        _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&remote_iv))))), @as(?*const anyopaque, @ptrCast(&(blk: {
            const tmp = buf_pos;
            if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*)), @as(c_ulong, @bitCast(@as(c_ulong, iv_len))));
        buf_pos += @as(c_int, @bitCast(@as(c_uint, iv_len)));
        var key_lengths: u8 = (blk: {
            const tmp = blk_1: {
                const ref = &buf_pos;
                const tmp_2 = ref.*;
                ref.* += 1;
                break :blk_1 tmp_2;
            };
            if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*;
        _ = &key_lengths;
        if ((@as(c_int, @bitCast(@as(c_uint, key_lengths))) > (@as(c_int, @bitCast(buf_len)) - buf_pos)) or (buf_pos > @as(c_int, @bitCast(buf_len)))) {
            tls_destroy_context(context);
            return null;
        }
        _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&temp))))), @as(?*const anyopaque, @ptrCast(&(blk: {
            const tmp = buf_pos;
            if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*)), @as(c_ulong, @bitCast(@as(c_ulong, key_lengths))));
        buf_pos += @as(c_int, @bitCast(@as(c_uint, key_lengths)));
        context.*.exportable = 0;
        var is_aead: c_int = _private_tls_is_aead(context);
        _ = &is_aead;
        if (is_aead == @as(c_int, 2)) {
            if (@as(c_int, @bitCast(@as(c_uint, iv_len))) > @as(c_int, 12)) {
                iv_len = 12;
            }
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_nonce))))), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&local_iv))))), @as(c_ulong, @bitCast(@as(c_ulong, iv_len))));
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_nonce))))), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&remote_iv))))), @as(c_ulong, @bitCast(@as(c_ulong, iv_len))));
        } else if (is_aead != 0) {
            if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
                if (@as(c_int, @bitCast(@as(c_uint, iv_len))) > @as(c_int, 12)) {
                    iv_len = 12;
                }
                _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_iv))))), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&local_iv))))), @as(c_ulong, @bitCast(@as(c_ulong, iv_len))));
                _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_iv))))), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&remote_iv))))), @as(c_ulong, @bitCast(@as(c_ulong, iv_len))));
            } else {
                if (@as(c_int, @bitCast(@as(c_uint, iv_len))) > @as(c_int, 4)) {
                    iv_len = 4;
                }
                _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_aead_iv))))), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&local_iv))))), @as(c_ulong, @bitCast(@as(c_ulong, iv_len))));
                _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_aead_iv))))), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&remote_iv))))), @as(c_ulong, @bitCast(@as(c_ulong, iv_len))));
            }
        }
        if (context.*.is_server != 0) {
            if (_private_tls_crypto_create(context, @divTrunc(@as(c_int, @bitCast(@as(c_uint, key_lengths))), @as(c_int, 2)), @as([*c]u8, @ptrCast(@alignCast(&temp))), @as([*c]u8, @ptrCast(@alignCast(&local_iv))), @as([*c]u8, @ptrCast(@alignCast(&temp))) + @as(usize, @bitCast(@as(isize, @intCast(@divTrunc(@as(c_int, @bitCast(@as(c_uint, key_lengths))), @as(c_int, 2)))))), @as([*c]u8, @ptrCast(@alignCast(&remote_iv)))) != 0) {
                tls_destroy_context(context);
                return null;
            }
        } else {
            if (_private_tls_crypto_create(context, @divTrunc(@as(c_int, @bitCast(@as(c_uint, key_lengths))), @as(c_int, 2)), @as([*c]u8, @ptrCast(@alignCast(&temp))) + @as(usize, @bitCast(@as(isize, @intCast(@divTrunc(@as(c_int, @bitCast(@as(c_uint, key_lengths))), @as(c_int, 2)))))), @as([*c]u8, @ptrCast(@alignCast(&remote_iv))), @as([*c]u8, @ptrCast(@alignCast(&temp))), @as([*c]u8, @ptrCast(@alignCast(&local_iv)))) != 0) {
                tls_destroy_context(context);
                return null;
            }
        }
        _ = memset(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&temp))))), @as(c_int, 0), @sizeOf([255]u8));
        var mac_length: u8 = (blk: {
            const tmp = blk_1: {
                const ref = &buf_pos;
                const tmp_2 = ref.*;
                ref.* += 1;
                break :blk_1 tmp_2;
            };
            if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*;
        _ = &mac_length;
        if (@as(c_int, @bitCast(@as(c_uint, mac_length))) > @as(c_int, 48)) {
            tls_destroy_context(context);
            return null;
        }
        if (mac_length != 0) {
            if ((@as(c_int, @bitCast(@as(c_uint, mac_length))) > (@as(c_int, @bitCast(buf_len)) - buf_pos)) or (buf_pos > @as(c_int, @bitCast(buf_len)))) {
                tls_destroy_context(context);
                return null;
            }
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_mac))))), @as(?*const anyopaque, @ptrCast(&(blk: {
                const tmp = buf_pos;
                if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*)), @as(c_ulong, @bitCast(@as(c_ulong, mac_length))));
            buf_pos += @as(c_int, @bitCast(@as(c_uint, mac_length)));
            if ((@as(c_int, @bitCast(@as(c_uint, mac_length))) > (@as(c_int, @bitCast(buf_len)) - buf_pos)) or (buf_pos > @as(c_int, @bitCast(buf_len)))) {
                tls_destroy_context(context);
                return null;
            }
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_mac))))), @as(?*const anyopaque, @ptrCast(&(blk: {
                const tmp = buf_pos;
                if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*)), @as(c_ulong, @bitCast(@as(c_ulong, mac_length))));
            buf_pos += @as(c_int, @bitCast(@as(c_uint, mac_length)));
        } else if (is_aead == @as(c_int, 2)) {
            var i: c_uint = undefined;
            _ = &i;
            if (((@as(c_int, 128) + (@as(c_int, 64) * @as(c_int, 2))) > (@as(c_int, @bitCast(buf_len)) - buf_pos)) or (buf_pos > @as(c_int, @bitCast(buf_len)))) {
                tls_destroy_context(context);
                return null;
            }
            {
                i = 0;
                while (i < @as(c_uint, @bitCast(@as(c_int, 16)))) : (i +%= 1) {
                    context.*.crypto.ctx_local.chacha_local.input[i] = ntohl(@as([*c]const c_uint, @ptrCast(@alignCast(buffer + @as(usize, @bitCast(@as(isize, @intCast(buf_pos))))))).*);
                    buf_pos += @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf(c_uint)))));
                }
            }
            {
                i = 0;
                while (i < @as(c_uint, @bitCast(@as(c_int, 16)))) : (i +%= 1) {
                    context.*.crypto.ctx_remote.chacha_remote.input[i] = ntohl(@as([*c]const c_uint, @ptrCast(@alignCast(buffer + @as(usize, @bitCast(@as(isize, @intCast(buf_pos))))))).*);
                    buf_pos += @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf(c_uint)))));
                }
            }
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local.chacha_local.ks))))), @as(?*const anyopaque, @ptrCast(buffer + @as(usize, @bitCast(@as(isize, @intCast(buf_pos)))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 64)))));
            buf_pos += @as(c_int, 64);
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote.chacha_remote.ks))))), @as(?*const anyopaque, @ptrCast(buffer + @as(usize, @bitCast(@as(isize, @intCast(buf_pos)))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 64)))));
            buf_pos += @as(c_int, 64);
        }
        if ((@as(c_int, 2) > (@as(c_int, @bitCast(buf_len)) - buf_pos)) or (buf_pos > @as(c_int, @bitCast(buf_len)))) {
            tls_destroy_context(context);
            return null;
        }
        var master_key_len: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(buffer + @as(usize, @bitCast(@as(isize, @intCast(buf_pos))))))).*);
        _ = &master_key_len;
        buf_pos += @as(c_int, 2);
        if (master_key_len != 0) {
            if ((@as(c_int, @bitCast(@as(c_uint, master_key_len))) > (@as(c_int, @bitCast(buf_len)) - buf_pos)) or (buf_pos > @as(c_int, @bitCast(buf_len)))) {
                tls_destroy_context(context);
                return null;
            }
            context.*.master_key = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, master_key_len)))))));
            if (context.*.master_key != null) {
                _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.master_key)), @as(?*const anyopaque, @ptrCast(&(blk: {
                    const tmp = buf_pos;
                    if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*)), @as(c_ulong, @bitCast(@as(c_ulong, master_key_len))));
                context.*.master_key_len = @as(c_uint, @bitCast(@as(c_uint, master_key_len)));
            }
            buf_pos += @as(c_int, @bitCast(@as(c_uint, master_key_len)));
        }
        if ((@as(c_int, 16) > (@as(c_int, @bitCast(buf_len)) - buf_pos)) or (buf_pos > @as(c_int, @bitCast(buf_len)))) {
            tls_destroy_context(context);
            return null;
        }
        context.*.local_sequence_number = if (@as(u32, @bitCast(@as(c_int, 1))) == ntohl(@as(u32, @bitCast(@as(c_int, 1))))) @as([*c]const u64, @ptrCast(@alignCast(&(blk: {
            const tmp = buf_pos;
            if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).* else (@as(u64, @bitCast(@as(c_ulong, ntohl(@as(u32, @bitCast(@as(c_uint, @truncate(@as([*c]const u64, @ptrCast(@alignCast(&(blk: {
            const tmp = buf_pos;
            if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).* & @as(u64, @bitCast(@as(c_ulong, @as(c_uint, 4294967295)))))))))))) << @intCast(32)) | @as(u64, @bitCast(@as(c_ulong, ntohl(@as(u32, @bitCast(@as(c_uint, @truncate(@as([*c]const u64, @ptrCast(@alignCast(&(blk: {
            const tmp = buf_pos;
            if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).* >> @intCast(32)))))))));
        buf_pos += @as(c_int, 8);
        context.*.remote_sequence_number = if (@as(u32, @bitCast(@as(c_int, 1))) == ntohl(@as(u32, @bitCast(@as(c_int, 1))))) @as([*c]const u64, @ptrCast(@alignCast(&(blk: {
            const tmp = buf_pos;
            if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).* else (@as(u64, @bitCast(@as(c_ulong, ntohl(@as(u32, @bitCast(@as(c_uint, @truncate(@as([*c]const u64, @ptrCast(@alignCast(&(blk: {
            const tmp = buf_pos;
            if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).* & @as(u64, @bitCast(@as(c_ulong, @as(c_uint, 4294967295)))))))))))) << @intCast(32)) | @as(u64, @bitCast(@as(c_ulong, ntohl(@as(u32, @bitCast(@as(c_uint, @truncate(@as([*c]const u64, @ptrCast(@alignCast(&(blk: {
            const tmp = buf_pos;
            if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).* >> @intCast(32)))))))));
        buf_pos += @as(c_int, 8);
        if ((@as(c_int, 4) > (@as(c_int, @bitCast(buf_len)) - buf_pos)) or (buf_pos > @as(c_int, @bitCast(buf_len)))) {
            tls_destroy_context(context);
            return null;
        }
        var tls_buffer_len: c_uint = ntohl(@as([*c]const c_uint, @ptrCast(@alignCast(&(blk: {
            const tmp = buf_pos;
            if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).*);
        _ = &tls_buffer_len;
        buf_pos += @as(c_int, 4);
        if ((@as(c_int, @bitCast(tls_buffer_len)) > (@as(c_int, @bitCast(buf_len)) - buf_pos)) or (buf_pos > @as(c_int, @bitCast(buf_len)))) {
            tls_destroy_context(context);
            return null;
        }
        if (tls_buffer_len != 0) {
            context.*.tls_buffer = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, tls_buffer_len)))))));
            if (context.*.tls_buffer != null) {
                _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.tls_buffer)), @as(?*const anyopaque, @ptrCast(&(blk: {
                    const tmp = buf_pos;
                    if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*)), @as(c_ulong, @bitCast(@as(c_ulong, tls_buffer_len))));
                context.*.tls_buffer_len = tls_buffer_len;
            }
            buf_pos += @as(c_int, @bitCast(tls_buffer_len));
        }
        if ((@as(c_int, 4) > (@as(c_int, @bitCast(buf_len)) - buf_pos)) or (buf_pos > @as(c_int, @bitCast(buf_len)))) {
            tls_destroy_context(context);
            return null;
        }
        var message_buffer_len: c_uint = ntohl(@as([*c]const c_uint, @ptrCast(@alignCast(&(blk: {
            const tmp = buf_pos;
            if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).*);
        _ = &message_buffer_len;
        buf_pos += @as(c_int, 4);
        if ((@as(c_int, @bitCast(message_buffer_len)) > (@as(c_int, @bitCast(buf_len)) - buf_pos)) or (buf_pos > @as(c_int, @bitCast(buf_len)))) {
            tls_destroy_context(context);
            return null;
        }
        if (message_buffer_len != 0) {
            context.*.message_buffer = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, message_buffer_len)))))));
            if (context.*.message_buffer != null) {
                _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.message_buffer)), @as(?*const anyopaque, @ptrCast(&(blk: {
                    const tmp = buf_pos;
                    if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*)), @as(c_ulong, @bitCast(@as(c_ulong, message_buffer_len))));
                context.*.message_buffer_len = message_buffer_len;
            }
            buf_pos += @as(c_int, @bitCast(message_buffer_len));
        }
        if ((@as(c_int, 4) > (@as(c_int, @bitCast(buf_len)) - buf_pos)) or (buf_pos > @as(c_int, @bitCast(buf_len)))) {
            tls_destroy_context(context);
            return null;
        }
        var application_buffer_len: c_uint = ntohl(@as([*c]const c_uint, @ptrCast(@alignCast(&(blk: {
            const tmp = buf_pos;
            if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).*);
        _ = &application_buffer_len;
        buf_pos += @as(c_int, 4);
        context.*.cipher_spec_set = 1;
        if ((@as(c_int, @bitCast(application_buffer_len)) > (@as(c_int, @bitCast(buf_len)) - buf_pos)) or (buf_pos > @as(c_int, @bitCast(buf_len)))) {
            tls_destroy_context(context);
            return null;
        }
        if (application_buffer_len != 0) {
            context.*.application_buffer = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, application_buffer_len)))))));
            if (context.*.application_buffer != null) {
                _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.application_buffer)), @as(?*const anyopaque, @ptrCast(&(blk: {
                    const tmp = buf_pos;
                    if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*)), @as(c_ulong, @bitCast(@as(c_ulong, application_buffer_len))));
                context.*.application_buffer_len = application_buffer_len;
            }
            buf_pos += @as(c_int, @bitCast(application_buffer_len));
        }
        if ((@as(c_int, 1) > (@as(c_int, @bitCast(buf_len)) - buf_pos)) or (buf_pos > @as(c_int, @bitCast(buf_len)))) {
            tls_destroy_context(context);
            return null;
        }
        context.*.dtls = (blk: {
            const tmp = buf_pos;
            if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*;
        buf_pos += 1;
        if (context.*.dtls != 0) {
            if ((@as(c_int, 4) > (@as(c_int, @bitCast(buf_len)) - buf_pos)) or (buf_pos > @as(c_int, @bitCast(buf_len)))) {
                tls_destroy_context(context);
                return null;
            }
            context.*.dtls_epoch_local = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
                const tmp = buf_pos;
                if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))).*);
            buf_pos += @as(c_int, 2);
            context.*.dtls_epoch_remote = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
                const tmp = buf_pos;
                if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))).*);
        }
    }
    return context;
}
pub export fn tls_is_broken(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    if (!(context != null) or (@as(c_int, @bitCast(@as(c_uint, context.*.critical_error))) != 0)) return 1;
    return 0;
}
pub export fn tls_request_client_certificate(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    if (!(context != null) or !(context.*.is_server != 0)) return 0;
    context.*.request_client_certificate = 1;
    return 1;
}
pub export fn tls_client_verified(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    if (!(context != null) or (@as(c_int, @bitCast(@as(c_uint, context.*.critical_error))) != 0)) return 0;
    return @intFromBool(@as(c_int, @bitCast(@as(c_uint, context.*.client_verified))) == @as(c_int, 1));
}
pub export fn tls_sni(arg_context: [*c]struct_TLSContext) [*c]const u8 {
    var context = arg_context;
    _ = &context;
    if (!(context != null)) return null;
    return context.*.sni;
}
pub export fn tls_sni_set(arg_context: [*c]struct_TLSContext, arg_sni: [*c]const u8) c_int {
    var context = arg_context;
    _ = &context;
    var sni = arg_sni;
    _ = &sni;
    if (!(context != null) or !(sni != null)) return 0;
    return tls_sni_nset(context, sni, @as(c_uint, @bitCast(@as(c_uint, @truncate(strlen(sni))))));
}
pub export fn tls_sni_nset(arg_context: [*c]struct_TLSContext, arg_sni: [*c]const u8, arg_len: c_uint) c_int {
    var context = arg_context;
    _ = &context;
    var sni = arg_sni;
    _ = &sni;
    var len = arg_len;
    _ = &len;
    if (((!(context != null) or (@as(c_int, @bitCast(@as(c_uint, context.*.is_server))) != 0)) or (@as(c_int, @bitCast(@as(c_uint, context.*.critical_error))) != 0)) or (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) != @as(c_int, 0))) return 0;
    if (context.*.sni != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.sni)));
    }
    context.*.sni = null;
    if ((sni != null) and (len > @as(c_uint, @bitCast(@as(c_int, 0))))) {
        context.*.sni = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, len +% @as(c_uint, @bitCast(@as(c_int, 1))))))))));
        if (context.*.sni != null) {
            context.*.sni[len] = 0;
            _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.sni)), @as(?*const anyopaque, @ptrCast(sni)), @as(c_ulong, @bitCast(@as(c_ulong, len))));
            return 1;
        }
    }
    return 0;
}
pub export fn tls_srtp_set(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    if (!(context != null) or !(context.*.dtls != 0)) return -@as(c_int, 1);
    context.*.dtls = 4;
    return 0;
}
pub export fn tls_srtp_key(arg_context: [*c]struct_TLSContext, arg_buffer: [*c]u8) c_int {
    var context = arg_context;
    _ = &context;
    var buffer = arg_buffer;
    _ = &buffer;
    if (!(context.*.master_key != null) or !(context.*.master_key_len != 0)) return -@as(c_int, 1);
    var material: [60]u8 = undefined;
    _ = &material;
    if (context.*.is_server != 0) {
        _private_tls_prf(context, @as([*c]u8, @ptrCast(@alignCast(&material))), @as(c_uint, @bitCast(@as(c_uint, @truncate(@sizeOf([60]u8))))), context.*.master_key, context.*.master_key_len, @as([*c]u8, @ptrCast(@alignCast("EXTRACTOR-dtls_srtp"))), @as(c_uint, @bitCast(@as(c_int, 19))), @as([*c]u8, @ptrCast(@alignCast(&context.*.remote_random))), @as(c_uint, @bitCast(@as(c_int, 32))), @as([*c]u8, @ptrCast(@alignCast(&context.*.local_random))), @as(c_uint, @bitCast(@as(c_int, 32))));
    } else {
        _private_tls_prf(context, @as([*c]u8, @ptrCast(@alignCast(&material))), @as(c_uint, @bitCast(@as(c_uint, @truncate(@sizeOf([60]u8))))), context.*.master_key, context.*.master_key_len, @as([*c]u8, @ptrCast(@alignCast("EXTRACTOR-dtls_srtp"))), @as(c_uint, @bitCast(@as(c_int, 19))), @as([*c]u8, @ptrCast(@alignCast(&context.*.local_random))), @as(c_uint, @bitCast(@as(c_int, 32))), @as([*c]u8, @ptrCast(@alignCast(&context.*.remote_random))), @as(c_uint, @bitCast(@as(c_int, 32))));
    }
    if (buffer != null) {
        _ = memcpy(@as(?*anyopaque, @ptrCast(buffer)), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&material))))), @sizeOf([60]u8));
    }
    return @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([60]u8)))));
}
pub export fn tls_stun_parse(arg_msg: [*c]u8, arg_len: c_int, arg_pwd: [*c]u8, arg_pwd_len: c_int, arg_is_ipv6: u8, arg_addr: [*c]u8, arg_port: c_uint, arg_response_buffer: [*c]u8) c_int {
    var msg = arg_msg;
    _ = &msg;
    var len = arg_len;
    _ = &len;
    var pwd = arg_pwd;
    _ = &pwd;
    var pwd_len = arg_pwd_len;
    _ = &pwd_len;
    var is_ipv6 = arg_is_ipv6;
    _ = &is_ipv6;
    var addr = arg_addr;
    _ = &addr;
    var port = arg_port;
    _ = &port;
    var response_buffer = arg_response_buffer;
    _ = &response_buffer;
    if (!(msg != null) or (len < @as(c_int, 20))) {
        return -@as(c_int, 1);
    }
    if ((((@as(c_int, @bitCast(@as(c_uint, msg[@as(c_uint, @intCast(@as(c_int, 4)))]))) != @as(c_int, 33)) or (@as(c_int, @bitCast(@as(c_uint, msg[@as(c_uint, @intCast(@as(c_int, 5)))]))) != @as(c_int, 18))) or (@as(c_int, @bitCast(@as(c_uint, msg[@as(c_uint, @intCast(@as(c_int, 6)))]))) != @as(c_int, 164))) or (@as(c_int, @bitCast(@as(c_uint, msg[@as(c_uint, @intCast(@as(c_int, 7)))]))) != @as(c_int, 66))) {
        return -@as(c_int, 1);
    }
    var addr_len: c_int = 4;
    _ = &addr_len;
    if (is_ipv6 != 0) {
        addr_len = 16;
    }
    var stun_message: [*c]u8 = msg;
    _ = &stun_message;
    var @"type": c_ushort = ntohs(@as([*c]c_ushort, @ptrCast(@alignCast(msg))).*);
    _ = &@"type";
    var msg_len: c_int = @as(c_int, @bitCast(@as(c_uint, ntohs(@as([*c]c_ushort, @ptrCast(@alignCast(&msg[@as(c_uint, @intCast(@as(c_int, 2)))]))).*))));
    _ = &msg_len;
    if (msg_len > (len - @as(c_int, 20))) return -@as(c_int, 1);
    var magic_cookie: [*c]const u8 = &msg[@as(c_uint, @intCast(@as(c_int, 4)))];
    _ = &magic_cookie;
    var transaction_id: [*c]const u8 = &msg[@as(c_uint, @intCast(@as(c_int, 8)))];
    _ = &transaction_id;
    var attributes: [*c]const u8 = &msg[@as(c_uint, @intCast(@as(c_int, 20)))];
    _ = &attributes;
    while (true) {
        switch (@as(c_int, @bitCast(@as(c_uint, @"type")))) {
            @as(c_int, 1) => break,
            @as(c_int, 257) => return 0,
            else => {
                {}
                return -@as(c_int, 17);
            },
        }
        break;
    }
    msg += @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20)))));
    var hash: [20]u8 = undefined;
    _ = &hash;
    var hash_len: c_ulong = 20;
    _ = &hash_len;
    var md5_hash: [16]u8 = undefined;
    _ = &md5_hash;
    var hmac: hmac_state = undefined;
    _ = &hmac;
    var md5_state_1: hash_state = undefined;
    _ = &md5_state_1;
    _ = memset(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&hash))))), @as(c_int, 0), @sizeOf([20]u8));
    var stun_message_len: c_int = 20;
    _ = &stun_message_len;
    var secret: [16]u8 = undefined;
    _ = &secret;
    var key: [1230]u8 = undefined;
    _ = &key;
    var username: [*c]u8 = null;
    _ = &username;
    var username_len: c_int = 0;
    _ = &username_len;
    var realm: [*c]u8 = null;
    _ = &realm;
    var realm_len: c_int = 0;
    _ = &realm_len;
    var nonce: [*c]u8 = null;
    _ = &nonce;
    var nonce_len: c_int = 0;
    _ = &nonce_len;
    var ptr: [*c]u8 = undefined;
    _ = &ptr;
    var validated: c_int = 0;
    _ = &validated;
    var priority: u32 = 0;
    _ = &priority;
    while (msg_len >= @as(c_int, 4)) {
        var attr_type: c_ushort = ntohs(@as([*c]c_ushort, @ptrCast(@alignCast(msg))).*);
        _ = &attr_type;
        var attr_len: c_int = @as(c_int, @bitCast(@as(c_uint, ntohs(@as([*c]c_ushort, @ptrCast(@alignCast(&msg[@as(c_uint, @intCast(@as(c_int, 2)))]))).*))));
        _ = &attr_len;
        msg += @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4)))));
        msg_len -= @as(c_int, 4);
        if (attr_len > msg_len) return -@as(c_int, 1);
        var temp: c_ushort = undefined;
        _ = &temp;
        while (true) {
            switch (@as(c_int, @bitCast(@as(c_uint, attr_type)))) {
                @as(c_int, 1) => break,
                @as(c_int, 6) => {
                    if (attr_len > @as(c_int, 513)) return -@as(c_int, 2);
                    username = msg;
                    username_len = attr_len;
                    break;
                },
                @as(c_int, 8) => {
                    if (((attr_len != @as(c_int, 20)) or !(username != null)) or !(username_len != 0)) return -@as(c_int, 1);
                    tls_init();
                    temp = @as([*c]c_ushort, @ptrCast(@alignCast(&stun_message[@as(c_uint, @intCast(@as(c_int, 2)))]))).*;
                    @as([*c]c_ushort, @ptrCast(@alignCast(&stun_message[@as(c_uint, @intCast(@as(c_int, 2)))]))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(((stun_message_len + attr_len) + @as(c_int, 4)) - @as(c_int, 20))))));
                    if ((realm != null) and (realm_len > @as(c_int, 0))) {
                        ptr = @as([*c]u8, @ptrCast(@alignCast(&key)));
                        _ = memcpy(@as(?*anyopaque, @ptrCast(ptr)), @as(?*const anyopaque, @ptrCast(username)), @as(c_ulong, @bitCast(@as(c_long, username_len))));
                        ptr += @as(usize, @bitCast(@as(isize, @intCast(username_len))));
                        ptr.* = ':';
                        ptr += 1;
                        if ((realm != null) and (realm_len > @as(c_int, 0))) {
                            _ = memcpy(@as(?*anyopaque, @ptrCast(ptr)), @as(?*const anyopaque, @ptrCast(realm)), @as(c_ulong, @bitCast(@as(c_long, realm_len))));
                            ptr += @as(usize, @bitCast(@as(isize, @intCast(username_len))));
                            ptr.* = ':';
                            ptr += 1;
                        }
                        _ = memcpy(@as(?*anyopaque, @ptrCast(ptr)), @as(?*const anyopaque, @ptrCast(pwd)), @as(c_ulong, @bitCast(@as(c_long, pwd_len))));
                        ptr += @as(usize, @bitCast(@as(isize, @intCast(pwd_len))));
                        ptr.* = 0;
                        _ = md5_init(&md5_state_1);
                        _ = md5_process(&md5_state_1, @as([*c]u8, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&key)))))), strlen(@as([*c]u8, @ptrCast(@alignCast(&key)))));
                        _ = md5_done(&md5_state_1, @as([*c]u8, @ptrCast(@alignCast(&md5_hash))));
                        _ = hmac_init(&hmac, find_hash("sha1"), @as([*c]u8, @ptrCast(@alignCast(&md5_hash))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16)))));
                    } else {
                        _ = hmac_init(&hmac, find_hash("sha1"), @as([*c]u8, @ptrCast(@alignCast(pwd))), @as(c_ulong, @bitCast(@as(c_long, pwd_len))));
                    }
                    _ = hmac_process(&hmac, stun_message, @as(c_ulong, @bitCast(@as(c_long, stun_message_len))));
                    _ = hmac_done(&hmac, @as([*c]u8, @ptrCast(@alignCast(&hash))), &hash_len);
                    @as([*c]c_ushort, @ptrCast(@alignCast(&stun_message[@as(c_uint, @intCast(@as(c_int, 2)))]))).* = temp;
                    if (memcmp(@as(?*const anyopaque, @ptrCast(msg)), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&hash))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16))))) != 0) {
                        return -@as(c_int, 11);
                    }
                    validated = 1;
                    break;
                },
                @as(c_int, 9) => break,
                @as(c_int, 10) => break,
                @as(c_int, 20) => {
                    if (attr_len > @as(c_int, 763)) return -@as(c_int, 2);
                    realm = msg;
                    realm_len = attr_len;
                    break;
                },
                @as(c_int, 21) => {
                    if (attr_len > @as(c_int, 763)) return -@as(c_int, 2);
                    nonce = msg;
                    nonce_len = attr_len;
                    break;
                },
                @as(c_int, 32) => break,
                @as(c_int, 36) => {
                    if (attr_len != @as(c_int, 4)) return -@as(c_int, 2);
                    var priority_: u32 = undefined;
                    _ = &priority_;
                    _ = memcpy(@as(?*anyopaque, @ptrCast(&priority_)), @as(?*const anyopaque, @ptrCast(msg)), @sizeOf(u32));
                    priority = ntohl(priority_);
                    break;
                },
                else => {},
            }
            break;
        }
        while (@import("std").zig.c_translation.signedRemainder(attr_len, @as(c_int, 4)) != 0) {
            attr_len += 1;
        }
        msg_len -= attr_len;
        msg += @as(usize, @bitCast(@as(isize, @intCast(attr_len))));
        stun_message_len += attr_len + @as(c_int, 4);
    }
    if (!(validated != 0)) return -@as(c_int, 1);
    if (response_buffer != null) {
        response_buffer[@as(c_uint, @intCast(@as(c_int, 0)))] = 1;
        response_buffer[@as(c_uint, @intCast(@as(c_int, 1)))] = 1;
        response_buffer[@as(c_uint, @intCast(@as(c_int, 2)))] = 0;
        response_buffer[@as(c_uint, @intCast(@as(c_int, 3)))] = 0;
        response_buffer[@as(c_uint, @intCast(@as(c_int, 4)))] = 33;
        response_buffer[@as(c_uint, @intCast(@as(c_int, 5)))] = 18;
        response_buffer[@as(c_uint, @intCast(@as(c_int, 6)))] = 164;
        response_buffer[@as(c_uint, @intCast(@as(c_int, 7)))] = 66;
        _ = memcpy(@as(?*anyopaque, @ptrCast(response_buffer + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))), @as(?*const anyopaque, @ptrCast(stun_message + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 12)))));
        response_buffer[@as(c_uint, @intCast(@as(c_int, 20)))] = 0;
        response_buffer[@as(c_uint, @intCast(@as(c_int, 21)))] = 32;
        @as([*c]c_ushort, @ptrCast(@alignCast(&response_buffer[@as(c_uint, @intCast(@as(c_int, 22)))]))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(addr_len + @as(c_int, 4))))));
        response_buffer[@as(c_uint, @intCast(@as(c_int, 24)))] = 0;
        if (is_ipv6 != 0) {
            response_buffer[@as(c_uint, @intCast(@as(c_int, 25)))] = 2;
        } else {
            response_buffer[@as(c_uint, @intCast(@as(c_int, 25)))] = 1;
        }
        @as([*c]c_ushort, @ptrCast(@alignCast(&response_buffer[@as(c_uint, @intCast(@as(c_int, 26)))]))).* = htons(@as(u16, @bitCast(@as(c_ushort, @truncate(port)))));
        response_buffer[@as(c_uint, @intCast(@as(c_int, 26)))] ^= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, response_buffer[@as(c_uint, @intCast(@as(c_int, 4)))])))))));
        response_buffer[@as(c_uint, @intCast(@as(c_int, 27)))] ^= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, response_buffer[@as(c_uint, @intCast(@as(c_int, 5)))])))))));
        _ = memcpy(@as(?*anyopaque, @ptrCast(response_buffer + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 28))))))), @as(?*const anyopaque, @ptrCast(addr)), @as(c_ulong, @bitCast(@as(c_long, addr_len))));
        var i: c_int = undefined;
        _ = &i;
        {
            i = 0;
            while (i < addr_len) : (i += 1) {
                (blk: {
                    const tmp = @as(c_int, 28) + i;
                    if (tmp >= 0) break :blk response_buffer + @as(usize, @intCast(tmp)) else break :blk response_buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).* ^= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, (blk: {
                    const tmp = @as(c_int, 4) + @import("std").zig.c_translation.signedRemainder(i, @as(c_int, 4));
                    if (tmp >= 0) break :blk response_buffer + @as(usize, @intCast(tmp)) else break :blk response_buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*)))))));
            }
        }
        var buffer_index: c_int = @as(c_int, 28) + addr_len;
        _ = &buffer_index;
        while (@import("std").zig.c_translation.signedRemainder(buffer_index, @as(c_int, 4)) != 0) {
            (blk: {
                const tmp = buffer_index;
                if (tmp >= 0) break :blk response_buffer + @as(usize, @intCast(tmp)) else break :blk response_buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = 0;
            buffer_index += 1;
            response_buffer[@as(c_uint, @intCast(@as(c_int, 22)))] +%= 1;
        }
        @as([*c]c_ushort, @ptrCast(@alignCast(&response_buffer[@as(c_uint, @intCast(@as(c_int, 2)))]))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(buffer_index + @as(c_int, 4))))));
        _ = hmac_init(&hmac, find_hash("sha1"), @as([*c]u8, @ptrCast(@alignCast(pwd))), @as(c_ulong, @bitCast(@as(c_long, pwd_len))));
        _ = hmac_process(&hmac, response_buffer, @as(c_ulong, @bitCast(@as(c_long, buffer_index))));
        _ = hmac_done(&hmac, (response_buffer + @as(usize, @bitCast(@as(isize, @intCast(buffer_index))))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))), &hash_len);
        (blk: {
            const tmp = buffer_index;
            if (tmp >= 0) break :blk response_buffer + @as(usize, @intCast(tmp)) else break :blk response_buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = 0;
        (blk: {
            const tmp = buffer_index + @as(c_int, 1);
            if (tmp >= 0) break :blk response_buffer + @as(usize, @intCast(tmp)) else break :blk response_buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = 8;
        (blk: {
            const tmp = buffer_index + @as(c_int, 2);
            if (tmp >= 0) break :blk response_buffer + @as(usize, @intCast(tmp)) else break :blk response_buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = 0;
        (blk: {
            const tmp = buffer_index + @as(c_int, 3);
            if (tmp >= 0) break :blk response_buffer + @as(usize, @intCast(tmp)) else break :blk response_buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = 20;
        buffer_index += @as(c_int, 24);
        (blk: {
            const tmp = blk_1: {
                const ref = &buffer_index;
                const tmp_2 = ref.*;
                ref.* += 1;
                break :blk_1 tmp_2;
            };
            if (tmp >= 0) break :blk response_buffer + @as(usize, @intCast(tmp)) else break :blk response_buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = 128;
        (blk: {
            const tmp = blk_1: {
                const ref = &buffer_index;
                const tmp_2 = ref.*;
                ref.* += 1;
                break :blk_1 tmp_2;
            };
            if (tmp >= 0) break :blk response_buffer + @as(usize, @intCast(tmp)) else break :blk response_buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = 40;
        (blk: {
            const tmp = blk_1: {
                const ref = &buffer_index;
                const tmp_2 = ref.*;
                ref.* += 1;
                break :blk_1 tmp_2;
            };
            if (tmp >= 0) break :blk response_buffer + @as(usize, @intCast(tmp)) else break :blk response_buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = 0;
        (blk: {
            const tmp = blk_1: {
                const ref = &buffer_index;
                const tmp_2 = ref.*;
                ref.* += 1;
                break :blk_1 tmp_2;
            };
            if (tmp >= 0) break :blk response_buffer + @as(usize, @intCast(tmp)) else break :blk response_buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = 4;
        @as([*c]c_ushort, @ptrCast(@alignCast(&response_buffer[@as(c_uint, @intCast(@as(c_int, 2)))]))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(buffer_index - @as(c_int, 16))))));
        var fingerprint: u32 = _private_tls_crc32(response_buffer, buffer_index - @as(c_int, 4)) ^ @as(u32, @bitCast(@as(c_int, 1398035790)));
        _ = &fingerprint;
        @as([*c]u32, @ptrCast(@alignCast(&(blk: {
            const tmp = buffer_index;
            if (tmp >= 0) break :blk response_buffer + @as(usize, @intCast(tmp)) else break :blk response_buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).* = htonl(fingerprint);
        buffer_index += @as(c_int, 4);
        return buffer_index;
    }
    return 0;
}
pub export fn tls_stun_build(arg_transaction_id: [*c]u8, arg_username: [*c]u8, arg_username_len: c_int, arg_pwd: [*c]u8, arg_pwd_len: c_int, arg_msg: [*c]u8) c_int {
    var transaction_id = arg_transaction_id;
    _ = &transaction_id;
    var username = arg_username;
    _ = &username;
    var username_len = arg_username_len;
    _ = &username_len;
    var pwd = arg_pwd;
    _ = &pwd;
    var pwd_len = arg_pwd_len;
    _ = &pwd_len;
    var msg = arg_msg;
    _ = &msg;
    if (!(msg != null)) return 0;
    @as([*c]c_ushort, @ptrCast(@alignCast(msg))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(@as(c_int, 1))))));
    msg[@as(c_uint, @intCast(@as(c_int, 4)))] = 33;
    msg[@as(c_uint, @intCast(@as(c_int, 5)))] = 18;
    msg[@as(c_uint, @intCast(@as(c_int, 6)))] = 164;
    msg[@as(c_uint, @intCast(@as(c_int, 7)))] = 66;
    _ = memcpy(@as(?*anyopaque, @ptrCast(msg + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))), @as(?*const anyopaque, @ptrCast(transaction_id)), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 12)))));
    var ptr: [*c]u8 = msg + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20)))));
    _ = &ptr;
    var len: c_int = 20;
    _ = &len;
    if (((username != null) and (username_len > @as(c_int, 0))) and (username_len <= @as(c_int, 513))) {
        @as([*c]c_ushort, @ptrCast(@alignCast(&msg[@as(c_uint, @intCast(@as(c_int, 20)))]))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(@as(c_int, 6))))));
        @as([*c]c_ushort, @ptrCast(@alignCast(&msg[@as(c_uint, @intCast(@as(c_int, 22)))]))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(username_len)))));
        len += @as(c_int, 4);
        _ = memcpy(@as(?*anyopaque, @ptrCast(msg + @as(usize, @bitCast(@as(isize, @intCast(len)))))), @as(?*const anyopaque, @ptrCast(username)), @as(c_ulong, @bitCast(@as(c_long, username_len))));
        len += username_len;
        while (@import("std").zig.c_translation.signedRemainder(len, @as(c_int, 4)) != 0) {
            (blk: {
                const tmp = blk_1: {
                    const ref = &len;
                    const tmp_2 = ref.*;
                    ref.* += 1;
                    break :blk_1 tmp_2;
                };
                if (tmp >= 0) break :blk msg + @as(usize, @intCast(tmp)) else break :blk msg - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = 0;
        }
    }
    @as([*c]c_ushort, @ptrCast(@alignCast(&(blk: {
        const tmp = len;
        if (tmp >= 0) break :blk msg + @as(usize, @intCast(tmp)) else break :blk msg - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(@as(c_int, 37))))));
    @as([*c]c_ushort, @ptrCast(@alignCast(&(blk: {
        const tmp = len + @as(c_int, 2);
        if (tmp >= 0) break :blk msg + @as(usize, @intCast(tmp)) else break :blk msg - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(@as(c_int, 0))))));
    len += @as(c_int, 4);
    @as([*c]c_ushort, @ptrCast(@alignCast(&(blk: {
        const tmp = len;
        if (tmp >= 0) break :blk msg + @as(usize, @intCast(tmp)) else break :blk msg - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(@as(c_int, 8))))));
    @as([*c]c_ushort, @ptrCast(@alignCast(&(blk: {
        const tmp = len + @as(c_int, 2);
        if (tmp >= 0) break :blk msg + @as(usize, @intCast(tmp)) else break :blk msg - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(@as(c_int, 20))))));
    len += @as(c_int, 24);
    @as([*c]c_ushort, @ptrCast(@alignCast(&msg[@as(c_uint, @intCast(@as(c_int, 2)))]))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(len - @as(c_int, 20))))));
    tls_init();
    var hmac: hmac_state = undefined;
    _ = &hmac;
    var hash_len: c_ulong = 20;
    _ = &hash_len;
    _ = hmac_init(&hmac, find_hash("sha1"), @as([*c]u8, @ptrCast(@alignCast(pwd))), @as(c_ulong, @bitCast(@as(c_long, pwd_len))));
    _ = hmac_process(&hmac, msg, @as(c_ulong, @bitCast(@as(c_long, len - @as(c_int, 24)))));
    _ = hmac_done(&hmac, (msg + @as(usize, @bitCast(@as(isize, @intCast(len))))) - @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20))))), &hash_len);
    (blk: {
        const tmp = blk_1: {
            const ref = &len;
            const tmp_2 = ref.*;
            ref.* += 1;
            break :blk_1 tmp_2;
        };
        if (tmp >= 0) break :blk msg + @as(usize, @intCast(tmp)) else break :blk msg - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* = 128;
    (blk: {
        const tmp = blk_1: {
            const ref = &len;
            const tmp_2 = ref.*;
            ref.* += 1;
            break :blk_1 tmp_2;
        };
        if (tmp >= 0) break :blk msg + @as(usize, @intCast(tmp)) else break :blk msg - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* = 40;
    (blk: {
        const tmp = blk_1: {
            const ref = &len;
            const tmp_2 = ref.*;
            ref.* += 1;
            break :blk_1 tmp_2;
        };
        if (tmp >= 0) break :blk msg + @as(usize, @intCast(tmp)) else break :blk msg - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* = 0;
    (blk: {
        const tmp = blk_1: {
            const ref = &len;
            const tmp_2 = ref.*;
            ref.* += 1;
            break :blk_1 tmp_2;
        };
        if (tmp >= 0) break :blk msg + @as(usize, @intCast(tmp)) else break :blk msg - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* = 4;
    @as([*c]c_ushort, @ptrCast(@alignCast(&msg[@as(c_uint, @intCast(@as(c_int, 2)))]))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(len - @as(c_int, 16))))));
    var fingerprint: u32 = _private_tls_crc32(msg, len - @as(c_int, 4)) ^ @as(u32, @bitCast(@as(c_int, 1398035790)));
    _ = &fingerprint;
    @as([*c]u32, @ptrCast(@alignCast(&(blk: {
        const tmp = len;
        if (tmp >= 0) break :blk msg + @as(usize, @intCast(tmp)) else break :blk msg - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*))).* = htonl(fingerprint);
    len += @as(c_int, 4);
    return len;
}
pub export fn tls_is_stun(arg_msg: [*c]const u8, arg_len: c_int) c_int {
    var msg = arg_msg;
    _ = &msg;
    var len = arg_len;
    _ = &len;
    if (!(msg != null) or (len < @as(c_int, 20))) return 0;
    if ((((@as(c_int, @bitCast(@as(c_uint, msg[@as(c_uint, @intCast(@as(c_int, 4)))]))) != @as(c_int, 33)) or (@as(c_int, @bitCast(@as(c_uint, msg[@as(c_uint, @intCast(@as(c_int, 5)))]))) != @as(c_int, 18))) or (@as(c_int, @bitCast(@as(c_uint, msg[@as(c_uint, @intCast(@as(c_int, 6)))]))) != @as(c_int, 164))) or (@as(c_int, @bitCast(@as(c_uint, msg[@as(c_uint, @intCast(@as(c_int, 7)))]))) != @as(c_int, 66))) return 0;
    return 1;
}
pub const tls_peerconnection_write_function = ?*const fn ([*c]struct_TLSRTCPeerConnection, [*c]const u8, c_int) callconv(.c) c_int;
pub export fn tls_peerconnection_context(arg_active: u8, arg_certificate_verify: tls_validation_function, arg_userdata: ?*anyopaque) [*c]struct_TLSRTCPeerConnection {
    var active = arg_active;
    _ = &active;
    var certificate_verify = arg_certificate_verify;
    _ = &certificate_verify;
    var userdata = arg_userdata;
    _ = &userdata;
    const pwd_chars: [64:0]u8 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_/".*;
    _ = &pwd_chars;
    var channel: [*c]struct_TLSRTCPeerConnection = @as([*c]struct_TLSRTCPeerConnection, @ptrCast(@alignCast(malloc(@sizeOf(struct_TLSRTCPeerConnection)))));
    _ = &channel;
    if (channel != null) {
        _ = memset(@as(?*anyopaque, @ptrCast(channel)), @as(c_int, 0), @sizeOf(struct_TLSRTCPeerConnection));
        _ = tls_random(@as([*c]u8, @ptrCast(@alignCast(&channel.*.stun_transcation_id))), @as(c_int, 12));
        var buffer: [32]u8 = undefined;
        _ = &buffer;
        _ = tls_random(@as([*c]u8, @ptrCast(@alignCast(&buffer))), @as(c_int, 32));
        var i: c_int = undefined;
        _ = &i;
        {
            i = 0;
            while (i < @as(c_int, 4)) : (i += 1) {
                channel.*.local_user[@as(c_uint, @intCast(i))] = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 'A') + @import("std").zig.c_translation.signedRemainder(@as(c_int, @bitCast(@as(c_uint, buffer[@as(c_uint, @intCast(i))]))), @as(c_int, 25))))));
            }
        }
        channel.*.local_user[@as(c_uint, @intCast(@as(c_int, 4)))] = 0;
        {
            i = 0;
            while (i < @as(c_int, 24)) : (i += 1) {
                channel.*.local_pwd[@as(c_uint, @intCast(i))] = pwd_chars[@as(c_ulong, @bitCast(@as(c_ulong, buffer[@as(c_uint, @intCast(i + @as(c_int, 4)))]))) % (@sizeOf([65]u8) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))))];
            }
        }
        channel.*.local_pwd[@as(c_uint, @intCast(@as(c_int, 24)))] = 0;
        channel.*.certificate_verify = certificate_verify;
        channel.*.active = active;
        channel.*.userdata = userdata;
    }
    return channel;
}
pub export fn tls_peerconnection_duplicate(arg_channel: [*c]struct_TLSRTCPeerConnection, arg_userdata: ?*anyopaque) [*c]struct_TLSRTCPeerConnection {
    var channel = arg_channel;
    _ = &channel;
    var userdata = arg_userdata;
    _ = &userdata;
    if ((!(channel != null) or (@as(c_int, @bitCast(@as(c_uint, channel.*.active))) != 0)) or !(channel.*.context != null)) return null;
    var clone: [*c]struct_TLSRTCPeerConnection = tls_peerconnection_context(@as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))), channel.*.certificate_verify, userdata);
    _ = &clone;
    clone.*.context = tls_accept(channel.*.context);
    _ = tls_srtp_set(clone.*.context);
    _ = tls_add_alpn(clone.*.context, "webrtc");
    return clone;
}
pub export fn tls_peerconnection_dtls_context(arg_channel: [*c]struct_TLSRTCPeerConnection) [*c]struct_TLSContext {
    var channel = arg_channel;
    _ = &channel;
    if (!(channel != null)) return null;
    return channel.*.context;
}
pub export fn tls_peerconnection_remote_credentials(arg_channel: [*c]struct_TLSRTCPeerConnection, arg_remote_username: [*c]u8, arg_remote_username_len: c_int, arg_remote_pwd: [*c]u8, arg_remote_pwd_len: c_int, arg_remote_fingerprint: [*c]u8, arg_remote_fingerprint_len: c_int) c_int {
    var channel = arg_channel;
    _ = &channel;
    var remote_username = arg_remote_username;
    _ = &remote_username;
    var remote_username_len = arg_remote_username_len;
    _ = &remote_username_len;
    var remote_pwd = arg_remote_pwd;
    _ = &remote_pwd;
    var remote_pwd_len = arg_remote_pwd_len;
    _ = &remote_pwd_len;
    var remote_fingerprint = arg_remote_fingerprint;
    _ = &remote_fingerprint;
    var remote_fingerprint_len = arg_remote_fingerprint_len;
    _ = &remote_fingerprint_len;
    if (!(channel != null)) return -@as(c_int, 1);
    if (channel.*.remote_user != null) {
        if (channel.*.remote_user != null) {
            free(@as(?*anyopaque, @ptrCast(channel.*.remote_user)));
        }
        channel.*.remote_user = null;
        channel.*.remote_user_len = 0;
    }
    if (channel.*.remote_pwd != null) {
        if (channel.*.remote_pwd != null) {
            free(@as(?*anyopaque, @ptrCast(channel.*.remote_pwd)));
        }
        channel.*.remote_pwd = null;
        channel.*.remote_pwd_len = 0;
    }
    if ((remote_username != null) and (remote_username_len > @as(c_int, 0))) {
        channel.*.remote_user = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, remote_username_len + @as(c_int, 1))))))));
        if (!(channel.*.remote_user != null)) return -@as(c_int, 9);
        _ = memcpy(@as(?*anyopaque, @ptrCast(channel.*.remote_user)), @as(?*const anyopaque, @ptrCast(remote_username)), @as(c_ulong, @bitCast(@as(c_long, remote_username_len))));
        (blk: {
            const tmp = remote_username_len;
            if (tmp >= 0) break :blk channel.*.remote_user + @as(usize, @intCast(tmp)) else break :blk channel.*.remote_user - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = 0;
        channel.*.remote_user_len = remote_username_len;
    }
    if ((remote_pwd != null) and (remote_pwd_len > @as(c_int, 0))) {
        channel.*.remote_pwd = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, remote_pwd_len + @as(c_int, 1))))))));
        if (!(channel.*.remote_pwd != null)) return -@as(c_int, 9);
        _ = memcpy(@as(?*anyopaque, @ptrCast(channel.*.remote_pwd)), @as(?*const anyopaque, @ptrCast(remote_pwd)), @as(c_ulong, @bitCast(@as(c_long, remote_pwd_len))));
        (blk: {
            const tmp = remote_pwd_len;
            if (tmp >= 0) break :blk channel.*.remote_pwd + @as(usize, @intCast(tmp)) else break :blk channel.*.remote_pwd - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = 0;
        channel.*.remote_pwd_len = remote_pwd_len;
    }
    if ((remote_fingerprint != null) and (remote_fingerprint_len > @as(c_int, 0))) {
        if (channel.*.context.*.dtls_data.*.remote_fingerprint != null) if (channel.*.context.*.dtls_data.*.remote_fingerprint != null) {
            free(@as(?*anyopaque, @ptrCast(channel.*.context.*.dtls_data.*.remote_fingerprint)));
        };
        channel.*.context.*.dtls_data.*.remote_fingerprint = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, remote_fingerprint_len + @as(c_int, 1))))))));
        if (!(channel.*.context.*.dtls_data.*.remote_fingerprint != null)) return -@as(c_int, 9);
        _ = memcpy(@as(?*anyopaque, @ptrCast(channel.*.context.*.dtls_data.*.remote_fingerprint)), @as(?*const anyopaque, @ptrCast(remote_fingerprint)), @as(c_ulong, @bitCast(@as(c_long, remote_fingerprint_len))));
        (blk: {
            const tmp = remote_fingerprint_len;
            if (tmp >= 0) break :blk channel.*.context.*.dtls_data.*.remote_fingerprint + @as(usize, @intCast(tmp)) else break :blk channel.*.context.*.dtls_data.*.remote_fingerprint - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = 0;
    }
    return 0;
}
pub export fn tls_peerconnection_local_pwd(arg_channel: [*c]struct_TLSRTCPeerConnection) [*c]const u8 {
    var channel = arg_channel;
    _ = &channel;
    if (!(channel != null)) return null;
    return @as([*c]u8, @ptrCast(@alignCast(&channel.*.local_pwd)));
}
pub export fn tls_peerconnection_local_username(arg_channel: [*c]struct_TLSRTCPeerConnection) [*c]const u8 {
    var channel = arg_channel;
    _ = &channel;
    if (!(channel != null)) return null;
    return @as([*c]u8, @ptrCast(@alignCast(&channel.*.local_user)));
}
pub export fn tls_peerconnection_userdata(arg_channel: [*c]struct_TLSRTCPeerConnection) ?*anyopaque {
    var channel = arg_channel;
    _ = &channel;
    if (!(channel != null)) return @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
    return channel.*.userdata;
}
pub export fn tls_peerconnection_load_keys(arg_channel: [*c]struct_TLSRTCPeerConnection, arg_pem_pub_key: [*c]const u8, arg_pem_pub_key_size: c_int, arg_pem_priv_key: [*c]const u8, arg_pem_priv_key_size: c_int) c_int {
    var channel = arg_channel;
    _ = &channel;
    var pem_pub_key = arg_pem_pub_key;
    _ = &pem_pub_key;
    var pem_pub_key_size = arg_pem_pub_key_size;
    _ = &pem_pub_key_size;
    var pem_priv_key = arg_pem_priv_key;
    _ = &pem_priv_key;
    var pem_priv_key_size = arg_pem_priv_key_size;
    _ = &pem_priv_key_size;
    if (!(channel.*.context != null)) {
        channel.*.context = tls_create_context(@as(u8, @intFromBool(!(channel.*.active != 0))), @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 65277))))));
        _ = tls_srtp_set(channel.*.context);
        _ = tls_add_alpn(channel.*.context, "webrtc");
        if (channel.*.context.*.is_server != 0) {
            channel.*.context.*.request_client_certificate = 1;
        }
    }
    if (tls_load_certificates(channel.*.context, pem_pub_key, pem_pub_key_size) < @as(c_int, 0)) return -@as(c_int, 15);
    if (tls_load_private_key(channel.*.context, pem_priv_key, pem_priv_key_size) < @as(c_int, 0)) return -@as(c_int, 15);
    return 0;
}
pub export fn tls_peerconnection_connect(arg_channel: [*c]struct_TLSRTCPeerConnection, arg_write_function: tls_peerconnection_write_function) c_int {
    var channel = arg_channel;
    _ = &channel;
    var write_function = arg_write_function;
    _ = &write_function;
    if ((!(channel != null) or !(channel.*.remote_pwd != null)) or !(channel.*.remote_user != null)) return -@as(c_int, 1);
    var msg: [1024]u8 = undefined;
    _ = &msg;
    var full_user: [1024]u8 = undefined;
    _ = &full_user;
    _ = snprintf(@as([*c]u8, @ptrCast(@alignCast(&full_user))), @sizeOf([1024]u8), "%s:%s", channel.*.remote_user, @as([*c]u8, @ptrCast(@alignCast(&channel.*.local_user))));
    var len: c_int = tls_stun_build(@as([*c]u8, @ptrCast(@alignCast(&channel.*.stun_transcation_id))), @as([*c]u8, @ptrCast(@alignCast(&full_user))), @as(c_int, @bitCast(@as(c_uint, @truncate(strlen(@as([*c]u8, @ptrCast(@alignCast(&full_user)))))))), @as([*c]u8, @ptrCast(@alignCast(channel.*.remote_pwd))), channel.*.remote_pwd_len, @as([*c]u8, @ptrCast(@alignCast(&msg))));
    _ = &len;
    if (len < @as(c_int, 0)) return 0;
    if (!(write_function != null)) return _private_tls_peerconnection_buffer_add(&channel.*.write_buffer, @as([*c]u8, @ptrCast(@alignCast(&msg))), len);
    return write_function.?(channel, @as([*c]u8, @ptrCast(@alignCast(&msg))), len);
}
pub export fn tls_peerconnection_iterate(arg_channel: [*c]struct_TLSRTCPeerConnection, arg_buf: [*c]u8, arg_buf_len: c_int, arg_addr: [*c]u8, arg_port: c_int, arg_is_ipv6: u8, arg_write_function: tls_peerconnection_write_function, arg_validate_addr: [*c]c_int) c_int {
    var channel = arg_channel;
    _ = &channel;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var addr = arg_addr;
    _ = &addr;
    var port = arg_port;
    _ = &port;
    var is_ipv6 = arg_is_ipv6;
    _ = &is_ipv6;
    var write_function = arg_write_function;
    _ = &write_function;
    var validate_addr = arg_validate_addr;
    _ = &validate_addr;
    if (validate_addr != null) {
        validate_addr.* = 0;
    }
    if ((!(channel != null) or !(buf != null)) or (buf_len <= @as(c_int, 0))) return 0;
    var err: c_int = 0;
    _ = &err;
    var context: [*c]struct_TLSContext = null;
    _ = &context;
    if (tls_is_stun(buf, buf_len) != 0) {
        var response_buffer: [32768]u8 = undefined;
        _ = &response_buffer;
        var len: c_int = tls_stun_parse(buf, buf_len, @as([*c]u8, @ptrCast(@alignCast(&channel.*.local_pwd))), @as(c_int, @bitCast(@as(c_uint, @truncate(strlen(@as([*c]u8, @ptrCast(@alignCast(&channel.*.local_pwd)))))))), is_ipv6, addr, @as(c_uint, @bitCast(port)), @as([*c]u8, @ptrCast(@alignCast(&response_buffer))));
        _ = &len;
        if ((len >= @as(c_int, 0)) and (validate_addr != null)) {
            validate_addr.* = 1;
        }
        var @"type": c_ushort = ntohs(@as([*c]c_ushort, @ptrCast(@alignCast(buf))).*);
        _ = &@"type";
        if ((len <= @as(c_int, 0)) and (@as(c_int, @bitCast(@as(c_uint, @"type"))) != @as(c_int, 257))) return len;
        if (!(channel.*.remote_state != 0)) {
            channel.*.remote_state = 1;
            if (!(channel.*.local_state != 0)) {
                _ = tls_peerconnection_connect(channel, write_function);
            }
        }
        if (((@as(c_int, @bitCast(@as(c_uint, @"type"))) == @as(c_int, 257)) and (@as(c_int, @bitCast(@as(c_uint, channel.*.remote_state))) == @as(c_int, 1))) and (@as(c_int, @bitCast(@as(c_uint, channel.*.active))) != 0)) {
            err = tls_client_connect(channel.*.context);
            if (err < @as(c_int, 0)) return err;
            context = channel.*.context;
        }
        if (len > @as(c_int, 0)) {
            if (write_function != null) {
                err = write_function.?(channel, @as([*c]u8, @ptrCast(@alignCast(&response_buffer))), len);
            } else {
                err = _private_tls_peerconnection_buffer_add(&channel.*.write_buffer, @as([*c]u8, @ptrCast(@alignCast(&response_buffer))), len);
            }
            if (err <= @as(c_int, 0)) return err;
        }
        context = channel.*.context;
        if (context != null) {
            var out_buffer_len: c_uint = 0;
            _ = &out_buffer_len;
            var out_buffer: [*c]const u8 = tls_get_write_buffer(context, &out_buffer_len);
            _ = &out_buffer;
            if ((out_buffer != null) and (out_buffer_len != 0)) {
                if (write_function != null) {
                    err = write_function.?(channel, out_buffer, @as(c_int, @bitCast(out_buffer_len)));
                } else {
                    err = _private_tls_peerconnection_buffer_add(&channel.*.write_buffer, out_buffer, @as(c_int, @bitCast(out_buffer_len)));
                }
                if (err > @as(c_int, 0)) {
                    tls_buffer_clear(context);
                }
            }
        }
        return err;
    }
    if ((@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 0)))]))) >= @as(c_int, 20)) and (@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 0)))]))) <= @as(c_int, 64))) {
        if (!(channel.*.remote_state != 0)) {
            return 0;
        }
        if (@as(c_int, @bitCast(@as(c_uint, channel.*.remote_state))) == @as(c_int, 1)) {
            channel.*.remote_state = 2;
        }
        err = tls_consume_stream(channel.*.context, buf, buf_len, channel.*.certificate_verify);
        var out_buffer_len: c_uint = 0;
        _ = &out_buffer_len;
        var out_buffer: [*c]const u8 = tls_get_write_buffer(channel.*.context, &out_buffer_len);
        _ = &out_buffer;
        if ((out_buffer != null) and (out_buffer_len != 0)) {
            if (write_function != null) {
                err = write_function.?(channel, out_buffer, @as(c_int, @bitCast(out_buffer_len)));
            } else {
                err = _private_tls_peerconnection_buffer_add(&channel.*.write_buffer, out_buffer, @as(c_int, @bitCast(out_buffer_len)));
            }
            if (err > @as(c_int, 0)) {
                tls_buffer_clear(channel.*.context);
            }
        }
        if (err < @as(c_int, 0)) return err;
        _private_dtls_ensure_keys(channel);
        return 0;
    }
    if ((@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 0)))]))) >= @as(c_int, 128)) and (@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 0)))]))) <= @as(c_int, 191))) {
        return 0;
    }
    return 0;
}
pub export fn tls_peerconnection_get_write_msg(arg_channel: [*c]struct_TLSRTCPeerConnection, arg_buf: [*c]u8) c_int {
    var channel = arg_channel;
    _ = &channel;
    var buf = arg_buf;
    _ = &buf;
    if (!(channel != null) or !(channel.*.write_buffer != null)) return 0;
    var buffer: [*c]struct_TLSRTCPeerBuffer = channel.*.write_buffer;
    _ = &buffer;
    var len: c_int = @as(c_int, @bitCast(buffer.*.len));
    _ = &len;
    if (!(buf != null)) return len;
    channel.*.write_buffer = @as([*c]struct_TLSRTCPeerBuffer, @ptrCast(@alignCast(buffer.*.next)));
    _ = memcpy(@as(?*anyopaque, @ptrCast(buf)), @as(?*const anyopaque, @ptrCast(buffer.*.buf)), @as(c_ulong, @bitCast(@as(c_ulong, buffer.*.len))));
    if (buffer.*.buf != null) if (buffer.*.buf != null) {
        free(@as(?*anyopaque, @ptrCast(buffer.*.buf)));
    };
    if (buffer != null) {
        free(@as(?*anyopaque, @ptrCast(buffer)));
    }
    return len;
}
pub export fn tls_peerconnection_get_read_msg(arg_channel: [*c]struct_TLSRTCPeerConnection, arg_buf: [*c]u8) c_int {
    var channel = arg_channel;
    _ = &channel;
    var buf = arg_buf;
    _ = &buf;
    if (!(channel != null) or !(channel.*.read_buffer != null)) return 0;
    var buffer: [*c]struct_TLSRTCPeerBuffer = channel.*.read_buffer;
    _ = &buffer;
    var len: c_int = @as(c_int, @bitCast(buffer.*.len));
    _ = &len;
    if (!(buf != null)) return len;
    channel.*.read_buffer = @as([*c]struct_TLSRTCPeerBuffer, @ptrCast(@alignCast(buffer.*.next)));
    _ = memcpy(@as(?*anyopaque, @ptrCast(buf)), @as(?*const anyopaque, @ptrCast(buffer.*.buf)), @as(c_ulong, @bitCast(@as(c_ulong, buffer.*.len))));
    if (buffer.*.buf != null) if (buffer.*.buf != null) {
        free(@as(?*anyopaque, @ptrCast(buffer.*.buf)));
    };
    if (buffer != null) {
        free(@as(?*anyopaque, @ptrCast(buffer)));
    }
    return len;
}
pub export fn tls_peerconnection_status(arg_channel: [*c]struct_TLSRTCPeerConnection) c_int {
    var channel = arg_channel;
    _ = &channel;
    if (!(channel != null)) return -@as(c_int, 1);
    var status: c_int = @as(c_int, @bitCast(@as(c_uint, channel.*.remote_state)));
    _ = &status;
    if (channel.*.context.*.critical_error != 0) {
        status = 4;
    }
    return status;
}
pub export fn tls_destroy_peerconnection(arg_channel: [*c]struct_TLSRTCPeerConnection) void {
    var channel = arg_channel;
    _ = &channel;
    if (!(channel != null)) return;
    if (channel.*.context != null) {
        tls_destroy_context(channel.*.context);
    }
    if (channel.*.remote_user != null) if (channel.*.remote_user != null) {
        free(@as(?*anyopaque, @ptrCast(channel.*.remote_user)));
    };
    if (channel.*.remote_pwd != null) if (channel.*.remote_pwd != null) {
        free(@as(?*anyopaque, @ptrCast(channel.*.remote_pwd)));
    };
    while (channel.*.write_buffer != null) {
        var next: [*c]struct_TLSRTCPeerBuffer = @as([*c]struct_TLSRTCPeerBuffer, @ptrCast(@alignCast(channel.*.write_buffer.*.next)));
        _ = &next;
        if (channel.*.write_buffer.*.buf != null) if (channel.*.write_buffer.*.buf != null) {
            free(@as(?*anyopaque, @ptrCast(channel.*.write_buffer.*.buf)));
        };
        if (channel.*.write_buffer != null) {
            free(@as(?*anyopaque, @ptrCast(channel.*.write_buffer)));
        }
        channel.*.write_buffer = next;
    }
    while (channel.*.read_buffer != null) {
        var next: [*c]struct_TLSRTCPeerBuffer = @as([*c]struct_TLSRTCPeerBuffer, @ptrCast(@alignCast(channel.*.read_buffer.*.next)));
        _ = &next;
        if (channel.*.read_buffer.*.buf != null) if (channel.*.read_buffer.*.buf != null) {
            free(@as(?*anyopaque, @ptrCast(channel.*.read_buffer.*.buf)));
        };
        if (channel.*.read_buffer != null) {
            free(@as(?*anyopaque, @ptrCast(channel.*.read_buffer)));
        }
        channel.*.read_buffer = next;
    }
    if (channel != null) {
        free(@as(?*anyopaque, @ptrCast(channel)));
    }
}
pub export fn tls_cert_fingerprint(arg_pem_data: [*c]const u8, arg_pem_size: c_int, arg_buffer: [*c]u8, arg_buf_len: c_uint) c_int {
    var pem_data = arg_pem_data;
    _ = &pem_data;
    var pem_size = arg_pem_size;
    _ = &pem_size;
    var buffer = arg_buffer;
    _ = &buffer;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var len: c_uint = 0;
    _ = &len;
    if (!(buffer != null) or !(buf_len != 0)) return -@as(c_int, 1);
    var data: [*c]u8 = tls_pem_decode(@as([*c]const u8, @ptrCast(@alignCast(pem_data))), @as(c_uint, @bitCast(pem_size)), @as(c_int, 0), &len);
    _ = &data;
    if (!(data != null)) return -@as(c_int, 1);
    var hash: [32]u8 = undefined;
    _ = &hash;
    var state: hash_state = undefined;
    _ = &state;
    _ = sha256_init(&state);
    _ = sha256_process(&state, data, @as(c_ulong, @bitCast(@as(c_ulong, len))));
    _ = sha256_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
    if (data != null) {
        free(@as(?*anyopaque, @ptrCast(data)));
    }
    var i: c_int = undefined;
    _ = &i;
    buffer[@as(c_uint, @intCast(@as(c_int, 0)))] = 0;
    {
        i = 0;
        while (i < @as(c_int, 32)) : (i += 1) {
            if (buf_len <= @as(c_uint, @bitCast(@as(c_int, 1)))) break;
            if (i != 0) {
                _ = snprintf(buffer, @as(c_ulong, @bitCast(@as(c_ulong, buf_len))), ":");
                buffer += 1;
                buf_len -%= 1;
            }
            if (buf_len <= @as(c_uint, @bitCast(@as(c_int, 2)))) break;
            _ = snprintf(buffer, @as(c_ulong, @bitCast(@as(c_ulong, buf_len))), "%02X", @as(c_uint, @bitCast(@as(c_uint, hash[@as(c_uint, @intCast(i))]))));
            buffer += @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 2)))));
            buf_len -%= @as(c_uint, @bitCast(@as(c_int, 2)));
        }
    }
    return 0;
}
pub export fn tls_load_root_certificates(arg_context: [*c]struct_TLSContext, arg_pem_buffer: [*c]const u8, arg_pem_size: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var pem_buffer = arg_pem_buffer;
    _ = &pem_buffer;
    var pem_size = arg_pem_size;
    _ = &pem_size;
    if (!(context != null)) return -@as(c_int, 1);
    var len: c_uint = undefined;
    _ = &len;
    var idx: c_int = 0;
    _ = &idx;
    while (true) {
        var data: [*c]u8 = tls_pem_decode(pem_buffer, @as(c_uint, @bitCast(pem_size)), blk: {
            const ref = &idx;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }, &len);
        _ = &data;
        if (!(data != null) or !(len != 0)) break;
        var cert: [*c]struct_TLSCertificate = asn1_parse(null, data, len, @as(c_int, 0));
        _ = &cert;
        if (cert != null) {
            if ((@as(c_int, @bitCast(@as(c_uint, cert.*.version))) == @as(c_int, 2)) or (@as(c_int, @bitCast(@as(c_uint, cert.*.version))) == @as(c_int, 0))) {
                if (cert.*.priv != null) {
                    if (cert.*.priv != null) {
                        free(@as(?*anyopaque, @ptrCast(cert.*.priv)));
                    }
                    cert.*.priv = null;
                    cert.*.priv_len = 0;
                }
                context.*.root_certificates = @as([*c][*c]struct_TLSCertificate, @ptrCast(@alignCast(realloc(@as(?*anyopaque, @ptrCast(context.*.root_certificates)), @as(c_ulong, @bitCast(@as(c_ulong, context.*.root_count +% @as(c_uint, @bitCast(@as(c_int, 1)))))) *% @sizeOf([*c]struct_TLSCertificate)))));
                if (!(context.*.root_certificates != null)) {
                    context.*.root_count = 0;
                    return -@as(c_int, 1);
                }
                context.*.root_certificates[context.*.root_count] = cert;
                context.*.root_count +%= 1;
            } else {
                tls_destroy_certificate(cert);
            }
        }
        if (data != null) {
            free(@as(?*anyopaque, @ptrCast(data)));
        }
    }
    return @as(c_int, @bitCast(context.*.root_count));
}
pub export fn tls_default_verify(arg_context: [*c]struct_TLSContext, arg_certificate_chain: [*c][*c]struct_TLSCertificate, arg_len: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var certificate_chain = arg_certificate_chain;
    _ = &certificate_chain;
    var len = arg_len;
    _ = &len;
    var i: c_int = undefined;
    _ = &i;
    var err: c_int = undefined;
    _ = &err;
    if (certificate_chain != null) {
        {
            i = 0;
            while (i < len) : (i += 1) {
                var certificate: [*c]struct_TLSCertificate = (blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk certificate_chain + @as(usize, @intCast(tmp)) else break :blk certificate_chain - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*;
                _ = &certificate;
                err = tls_certificate_is_valid(certificate);
                if (err != 0) return err;
            }
        }
    }
    err = tls_certificate_chain_is_valid(certificate_chain, len);
    if (err != 0) return err;
    if (((!(context.*.is_server != 0) and (context.*.sni != null)) and (len > @as(c_int, 0))) and (certificate_chain != null)) {
        err = tls_certificate_valid_subject(certificate_chain[@as(c_uint, @intCast(@as(c_int, 0)))], context.*.sni);
        if (err != 0) return err;
    }
    err = tls_certificate_chain_is_valid_root(context, certificate_chain, len);
    if (err != 0) return err;
    return no_error;
}
pub extern fn tls_print_certificate(fname: [*c]const u8) void;
pub export fn tls_add_alpn(arg_context: [*c]struct_TLSContext, arg_alpn: [*c]const u8) c_int {
    var context = arg_context;
    _ = &context;
    var alpn = arg_alpn;
    _ = &alpn;
    if (((!(context != null) or !(alpn != null)) or !(alpn[@as(c_uint, @intCast(@as(c_int, 0)))] != 0)) or ((@as(c_int, @bitCast(@as(c_uint, context.*.is_server))) != 0) and (@as(c_int, @bitCast(@as(c_uint, context.*.is_child))) != 0))) return -@as(c_int, 1);
    var len: c_int = @as(c_int, @bitCast(@as(c_uint, @truncate(strlen(alpn)))));
    _ = &len;
    if (tls_alpn_contains(context, alpn, @as(u8, @bitCast(@as(i8, @truncate(len))))) != 0) return 0;
    context.*.alpn = @as([*c][*c]u8, @ptrCast(@alignCast(realloc(@as(?*anyopaque, @ptrCast(context.*.alpn)), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, context.*.alpn_count))) + @as(c_int, 1)))) *% @sizeOf([*c]u8)))));
    if (!(context.*.alpn != null)) {
        context.*.alpn_count = 0;
        return -@as(c_int, 9);
    }
    var alpn_ref: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, len + @as(c_int, 1))))))));
    _ = &alpn_ref;
    context.*.alpn[context.*.alpn_count] = alpn_ref;
    if (alpn_ref != null) {
        _ = memcpy(@as(?*anyopaque, @ptrCast(alpn_ref)), @as(?*const anyopaque, @ptrCast(alpn)), @as(c_ulong, @bitCast(@as(c_long, len))));
        (blk: {
            const tmp = len;
            if (tmp >= 0) break :blk alpn_ref + @as(usize, @intCast(tmp)) else break :blk alpn_ref - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = 0;
        context.*.alpn_count +%= 1;
    } else return -@as(c_int, 9);
    return 0;
}
pub export fn tls_alpn_contains(arg_context: [*c]struct_TLSContext, arg_alpn: [*c]const u8, arg_alpn_size: u8) c_int {
    var context = arg_context;
    _ = &context;
    var alpn = arg_alpn;
    _ = &alpn;
    var alpn_size = arg_alpn_size;
    _ = &alpn_size;
    if ((!(context != null) or !(alpn != null)) or !(alpn_size != 0)) return 0;
    if (context.*.alpn != null) {
        var i: c_int = undefined;
        _ = &i;
        {
            i = 0;
            while (i < @as(c_int, @bitCast(@as(c_uint, context.*.alpn_count)))) : (i += 1) {
                var alpn_local: [*c]const u8 = (blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk context.*.alpn + @as(usize, @intCast(tmp)) else break :blk context.*.alpn - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*;
                _ = &alpn_local;
                if (alpn_local != null) {
                    var len: c_int = @as(c_int, @bitCast(@as(c_uint, @truncate(strlen(alpn_local)))));
                    _ = &len;
                    if (@as(c_int, @bitCast(@as(c_uint, alpn_size))) == len) {
                        if (!(memcmp(@as(?*const anyopaque, @ptrCast(alpn_local)), @as(?*const anyopaque, @ptrCast(alpn)), @as(c_ulong, @bitCast(@as(c_ulong, alpn_size)))) != 0)) return 1;
                    }
                }
            }
        }
    }
    return 0;
}
pub export fn tls_alpn(arg_context: [*c]struct_TLSContext) [*c]const u8 {
    var context = arg_context;
    _ = &context;
    if (!(context != null)) return null;
    return context.*.negotiated_alpn;
}
pub export fn tls_clear_certificates(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    var i: c_uint = undefined;
    _ = &i;
    if ((!(context != null) or !(context.*.is_server != 0)) or (@as(c_int, @bitCast(@as(c_uint, context.*.is_child))) != 0)) return -@as(c_int, 1);
    if (context.*.root_certificates != null) {
        {
            i = 0;
            while (i < context.*.root_count) : (i +%= 1) {
                tls_destroy_certificate(context.*.root_certificates[i]);
            }
        }
    }
    context.*.root_certificates = null;
    context.*.root_count = 0;
    if (context.*.private_key != null) {
        tls_destroy_certificate(context.*.private_key);
    }
    context.*.private_key = null;
    if (context.*.ec_private_key != null) {
        tls_destroy_certificate(context.*.ec_private_key);
    }
    context.*.ec_private_key = null;
    if (context.*.certificates != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.certificates)));
    }
    context.*.certificates = null;
    context.*.certificates_count = 0;
    return 0;
}
pub export fn tls_make_ktls(arg_context: [*c]struct_TLSContext, arg_socket_1: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var socket_1 = arg_socket_1;
    _ = &socket_1;
    if (((!(context != null) or (@as(c_int, @bitCast(@as(c_uint, context.*.critical_error))) != 0)) or (@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) != @as(c_int, 255))) or !(context.*.crypto.created != 0)) {
        return -@as(c_int, 1);
    }
    if (!(context.*.exportable != 0) or !(context.*.exportable_keys != null)) {
        return -@as(c_int, 1);
    }
    if ((((@as(c_int, @bitCast(@as(c_uint, context.*.version))) != @as(c_int, 771)) and (@as(c_int, @bitCast(@as(c_uint, context.*.version))) != @as(c_int, 65277))) and (@as(c_int, @bitCast(@as(c_uint, context.*.version))) != @as(c_int, 772))) and (@as(c_int, @bitCast(@as(c_uint, context.*.version))) != @as(c_int, 65276))) {
        return -@as(c_int, 17);
    }
    while (true) {
        switch (@as(c_int, @bitCast(@as(c_uint, context.*.cipher)))) {
            @as(c_int, 156), @as(c_int, 158), @as(c_int, 49199), @as(c_int, 49195), @as(c_int, 4865) => break,
            else => {
                {}
                return -@as(c_int, 17);
            },
        }
        break;
    }
    return -@as(c_int, 17);
}
pub export fn tls_unmake_ktls(arg_context: [*c]struct_TLSContext, arg_socket_1: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var socket_1 = arg_socket_1;
    _ = &socket_1;
    return -@as(c_int, 17);
}
pub export fn dtls_reset_cookie_secret() void {
    _ = tls_random(@as([*c]u8, @ptrCast(@alignCast(&dtls_secret))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([32]u8))))));
}
pub export fn tls_remote_error(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    if (!(context != null)) return -@as(c_int, 1);
    return @as(c_int, @bitCast(@as(c_uint, context.*.error_code)));
}
pub const SSL_CTX = struct_TLSContext;
pub const SSL = struct_TLSContext;
pub const SOCKET_RECV_CALLBACK = ?*const fn (c_int, ?*anyopaque, usize, c_int) callconv(.c) c_int;
pub const SOCKET_SEND_CALLBACK = ?*const fn (c_int, ?*const anyopaque, usize, c_int) callconv(.c) c_int;
pub const SSLUserData = extern struct {
    fd: c_int = @import("std").mem.zeroes(c_int),
    certificate_verify: tls_validation_function = @import("std").mem.zeroes(tls_validation_function),
    recv: SOCKET_RECV_CALLBACK = @import("std").mem.zeroes(SOCKET_RECV_CALLBACK),
    send: SOCKET_SEND_CALLBACK = @import("std").mem.zeroes(SOCKET_SEND_CALLBACK),
    user_data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub export fn SSL_library_init() c_int {
    return 1;
}
pub export fn SSL_load_error_strings() void {}
pub export fn OpenSSL_add_all_algorithms() void {}
pub export fn OpenSSL_add_all_ciphers() void {}
pub export fn OpenSSL_add_all_digests() void {}
pub export fn EVP_cleanup() void {}
pub export fn SSLv3_server_method() c_int {
    return 1;
}
pub export fn SSLv3_client_method() c_int {
    return 0;
}
pub export fn SSL_new(arg_context: [*c]struct_TLSContext) [*c]struct_TLSContext {
    var context = arg_context;
    _ = &context;
    return tls_accept(context);
}
pub export fn SSL_CTX_use_certificate_file(arg_context: [*c]struct_TLSContext, arg_filename: [*c]const u8, arg_dummy: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var filename = arg_filename;
    _ = &filename;
    var dummy = arg_dummy;
    _ = &dummy;
    var buf: [65535]u8 = undefined;
    _ = &buf;
    var size: c_int = _private_tls_read_from_file(filename, @as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&buf))))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([65535]u8))))));
    _ = &size;
    if (size > @as(c_int, 0)) return tls_load_certificates(context, @as([*c]u8, @ptrCast(@alignCast(&buf))), size);
    return size;
}
pub export fn SSL_CTX_use_PrivateKey_file(arg_context: [*c]struct_TLSContext, arg_filename: [*c]const u8, arg_dummy: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var filename = arg_filename;
    _ = &filename;
    var dummy = arg_dummy;
    _ = &dummy;
    var buf: [65535]u8 = undefined;
    _ = &buf;
    var size: c_int = _private_tls_read_from_file(filename, @as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&buf))))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([65535]u8))))));
    _ = &size;
    if (size > @as(c_int, 0)) return tls_load_private_key(context, @as([*c]u8, @ptrCast(@alignCast(&buf))), size);
    return size;
}
pub export fn SSL_CTX_check_private_key(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    if (!(context != null) or (((!(context.*.private_key != null) or !(context.*.private_key.*.der_bytes != null)) or !(context.*.private_key.*.der_len != 0)) and ((!(context.*.ec_private_key != null) or !(context.*.ec_private_key.*.der_bytes != null)) or !(context.*.ec_private_key.*.der_len != 0)))) return 0;
    return 1;
}
pub export fn SSL_CTX_new(arg_method: c_int) [*c]struct_TLSContext {
    var method = arg_method;
    _ = &method;
    return tls_create_context(@as(u8, @bitCast(@as(i8, @truncate(method)))), @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 772))))));
}
pub export fn SSL_free(arg_context: [*c]struct_TLSContext) void {
    var context = arg_context;
    _ = &context;
    if (context != null) {
        if (context.*.user_data != null) {
            free(context.*.user_data);
        }
        tls_destroy_context(context);
    }
}
pub export fn SSL_CTX_free(arg_context: [*c]struct_TLSContext) void {
    var context = arg_context;
    _ = &context;
    SSL_free(context);
}
pub export fn SSL_get_error(arg_context: [*c]struct_TLSContext, arg_ret: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var ret = arg_ret;
    _ = &ret;
    if (!(context != null)) return -@as(c_int, 1);
    return @as(c_int, @bitCast(@as(c_uint, context.*.critical_error)));
}
pub export fn SSL_set_fd(arg_context: [*c]struct_TLSContext, arg_socket_1: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var socket_1 = arg_socket_1;
    _ = &socket_1;
    if (!(context != null)) return 0;
    var ssl_data: [*c]SSLUserData = @as([*c]SSLUserData, @ptrCast(@alignCast(context.*.user_data)));
    _ = &ssl_data;
    if (!(ssl_data != null)) {
        ssl_data = @as([*c]SSLUserData, @ptrCast(@alignCast(malloc(@sizeOf(SSLUserData)))));
        if (!(ssl_data != null)) return -@as(c_int, 9);
        _ = memset(@as(?*anyopaque, @ptrCast(ssl_data)), @as(c_int, 0), @sizeOf(SSLUserData));
        context.*.user_data = @as(?*anyopaque, @ptrCast(ssl_data));
    }
    ssl_data.*.fd = socket_1;
    return 1;
}
pub export fn SSL_set_userdata(arg_context: [*c]struct_TLSContext, arg_data: ?*anyopaque) ?*anyopaque {
    var context = arg_context;
    _ = &context;
    var data = arg_data;
    _ = &data;
    if (!(context != null)) return @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
    var ssl_data: [*c]SSLUserData = @as([*c]SSLUserData, @ptrCast(@alignCast(context.*.user_data)));
    _ = &ssl_data;
    if (!(ssl_data != null)) {
        ssl_data = @as([*c]SSLUserData, @ptrCast(@alignCast(malloc(@sizeOf(SSLUserData)))));
        if (!(ssl_data != null)) return @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
        _ = memset(@as(?*anyopaque, @ptrCast(ssl_data)), @as(c_int, 0), @sizeOf(SSLUserData));
        context.*.user_data = @as(?*anyopaque, @ptrCast(ssl_data));
    }
    var old_data: ?*anyopaque = ssl_data.*.user_data;
    _ = &old_data;
    ssl_data.*.user_data = data;
    return old_data;
}
pub export fn SSL_userdata(arg_context: [*c]struct_TLSContext) ?*anyopaque {
    var context = arg_context;
    _ = &context;
    if (!(context != null)) return @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
    var ssl_data: [*c]SSLUserData = @as([*c]SSLUserData, @ptrCast(@alignCast(context.*.user_data)));
    _ = &ssl_data;
    if (!(ssl_data != null)) return @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
    return ssl_data.*.user_data;
}
pub export fn SSL_CTX_root_ca(arg_context: [*c]struct_TLSContext, arg_pem_filename: [*c]const u8) c_int {
    var context = arg_context;
    _ = &context;
    var pem_filename = arg_pem_filename;
    _ = &pem_filename;
    if (!(context != null)) return -@as(c_int, 1);
    var count: c_int = -@as(c_int, 1);
    _ = &count;
    var f: [*c]FILE = fopen(pem_filename, "rb");
    _ = &f;
    if (f != null) {
        _ = fseek(f, @as(c_long, @bitCast(@as(c_long, @as(c_int, 0)))), @as(c_int, 2));
        var size: usize = @as(usize, @bitCast(ftell(f)));
        _ = &size;
        _ = fseek(f, @as(c_long, @bitCast(@as(c_long, @as(c_int, 0)))), @as(c_int, 0));
        if (size != 0) {
            var buf: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(malloc(size +% @as(usize, @bitCast(@as(c_long, @as(c_int, 1))))))));
            _ = &buf;
            if (buf != null) {
                buf[size] = 1;
                if (fread(@as(?*anyopaque, @ptrCast(buf)), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))), size, f) == size) {
                    count = tls_load_root_certificates(context, buf, @as(c_int, @bitCast(@as(c_uint, @truncate(size)))));
                    if (count > @as(c_int, 0)) {
                        var ssl_data: [*c]SSLUserData = @as([*c]SSLUserData, @ptrCast(@alignCast(context.*.user_data)));
                        _ = &ssl_data;
                        if (!(ssl_data != null)) {
                            ssl_data = @as([*c]SSLUserData, @ptrCast(@alignCast(malloc(@sizeOf(SSLUserData)))));
                            if (!(ssl_data != null)) {
                                _ = fclose(f);
                                return -@as(c_int, 9);
                            }
                            _ = memset(@as(?*anyopaque, @ptrCast(ssl_data)), @as(c_int, 0), @sizeOf(SSLUserData));
                            context.*.user_data = @as(?*anyopaque, @ptrCast(ssl_data));
                        }
                        if (!(ssl_data.*.certificate_verify != null)) {
                            ssl_data.*.certificate_verify = &tls_default_verify;
                        }
                    }
                }
                if (buf != null) {
                    free(@as(?*anyopaque, @ptrCast(buf)));
                }
            }
        }
        _ = fclose(f);
    }
    return count;
}
pub export fn SSL_CTX_set_verify(arg_context: [*c]struct_TLSContext, arg_mode: c_int, arg_verify_callback: tls_validation_function) void {
    var context = arg_context;
    _ = &context;
    var mode = arg_mode;
    _ = &mode;
    var verify_callback = arg_verify_callback;
    _ = &verify_callback;
    if (!(context != null)) return;
    var ssl_data: [*c]SSLUserData = @as([*c]SSLUserData, @ptrCast(@alignCast(context.*.user_data)));
    _ = &ssl_data;
    if (!(ssl_data != null)) {
        ssl_data = @as([*c]SSLUserData, @ptrCast(@alignCast(malloc(@sizeOf(SSLUserData)))));
        if (!(ssl_data != null)) return;
        _ = memset(@as(?*anyopaque, @ptrCast(ssl_data)), @as(c_int, 0), @sizeOf(SSLUserData));
        context.*.user_data = @as(?*anyopaque, @ptrCast(ssl_data));
    }
    if (mode == @as(c_int, 0)) {
        ssl_data.*.certificate_verify = null;
    } else {
        ssl_data.*.certificate_verify = verify_callback;
    }
}
pub export fn SSL_accept(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    if (!(context != null)) return -@as(c_int, 1);
    var ssl_data: [*c]SSLUserData = @as([*c]SSLUserData, @ptrCast(@alignCast(context.*.user_data)));
    _ = &ssl_data;
    if (!(ssl_data != null) or (ssl_data.*.fd < @as(c_int, 0))) return -@as(c_int, 1);
    if (tls_established(context) != 0) return 1;
    var client_message: [65535]u8 = undefined;
    _ = &client_message;
    var read_size: c_int = 0;
    _ = &read_size;
    while ((blk: {
        const tmp = _private_tls_safe_read(context, @as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&client_message)))))))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([65535]u8))))));
        read_size = tmp;
        break :blk tmp;
    }) > @as(c_int, 0)) {
        if (tls_consume_stream(context, @as([*c]u8, @ptrCast(@alignCast(&client_message))), read_size, ssl_data.*.certificate_verify) >= @as(c_int, 0)) {
            var res: c_int = _tls_ssl_private_send_pending(ssl_data.*.fd, context);
            _ = &res;
            if (res < @as(c_int, 0)) return res;
        }
        if (tls_established(context) != 0) return 1;
    }
    if (read_size <= @as(c_int, 0)) return -@as(c_int, 13);
    return 0;
}
pub export fn SSL_connect(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    if (!(context != null)) return -@as(c_int, 1);
    var ssl_data: [*c]SSLUserData = @as([*c]SSLUserData, @ptrCast(@alignCast(context.*.user_data)));
    _ = &ssl_data;
    if ((!(ssl_data != null) or (ssl_data.*.fd < @as(c_int, 0))) or (@as(c_int, @bitCast(@as(c_uint, context.*.critical_error))) != 0)) return -@as(c_int, 1);
    var res: c_int = tls_client_connect(context);
    _ = &res;
    if (res < @as(c_int, 0)) return res;
    res = _tls_ssl_private_send_pending(ssl_data.*.fd, context);
    if (res < @as(c_int, 0)) return res;
    var read_size: c_int = undefined;
    _ = &read_size;
    var client_message: [65535]u8 = undefined;
    _ = &client_message;
    while ((blk: {
        const tmp = _private_tls_safe_read(context, @as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&client_message)))))))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([65535]u8))))));
        read_size = tmp;
        break :blk tmp;
    }) > @as(c_int, 0)) {
        if (tls_consume_stream(context, @as([*c]u8, @ptrCast(@alignCast(&client_message))), read_size, ssl_data.*.certificate_verify) >= @as(c_int, 0)) {
            res = _tls_ssl_private_send_pending(ssl_data.*.fd, context);
            if (res < @as(c_int, 0)) return res;
        }
        if (tls_established(context) != 0) return 1;
        if (context.*.critical_error != 0) return -@as(c_int, 1);
    }
    return read_size;
}
pub export fn SSL_shutdown(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    if (!(context != null)) return -@as(c_int, 1);
    var ssl_data: [*c]SSLUserData = @as([*c]SSLUserData, @ptrCast(@alignCast(context.*.user_data)));
    _ = &ssl_data;
    if (!(ssl_data != null) or (ssl_data.*.fd < @as(c_int, 0))) return -@as(c_int, 1);
    tls_close_notify(context);
    return 0;
}
pub export fn SSL_write(arg_context: [*c]struct_TLSContext, arg_buf: ?*const anyopaque, arg_len: c_uint) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var len = arg_len;
    _ = &len;
    if (!(context != null)) return -@as(c_int, 1);
    var ssl_data: [*c]SSLUserData = @as([*c]SSLUserData, @ptrCast(@alignCast(context.*.user_data)));
    _ = &ssl_data;
    if (!(ssl_data != null) or (ssl_data.*.fd < @as(c_int, 0))) return -@as(c_int, 1);
    var written_size: c_int = tls_write(context, @as([*c]const u8, @ptrCast(@alignCast(buf))), len);
    _ = &written_size;
    if (written_size > @as(c_int, 0)) {
        var res: c_int = _tls_ssl_private_send_pending(ssl_data.*.fd, context);
        _ = &res;
        if (res <= @as(c_int, 0)) return res;
    }
    return written_size;
}
pub export fn SSL_read(arg_context: [*c]struct_TLSContext, arg_buf: ?*anyopaque, arg_len: c_uint) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var len = arg_len;
    _ = &len;
    if (!(context != null)) return -@as(c_int, 1);
    if (context.*.application_buffer_len != 0) return tls_read(context, @as([*c]u8, @ptrCast(@alignCast(buf))), len);
    var ssl_data: [*c]SSLUserData = @as([*c]SSLUserData, @ptrCast(@alignCast(context.*.user_data)));
    _ = &ssl_data;
    if ((!(ssl_data != null) or (ssl_data.*.fd < @as(c_int, 0))) or (@as(c_int, @bitCast(@as(c_uint, context.*.critical_error))) != 0)) return -@as(c_int, 1);
    if (tls_established(context) != @as(c_int, 1)) return -@as(c_int, 1);
    var client_message: [65535]u8 = undefined;
    _ = &client_message;
    var read_size: c_int = 0;
    _ = &read_size;
    while (!(context.*.application_buffer_len != 0) and ((blk: {
        const tmp = _private_tls_safe_read(context, @as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&client_message)))))))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([65535]u8))))));
        read_size = tmp;
        break :blk tmp;
    }) > @as(c_int, 0))) {
        if (tls_consume_stream(context, @as([*c]u8, @ptrCast(@alignCast(&client_message))), read_size, ssl_data.*.certificate_verify) > @as(c_int, 0)) {
            _ = _tls_ssl_private_send_pending(ssl_data.*.fd, context);
        }
        if ((@as(c_int, @bitCast(@as(c_uint, context.*.critical_error))) != 0) and !(context.*.application_buffer_len != 0)) return -@as(c_int, 1);
    }
    if ((read_size <= @as(c_int, 0)) and !(context.*.application_buffer_len != 0)) return read_size;
    return tls_read(context, @as([*c]u8, @ptrCast(@alignCast(buf))), len);
}
pub export fn SSL_pending(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    if (!(context != null)) return -@as(c_int, 1);
    return @as(c_int, @bitCast(context.*.application_buffer_len));
}
pub export fn SSL_set_io(arg_context: [*c]struct_TLSContext, arg_recv_cb: SOCKET_RECV_CALLBACK, arg_send_cb: SOCKET_SEND_CALLBACK) c_int {
    var context = arg_context;
    _ = &context;
    var recv_cb = arg_recv_cb;
    _ = &recv_cb;
    var send_cb = arg_send_cb;
    _ = &send_cb;
    if (!(context != null)) return -@as(c_int, 1);
    var ssl_data: [*c]SSLUserData = @as([*c]SSLUserData, @ptrCast(@alignCast(context.*.user_data)));
    _ = &ssl_data;
    if (!(ssl_data != null)) {
        ssl_data = @as([*c]SSLUserData, @ptrCast(@alignCast(malloc(@sizeOf(SSLUserData)))));
        if (!(ssl_data != null)) return -@as(c_int, 9);
        _ = memset(@as(?*anyopaque, @ptrCast(ssl_data)), @as(c_int, 0), @sizeOf(SSLUserData));
        context.*.user_data = @as(?*anyopaque, @ptrCast(ssl_data));
    }
    ssl_data.*.recv = recv_cb;
    ssl_data.*.send = send_cb;
    return 0;
}
pub const struct_chacha_ctx = extern struct {
    input: [16]c_uint = @import("std").mem.zeroes([16]c_uint),
    ks: [64]u8 = @import("std").mem.zeroes([64]u8),
    unused: u8 = @import("std").mem.zeroes(u8),
};
pub const djb_u32 = c_uint;
pub fn chacha_keysetup(arg_x: [*c]struct_chacha_ctx, arg_k: [*c]const u8, arg_kbits: c_uint) callconv(.c) void {
    var x = arg_x;
    _ = &x;
    var k = arg_k;
    _ = &k;
    var kbits = arg_kbits;
    _ = &kbits;
    var constants: [*c]const u8 = undefined;
    _ = &constants;
    x.*.input[@as(c_uint, @intCast(@as(c_int, 4)))] = ((@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
    x.*.input[@as(c_uint, @intCast(@as(c_int, 5)))] = ((@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
    x.*.input[@as(c_uint, @intCast(@as(c_int, 6)))] = ((@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
    x.*.input[@as(c_uint, @intCast(@as(c_int, 7)))] = ((@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
    if (kbits == @as(djb_u32, @bitCast(@as(c_int, 256)))) {
        k += @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16)))));
        constants = @as([*c]const u8, @ptrCast(@alignCast(&sigma)));
    } else {
        constants = @as([*c]const u8, @ptrCast(@alignCast(&tau)));
    }
    x.*.input[@as(c_uint, @intCast(@as(c_int, 8)))] = ((@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
    x.*.input[@as(c_uint, @intCast(@as(c_int, 9)))] = ((@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
    x.*.input[@as(c_uint, @intCast(@as(c_int, 10)))] = ((@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
    x.*.input[@as(c_uint, @intCast(@as(c_int, 11)))] = ((@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
    x.*.input[@as(c_uint, @intCast(@as(c_int, 0)))] = ((@as(djb_u32, @bitCast(@as(c_uint, (constants + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (constants + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (constants + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (constants + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
    x.*.input[@as(c_uint, @intCast(@as(c_int, 1)))] = ((@as(djb_u32, @bitCast(@as(c_uint, (constants + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (constants + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (constants + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (constants + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
    x.*.input[@as(c_uint, @intCast(@as(c_int, 2)))] = ((@as(djb_u32, @bitCast(@as(c_uint, (constants + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (constants + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (constants + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (constants + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
    x.*.input[@as(c_uint, @intCast(@as(c_int, 3)))] = ((@as(djb_u32, @bitCast(@as(c_uint, (constants + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (constants + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (constants + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (constants + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
}
pub fn chacha_ivsetup(arg_x: [*c]struct_chacha_ctx, arg_iv: [*c]const u8, arg_counter: [*c]const u8) callconv(.c) void {
    var x = arg_x;
    _ = &x;
    var iv = arg_iv;
    _ = &iv;
    var counter = arg_counter;
    _ = &counter;
    x.*.input[@as(c_uint, @intCast(@as(c_int, 12)))] = if (counter == @as([*c]const djb_u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) @as(djb_u32, @bitCast(@as(c_int, 0))) else ((@as(djb_u32, @bitCast(@as(c_uint, (counter + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (counter + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (counter + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (counter + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
    x.*.input[@as(c_uint, @intCast(@as(c_int, 13)))] = if (counter == @as([*c]const djb_u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) @as(djb_u32, @bitCast(@as(c_int, 0))) else ((@as(djb_u32, @bitCast(@as(c_uint, (counter + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (counter + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (counter + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (counter + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
    if (iv != null) {
        x.*.input[@as(c_uint, @intCast(@as(c_int, 14)))] = ((@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
        x.*.input[@as(c_uint, @intCast(@as(c_int, 15)))] = ((@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
    }
}
pub fn chacha_ivsetup_96bitnonce(arg_x: [*c]struct_chacha_ctx, arg_iv: [*c]const u8, arg_counter: [*c]const u8) callconv(.c) void {
    var x = arg_x;
    _ = &x;
    var iv = arg_iv;
    _ = &iv;
    var counter = arg_counter;
    _ = &counter;
    x.*.input[@as(c_uint, @intCast(@as(c_int, 12)))] = if (counter == @as([*c]const djb_u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) @as(djb_u32, @bitCast(@as(c_int, 0))) else ((@as(djb_u32, @bitCast(@as(c_uint, (counter + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (counter + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (counter + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (counter + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
    if (iv != null) {
        x.*.input[@as(c_uint, @intCast(@as(c_int, 13)))] = ((@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
        x.*.input[@as(c_uint, @intCast(@as(c_int, 14)))] = ((@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
        x.*.input[@as(c_uint, @intCast(@as(c_int, 15)))] = ((@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
    }
}
pub fn chacha_encrypt_bytes(arg_x: [*c]struct_chacha_ctx, arg_m: [*c]const u8, arg_c: [*c]u8, arg_bytes: c_uint) callconv(.c) void {
    var x = arg_x;
    _ = &x;
    var m = arg_m;
    _ = &m;
    var c = arg_c;
    _ = &c;
    var bytes = arg_bytes;
    _ = &bytes;
    var x0: djb_u32 = undefined;
    _ = &x0;
    var x1: djb_u32 = undefined;
    _ = &x1;
    var x2: djb_u32 = undefined;
    _ = &x2;
    var x3: djb_u32 = undefined;
    _ = &x3;
    var x4: djb_u32 = undefined;
    _ = &x4;
    var x5: djb_u32 = undefined;
    _ = &x5;
    var x6: djb_u32 = undefined;
    _ = &x6;
    var x7: djb_u32 = undefined;
    _ = &x7;
    var x8: djb_u32 = undefined;
    _ = &x8;
    var x9: djb_u32 = undefined;
    _ = &x9;
    var x10: djb_u32 = undefined;
    _ = &x10;
    var x11: djb_u32 = undefined;
    _ = &x11;
    var x12: djb_u32 = undefined;
    _ = &x12;
    var x13: djb_u32 = undefined;
    _ = &x13;
    var x14: djb_u32 = undefined;
    _ = &x14;
    var x15: djb_u32 = undefined;
    _ = &x15;
    var j0: djb_u32 = undefined;
    _ = &j0;
    var j1: djb_u32 = undefined;
    _ = &j1;
    var j2: djb_u32 = undefined;
    _ = &j2;
    var j3: djb_u32 = undefined;
    _ = &j3;
    var j4: djb_u32 = undefined;
    _ = &j4;
    var j5: djb_u32 = undefined;
    _ = &j5;
    var j6: djb_u32 = undefined;
    _ = &j6;
    var j7: djb_u32 = undefined;
    _ = &j7;
    var j8: djb_u32 = undefined;
    _ = &j8;
    var j9: djb_u32 = undefined;
    _ = &j9;
    var j10: djb_u32 = undefined;
    _ = &j10;
    var j11: djb_u32 = undefined;
    _ = &j11;
    var j12: djb_u32 = undefined;
    _ = &j12;
    var j13: djb_u32 = undefined;
    _ = &j13;
    var j14: djb_u32 = undefined;
    _ = &j14;
    var j15: djb_u32 = undefined;
    _ = &j15;
    var ctarget: [*c]djb_u8 = null;
    _ = &ctarget;
    var tmp: [64]djb_u8 = undefined;
    _ = &tmp;
    var i: c_uint = undefined;
    _ = &i;
    if (!(bytes != 0)) return;
    j0 = x.*.input[@as(c_uint, @intCast(@as(c_int, 0)))];
    j1 = x.*.input[@as(c_uint, @intCast(@as(c_int, 1)))];
    j2 = x.*.input[@as(c_uint, @intCast(@as(c_int, 2)))];
    j3 = x.*.input[@as(c_uint, @intCast(@as(c_int, 3)))];
    j4 = x.*.input[@as(c_uint, @intCast(@as(c_int, 4)))];
    j5 = x.*.input[@as(c_uint, @intCast(@as(c_int, 5)))];
    j6 = x.*.input[@as(c_uint, @intCast(@as(c_int, 6)))];
    j7 = x.*.input[@as(c_uint, @intCast(@as(c_int, 7)))];
    j8 = x.*.input[@as(c_uint, @intCast(@as(c_int, 8)))];
    j9 = x.*.input[@as(c_uint, @intCast(@as(c_int, 9)))];
    j10 = x.*.input[@as(c_uint, @intCast(@as(c_int, 10)))];
    j11 = x.*.input[@as(c_uint, @intCast(@as(c_int, 11)))];
    j12 = x.*.input[@as(c_uint, @intCast(@as(c_int, 12)))];
    j13 = x.*.input[@as(c_uint, @intCast(@as(c_int, 13)))];
    j14 = x.*.input[@as(c_uint, @intCast(@as(c_int, 14)))];
    j15 = x.*.input[@as(c_uint, @intCast(@as(c_int, 15)))];
    while (true) {
        if (bytes < @as(djb_u32, @bitCast(@as(c_int, 64)))) {
            {
                i = 0;
                while (i < bytes) : (i +%= 1) {
                    tmp[i] = m[i];
                }
            }
            m = @as([*c]djb_u8, @ptrCast(@alignCast(&tmp)));
            ctarget = c;
            c = @as([*c]djb_u8, @ptrCast(@alignCast(&tmp)));
        }
        x0 = j0;
        x1 = j1;
        x2 = j2;
        x3 = j3;
        x4 = j4;
        x5 = j5;
        x6 = j6;
        x7 = j7;
        x8 = j8;
        x9 = j9;
        x10 = j10;
        x11 = j11;
        x12 = j12;
        x13 = j13;
        x14 = j14;
        x15 = j15;
        {
            i = 20;
            while (i > @as(c_uint, @bitCast(@as(c_int, 0)))) : (i -%= @as(c_uint, @bitCast(@as(c_int, 2)))) {
                x0 = (x0 +% x4) & @as(c_uint, 4294967295);
                x12 = (((x12 ^ x0) << @intCast(@as(c_int, 16))) & @as(c_uint, 4294967295)) | ((x12 ^ x0) >> @intCast(@as(c_int, 32) - @as(c_int, 16)));
                x8 = (x8 +% x12) & @as(c_uint, 4294967295);
                x4 = (((x4 ^ x8) << @intCast(@as(c_int, 12))) & @as(c_uint, 4294967295)) | ((x4 ^ x8) >> @intCast(@as(c_int, 32) - @as(c_int, 12)));
                x0 = (x0 +% x4) & @as(c_uint, 4294967295);
                x12 = (((x12 ^ x0) << @intCast(@as(c_int, 8))) & @as(c_uint, 4294967295)) | ((x12 ^ x0) >> @intCast(@as(c_int, 32) - @as(c_int, 8)));
                x8 = (x8 +% x12) & @as(c_uint, 4294967295);
                x4 = (((x4 ^ x8) << @intCast(@as(c_int, 7))) & @as(c_uint, 4294967295)) | ((x4 ^ x8) >> @intCast(@as(c_int, 32) - @as(c_int, 7)));
                x1 = (x1 +% x5) & @as(c_uint, 4294967295);
                x13 = (((x13 ^ x1) << @intCast(@as(c_int, 16))) & @as(c_uint, 4294967295)) | ((x13 ^ x1) >> @intCast(@as(c_int, 32) - @as(c_int, 16)));
                x9 = (x9 +% x13) & @as(c_uint, 4294967295);
                x5 = (((x5 ^ x9) << @intCast(@as(c_int, 12))) & @as(c_uint, 4294967295)) | ((x5 ^ x9) >> @intCast(@as(c_int, 32) - @as(c_int, 12)));
                x1 = (x1 +% x5) & @as(c_uint, 4294967295);
                x13 = (((x13 ^ x1) << @intCast(@as(c_int, 8))) & @as(c_uint, 4294967295)) | ((x13 ^ x1) >> @intCast(@as(c_int, 32) - @as(c_int, 8)));
                x9 = (x9 +% x13) & @as(c_uint, 4294967295);
                x5 = (((x5 ^ x9) << @intCast(@as(c_int, 7))) & @as(c_uint, 4294967295)) | ((x5 ^ x9) >> @intCast(@as(c_int, 32) - @as(c_int, 7)));
                x2 = (x2 +% x6) & @as(c_uint, 4294967295);
                x14 = (((x14 ^ x2) << @intCast(@as(c_int, 16))) & @as(c_uint, 4294967295)) | ((x14 ^ x2) >> @intCast(@as(c_int, 32) - @as(c_int, 16)));
                x10 = (x10 +% x14) & @as(c_uint, 4294967295);
                x6 = (((x6 ^ x10) << @intCast(@as(c_int, 12))) & @as(c_uint, 4294967295)) | ((x6 ^ x10) >> @intCast(@as(c_int, 32) - @as(c_int, 12)));
                x2 = (x2 +% x6) & @as(c_uint, 4294967295);
                x14 = (((x14 ^ x2) << @intCast(@as(c_int, 8))) & @as(c_uint, 4294967295)) | ((x14 ^ x2) >> @intCast(@as(c_int, 32) - @as(c_int, 8)));
                x10 = (x10 +% x14) & @as(c_uint, 4294967295);
                x6 = (((x6 ^ x10) << @intCast(@as(c_int, 7))) & @as(c_uint, 4294967295)) | ((x6 ^ x10) >> @intCast(@as(c_int, 32) - @as(c_int, 7)));
                x3 = (x3 +% x7) & @as(c_uint, 4294967295);
                x15 = (((x15 ^ x3) << @intCast(@as(c_int, 16))) & @as(c_uint, 4294967295)) | ((x15 ^ x3) >> @intCast(@as(c_int, 32) - @as(c_int, 16)));
                x11 = (x11 +% x15) & @as(c_uint, 4294967295);
                x7 = (((x7 ^ x11) << @intCast(@as(c_int, 12))) & @as(c_uint, 4294967295)) | ((x7 ^ x11) >> @intCast(@as(c_int, 32) - @as(c_int, 12)));
                x3 = (x3 +% x7) & @as(c_uint, 4294967295);
                x15 = (((x15 ^ x3) << @intCast(@as(c_int, 8))) & @as(c_uint, 4294967295)) | ((x15 ^ x3) >> @intCast(@as(c_int, 32) - @as(c_int, 8)));
                x11 = (x11 +% x15) & @as(c_uint, 4294967295);
                x7 = (((x7 ^ x11) << @intCast(@as(c_int, 7))) & @as(c_uint, 4294967295)) | ((x7 ^ x11) >> @intCast(@as(c_int, 32) - @as(c_int, 7)));
                x0 = (x0 +% x5) & @as(c_uint, 4294967295);
                x15 = (((x15 ^ x0) << @intCast(@as(c_int, 16))) & @as(c_uint, 4294967295)) | ((x15 ^ x0) >> @intCast(@as(c_int, 32) - @as(c_int, 16)));
                x10 = (x10 +% x15) & @as(c_uint, 4294967295);
                x5 = (((x5 ^ x10) << @intCast(@as(c_int, 12))) & @as(c_uint, 4294967295)) | ((x5 ^ x10) >> @intCast(@as(c_int, 32) - @as(c_int, 12)));
                x0 = (x0 +% x5) & @as(c_uint, 4294967295);
                x15 = (((x15 ^ x0) << @intCast(@as(c_int, 8))) & @as(c_uint, 4294967295)) | ((x15 ^ x0) >> @intCast(@as(c_int, 32) - @as(c_int, 8)));
                x10 = (x10 +% x15) & @as(c_uint, 4294967295);
                x5 = (((x5 ^ x10) << @intCast(@as(c_int, 7))) & @as(c_uint, 4294967295)) | ((x5 ^ x10) >> @intCast(@as(c_int, 32) - @as(c_int, 7)));
                x1 = (x1 +% x6) & @as(c_uint, 4294967295);
                x12 = (((x12 ^ x1) << @intCast(@as(c_int, 16))) & @as(c_uint, 4294967295)) | ((x12 ^ x1) >> @intCast(@as(c_int, 32) - @as(c_int, 16)));
                x11 = (x11 +% x12) & @as(c_uint, 4294967295);
                x6 = (((x6 ^ x11) << @intCast(@as(c_int, 12))) & @as(c_uint, 4294967295)) | ((x6 ^ x11) >> @intCast(@as(c_int, 32) - @as(c_int, 12)));
                x1 = (x1 +% x6) & @as(c_uint, 4294967295);
                x12 = (((x12 ^ x1) << @intCast(@as(c_int, 8))) & @as(c_uint, 4294967295)) | ((x12 ^ x1) >> @intCast(@as(c_int, 32) - @as(c_int, 8)));
                x11 = (x11 +% x12) & @as(c_uint, 4294967295);
                x6 = (((x6 ^ x11) << @intCast(@as(c_int, 7))) & @as(c_uint, 4294967295)) | ((x6 ^ x11) >> @intCast(@as(c_int, 32) - @as(c_int, 7)));
                x2 = (x2 +% x7) & @as(c_uint, 4294967295);
                x13 = (((x13 ^ x2) << @intCast(@as(c_int, 16))) & @as(c_uint, 4294967295)) | ((x13 ^ x2) >> @intCast(@as(c_int, 32) - @as(c_int, 16)));
                x8 = (x8 +% x13) & @as(c_uint, 4294967295);
                x7 = (((x7 ^ x8) << @intCast(@as(c_int, 12))) & @as(c_uint, 4294967295)) | ((x7 ^ x8) >> @intCast(@as(c_int, 32) - @as(c_int, 12)));
                x2 = (x2 +% x7) & @as(c_uint, 4294967295);
                x13 = (((x13 ^ x2) << @intCast(@as(c_int, 8))) & @as(c_uint, 4294967295)) | ((x13 ^ x2) >> @intCast(@as(c_int, 32) - @as(c_int, 8)));
                x8 = (x8 +% x13) & @as(c_uint, 4294967295);
                x7 = (((x7 ^ x8) << @intCast(@as(c_int, 7))) & @as(c_uint, 4294967295)) | ((x7 ^ x8) >> @intCast(@as(c_int, 32) - @as(c_int, 7)));
                x3 = (x3 +% x4) & @as(c_uint, 4294967295);
                x14 = (((x14 ^ x3) << @intCast(@as(c_int, 16))) & @as(c_uint, 4294967295)) | ((x14 ^ x3) >> @intCast(@as(c_int, 32) - @as(c_int, 16)));
                x9 = (x9 +% x14) & @as(c_uint, 4294967295);
                x4 = (((x4 ^ x9) << @intCast(@as(c_int, 12))) & @as(c_uint, 4294967295)) | ((x4 ^ x9) >> @intCast(@as(c_int, 32) - @as(c_int, 12)));
                x3 = (x3 +% x4) & @as(c_uint, 4294967295);
                x14 = (((x14 ^ x3) << @intCast(@as(c_int, 8))) & @as(c_uint, 4294967295)) | ((x14 ^ x3) >> @intCast(@as(c_int, 32) - @as(c_int, 8)));
                x9 = (x9 +% x14) & @as(c_uint, 4294967295);
                x4 = (((x4 ^ x9) << @intCast(@as(c_int, 7))) & @as(c_uint, 4294967295)) | ((x4 ^ x9) >> @intCast(@as(c_int, 32) - @as(c_int, 7)));
            }
        }
        x0 = (x0 +% j0) & @as(c_uint, 4294967295);
        x1 = (x1 +% j1) & @as(c_uint, 4294967295);
        x2 = (x2 +% j2) & @as(c_uint, 4294967295);
        x3 = (x3 +% j3) & @as(c_uint, 4294967295);
        x4 = (x4 +% j4) & @as(c_uint, 4294967295);
        x5 = (x5 +% j5) & @as(c_uint, 4294967295);
        x6 = (x6 +% j6) & @as(c_uint, 4294967295);
        x7 = (x7 +% j7) & @as(c_uint, 4294967295);
        x8 = (x8 +% j8) & @as(c_uint, 4294967295);
        x9 = (x9 +% j9) & @as(c_uint, 4294967295);
        x10 = (x10 +% j10) & @as(c_uint, 4294967295);
        x11 = (x11 +% j11) & @as(c_uint, 4294967295);
        x12 = (x12 +% j12) & @as(c_uint, 4294967295);
        x13 = (x13 +% j13) & @as(c_uint, 4294967295);
        x14 = (x14 +% j14) & @as(c_uint, 4294967295);
        x15 = (x15 +% j15) & @as(c_uint, 4294967295);
        if (bytes < @as(djb_u32, @bitCast(@as(c_int, 64)))) {
            while (true) {
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x0))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x0 >> @intCast(8)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x0 >> @intCast(16)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x0 >> @intCast(24)))))))) & @as(c_uint, 255)))));
                if (!false) break;
            }
            while (true) {
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x1))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x1 >> @intCast(8)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x1 >> @intCast(16)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x1 >> @intCast(24)))))))) & @as(c_uint, 255)))));
                if (!false) break;
            }
            while (true) {
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x2))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x2 >> @intCast(8)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x2 >> @intCast(16)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x2 >> @intCast(24)))))))) & @as(c_uint, 255)))));
                if (!false) break;
            }
            while (true) {
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x3))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x3 >> @intCast(8)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x3 >> @intCast(16)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x3 >> @intCast(24)))))))) & @as(c_uint, 255)))));
                if (!false) break;
            }
            while (true) {
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x4))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x4 >> @intCast(8)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x4 >> @intCast(16)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x4 >> @intCast(24)))))))) & @as(c_uint, 255)))));
                if (!false) break;
            }
            while (true) {
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x5))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x5 >> @intCast(8)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x5 >> @intCast(16)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x5 >> @intCast(24)))))))) & @as(c_uint, 255)))));
                if (!false) break;
            }
            while (true) {
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 24))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x6))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 24))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x6 >> @intCast(8)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 24))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x6 >> @intCast(16)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 24))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x6 >> @intCast(24)))))))) & @as(c_uint, 255)))));
                if (!false) break;
            }
            while (true) {
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 28))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x7))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 28))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x7 >> @intCast(8)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 28))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x7 >> @intCast(16)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 28))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x7 >> @intCast(24)))))))) & @as(c_uint, 255)))));
                if (!false) break;
            }
            while (true) {
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x8))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x8 >> @intCast(8)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x8 >> @intCast(16)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x8 >> @intCast(24)))))))) & @as(c_uint, 255)))));
                if (!false) break;
            }
            while (true) {
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 36))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x9))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 36))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x9 >> @intCast(8)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 36))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x9 >> @intCast(16)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 36))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x9 >> @intCast(24)))))))) & @as(c_uint, 255)))));
                if (!false) break;
            }
            while (true) {
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 40))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x10))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 40))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x10 >> @intCast(8)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 40))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x10 >> @intCast(16)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 40))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x10 >> @intCast(24)))))))) & @as(c_uint, 255)))));
                if (!false) break;
            }
            while (true) {
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 44))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x11))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 44))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x11 >> @intCast(8)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 44))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x11 >> @intCast(16)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 44))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x11 >> @intCast(24)))))))) & @as(c_uint, 255)))));
                if (!false) break;
            }
            while (true) {
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 48))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x12))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 48))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x12 >> @intCast(8)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 48))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x12 >> @intCast(16)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 48))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x12 >> @intCast(24)))))))) & @as(c_uint, 255)))));
                if (!false) break;
            }
            while (true) {
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 52))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x13))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 52))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x13 >> @intCast(8)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 52))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x13 >> @intCast(16)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 52))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x13 >> @intCast(24)))))))) & @as(c_uint, 255)))));
                if (!false) break;
            }
            while (true) {
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 56))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x14))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 56))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x14 >> @intCast(8)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 56))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x14 >> @intCast(16)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 56))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x14 >> @intCast(24)))))))) & @as(c_uint, 255)))));
                if (!false) break;
            }
            while (true) {
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 60))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x15))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 60))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x15 >> @intCast(8)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 60))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x15 >> @intCast(16)))))))) & @as(c_uint, 255)))));
                (@as([*c]u8, @ptrCast(@alignCast(&x.*.ks))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 60))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x15 >> @intCast(24)))))))) & @as(c_uint, 255)))));
                if (!false) break;
            }
        }
        x0 = x0 ^ (((@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24)));
        x1 = x1 ^ (((@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24)));
        x2 = x2 ^ (((@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24)));
        x3 = x3 ^ (((@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24)));
        x4 = x4 ^ (((@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24)));
        x5 = x5 ^ (((@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24)));
        x6 = x6 ^ (((@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 24))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 24))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 24))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 24))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24)));
        x7 = x7 ^ (((@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 28))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 28))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 28))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 28))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24)));
        x8 = x8 ^ (((@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24)));
        x9 = x9 ^ (((@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 36))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 36))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 36))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 36))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24)));
        x10 = x10 ^ (((@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 40))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 40))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 40))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 40))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24)));
        x11 = x11 ^ (((@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 44))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 44))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 44))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 44))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24)));
        x12 = x12 ^ (((@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 48))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 48))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 48))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 48))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24)));
        x13 = x13 ^ (((@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 52))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 52))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 52))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 52))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24)));
        x14 = x14 ^ (((@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 56))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 56))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 56))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 56))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24)));
        x15 = x15 ^ (((@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 60))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 60))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 60))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 60))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24)));
        j12 = (j12 +% @as(djb_u32, @bitCast(@as(c_int, 1)))) & @as(c_uint, 4294967295);
        if (!(j12 != 0)) {
            j13 = (j13 +% @as(djb_u32, @bitCast(@as(c_int, 1)))) & @as(c_uint, 4294967295);
        }
        while (true) {
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x0))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x0 >> @intCast(8)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x0 >> @intCast(16)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x0 >> @intCast(24)))))))) & @as(c_uint, 255)))));
            if (!false) break;
        }
        while (true) {
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x1))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x1 >> @intCast(8)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x1 >> @intCast(16)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x1 >> @intCast(24)))))))) & @as(c_uint, 255)))));
            if (!false) break;
        }
        while (true) {
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x2))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x2 >> @intCast(8)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x2 >> @intCast(16)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x2 >> @intCast(24)))))))) & @as(c_uint, 255)))));
            if (!false) break;
        }
        while (true) {
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x3))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x3 >> @intCast(8)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x3 >> @intCast(16)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x3 >> @intCast(24)))))))) & @as(c_uint, 255)))));
            if (!false) break;
        }
        while (true) {
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x4))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x4 >> @intCast(8)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x4 >> @intCast(16)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x4 >> @intCast(24)))))))) & @as(c_uint, 255)))));
            if (!false) break;
        }
        while (true) {
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x5))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x5 >> @intCast(8)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x5 >> @intCast(16)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x5 >> @intCast(24)))))))) & @as(c_uint, 255)))));
            if (!false) break;
        }
        while (true) {
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 24))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x6))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 24))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x6 >> @intCast(8)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 24))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x6 >> @intCast(16)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 24))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x6 >> @intCast(24)))))))) & @as(c_uint, 255)))));
            if (!false) break;
        }
        while (true) {
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 28))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x7))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 28))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x7 >> @intCast(8)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 28))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x7 >> @intCast(16)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 28))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x7 >> @intCast(24)))))))) & @as(c_uint, 255)))));
            if (!false) break;
        }
        while (true) {
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x8))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x8 >> @intCast(8)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x8 >> @intCast(16)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 32))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x8 >> @intCast(24)))))))) & @as(c_uint, 255)))));
            if (!false) break;
        }
        while (true) {
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 36))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x9))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 36))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x9 >> @intCast(8)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 36))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x9 >> @intCast(16)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 36))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x9 >> @intCast(24)))))))) & @as(c_uint, 255)))));
            if (!false) break;
        }
        while (true) {
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 40))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x10))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 40))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x10 >> @intCast(8)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 40))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x10 >> @intCast(16)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 40))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x10 >> @intCast(24)))))))) & @as(c_uint, 255)))));
            if (!false) break;
        }
        while (true) {
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 44))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x11))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 44))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x11 >> @intCast(8)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 44))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x11 >> @intCast(16)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 44))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x11 >> @intCast(24)))))))) & @as(c_uint, 255)))));
            if (!false) break;
        }
        while (true) {
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 48))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x12))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 48))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x12 >> @intCast(8)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 48))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x12 >> @intCast(16)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 48))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x12 >> @intCast(24)))))))) & @as(c_uint, 255)))));
            if (!false) break;
        }
        while (true) {
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 52))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x13))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 52))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x13 >> @intCast(8)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 52))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x13 >> @intCast(16)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 52))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x13 >> @intCast(24)))))))) & @as(c_uint, 255)))));
            if (!false) break;
        }
        while (true) {
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 56))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x14))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 56))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x14 >> @intCast(8)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 56))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x14 >> @intCast(16)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 56))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x14 >> @intCast(24)))))))) & @as(c_uint, 255)))));
            if (!false) break;
        }
        while (true) {
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 60))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x15))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 60))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x15 >> @intCast(8)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 60))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x15 >> @intCast(16)))))))) & @as(c_uint, 255)))));
            (c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 60))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x15 >> @intCast(24)))))))) & @as(c_uint, 255)))));
            if (!false) break;
        }
        if (bytes <= @as(djb_u32, @bitCast(@as(c_int, 64)))) {
            if (bytes < @as(djb_u32, @bitCast(@as(c_int, 64)))) {
                {
                    i = 0;
                    while (i < bytes) : (i +%= 1) {
                        ctarget[i] = c[i];
                    }
                }
            }
            x.*.input[@as(c_uint, @intCast(@as(c_int, 12)))] = j12;
            x.*.input[@as(c_uint, @intCast(@as(c_int, 13)))] = j13;
            x.*.unused = @as(u8, @bitCast(@as(u8, @truncate(@as(djb_u32, @bitCast(@as(c_int, 64))) -% bytes))));
            return;
        }
        bytes -%= @as(djb_u32, @bitCast(@as(c_int, 64)));
        c += @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 64)))));
        m += @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 64)))));
    }
}
pub fn poly1305_generate_key(arg_key256: [*c]u8, arg_nonce: [*c]u8, arg_noncelen: c_uint, arg_poly_key: [*c]u8, arg_counter: c_uint) callconv(.c) c_int {
    var key256 = arg_key256;
    _ = &key256;
    var nonce = arg_nonce;
    _ = &nonce;
    var noncelen = arg_noncelen;
    _ = &noncelen;
    var poly_key = arg_poly_key;
    _ = &poly_key;
    var counter = arg_counter;
    _ = &counter;
    var ctx: struct_chacha_ctx = undefined;
    _ = &ctx;
    var ctr: u64 = undefined;
    _ = &ctr;
    _ = memset(@as(?*anyopaque, @ptrCast(&ctx)), @as(c_int, 0), @sizeOf(struct_chacha_ctx));
    chacha_keysetup(&ctx, key256, @as(c_uint, @bitCast(@as(c_int, 256))));
    while (true) {
        switch (noncelen) {
            @as(c_uint, @bitCast(@as(c_int, 8))) => {
                ctr = @as(u64, @bitCast(@as(c_ulong, counter)));
                chacha_ivsetup(&ctx, nonce, @as([*c]u8, @ptrCast(@alignCast(&ctr))));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 12))) => {
                chacha_ivsetup_96bitnonce(&ctx, nonce, @as([*c]u8, @ptrCast(@alignCast(&counter))));
                break;
            },
            else => return -@as(c_int, 1),
        }
        break;
    }
    chacha20_block(&ctx, poly_key, @as(c_uint, @bitCast(@as(c_int, 32))));
    return 0;
}
pub const chacha_ctx = struct_chacha_ctx;
pub const sigma: [16:0]u8 = "expand 32-byte k".*;
pub const tau: [16:0]u8 = "expand 16-byte k".*;
pub fn chacha_key(arg_x: [*c]chacha_ctx, arg_k: [*c]djb_u8) callconv(.c) void {
    var x = arg_x;
    _ = &x;
    var k = arg_k;
    _ = &k;
    while (true) {
        k[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 4)))]))))))) & @as(c_uint, 255)))));
        k[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 4)))] >> @intCast(8)))))))) & @as(c_uint, 255)))));
        k[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 4)))] >> @intCast(16)))))))) & @as(c_uint, 255)))));
        k[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 4)))] >> @intCast(24)))))))) & @as(c_uint, 255)))));
        if (!false) break;
    }
    while (true) {
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 5)))]))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 5)))] >> @intCast(8)))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 5)))] >> @intCast(16)))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 5)))] >> @intCast(24)))))))) & @as(c_uint, 255)))));
        if (!false) break;
    }
    while (true) {
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 6)))]))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 6)))] >> @intCast(8)))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 6)))] >> @intCast(16)))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 6)))] >> @intCast(24)))))))) & @as(c_uint, 255)))));
        if (!false) break;
    }
    while (true) {
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 7)))]))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 7)))] >> @intCast(8)))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 7)))] >> @intCast(16)))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 7)))] >> @intCast(24)))))))) & @as(c_uint, 255)))));
        if (!false) break;
    }
    while (true) {
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 8)))]))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 8)))] >> @intCast(8)))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 8)))] >> @intCast(16)))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 8)))] >> @intCast(24)))))))) & @as(c_uint, 255)))));
        if (!false) break;
    }
    while (true) {
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 9)))]))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 9)))] >> @intCast(8)))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 9)))] >> @intCast(16)))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 20))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 9)))] >> @intCast(24)))))))) & @as(c_uint, 255)))));
        if (!false) break;
    }
    while (true) {
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 24))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 10)))]))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 24))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 10)))] >> @intCast(8)))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 24))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 10)))] >> @intCast(16)))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 24))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 10)))] >> @intCast(24)))))))) & @as(c_uint, 255)))));
        if (!false) break;
    }
    while (true) {
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 28))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 11)))]))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 28))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 11)))] >> @intCast(8)))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 28))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 11)))] >> @intCast(16)))))))) & @as(c_uint, 255)))));
        (k + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 28))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 11)))] >> @intCast(24)))))))) & @as(c_uint, 255)))));
        if (!false) break;
    }
}
pub fn chacha_nonce(arg_x: [*c]chacha_ctx, arg_nonce: [*c]djb_u8) callconv(.c) void {
    var x = arg_x;
    _ = &x;
    var nonce = arg_nonce;
    _ = &nonce;
    while (true) {
        (nonce + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 13)))]))))))) & @as(c_uint, 255)))));
        (nonce + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 13)))] >> @intCast(8)))))))) & @as(c_uint, 255)))));
        (nonce + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 13)))] >> @intCast(16)))))))) & @as(c_uint, 255)))));
        (nonce + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 13)))] >> @intCast(24)))))))) & @as(c_uint, 255)))));
        if (!false) break;
    }
    while (true) {
        (nonce + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 14)))]))))))) & @as(c_uint, 255)))));
        (nonce + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 14)))] >> @intCast(8)))))))) & @as(c_uint, 255)))));
        (nonce + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 14)))] >> @intCast(16)))))))) & @as(c_uint, 255)))));
        (nonce + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 14)))] >> @intCast(24)))))))) & @as(c_uint, 255)))));
        if (!false) break;
    }
    while (true) {
        (nonce + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 15)))]))))))) & @as(c_uint, 255)))));
        (nonce + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 15)))] >> @intCast(8)))))))) & @as(c_uint, 255)))));
        (nonce + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 15)))] >> @intCast(16)))))))) & @as(c_uint, 255)))));
        (nonce + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[@as(c_uint, @intCast(@as(c_int, 15)))] >> @intCast(24)))))))) & @as(c_uint, 255)))));
        if (!false) break;
    }
}
pub fn chacha_ivupdate(arg_x: [*c]chacha_ctx, arg_iv: [*c]const djb_u8, arg_aad: [*c]const djb_u8, arg_counter: [*c]const djb_u8) callconv(.c) void {
    var x = arg_x;
    _ = &x;
    var iv = arg_iv;
    _ = &iv;
    var aad = arg_aad;
    _ = &aad;
    var counter = arg_counter;
    _ = &counter;
    x.*.input[@as(c_uint, @intCast(@as(c_int, 12)))] = if (counter == @as([*c]const djb_u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) @as(djb_u32, @bitCast(@as(c_int, 0))) else ((@as(djb_u32, @bitCast(@as(c_uint, (counter + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (counter + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (counter + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (counter + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
    x.*.input[@as(c_uint, @intCast(@as(c_int, 13)))] = ((@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24));
    x.*.input[@as(c_uint, @intCast(@as(c_int, 14)))] = (((@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24))) ^ (((@as(djb_u32, @bitCast(@as(c_uint, aad[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, aad[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, aad[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, aad[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24)));
    x.*.input[@as(c_uint, @intCast(@as(c_int, 15)))] = (((@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (iv + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24))) ^ (((@as(djb_u32, @bitCast(@as(c_uint, (aad + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 0)))]))) | (@as(djb_u32, @bitCast(@as(c_uint, (aad + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8))) | (@as(djb_u32, @bitCast(@as(c_uint, (aad + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16))) | (@as(djb_u32, @bitCast(@as(c_uint, (aad + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))[@as(c_uint, @intCast(@as(c_int, 3)))]))) << @intCast(24)));
}
pub fn chacha20_block(arg_x: [*c]chacha_ctx, arg_c: [*c]u8, arg_len: c_uint) callconv(.c) void {
    var x = arg_x;
    _ = &x;
    var c = arg_c;
    _ = &c;
    var len = arg_len;
    _ = &len;
    var i: c_uint = undefined;
    _ = &i;
    var state: [16]c_uint = undefined;
    _ = &state;
    {
        i = 0;
        while (i < @as(c_uint, @bitCast(@as(c_int, 16)))) : (i +%= 1) {
            state[i] = x.*.input[i];
        }
    }
    {
        i = 20;
        while (i > @as(c_uint, @bitCast(@as(c_int, 0)))) : (i -%= @as(c_uint, @bitCast(@as(c_int, 2)))) {
            state[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 0)))] +% state[@as(c_uint, @intCast(@as(c_int, 4)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 12)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 12)))] ^ state[@as(c_uint, @intCast(@as(c_int, 0)))]) << @intCast(@as(c_int, 16)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 12)))] ^ state[@as(c_uint, @intCast(@as(c_int, 0)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 16)));
            state[@as(c_uint, @intCast(@as(c_int, 8)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 8)))] +% state[@as(c_uint, @intCast(@as(c_int, 12)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 4)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 4)))] ^ state[@as(c_uint, @intCast(@as(c_int, 8)))]) << @intCast(@as(c_int, 12)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 4)))] ^ state[@as(c_uint, @intCast(@as(c_int, 8)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 12)));
            state[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 0)))] +% state[@as(c_uint, @intCast(@as(c_int, 4)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 12)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 12)))] ^ state[@as(c_uint, @intCast(@as(c_int, 0)))]) << @intCast(@as(c_int, 8)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 12)))] ^ state[@as(c_uint, @intCast(@as(c_int, 0)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 8)));
            state[@as(c_uint, @intCast(@as(c_int, 8)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 8)))] +% state[@as(c_uint, @intCast(@as(c_int, 12)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 4)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 4)))] ^ state[@as(c_uint, @intCast(@as(c_int, 8)))]) << @intCast(@as(c_int, 7)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 4)))] ^ state[@as(c_uint, @intCast(@as(c_int, 8)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 7)));
            state[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 1)))] +% state[@as(c_uint, @intCast(@as(c_int, 5)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 13)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 13)))] ^ state[@as(c_uint, @intCast(@as(c_int, 1)))]) << @intCast(@as(c_int, 16)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 13)))] ^ state[@as(c_uint, @intCast(@as(c_int, 1)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 16)));
            state[@as(c_uint, @intCast(@as(c_int, 9)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 9)))] +% state[@as(c_uint, @intCast(@as(c_int, 13)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 5)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 5)))] ^ state[@as(c_uint, @intCast(@as(c_int, 9)))]) << @intCast(@as(c_int, 12)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 5)))] ^ state[@as(c_uint, @intCast(@as(c_int, 9)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 12)));
            state[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 1)))] +% state[@as(c_uint, @intCast(@as(c_int, 5)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 13)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 13)))] ^ state[@as(c_uint, @intCast(@as(c_int, 1)))]) << @intCast(@as(c_int, 8)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 13)))] ^ state[@as(c_uint, @intCast(@as(c_int, 1)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 8)));
            state[@as(c_uint, @intCast(@as(c_int, 9)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 9)))] +% state[@as(c_uint, @intCast(@as(c_int, 13)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 5)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 5)))] ^ state[@as(c_uint, @intCast(@as(c_int, 9)))]) << @intCast(@as(c_int, 7)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 5)))] ^ state[@as(c_uint, @intCast(@as(c_int, 9)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 7)));
            state[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 2)))] +% state[@as(c_uint, @intCast(@as(c_int, 6)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 14)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 14)))] ^ state[@as(c_uint, @intCast(@as(c_int, 2)))]) << @intCast(@as(c_int, 16)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 14)))] ^ state[@as(c_uint, @intCast(@as(c_int, 2)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 16)));
            state[@as(c_uint, @intCast(@as(c_int, 10)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 10)))] +% state[@as(c_uint, @intCast(@as(c_int, 14)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 6)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 6)))] ^ state[@as(c_uint, @intCast(@as(c_int, 10)))]) << @intCast(@as(c_int, 12)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 6)))] ^ state[@as(c_uint, @intCast(@as(c_int, 10)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 12)));
            state[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 2)))] +% state[@as(c_uint, @intCast(@as(c_int, 6)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 14)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 14)))] ^ state[@as(c_uint, @intCast(@as(c_int, 2)))]) << @intCast(@as(c_int, 8)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 14)))] ^ state[@as(c_uint, @intCast(@as(c_int, 2)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 8)));
            state[@as(c_uint, @intCast(@as(c_int, 10)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 10)))] +% state[@as(c_uint, @intCast(@as(c_int, 14)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 6)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 6)))] ^ state[@as(c_uint, @intCast(@as(c_int, 10)))]) << @intCast(@as(c_int, 7)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 6)))] ^ state[@as(c_uint, @intCast(@as(c_int, 10)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 7)));
            state[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 3)))] +% state[@as(c_uint, @intCast(@as(c_int, 7)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 15)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 15)))] ^ state[@as(c_uint, @intCast(@as(c_int, 3)))]) << @intCast(@as(c_int, 16)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 15)))] ^ state[@as(c_uint, @intCast(@as(c_int, 3)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 16)));
            state[@as(c_uint, @intCast(@as(c_int, 11)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 11)))] +% state[@as(c_uint, @intCast(@as(c_int, 15)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 7)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 7)))] ^ state[@as(c_uint, @intCast(@as(c_int, 11)))]) << @intCast(@as(c_int, 12)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 7)))] ^ state[@as(c_uint, @intCast(@as(c_int, 11)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 12)));
            state[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 3)))] +% state[@as(c_uint, @intCast(@as(c_int, 7)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 15)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 15)))] ^ state[@as(c_uint, @intCast(@as(c_int, 3)))]) << @intCast(@as(c_int, 8)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 15)))] ^ state[@as(c_uint, @intCast(@as(c_int, 3)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 8)));
            state[@as(c_uint, @intCast(@as(c_int, 11)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 11)))] +% state[@as(c_uint, @intCast(@as(c_int, 15)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 7)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 7)))] ^ state[@as(c_uint, @intCast(@as(c_int, 11)))]) << @intCast(@as(c_int, 7)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 7)))] ^ state[@as(c_uint, @intCast(@as(c_int, 11)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 7)));
            state[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 0)))] +% state[@as(c_uint, @intCast(@as(c_int, 5)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 15)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 15)))] ^ state[@as(c_uint, @intCast(@as(c_int, 0)))]) << @intCast(@as(c_int, 16)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 15)))] ^ state[@as(c_uint, @intCast(@as(c_int, 0)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 16)));
            state[@as(c_uint, @intCast(@as(c_int, 10)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 10)))] +% state[@as(c_uint, @intCast(@as(c_int, 15)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 5)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 5)))] ^ state[@as(c_uint, @intCast(@as(c_int, 10)))]) << @intCast(@as(c_int, 12)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 5)))] ^ state[@as(c_uint, @intCast(@as(c_int, 10)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 12)));
            state[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 0)))] +% state[@as(c_uint, @intCast(@as(c_int, 5)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 15)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 15)))] ^ state[@as(c_uint, @intCast(@as(c_int, 0)))]) << @intCast(@as(c_int, 8)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 15)))] ^ state[@as(c_uint, @intCast(@as(c_int, 0)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 8)));
            state[@as(c_uint, @intCast(@as(c_int, 10)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 10)))] +% state[@as(c_uint, @intCast(@as(c_int, 15)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 5)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 5)))] ^ state[@as(c_uint, @intCast(@as(c_int, 10)))]) << @intCast(@as(c_int, 7)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 5)))] ^ state[@as(c_uint, @intCast(@as(c_int, 10)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 7)));
            state[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 1)))] +% state[@as(c_uint, @intCast(@as(c_int, 6)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 12)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 12)))] ^ state[@as(c_uint, @intCast(@as(c_int, 1)))]) << @intCast(@as(c_int, 16)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 12)))] ^ state[@as(c_uint, @intCast(@as(c_int, 1)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 16)));
            state[@as(c_uint, @intCast(@as(c_int, 11)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 11)))] +% state[@as(c_uint, @intCast(@as(c_int, 12)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 6)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 6)))] ^ state[@as(c_uint, @intCast(@as(c_int, 11)))]) << @intCast(@as(c_int, 12)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 6)))] ^ state[@as(c_uint, @intCast(@as(c_int, 11)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 12)));
            state[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 1)))] +% state[@as(c_uint, @intCast(@as(c_int, 6)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 12)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 12)))] ^ state[@as(c_uint, @intCast(@as(c_int, 1)))]) << @intCast(@as(c_int, 8)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 12)))] ^ state[@as(c_uint, @intCast(@as(c_int, 1)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 8)));
            state[@as(c_uint, @intCast(@as(c_int, 11)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 11)))] +% state[@as(c_uint, @intCast(@as(c_int, 12)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 6)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 6)))] ^ state[@as(c_uint, @intCast(@as(c_int, 11)))]) << @intCast(@as(c_int, 7)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 6)))] ^ state[@as(c_uint, @intCast(@as(c_int, 11)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 7)));
            state[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 2)))] +% state[@as(c_uint, @intCast(@as(c_int, 7)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 13)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 13)))] ^ state[@as(c_uint, @intCast(@as(c_int, 2)))]) << @intCast(@as(c_int, 16)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 13)))] ^ state[@as(c_uint, @intCast(@as(c_int, 2)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 16)));
            state[@as(c_uint, @intCast(@as(c_int, 8)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 8)))] +% state[@as(c_uint, @intCast(@as(c_int, 13)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 7)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 7)))] ^ state[@as(c_uint, @intCast(@as(c_int, 8)))]) << @intCast(@as(c_int, 12)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 7)))] ^ state[@as(c_uint, @intCast(@as(c_int, 8)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 12)));
            state[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 2)))] +% state[@as(c_uint, @intCast(@as(c_int, 7)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 13)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 13)))] ^ state[@as(c_uint, @intCast(@as(c_int, 2)))]) << @intCast(@as(c_int, 8)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 13)))] ^ state[@as(c_uint, @intCast(@as(c_int, 2)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 8)));
            state[@as(c_uint, @intCast(@as(c_int, 8)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 8)))] +% state[@as(c_uint, @intCast(@as(c_int, 13)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 7)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 7)))] ^ state[@as(c_uint, @intCast(@as(c_int, 8)))]) << @intCast(@as(c_int, 7)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 7)))] ^ state[@as(c_uint, @intCast(@as(c_int, 8)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 7)));
            state[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 3)))] +% state[@as(c_uint, @intCast(@as(c_int, 4)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 14)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 14)))] ^ state[@as(c_uint, @intCast(@as(c_int, 3)))]) << @intCast(@as(c_int, 16)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 14)))] ^ state[@as(c_uint, @intCast(@as(c_int, 3)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 16)));
            state[@as(c_uint, @intCast(@as(c_int, 9)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 9)))] +% state[@as(c_uint, @intCast(@as(c_int, 14)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 4)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 4)))] ^ state[@as(c_uint, @intCast(@as(c_int, 9)))]) << @intCast(@as(c_int, 12)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 4)))] ^ state[@as(c_uint, @intCast(@as(c_int, 9)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 12)));
            state[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 3)))] +% state[@as(c_uint, @intCast(@as(c_int, 4)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 14)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 14)))] ^ state[@as(c_uint, @intCast(@as(c_int, 3)))]) << @intCast(@as(c_int, 8)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 14)))] ^ state[@as(c_uint, @intCast(@as(c_int, 3)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 8)));
            state[@as(c_uint, @intCast(@as(c_int, 9)))] = @as(djb_u32, @bitCast(state[@as(c_uint, @intCast(@as(c_int, 9)))] +% state[@as(c_uint, @intCast(@as(c_int, 14)))])) & @as(c_uint, 4294967295);
            state[@as(c_uint, @intCast(@as(c_int, 4)))] = (@as(djb_u32, @bitCast((state[@as(c_uint, @intCast(@as(c_int, 4)))] ^ state[@as(c_uint, @intCast(@as(c_int, 9)))]) << @intCast(@as(c_int, 7)))) & @as(c_uint, 4294967295)) | ((state[@as(c_uint, @intCast(@as(c_int, 4)))] ^ state[@as(c_uint, @intCast(@as(c_int, 9)))]) >> @intCast(@as(c_int, 32) - @as(c_int, 7)));
        }
    }
    {
        i = 0;
        while (i < @as(c_uint, @bitCast(@as(c_int, 16)))) : (i +%= 1) {
            x.*.input[i] = @as(djb_u32, @bitCast(x.*.input[i] +% state[i])) & @as(c_uint, 4294967295);
        }
    }
    {
        i = 0;
        while (i < len) : (i +%= @as(c_uint, @bitCast(@as(c_int, 4)))) {
            while (true) {
                (c + i)[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[i / @as(c_uint, @bitCast(@as(c_int, 4)))]))))))) & @as(c_uint, 255)))));
                (c + i)[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[i / @as(c_uint, @bitCast(@as(c_int, 4)))] >> @intCast(8)))))))) & @as(c_uint, 255)))));
                (c + i)[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[i / @as(c_uint, @bitCast(@as(c_int, 4)))] >> @intCast(16)))))))) & @as(c_uint, 255)))));
                (c + i)[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(u8, @truncate(@as(c_uint, @bitCast(@as(c_uint, @as(djb_u8, @bitCast(@as(u8, @truncate(x.*.input[i / @as(c_uint, @bitCast(@as(c_int, 4)))] >> @intCast(24)))))))) & @as(c_uint, 255)))));
                if (!false) break;
            }
        }
    }
}
pub fn _private_tls_U8TO32(arg_p: [*c]const u8) callconv(.c) c_ulong {
    var p = arg_p;
    _ = &p;
    return ((@as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, p[@as(c_uint, @intCast(@as(c_int, 0)))]))) & @as(c_int, 255)))) | (@as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, p[@as(c_uint, @intCast(@as(c_int, 1)))]))) & @as(c_int, 255)))) << @intCast(8))) | (@as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, p[@as(c_uint, @intCast(@as(c_int, 2)))]))) & @as(c_int, 255)))) << @intCast(16))) | (@as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, p[@as(c_uint, @intCast(@as(c_int, 3)))]))) & @as(c_int, 255)))) << @intCast(24));
}
pub fn _private_tls_U32TO8(arg_p: [*c]u8, arg_v: c_ulong) callconv(.c) void {
    var p = arg_p;
    _ = &p;
    var v = arg_v;
    _ = &v;
    p[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(u8, @truncate(v & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
    p[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(u8, @truncate((v >> @intCast(8)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
    p[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(u8, @truncate((v >> @intCast(16)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
    p[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(u8, @truncate((v >> @intCast(24)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
}
pub export fn _private_tls_poly1305_init(arg_ctx: [*c]poly1305_state_internal_t, key: [*c]const u8) void {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = &key;
    var st: [*c]poly1305_state_internal_t = ctx;
    _ = &st;
    st.*.r[@as(c_uint, @intCast(@as(c_int, 0)))] = _private_tls_U8TO32(&key[@as(c_uint, @intCast(@as(c_int, 0)))]) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
    st.*.r[@as(c_uint, @intCast(@as(c_int, 1)))] = (_private_tls_U8TO32(&key[@as(c_uint, @intCast(@as(c_int, 3)))]) >> @intCast(2)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108611))));
    st.*.r[@as(c_uint, @intCast(@as(c_int, 2)))] = (_private_tls_U8TO32(&key[@as(c_uint, @intCast(@as(c_int, 6)))]) >> @intCast(4)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67092735))));
    st.*.r[@as(c_uint, @intCast(@as(c_int, 3)))] = (_private_tls_U8TO32(&key[@as(c_uint, @intCast(@as(c_int, 9)))]) >> @intCast(6)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 66076671))));
    st.*.r[@as(c_uint, @intCast(@as(c_int, 4)))] = (_private_tls_U8TO32(&key[@as(c_uint, @intCast(@as(c_int, 12)))]) >> @intCast(8)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1048575))));
    st.*.h[@as(c_uint, @intCast(@as(c_int, 0)))] = 0;
    st.*.h[@as(c_uint, @intCast(@as(c_int, 1)))] = 0;
    st.*.h[@as(c_uint, @intCast(@as(c_int, 2)))] = 0;
    st.*.h[@as(c_uint, @intCast(@as(c_int, 3)))] = 0;
    st.*.h[@as(c_uint, @intCast(@as(c_int, 4)))] = 0;
    st.*.pad[@as(c_uint, @intCast(@as(c_int, 0)))] = _private_tls_U8TO32(&key[@as(c_uint, @intCast(@as(c_int, 16)))]);
    st.*.pad[@as(c_uint, @intCast(@as(c_int, 1)))] = _private_tls_U8TO32(&key[@as(c_uint, @intCast(@as(c_int, 20)))]);
    st.*.pad[@as(c_uint, @intCast(@as(c_int, 2)))] = _private_tls_U8TO32(&key[@as(c_uint, @intCast(@as(c_int, 24)))]);
    st.*.pad[@as(c_uint, @intCast(@as(c_int, 3)))] = _private_tls_U8TO32(&key[@as(c_uint, @intCast(@as(c_int, 28)))]);
    st.*.leftover = 0;
    st.*.final = 0;
}
pub fn _private_tls_poly1305_blocks(arg_st: [*c]poly1305_state_internal_t, arg_m: [*c]const u8, arg_bytes: usize) callconv(.c) void {
    var st = arg_st;
    _ = &st;
    var m = arg_m;
    _ = &m;
    var bytes = arg_bytes;
    _ = &bytes;
    const hibit: c_ulong = if (@as(c_int, @bitCast(@as(c_uint, st.*.final))) != 0) @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0)))) else @as(c_ulong, 1) << @intCast(24);
    _ = &hibit;
    var r0: c_ulong = undefined;
    _ = &r0;
    var r1: c_ulong = undefined;
    _ = &r1;
    var r2: c_ulong = undefined;
    _ = &r2;
    var r3: c_ulong = undefined;
    _ = &r3;
    var r4: c_ulong = undefined;
    _ = &r4;
    var s1: c_ulong = undefined;
    _ = &s1;
    var s2: c_ulong = undefined;
    _ = &s2;
    var s3: c_ulong = undefined;
    _ = &s3;
    var s4: c_ulong = undefined;
    _ = &s4;
    var h0: c_ulong = undefined;
    _ = &h0;
    var h1: c_ulong = undefined;
    _ = &h1;
    var h2: c_ulong = undefined;
    _ = &h2;
    var h3: c_ulong = undefined;
    _ = &h3;
    var h4: c_ulong = undefined;
    _ = &h4;
    var d0: c_ulonglong = undefined;
    _ = &d0;
    var d1: c_ulonglong = undefined;
    _ = &d1;
    var d2: c_ulonglong = undefined;
    _ = &d2;
    var d3: c_ulonglong = undefined;
    _ = &d3;
    var d4: c_ulonglong = undefined;
    _ = &d4;
    var c: c_ulong = undefined;
    _ = &c;
    r0 = st.*.r[@as(c_uint, @intCast(@as(c_int, 0)))];
    r1 = st.*.r[@as(c_uint, @intCast(@as(c_int, 1)))];
    r2 = st.*.r[@as(c_uint, @intCast(@as(c_int, 2)))];
    r3 = st.*.r[@as(c_uint, @intCast(@as(c_int, 3)))];
    r4 = st.*.r[@as(c_uint, @intCast(@as(c_int, 4)))];
    s1 = r1 *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 5))));
    s2 = r2 *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 5))));
    s3 = r3 *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 5))));
    s4 = r4 *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 5))));
    h0 = st.*.h[@as(c_uint, @intCast(@as(c_int, 0)))];
    h1 = st.*.h[@as(c_uint, @intCast(@as(c_int, 1)))];
    h2 = st.*.h[@as(c_uint, @intCast(@as(c_int, 2)))];
    h3 = st.*.h[@as(c_uint, @intCast(@as(c_int, 3)))];
    h4 = st.*.h[@as(c_uint, @intCast(@as(c_int, 4)))];
    while (bytes >= @as(usize, @bitCast(@as(c_long, @as(c_int, 16))))) {
        h0 +%= _private_tls_U8TO32(m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0)))))) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
        h1 +%= (_private_tls_U8TO32(m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 3)))))) >> @intCast(2)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
        h2 +%= (_private_tls_U8TO32(m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 6)))))) >> @intCast(4)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
        h3 +%= (_private_tls_U8TO32(m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 9)))))) >> @intCast(6)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
        h4 +%= (_private_tls_U8TO32(m + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12)))))) >> @intCast(8)) | hibit;
        d0 = ((((@as(c_ulonglong, @bitCast(@as(c_ulonglong, h0))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, r0)))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h1))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, s4))))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h2))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, s3))))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h3))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, s2))))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h4))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, s1))));
        d1 = ((((@as(c_ulonglong, @bitCast(@as(c_ulonglong, h0))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, r1)))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h1))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, r0))))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h2))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, s4))))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h3))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, s3))))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h4))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, s2))));
        d2 = ((((@as(c_ulonglong, @bitCast(@as(c_ulonglong, h0))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, r2)))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h1))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, r1))))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h2))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, r0))))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h3))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, s4))))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h4))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, s3))));
        d3 = ((((@as(c_ulonglong, @bitCast(@as(c_ulonglong, h0))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, r3)))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h1))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, r2))))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h2))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, r1))))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h3))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, r0))))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h4))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, s4))));
        d4 = ((((@as(c_ulonglong, @bitCast(@as(c_ulonglong, h0))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, r4)))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h1))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, r3))))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h2))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, r2))))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h3))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, r1))))) +% (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h4))) *% @as(c_ulonglong, @bitCast(@as(c_ulonglong, r0))));
        c = @as(c_ulong, @bitCast(@as(c_ulong, @truncate(d0 >> @intCast(26)))));
        h0 = @as(c_ulong, @bitCast(@as(c_ulong, @truncate(d0)))) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
        d1 +%= @as(c_ulonglong, @bitCast(@as(c_ulonglong, c)));
        c = @as(c_ulong, @bitCast(@as(c_ulong, @truncate(d1 >> @intCast(26)))));
        h1 = @as(c_ulong, @bitCast(@as(c_ulong, @truncate(d1)))) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
        d2 +%= @as(c_ulonglong, @bitCast(@as(c_ulonglong, c)));
        c = @as(c_ulong, @bitCast(@as(c_ulong, @truncate(d2 >> @intCast(26)))));
        h2 = @as(c_ulong, @bitCast(@as(c_ulong, @truncate(d2)))) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
        d3 +%= @as(c_ulonglong, @bitCast(@as(c_ulonglong, c)));
        c = @as(c_ulong, @bitCast(@as(c_ulong, @truncate(d3 >> @intCast(26)))));
        h3 = @as(c_ulong, @bitCast(@as(c_ulong, @truncate(d3)))) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
        d4 +%= @as(c_ulonglong, @bitCast(@as(c_ulonglong, c)));
        c = @as(c_ulong, @bitCast(@as(c_ulong, @truncate(d4 >> @intCast(26)))));
        h4 = @as(c_ulong, @bitCast(@as(c_ulong, @truncate(d4)))) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
        h0 +%= c *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 5))));
        c = h0 >> @intCast(26);
        h0 = h0 & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
        h1 +%= c;
        m += @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16)))));
        bytes -%= @as(usize, @bitCast(@as(c_long, @as(c_int, 16))));
    }
    st.*.h[@as(c_uint, @intCast(@as(c_int, 0)))] = h0;
    st.*.h[@as(c_uint, @intCast(@as(c_int, 1)))] = h1;
    st.*.h[@as(c_uint, @intCast(@as(c_int, 2)))] = h2;
    st.*.h[@as(c_uint, @intCast(@as(c_int, 3)))] = h3;
    st.*.h[@as(c_uint, @intCast(@as(c_int, 4)))] = h4;
}
pub export fn _private_tls_poly1305_finish(arg_ctx: [*c]poly1305_state_internal_t, arg_mac: [*c]u8) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var mac = arg_mac;
    _ = &mac;
    var st: [*c]poly1305_state_internal_t = ctx;
    _ = &st;
    var h0: c_ulong = undefined;
    _ = &h0;
    var h1: c_ulong = undefined;
    _ = &h1;
    var h2: c_ulong = undefined;
    _ = &h2;
    var h3: c_ulong = undefined;
    _ = &h3;
    var h4: c_ulong = undefined;
    _ = &h4;
    var c: c_ulong = undefined;
    _ = &c;
    var g0: c_ulong = undefined;
    _ = &g0;
    var g1: c_ulong = undefined;
    _ = &g1;
    var g2: c_ulong = undefined;
    _ = &g2;
    var g3: c_ulong = undefined;
    _ = &g3;
    var g4: c_ulong = undefined;
    _ = &g4;
    var f: c_ulonglong = undefined;
    _ = &f;
    var mask: c_ulong = undefined;
    _ = &mask;
    if (st.*.leftover != 0) {
        var i: usize = st.*.leftover;
        _ = &i;
        st.*.buffer[blk: {
            const ref = &i;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }] = 1;
        while (i < @as(usize, @bitCast(@as(c_long, @as(c_int, 16))))) : (i +%= 1) {
            st.*.buffer[i] = 0;
        }
        st.*.final = 1;
        _private_tls_poly1305_blocks(st, @as([*c]u8, @ptrCast(@alignCast(&st.*.buffer))), @as(usize, @bitCast(@as(c_long, @as(c_int, 16)))));
    }
    h0 = st.*.h[@as(c_uint, @intCast(@as(c_int, 0)))];
    h1 = st.*.h[@as(c_uint, @intCast(@as(c_int, 1)))];
    h2 = st.*.h[@as(c_uint, @intCast(@as(c_int, 2)))];
    h3 = st.*.h[@as(c_uint, @intCast(@as(c_int, 3)))];
    h4 = st.*.h[@as(c_uint, @intCast(@as(c_int, 4)))];
    c = h1 >> @intCast(26);
    h1 = h1 & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
    h2 +%= c;
    c = h2 >> @intCast(26);
    h2 = h2 & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
    h3 +%= c;
    c = h3 >> @intCast(26);
    h3 = h3 & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
    h4 +%= c;
    c = h4 >> @intCast(26);
    h4 = h4 & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
    h0 +%= c *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 5))));
    c = h0 >> @intCast(26);
    h0 = h0 & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
    h1 +%= c;
    g0 = h0 +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 5))));
    c = g0 >> @intCast(26);
    g0 &= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
    g1 = h1 +% c;
    c = g1 >> @intCast(26);
    g1 &= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
    g2 = h2 +% c;
    c = g2 >> @intCast(26);
    g2 &= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
    g3 = h3 +% c;
    c = g3 >> @intCast(26);
    g3 &= @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 67108863))));
    g4 = (h4 +% c) -% (@as(c_ulong, 1) << @intCast(26));
    mask = (g4 >> @intCast((@sizeOf(c_ulong) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))))) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))));
    g0 &= mask;
    g1 &= mask;
    g2 &= mask;
    g3 &= mask;
    g4 &= mask;
    mask = ~mask;
    h0 = (h0 & mask) | g0;
    h1 = (h1 & mask) | g1;
    h2 = (h2 & mask) | g2;
    h3 = (h3 & mask) | g3;
    h4 = (h4 & mask) | g4;
    h0 = (h0 | (h1 << @intCast(26))) & @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, 4294967295))));
    h1 = ((h1 >> @intCast(6)) | (h2 << @intCast(20))) & @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, 4294967295))));
    h2 = ((h2 >> @intCast(12)) | (h3 << @intCast(14))) & @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, 4294967295))));
    h3 = ((h3 >> @intCast(18)) | (h4 << @intCast(8))) & @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, 4294967295))));
    f = @as(c_ulonglong, @bitCast(@as(c_ulonglong, h0))) +% @as(c_ulonglong, @bitCast(@as(c_ulonglong, st.*.pad[@as(c_uint, @intCast(@as(c_int, 0)))])));
    h0 = @as(c_ulong, @bitCast(@as(c_ulong, @truncate(f))));
    f = (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h1))) +% @as(c_ulonglong, @bitCast(@as(c_ulonglong, st.*.pad[@as(c_uint, @intCast(@as(c_int, 1)))])))) +% (f >> @intCast(32));
    h1 = @as(c_ulong, @bitCast(@as(c_ulong, @truncate(f))));
    f = (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h2))) +% @as(c_ulonglong, @bitCast(@as(c_ulonglong, st.*.pad[@as(c_uint, @intCast(@as(c_int, 2)))])))) +% (f >> @intCast(32));
    h2 = @as(c_ulong, @bitCast(@as(c_ulong, @truncate(f))));
    f = (@as(c_ulonglong, @bitCast(@as(c_ulonglong, h3))) +% @as(c_ulonglong, @bitCast(@as(c_ulonglong, st.*.pad[@as(c_uint, @intCast(@as(c_int, 3)))])))) +% (f >> @intCast(32));
    h3 = @as(c_ulong, @bitCast(@as(c_ulong, @truncate(f))));
    _private_tls_U32TO8(mac + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))), h0);
    _private_tls_U32TO8(mac + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))), h1);
    _private_tls_U32TO8(mac + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))), h2);
    _private_tls_U32TO8(mac + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))), h3);
    st.*.h[@as(c_uint, @intCast(@as(c_int, 0)))] = 0;
    st.*.h[@as(c_uint, @intCast(@as(c_int, 1)))] = 0;
    st.*.h[@as(c_uint, @intCast(@as(c_int, 2)))] = 0;
    st.*.h[@as(c_uint, @intCast(@as(c_int, 3)))] = 0;
    st.*.h[@as(c_uint, @intCast(@as(c_int, 4)))] = 0;
    st.*.r[@as(c_uint, @intCast(@as(c_int, 0)))] = 0;
    st.*.r[@as(c_uint, @intCast(@as(c_int, 1)))] = 0;
    st.*.r[@as(c_uint, @intCast(@as(c_int, 2)))] = 0;
    st.*.r[@as(c_uint, @intCast(@as(c_int, 3)))] = 0;
    st.*.r[@as(c_uint, @intCast(@as(c_int, 4)))] = 0;
    st.*.pad[@as(c_uint, @intCast(@as(c_int, 0)))] = 0;
    st.*.pad[@as(c_uint, @intCast(@as(c_int, 1)))] = 0;
    st.*.pad[@as(c_uint, @intCast(@as(c_int, 2)))] = 0;
    st.*.pad[@as(c_uint, @intCast(@as(c_int, 3)))] = 0;
}
pub export fn _private_tls_poly1305_update(arg_ctx: [*c]poly1305_state_internal_t, arg_m: [*c]const u8, arg_bytes: usize) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var m = arg_m;
    _ = &m;
    var bytes = arg_bytes;
    _ = &bytes;
    var st: [*c]poly1305_state_internal_t = ctx;
    _ = &st;
    var i: usize = undefined;
    _ = &i;
    if (st.*.leftover != 0) {
        var want: usize = @as(usize, @bitCast(@as(c_long, @as(c_int, 16)))) -% st.*.leftover;
        _ = &want;
        if (want > bytes) {
            want = bytes;
        }
        {
            i = 0;
            while (i < want) : (i +%= 1) {
                st.*.buffer[st.*.leftover +% i] = m[i];
            }
        }
        bytes -%= want;
        m += want;
        st.*.leftover +%= want;
        if (st.*.leftover < @as(usize, @bitCast(@as(c_long, @as(c_int, 16))))) return;
        _private_tls_poly1305_blocks(st, @as([*c]u8, @ptrCast(@alignCast(&st.*.buffer))), @as(usize, @bitCast(@as(c_long, @as(c_int, 16)))));
        st.*.leftover = 0;
    }
    if (bytes >= @as(usize, @bitCast(@as(c_long, @as(c_int, 16))))) {
        var want: usize = bytes & @as(usize, @bitCast(@as(c_long, ~(@as(c_int, 16) - @as(c_int, 1)))));
        _ = &want;
        _private_tls_poly1305_blocks(st, m, want);
        m += want;
        bytes -%= want;
    }
    if (bytes != 0) {
        {
            i = 0;
            while (i < bytes) : (i +%= 1) {
                st.*.buffer[st.*.leftover +% i] = m[i];
            }
        }
        st.*.leftover +%= bytes;
    }
}
pub export fn poly1305_verify(mac1: [*c]const u8, mac2: [*c]const u8) c_int {
    _ = &mac1;
    _ = &mac2;
    var i: usize = undefined;
    _ = &i;
    var dif: c_uint = 0;
    _ = &dif;
    {
        i = 0;
        while (i < @as(usize, @bitCast(@as(c_long, @as(c_int, 16))))) : (i +%= 1) {
            dif |= @as(c_uint, @bitCast(@as(c_int, @bitCast(@as(c_uint, mac1[i]))) ^ @as(c_int, @bitCast(@as(c_uint, mac2[i])))));
        }
    }
    dif = (dif -% @as(c_uint, @bitCast(@as(c_int, 1)))) >> @intCast((@sizeOf(c_uint) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8))))) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))));
    return @as(c_int, @bitCast(dif & @as(c_uint, @bitCast(@as(c_int, 1)))));
}
pub export fn chacha20_poly1305_key(arg_ctx: [*c]struct_chacha_ctx, arg_poly1305_key: [*c]u8) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var poly1305_key = arg_poly1305_key;
    _ = &poly1305_key;
    var key: [32]u8 = undefined;
    _ = &key;
    var nonce: [12]u8 = undefined;
    _ = &nonce;
    chacha_key(ctx, @as([*c]u8, @ptrCast(@alignCast(&key))));
    chacha_nonce(ctx, @as([*c]u8, @ptrCast(@alignCast(&nonce))));
    _ = poly1305_generate_key(@as([*c]u8, @ptrCast(@alignCast(&key))), @as([*c]u8, @ptrCast(@alignCast(&nonce))), @as(c_uint, @bitCast(@as(c_uint, @truncate(@sizeOf([12]u8))))), poly1305_key, @as(c_uint, @bitCast(@as(c_int, 0))));
}
pub export fn chacha20_poly1305_aead(arg_ctx: [*c]struct_chacha_ctx, arg_pt: [*c]u8, arg_len: c_uint, arg_aad: [*c]u8, arg_aad_len: c_uint, arg_poly_key: [*c]u8, arg_out: [*c]u8) c_int {
    var ctx = arg_ctx;
    _ = &ctx;
    var pt = arg_pt;
    _ = &pt;
    var len = arg_len;
    _ = &len;
    var aad = arg_aad;
    _ = &aad;
    var aad_len = arg_aad_len;
    _ = &aad_len;
    var poly_key = arg_poly_key;
    _ = &poly_key;
    var out = arg_out;
    _ = &out;
    const zeropad = struct {
        var static: [15]u8 = [15]u8{
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        };
    };
    _ = &zeropad;
    if (aad_len > @as(c_uint, @bitCast(@as(c_int, 32)))) return -@as(c_int, 1);
    var counter: c_uint = 1;
    _ = &counter;
    chacha_ivsetup_96bitnonce(ctx, null, @as([*c]u8, @ptrCast(@alignCast(&counter))));
    chacha_encrypt_bytes(ctx, pt, out, len);
    var aead_ctx: poly1305_state_internal_t = undefined;
    _ = &aead_ctx;
    _private_tls_poly1305_init(&aead_ctx, poly_key);
    _private_tls_poly1305_update(&aead_ctx, aad, @as(usize, @bitCast(@as(c_ulong, aad_len))));
    var rem: c_int = @as(c_int, @bitCast(aad_len % @as(c_uint, @bitCast(@as(c_int, 16)))));
    _ = &rem;
    if (rem != 0) {
        _private_tls_poly1305_update(&aead_ctx, @as([*c]u8, @ptrCast(@alignCast(&zeropad.static))), @as(usize, @bitCast(@as(c_long, @as(c_int, 16) - rem))));
    }
    _private_tls_poly1305_update(&aead_ctx, out, @as(usize, @bitCast(@as(c_ulong, len))));
    rem = @as(c_int, @bitCast(len % @as(c_uint, @bitCast(@as(c_int, 16)))));
    if (rem != 0) {
        _private_tls_poly1305_update(&aead_ctx, @as([*c]u8, @ptrCast(@alignCast(&zeropad.static))), @as(usize, @bitCast(@as(c_long, @as(c_int, 16) - rem))));
    }
    var trail: [16]u8 = undefined;
    _ = &trail;
    _private_tls_U32TO8(@as([*c]u8, @ptrCast(@alignCast(&trail))), @as(c_ulong, @bitCast(@as(c_ulong, aad_len))));
    @as([*c]c_int, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&trail))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4)))))))).* = 0;
    _private_tls_U32TO8(@as([*c]u8, @ptrCast(@alignCast(&trail))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))), @as(c_ulong, @bitCast(@as(c_ulong, len))));
    @as([*c]c_int, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&trail))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12)))))))).* = 0;
    _private_tls_poly1305_update(&aead_ctx, @as([*c]u8, @ptrCast(@alignCast(&trail))), @as(usize, @bitCast(@as(c_long, @as(c_int, 16)))));
    _private_tls_poly1305_finish(&aead_ctx, out + len);
    return @as(c_int, @bitCast(len +% @as(c_uint, @bitCast(@as(c_int, 16)))));
}
pub const KEA_dhe_dss: c_int = 0;
pub const KEA_dhe_rsa: c_int = 1;
pub const KEA_dh_anon: c_int = 2;
pub const KEA_rsa: c_int = 3;
pub const KEA_dh_dss: c_int = 4;
pub const KEA_dh_rsa: c_int = 5;
pub const KEA_ec_diffie_hellman: c_int = 6;
pub const KeyExchangeAlgorithm = c_uint;
pub const rsa_sign: c_int = 1;
pub const dss_sign: c_int = 2;
pub const rsa_fixed_dh: c_int = 3;
pub const dss_fixed_dh: c_int = 4;
pub const rsa_ephemeral_dh_RESERVED: c_int = 5;
pub const dss_ephemeral_dh_RESERVED: c_int = 6;
pub const fortezza_dms_RESERVED: c_int = 20;
pub const ecdsa_sign: c_int = 64;
pub const rsa_fixed_ecdh: c_int = 65;
pub const ecdsa_fixed_ecdh: c_int = 66;
pub const TLSClientCertificateType = c_uint;
pub const none: c_int = 0;
pub const md5: c_int = 1;
pub const sha1: c_int = 2;
pub const sha224: c_int = 3;
pub const sha256: c_int = 4;
pub const sha384: c_int = 5;
pub const sha512: c_int = 6;
pub const _md5_sha1: c_int = 255;
pub const TLSHashAlgorithm = c_uint;
pub const anonymous: c_int = 0;
pub const rsa_pkcs1: c_int = 1;
pub const ecdsa: c_int = 3;
pub const rsa_pss: c_int = 8;
pub const TLSSignatureAlgorithm = c_uint;
pub const struct__private_OID_chain = extern struct {
    top: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    oid: [*c]u8 = @import("std").mem.zeroes([*c]u8),
};
const union_unnamed_54 = extern union {
    aes_local: symmetric_CBC,
    aes_gcm_local: gcm_state,
    chacha_local: chacha_ctx,
};
const union_unnamed_55 = extern union {
    aes_remote: symmetric_CBC,
    aes_gcm_remote: gcm_state,
    chacha_remote: chacha_ctx,
};
const union_unnamed_56 = extern union {
    local_mac: [48]u8,
    local_aead_iv: [4]u8,
    local_iv: [12]u8,
    local_nonce: [12]u8,
};
const union_unnamed_57 = extern union {
    remote_aead_iv: [4]u8,
    remote_mac: [48]u8,
    remote_iv: [12]u8,
    remote_nonce: [12]u8,
};
pub const TLSCipher = extern struct {
    ctx_local: union_unnamed_54 = @import("std").mem.zeroes(union_unnamed_54),
    ctx_remote: union_unnamed_55 = @import("std").mem.zeroes(union_unnamed_55),
    ctx_local_mac: union_unnamed_56 = @import("std").mem.zeroes(union_unnamed_56),
    ctx_remote_mac: union_unnamed_57 = @import("std").mem.zeroes(union_unnamed_57),
    created: u8 = @import("std").mem.zeroes(u8),
};
pub const TLSHash = extern struct {
    hash32: hash_state = @import("std").mem.zeroes(hash_state),
    hash48: hash_state = @import("std").mem.zeroes(hash_state),
    hash2: hash_state = @import("std").mem.zeroes(hash_state),
    created: u8 = @import("std").mem.zeroes(u8),
};
pub const DHKey = extern struct {
    iana: c_int = @import("std").mem.zeroes(c_int),
    x: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    y: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    p: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    g: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub var ffdhe2048: DHKey = DHKey{
    .iana = @as(c_int, 256),
    .x = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))),
    .y = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))),
    .p = @as(?*anyopaque, @ptrCast("FFFFFFFFFFFFFFFFADF85458A2BB4A9AAFDC5620273D3CF1D8B9C583CE2D3695A9E13641146433FBCC939DCE249B3EF97D2FE363630C75D8F681B202AEC4617AD3DF1ED5D5FD65612433F51F5F066ED0856365553DED1AF3B557135E7F57C935984F0C70E0E68B77E2A689DAF3EFE8721DF158A136ADE73530ACCA4F483A797ABC0AB182B324FB61D108A94BB2C8E3FBB96ADAB760D7F4681D4F42A3DE394DF4AE56EDE76372BB190B07A7C8EE0A6D709E02FCE1CDF7E2ECC03404CD28342F619172FE9CE98583FF8E4F1232EEF28183C3FE3B1B4C6FAD733BB5FCBC2EC22005C58EF1837D1683B2C6F34A26C1B2EFFA886B423861285C97FFFFFFFFFFFFFFFF")),
    .g = @as(?*anyopaque, @ptrCast("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002")),
};
pub var ffdhe3072: DHKey = DHKey{
    .iana = @as(c_int, 257),
    .x = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))),
    .y = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))),
    .p = @as(?*anyopaque, @ptrCast("FFFFFFFFFFFFFFFFADF85458A2BB4A9AAFDC5620273D3CF1D8B9C583CE2D3695A9E13641146433FBCC939DCE249B3EF97D2FE363630C75D8F681B202AEC4617AD3DF1ED5D5FD65612433F51F5F066ED0856365553DED1AF3B557135E7F57C935984F0C70E0E68B77E2A689DAF3EFE8721DF158A136ADE73530ACCA4F483A797ABC0AB182B324FB61D108A94BB2C8E3FBB96ADAB760D7F4681D4F42A3DE394DF4AE56EDE76372BB190B07A7C8EE0A6D709E02FCE1CDF7E2ECC03404CD28342F619172FE9CE98583FF8E4F1232EEF28183C3FE3B1B4C6FAD733BB5FCBC2EC22005C58EF1837D1683B2C6F34A26C1B2EFFA886B4238611FCFDCDE355B3B6519035BBC34F4DEF99C023861B46FC9D6E6C9077AD91D2691F7F7EE598CB0FAC186D91CAEFE130985139270B4130C93BC437944F4FD4452E2D74DD364F2E21E71F54BFF5CAE82AB9C9DF69EE86D2BC522363A0DABC521979B0DEADA1DBF9A42D5C4484E0ABCD06BFA53DDEF3C1B20EE3FD59D7C25E41D2B66C62E37FFFFFFFFFFFFFFFF")),
    .g = @as(?*anyopaque, @ptrCast("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002")),
};
pub var ffdhe4096: DHKey = DHKey{
    .iana = @as(c_int, 258),
    .x = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))),
    .y = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))),
    .p = @as(?*anyopaque, @ptrCast("FFFFFFFFFFFFFFFFADF85458A2BB4A9AAFDC5620273D3CF1D8B9C583CE2D3695A9E13641146433FBCC939DCE249B3EF97D2FE363630C75D8F681B202AEC4617AD3DF1ED5D5FD65612433F51F5F066ED0856365553DED1AF3B557135E7F57C935984F0C70E0E68B77E2A689DAF3EFE8721DF158A136ADE73530ACCA4F483A797ABC0AB182B324FB61D108A94BB2C8E3FBB96ADAB760D7F4681D4F42A3DE394DF4AE56EDE76372BB190B07A7C8EE0A6D709E02FCE1CDF7E2ECC03404CD28342F619172FE9CE98583FF8E4F1232EEF28183C3FE3B1B4C6FAD733BB5FCBC2EC22005C58EF1837D1683B2C6F34A26C1B2EFFA886B4238611FCFDCDE355B3B6519035BBC34F4DEF99C023861B46FC9D6E6C9077AD91D2691F7F7EE598CB0FAC186D91CAEFE130985139270B4130C93BC437944F4FD4452E2D74DD364F2E21E71F54BFF5CAE82AB9C9DF69EE86D2BC522363A0DABC521979B0DEADA1DBF9A42D5C4484E0ABCD06BFA53DDEF3C1B20EE3FD59D7C25E41D2B669E1EF16E6F52C3164DF4FB7930E9E4E58857B6AC7D5F42D69F6D187763CF1D5503400487F55BA57E31CC7A7135C886EFB4318AED6A1E012D9E6832A907600A918130C46DC778F971AD0038092999A333CB8B7A1A1DB93D7140003C2A4ECEA9F98D0ACC0A8291CDCEC97DCF8EC9B55A7F88A46B4DB5A851F44182E1C68A007E5E655F6AFFFFFFFFFFFFFFFF")),
    .g = @as(?*anyopaque, @ptrCast("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002")),
};
pub var ffdhe6144: DHKey = DHKey{
    .iana = @as(c_int, 259),
    .x = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))),
    .y = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))),
    .p = @as(?*anyopaque, @ptrCast("FFFFFFFFFFFFFFFFADF85458A2BB4A9AAFDC5620273D3CF1D8B9C583CE2D3695A9E13641146433FBCC939DCE249B3EF97D2FE363630C75D8F681B202AEC4617AD3DF1ED5D5FD65612433F51F5F066ED0856365553DED1AF3B557135E7F57C935984F0C70E0E68B77E2A689DAF3EFE8721DF158A136ADE73530ACCA4F483A797ABC0AB182B324FB61D108A94BB2C8E3FBB96ADAB760D7F4681D4F42A3DE394DF4AE56EDE76372BB190B07A7C8EE0A6D709E02FCE1CDF7E2ECC03404CD28342F619172FE9CE98583FF8E4F1232EEF28183C3FE3B1B4C6FAD733BB5FCBC2EC22005C58EF1837D1683B2C6F34A26C1B2EFFA886B4238611FCFDCDE355B3B6519035BBC34F4DEF99C023861B46FC9D6E6C9077AD91D2691F7F7EE598CB0FAC186D91CAEFE130985139270B4130C93BC437944F4FD4452E2D74DD364F2E21E71F54BFF5CAE82AB9C9DF69EE86D2BC522363A0DABC521979B0DEADA1DBF9A42D5C4484E0ABCD06BFA53DDEF3C1B20EE3FD59D7C25E41D2B669E1EF16E6F52C3164DF4FB7930E9E4E58857B6AC7D5F42D69F6D187763CF1D5503400487F55BA57E31CC7A7135C886EFB4318AED6A1E012D9E6832A907600A918130C46DC778F971AD0038092999A333CB8B7A1A1DB93D7140003C2A4ECEA9F98D0ACC0A8291CDCEC97DCF8EC9B55A7F88A46B4DB5A851F44182E1C68A007E5E0DD9020BFD64B645036C7A4E677D2C38532A3A23BA4442CAF53EA63BB454329B7624C8917BDD64B1C0FD4CB38E8C334C701C3ACDAD0657FCCFEC719B1F5C3E4E46041F388147FB4CFDB477A52471F7A9A96910B855322EDB6340D8A00EF092350511E30ABEC1FFF9E3A26E7FB29F8C183023C3587E38DA0077D9B4763E4E4B94B2BBC194C6651E77CAF992EEAAC0232A281BF6B3A739C1226116820AE8DB5847A67CBEF9C9091B462D538CD72B03746AE77F5E62292C311562A846505DC82DB854338AE49F5235C95B91178CCF2DD5CACEF403EC9D1810C6272B045B3B71F9DC6B80D63FDD4A8E9ADB1E6962A69526D43161C1A41D570D7938DAD4A40E329CD0E40E65FFFFFFFFFFFFFFFF")),
    .g = @as(?*anyopaque, @ptrCast("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002")),
};
pub var ffdhe8192: DHKey = DHKey{
    .iana = @as(c_int, 260),
    .x = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))),
    .y = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))),
    .p = @as(?*anyopaque, @ptrCast("FFFFFFFFFFFFFFFFADF85458A2BB4A9AAFDC5620273D3CF1D8B9C583CE2D3695A9E13641146433FBCC939DCE249B3EF97D2FE363630C75D8F681B202AEC4617AD3DF1ED5D5FD65612433F51F5F066ED0856365553DED1AF3B557135E7F57C935984F0C70E0E68B77E2A689DAF3EFE8721DF158A136ADE73530ACCA4F483A797ABC0AB182B324FB61D108A94BB2C8E3FBB96ADAB760D7F4681D4F42A3DE394DF4AE56EDE76372BB190B07A7C8EE0A6D709E02FCE1CDF7E2ECC03404CD28342F619172FE9CE98583FF8E4F1232EEF28183C3FE3B1B4C6FAD733BB5FCBC2EC22005C58EF1837D1683B2C6F34A26C1B2EFFA886B4238611FCFDCDE355B3B6519035BBC34F4DEF99C023861B46FC9D6E6C9077AD91D2691F7F7EE598CB0FAC186D91CAEFE130985139270B4130C93BC437944F4FD4452E2D74DD364F2E21E71F54BFF5CAE82AB9C9DF69EE86D2BC522363A0DABC521979B0DEADA1DBF9A42D5C4484E0ABCD06BFA53DDEF3C1B20EE3FD59D7C25E41D2B669E1EF16E6F52C3164DF4FB7930E9E4E58857B6AC7D5F42D69F6D187763CF1D5503400487F55BA57E31CC7A7135C886EFB4318AED6A1E012D9E6832A907600A918130C46DC778F971AD0038092999A333CB8B7A1A1DB93D7140003C2A4ECEA9F98D0ACC0A8291CDCEC97DCF8EC9B55A7F88A46B4DB5A851F44182E1C68A007E5E0DD9020BFD64B645036C7A4E677D2C38532A3A23BA4442CAF53EA63BB454329B7624C8917BDD64B1C0FD4CB38E8C334C701C3ACDAD0657FCCFEC719B1F5C3E4E46041F388147FB4CFDB477A52471F7A9A96910B855322EDB6340D8A00EF092350511E30ABEC1FFF9E3A26E7FB29F8C183023C3587E38DA0077D9B4763E4E4B94B2BBC194C6651E77CAF992EEAAC0232A281BF6B3A739C1226116820AE8DB5847A67CBEF9C9091B462D538CD72B03746AE77F5E62292C311562A846505DC82DB854338AE49F5235C95B91178CCF2DD5CACEF403EC9D1810C6272B045B3B71F9DC6B80D63FDD4A8E9ADB1E6962A69526D43161C1A41D570D7938DAD4A40E329CCFF46AAA36AD004CF600C8381E425A31D951AE64FDB23FCEC9509D43687FEB69EDD1CC5E0B8CC3BDF64B10EF86B63142A3AB8829555B2F747C932665CB2C0F1CC01BD70229388839D2AF05E454504AC78B7582822846C0BA35C35F5C59160CC046FD8251541FC68C9C86B022BB7099876A460E7451A8A93109703FEE1C217E6C3826E52C51AA691E0E423CFC99E9E31650C1217B624816CDAD9A95F9D5B8019488D9C0A0A1FE3075A577E23183F81D4A3F2FA4571EFC8CE0BA8A4FE8B6855DFE72B0A66EDED2FBABFBE58A30FAFABE1C5D71A87E2F741EF8C1FE86FEA6BBFDE530677F0D97D11D49F7A8443D0822E506A9F4614E011E2A94838FF88CD68C8BB7C5C6424CFFFFFFFFFFFFFFFF")),
    .g = @as(?*anyopaque, @ptrCast("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002")),
};
pub var secp192r1: struct_ECCCurveParameters = struct_ECCCurveParameters{
    .size = @as(c_int, 24),
    .iana = @as(c_int, 19),
    .name = "secp192r1",
    .P = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF",
    .A = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC",
    .B = "64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1",
    .Gx = "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012",
    .Gy = "07192B95FFC8DA78631011ED6B24CDD573F977A11E794811",
    .order = "FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831",
    .oid = "1.2.840.10045.3.1.1",
    .dp = ltc_ecc_set_type{
        .size = @as(c_int, 0),
        .name = null,
        .prime = null,
        .B = null,
        .order = null,
        .Gx = null,
        .Gy = null,
    },
};
pub var secp224r1: struct_ECCCurveParameters = struct_ECCCurveParameters{
    .size = @as(c_int, 28),
    .iana = @as(c_int, 21),
    .name = "secp224r1",
    .P = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001",
    .A = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE",
    .B = "B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4",
    .Gx = "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21",
    .Gy = "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34",
    .order = "FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D",
    .oid = "1.3.132.0.33",
    .dp = ltc_ecc_set_type{
        .size = @as(c_int, 0),
        .name = null,
        .prime = null,
        .B = null,
        .order = null,
        .Gx = null,
        .Gy = null,
    },
};
pub var secp224k1: struct_ECCCurveParameters = struct_ECCCurveParameters{
    .size = @as(c_int, 28),
    .iana = @as(c_int, 20),
    .name = "secp224k1",
    .P = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFE56D",
    .A = "00000000000000000000000000000000000000000000000000000000",
    .B = "00000000000000000000000000000000000000000000000000000005",
    .Gx = "A1455B334DF099DF30FC28A169A467E9E47075A90F7E650EB6B7A45C",
    .Gy = "7E089FED7FBA344282CAFBD6F7E319F7C0B0BD59E2CA4BDB556D61A5",
    .order = "0000000000000000000000000001DCE8D2EC6184CAF0A971769FB1F7",
    .oid = "1.3.132.0.32",
    .dp = ltc_ecc_set_type{
        .size = @as(c_int, 0),
        .name = null,
        .prime = null,
        .B = null,
        .order = null,
        .Gx = null,
        .Gy = null,
    },
};
pub var secp256r1: struct_ECCCurveParameters = struct_ECCCurveParameters{
    .size = @as(c_int, 32),
    .iana = @as(c_int, 23),
    .name = "secp256r1",
    .P = "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF",
    .A = "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC",
    .B = "5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B",
    .Gx = "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296",
    .Gy = "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5",
    .order = "FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551",
    .oid = "1.2.840.10045.3.1.7",
    .dp = ltc_ecc_set_type{
        .size = @as(c_int, 0),
        .name = null,
        .prime = null,
        .B = null,
        .order = null,
        .Gx = null,
        .Gy = null,
    },
};
pub var secp256k1: struct_ECCCurveParameters = struct_ECCCurveParameters{
    .size = @as(c_int, 32),
    .iana = @as(c_int, 22),
    .name = "secp256k1",
    .P = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F",
    .A = "0000000000000000000000000000000000000000000000000000000000000000",
    .B = "0000000000000000000000000000000000000000000000000000000000000007",
    .Gx = "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798",
    .Gy = "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8",
    .order = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141",
    .oid = "1.3.132.0.10",
    .dp = ltc_ecc_set_type{
        .size = @as(c_int, 0),
        .name = null,
        .prime = null,
        .B = null,
        .order = null,
        .Gx = null,
        .Gy = null,
    },
};
pub var secp384r1: struct_ECCCurveParameters = struct_ECCCurveParameters{
    .size = @as(c_int, 48),
    .iana = @as(c_int, 24),
    .name = "secp384r1",
    .P = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF",
    .A = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC",
    .B = "B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF",
    .Gx = "AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7",
    .Gy = "3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F",
    .order = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973",
    .oid = "1.3.132.0.34",
    .dp = ltc_ecc_set_type{
        .size = @as(c_int, 0),
        .name = null,
        .prime = null,
        .B = null,
        .order = null,
        .Gx = null,
        .Gy = null,
    },
};
pub var secp521r1: struct_ECCCurveParameters = struct_ECCCurveParameters{
    .size = @as(c_int, 66),
    .iana = @as(c_int, 25),
    .name = "secp521r1",
    .P = "01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
    .A = "01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC",
    .B = "0051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00",
    .Gx = "00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66",
    .Gy = "011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650",
    .order = "01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409",
    .oid = "1.3.132.0.35",
    .dp = ltc_ecc_set_type{
        .size = @as(c_int, 0),
        .name = null,
        .prime = null,
        .B = null,
        .order = null,
        .Gx = null,
        .Gy = null,
    },
};
pub var x25519: struct_ECCCurveParameters = struct_ECCCurveParameters{
    .size = @as(c_int, 32),
    .iana = @as(c_int, 29),
    .name = "x25519",
    .P = "7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFED",
    .A = "0000000000000000000000000000000000000000000000000000000000076D06",
    .B = "0000000000000000000000000000000000000000000000000000000000000000",
    .Gx = "0000000000000000000000000000000000000000000000000000000000000009",
    .Gy = "20AE19A1B8A086B4E01EDD2C7748D14C923D4D7E6D7C61B229E9C5A27ECED3D9",
    .order = "1000000000000000000000000000000014DEF9DEA2F79CD65812631A5CF5D3ED",
    .oid = "1.3.101.110",
    .dp = ltc_ecc_set_type{
        .size = @as(c_int, 0),
        .name = null,
        .prime = null,
        .B = null,
        .order = null,
        .Gx = null,
        .Gy = null,
    },
};
pub const default_curve: [*c]struct_ECCCurveParameters = &secp256r1;
pub export fn init_curve(arg_curve: [*c]struct_ECCCurveParameters) void {
    var curve = arg_curve;
    _ = &curve;
    curve.*.dp.size = curve.*.size;
    curve.*.dp.name = @as([*c]u8, @ptrCast(@volatileCast(@constCast(curve.*.name))));
    curve.*.dp.B = curve.*.B;
    curve.*.dp.prime = curve.*.P;
    curve.*.dp.Gx = curve.*.Gx;
    curve.*.dp.Gy = curve.*.Gy;
    curve.*.dp.order = curve.*.order;
}
pub export fn init_curves() void {
    init_curve(&secp192r1);
    init_curve(&secp224r1);
    init_curve(&secp224k1);
    init_curve(&secp256r1);
    init_curve(&secp256k1);
    init_curve(&secp384r1);
    init_curve(&secp521r1);
}
pub const version_id: [4]c_uint = [4]c_uint{
    1,
    1,
    1,
    0,
};
pub const pk_id: [4]c_uint = [4]c_uint{
    1,
    1,
    7,
    0,
};
pub const serial_id: [5]c_uint = [5]c_uint{
    1,
    1,
    2,
    1,
    0,
};
pub const issurer_id: [4]c_uint = [4]c_uint{
    1,
    1,
    4,
    0,
};
pub const owner_id: [4]c_uint = [4]c_uint{
    1,
    1,
    6,
    0,
};
pub const validity_id: [4]c_uint = [4]c_uint{
    1,
    1,
    5,
    0,
};
pub const algorithm_id: [4]c_uint = [4]c_uint{
    1,
    1,
    3,
    0,
};
pub const sign_id: [5]c_uint = [5]c_uint{
    1,
    3,
    2,
    1,
    0,
};
pub const priv_id: [3]c_uint = [3]c_uint{
    1,
    4,
    0,
};
pub const priv_der_id: [4]c_uint = [4]c_uint{
    1,
    3,
    1,
    0,
};
pub const ecc_priv_id: [3]c_uint = [3]c_uint{
    1,
    2,
    0,
};
pub const country_oid: [4]u8 = [4]u8{
    85,
    4,
    6,
    0,
};
pub const state_oid: [4]u8 = [4]u8{
    85,
    4,
    8,
    0,
};
pub const location_oid: [4]u8 = [4]u8{
    85,
    4,
    7,
    0,
};
pub const entity_oid: [4]u8 = [4]u8{
    85,
    4,
    10,
    0,
};
pub const subject_oid: [4]u8 = [4]u8{
    85,
    4,
    3,
    0,
};
pub const san_oid: [4]u8 = [4]u8{
    85,
    29,
    17,
    0,
};
pub const ocsp_oid: [9]u8 = [9]u8{
    43,
    6,
    1,
    5,
    5,
    7,
    48,
    1,
    0,
};
pub const TLS_RSA_SIGN_RSA_OID: [10]u8 = [10]u8{
    42,
    134,
    72,
    134,
    247,
    13,
    1,
    1,
    1,
    0,
};
pub const TLS_RSA_SIGN_MD5_OID: [10]u8 = [10]u8{
    42,
    134,
    72,
    134,
    247,
    13,
    1,
    1,
    4,
    0,
};
pub const TLS_RSA_SIGN_SHA1_OID: [10]u8 = [10]u8{
    42,
    134,
    72,
    134,
    247,
    13,
    1,
    1,
    5,
    0,
};
pub const TLS_RSA_SIGN_SHA224_OID: [10]u8 = [10]u8{
    42,
    134,
    72,
    134,
    247,
    13,
    1,
    1,
    14,
    0,
};
pub const TLS_RSA_SIGN_SHA256_OID: [10]u8 = [10]u8{
    42,
    134,
    72,
    134,
    247,
    13,
    1,
    1,
    11,
    0,
};
pub const TLS_RSA_SIGN_SHA384_OID: [10]u8 = [10]u8{
    42,
    134,
    72,
    134,
    247,
    13,
    1,
    1,
    12,
    0,
};
pub const TLS_RSA_SIGN_SHA512_OID: [10]u8 = [10]u8{
    42,
    134,
    72,
    134,
    247,
    13,
    1,
    1,
    13,
    0,
};
pub const TLS_ECDSA_SIGN_SHA224_OID: [9]u8 = [9]u8{
    42,
    134,
    72,
    206,
    61,
    4,
    3,
    1,
    0,
};
pub const TLS_ECDSA_SIGN_SHA256_OID: [9]u8 = [9]u8{
    42,
    134,
    72,
    206,
    61,
    4,
    3,
    2,
    0,
};
pub const TLS_ECDSA_SIGN_SHA384_OID: [9]u8 = [9]u8{
    42,
    134,
    72,
    206,
    61,
    4,
    3,
    3,
    0,
};
pub const TLS_ECDSA_SIGN_SHA512_OID: [9]u8 = [9]u8{
    42,
    134,
    72,
    206,
    61,
    4,
    3,
    4,
    0,
};
pub const TLS_EC_PUBLIC_KEY_OID: [8]u8 = [8]u8{
    42,
    134,
    72,
    206,
    61,
    2,
    1,
    0,
};
pub const TLS_EC_prime192v1_OID: [9]u8 = [9]u8{
    42,
    134,
    72,
    206,
    61,
    3,
    1,
    1,
    0,
};
pub const TLS_EC_prime192v2_OID: [9]u8 = [9]u8{
    42,
    134,
    72,
    206,
    61,
    3,
    1,
    2,
    0,
};
pub const TLS_EC_prime192v3_OID: [9]u8 = [9]u8{
    42,
    134,
    72,
    206,
    61,
    3,
    1,
    3,
    0,
};
pub const TLS_EC_prime239v1_OID: [9]u8 = [9]u8{
    42,
    134,
    72,
    206,
    61,
    3,
    1,
    4,
    0,
};
pub const TLS_EC_prime239v2_OID: [9]u8 = [9]u8{
    42,
    134,
    72,
    206,
    61,
    3,
    1,
    5,
    0,
};
pub const TLS_EC_prime239v3_OID: [9]u8 = [9]u8{
    42,
    134,
    72,
    206,
    61,
    3,
    1,
    6,
    0,
};
pub const TLS_EC_prime256v1_OID: [9]u8 = [9]u8{
    42,
    134,
    72,
    206,
    61,
    3,
    1,
    7,
    0,
};
pub const TLS_EC_secp224r1_OID: [6]u8 = [6]u8{
    43,
    129,
    4,
    0,
    33,
    0,
};
pub const TLS_EC_secp384r1_OID: [6]u8 = [6]u8{
    43,
    129,
    4,
    0,
    34,
    0,
};
pub const TLS_EC_secp521r1_OID: [6]u8 = [6]u8{
    43,
    129,
    4,
    0,
    35,
    0,
};
pub export fn asn1_parse(arg_context: [*c]struct_TLSContext, arg_buffer: [*c]const u8, arg_size: c_uint, arg_client_cert: c_int) [*c]struct_TLSCertificate {
    var context = arg_context;
    _ = &context;
    var buffer = arg_buffer;
    _ = &buffer;
    var size = arg_size;
    _ = &size;
    var client_cert = arg_client_cert;
    _ = &client_cert;
    var fields: [255]c_uint = undefined;
    _ = &fields;
    _ = memset(@as(?*anyopaque, @ptrCast(@as([*c]c_uint, @ptrCast(@alignCast(&fields))))), @as(c_int, 0), @sizeOf(c_int) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255)))));
    var cert: [*c]struct_TLSCertificate = tls_create_certificate();
    _ = &cert;
    if (cert != null) {
        if (client_cert < @as(c_int, 0)) {
            client_cert = 0;
            var top_oid: [16]u8 = undefined;
            _ = &top_oid;
            _ = memset(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&top_oid))))), @as(c_int, 0), @sizeOf([16]u8));
            _ = _private_asn1_parse(context, cert, buffer, size, @as(c_int, 1), @as([*c]c_uint, @ptrCast(@alignCast(&fields))), null, client_cert, @as([*c]u8, @ptrCast(@alignCast(&top_oid))), null);
        } else {
            _ = _private_asn1_parse(context, cert, buffer, size, @as(c_int, 1), @as([*c]c_uint, @ptrCast(@alignCast(&fields))), null, client_cert, null, null);
        }
    }
    return cert;
}
pub export fn _private_tls_update_hash(arg_context: [*c]struct_TLSContext, arg_in: [*c]const u8, arg_len: c_uint, arg_direction: u8, arg_connection_status: u8) c_int {
    var context = arg_context;
    _ = &context;
    var in = arg_in;
    _ = &in;
    var len = arg_len;
    _ = &len;
    var direction = arg_direction;
    _ = &direction;
    var connection_status = arg_connection_status;
    _ = &connection_status;
    if (!(context != null)) return 0;
    if (context.*.dtls != 0) {
        _private_tls_update_handshake_list(context, in, len, direction, connection_status);
    }
    var hash: [*c]TLSHash = _private_tls_ensure_hash(context);
    _ = &hash;
    if ((((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65277))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
        if (!(hash.*.created != 0)) {
            _private_tls_create_hash(context);
            if (((!(context.*.is_server != 0) and !(context.*.cached_handshake != null)) and !(context.*.request_client_certificate != 0)) and (len != 0)) {
                context.*.cached_handshake = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, len)))))));
                if (context.*.cached_handshake != null) {
                    _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.cached_handshake)), @as(?*const anyopaque, @ptrCast(in)), @as(c_ulong, @bitCast(@as(c_ulong, len))));
                    context.*.cached_handshake_len = len;
                }
            }
        }
        var hash_size: c_int = @as(c_int, @bitCast(_private_tls_mac_length(context)));
        _ = &hash_size;
        _ = sha256_process(&hash.*.hash32, in, @as(c_ulong, @bitCast(@as(c_ulong, len))));
        _ = sha512_process(&hash.*.hash48, in, @as(c_ulong, @bitCast(@as(c_ulong, len))));
        if (!(hash_size != 0)) {
            hash_size = 32;
        }
    } else {
        if (!(hash.*.created != 0)) {
            _private_tls_create_hash(context);
        }
        _ = md5_process(&hash.*.hash32, in, @as(c_ulong, @bitCast(@as(c_ulong, len))));
        _ = sha1_process(&hash.*.hash2, in, @as(c_ulong, @bitCast(@as(c_ulong, len))));
    }
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.request_client_certificate))) != 0) and (len != 0)) {
        var new_len: c_int = @as(c_int, @bitCast(context.*.cached_handshake_len +% len));
        _ = &new_len;
        context.*.cached_handshake = @as([*c]u8, @ptrCast(@alignCast(realloc(@as(?*anyopaque, @ptrCast(context.*.cached_handshake)), @as(c_ulong, @bitCast(@as(c_long, new_len)))))));
        if (context.*.cached_handshake != null) {
            _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.cached_handshake + context.*.cached_handshake_len)), @as(?*const anyopaque, @ptrCast(in)), @as(c_ulong, @bitCast(@as(c_ulong, len))));
            context.*.cached_handshake_len = @as(c_uint, @bitCast(new_len));
        } else {
            context.*.cached_handshake_len = 0;
        }
    }
    return 0;
}
pub export fn _private_tls_hmac_message(arg_local: u8, arg_context: [*c]struct_TLSContext, arg_buf: [*c]const u8, arg_buf_len: c_int, arg_buf2: [*c]const u8, arg_buf_len2: c_int, arg_out: [*c]u8, arg_outlen: c_uint, arg_remote_sequence_number: u64) c_uint {
    var local = arg_local;
    _ = &local;
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var buf2 = arg_buf2;
    _ = &buf2;
    var buf_len2 = arg_buf_len2;
    _ = &buf_len2;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var remote_sequence_number = arg_remote_sequence_number;
    _ = &remote_sequence_number;
    var hash: hmac_state = undefined;
    _ = &hash;
    var mac_size: c_int = @as(c_int, @bitCast(outlen));
    _ = &mac_size;
    var hash_idx: c_int = undefined;
    _ = &hash_idx;
    if (mac_size == @as(c_int, 20)) {
        hash_idx = find_hash("sha1");
    } else if (mac_size == @as(c_int, 48)) {
        hash_idx = find_hash("sha384");
    } else {
        hash_idx = find_hash("sha256");
    }
    if (hmac_init(&hash, hash_idx, if (@as(c_int, @bitCast(@as(c_uint, local))) != 0) @as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_mac))) else @as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_mac))), @as(c_ulong, @bitCast(@as(c_long, mac_size)))) != 0) return 0;
    var squence_number: u64 = undefined;
    _ = &squence_number;
    if (context.*.dtls != 0) {
        squence_number = if (@as(u32, @bitCast(@as(c_int, 1))) == htonl(@as(u32, @bitCast(@as(c_int, 1))))) remote_sequence_number else (@as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(remote_sequence_number & @as(u64, @bitCast(@as(c_ulong, @as(c_uint, 4294967295)))))))))))) << @intCast(32)) | @as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(remote_sequence_number >> @intCast(32)))))))));
    } else if (local != 0) {
        squence_number = if (@as(u32, @bitCast(@as(c_int, 1))) == htonl(@as(u32, @bitCast(@as(c_int, 1))))) context.*.local_sequence_number else (@as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(context.*.local_sequence_number & @as(u64, @bitCast(@as(c_ulong, @as(c_uint, 4294967295)))))))))))) << @intCast(32)) | @as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(context.*.local_sequence_number >> @intCast(32)))))))));
    } else {
        squence_number = if (@as(u32, @bitCast(@as(c_int, 1))) == htonl(@as(u32, @bitCast(@as(c_int, 1))))) context.*.remote_sequence_number else (@as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(context.*.remote_sequence_number & @as(u64, @bitCast(@as(c_ulong, @as(c_uint, 4294967295)))))))))))) << @intCast(32)) | @as(u64, @bitCast(@as(c_ulong, htonl(@as(u32, @bitCast(@as(c_uint, @truncate(context.*.remote_sequence_number >> @intCast(32)))))))));
    }
    if (hmac_process(&hash, @as([*c]u8, @ptrCast(@alignCast(&squence_number))), @sizeOf(u64)) != 0) return 0;
    if (hmac_process(&hash, buf, @as(c_ulong, @bitCast(@as(c_long, buf_len)))) != 0) return 0;
    if ((buf2 != null) and (buf_len2 != 0)) {
        if (hmac_process(&hash, buf2, @as(c_ulong, @bitCast(@as(c_long, buf_len2)))) != 0) return 0;
    }
    var ref_outlen: c_ulong = @as(c_ulong, @bitCast(@as(c_ulong, outlen)));
    _ = &ref_outlen;
    if (hmac_done(&hash, out, &ref_outlen) != 0) return 0;
    return @as(c_uint, @bitCast(@as(c_uint, @truncate(ref_outlen))));
}
pub export fn _private_tls_crypto_create(arg_context: [*c]struct_TLSContext, arg_key_length: c_int, arg_localkey: [*c]u8, arg_localiv: [*c]u8, arg_remotekey: [*c]u8, arg_remoteiv: [*c]u8) c_int {
    var context = arg_context;
    _ = &context;
    var key_length = arg_key_length;
    _ = &key_length;
    var localkey = arg_localkey;
    _ = &localkey;
    var localiv = arg_localiv;
    _ = &localiv;
    var remotekey = arg_remotekey;
    _ = &remotekey;
    var remoteiv = arg_remoteiv;
    _ = &remoteiv;
    if (context.*.crypto.created != 0) {
        if (@as(c_int, @bitCast(@as(c_uint, context.*.crypto.created))) == @as(c_int, 1)) {
            _ = cbc_done(&context.*.crypto.ctx_remote.aes_remote);
            _ = cbc_done(&context.*.crypto.ctx_local.aes_local);
        } else {
            if (@as(c_int, @bitCast(@as(c_uint, context.*.crypto.created))) == @as(c_int, 2)) {
                var dummy_buffer: [32]u8 = undefined;
                _ = &dummy_buffer;
                var tag_len: c_ulong = 0;
                _ = &tag_len;
                _ = gcm_done(&context.*.crypto.ctx_remote.aes_gcm_remote, @as([*c]u8, @ptrCast(@alignCast(&dummy_buffer))), &tag_len);
                _ = gcm_done(&context.*.crypto.ctx_local.aes_gcm_local, @as([*c]u8, @ptrCast(@alignCast(&dummy_buffer))), &tag_len);
            }
        }
        context.*.crypto.created = 0;
    }
    tls_init();
    var is_aead: c_int = _private_tls_is_aead(context);
    _ = &is_aead;
    var cipherID: c_int = find_cipher("aes");
    _ = &cipherID;
    if (is_aead == @as(c_int, 2)) {
        var counter: c_uint = 1;
        _ = &counter;
        chacha_keysetup(&context.*.crypto.ctx_local.chacha_local, localkey, @as(c_uint, @bitCast(key_length * @as(c_int, 8))));
        chacha_ivsetup_96bitnonce(&context.*.crypto.ctx_local.chacha_local, localiv, @as([*c]u8, @ptrCast(@alignCast(&counter))));
        chacha_keysetup(&context.*.crypto.ctx_remote.chacha_remote, remotekey, @as(c_uint, @bitCast(key_length * @as(c_int, 8))));
        chacha_ivsetup_96bitnonce(&context.*.crypto.ctx_remote.chacha_remote, remoteiv, @as([*c]u8, @ptrCast(@alignCast(&counter))));
        context.*.crypto.created = 3;
    } else if (is_aead != 0) {
        var res1: c_int = gcm_init(&context.*.crypto.ctx_local.aes_gcm_local, cipherID, localkey, key_length);
        _ = &res1;
        var res2: c_int = gcm_init(&context.*.crypto.ctx_remote.aes_gcm_remote, cipherID, remotekey, key_length);
        _ = &res2;
        if ((res1 != 0) or (res2 != 0)) return -@as(c_int, 1);
        context.*.crypto.created = 2;
    } else {
        var res1: c_int = cbc_start(cipherID, localiv, localkey, key_length, @as(c_int, 0), &context.*.crypto.ctx_local.aes_local);
        _ = &res1;
        var res2: c_int = cbc_start(cipherID, remoteiv, remotekey, key_length, @as(c_int, 0), &context.*.crypto.ctx_remote.aes_remote);
        _ = &res2;
        if ((res1 != 0) or (res2 != 0)) return -@as(c_int, 1);
        context.*.crypto.created = 1;
    }
    return 0;
}
pub export fn _private_tls_get_hash(arg_context: [*c]struct_TLSContext, arg_hout: [*c]u8) c_int {
    var context = arg_context;
    _ = &context;
    var hout = arg_hout;
    _ = &hout;
    if (!(context != null)) return 0;
    var hash: [*c]TLSHash = _private_tls_ensure_hash(context);
    _ = &hash;
    if (!(hash.*.created != 0)) return 0;
    var hash_size: c_int = 0;
    _ = &hash_size;
    if ((((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65277))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
        hash_size = @as(c_int, @bitCast(_private_tls_mac_length(context)));
        var prec: hash_state = undefined;
        _ = &prec;
        if (hash_size == @as(c_int, 48)) {
            _ = memcpy(@as(?*anyopaque, @ptrCast(&prec)), @as(?*const anyopaque, @ptrCast(&hash.*.hash48)), @sizeOf(hash_state));
            _ = sha384_done(&hash.*.hash48, hout);
            _ = memcpy(@as(?*anyopaque, @ptrCast(&hash.*.hash48)), @as(?*const anyopaque, @ptrCast(&prec)), @sizeOf(hash_state));
        } else {
            _ = memcpy(@as(?*anyopaque, @ptrCast(&prec)), @as(?*const anyopaque, @ptrCast(&hash.*.hash32)), @sizeOf(hash_state));
            hash_size = 32;
            _ = sha256_done(&hash.*.hash32, hout);
            _ = memcpy(@as(?*anyopaque, @ptrCast(&hash.*.hash32)), @as(?*const anyopaque, @ptrCast(&prec)), @sizeOf(hash_state));
        }
    } else {
        var prec: hash_state = undefined;
        _ = &prec;
        _ = memcpy(@as(?*anyopaque, @ptrCast(&prec)), @as(?*const anyopaque, @ptrCast(&hash.*.hash32)), @sizeOf(hash_state));
        _ = md5_done(&hash.*.hash32, hout);
        _ = memcpy(@as(?*anyopaque, @ptrCast(&hash.*.hash32)), @as(?*const anyopaque, @ptrCast(&prec)), @sizeOf(hash_state));
        _ = memcpy(@as(?*anyopaque, @ptrCast(&prec)), @as(?*const anyopaque, @ptrCast(&hash.*.hash2)), @sizeOf(hash_state));
        _ = sha1_done(&hash.*.hash2, hout + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))));
        _ = memcpy(@as(?*anyopaque, @ptrCast(&hash.*.hash2)), @as(?*const anyopaque, @ptrCast(&prec)), @sizeOf(hash_state));
        hash_size = 36;
    }
    return hash_size;
}
pub export fn _private_tls_done_hash(arg_context: [*c]struct_TLSContext, arg_hout: [*c]u8) c_int {
    var context = arg_context;
    _ = &context;
    var hout = arg_hout;
    _ = &hout;
    if (!(context != null)) return 0;
    var hash: [*c]TLSHash = _private_tls_ensure_hash(context);
    _ = &hash;
    if (!(hash.*.created != 0)) return 0;
    var hash_size: c_int = 0;
    _ = &hash_size;
    if ((((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65277))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
        var temp: [48]u8 = undefined;
        _ = &temp;
        if (!(hout != null)) {
            hout = @as([*c]u8, @ptrCast(@alignCast(&temp)));
        }
        hash_size = @as(c_int, @bitCast(_private_tls_mac_length(context)));
        if (hash_size == @as(c_int, 48)) {
            _ = sha256_done(&hash.*.hash32, @as([*c]u8, @ptrCast(@alignCast(&temp))));
            _ = sha384_done(&hash.*.hash48, hout);
        } else {
            _ = sha256_done(&hash.*.hash32, hout);
            _ = sha384_done(&hash.*.hash48, @as([*c]u8, @ptrCast(@alignCast(&temp))));
            hash_size = 32;
        }
    } else {
        var temp: [36]u8 = undefined;
        _ = &temp;
        if (!(hout != null)) {
            hout = @as([*c]u8, @ptrCast(@alignCast(&temp)));
        }
        _ = md5_done(&hash.*.hash32, hout);
        _ = sha1_done(&hash.*.hash2, hout + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))));
        hash_size = 36;
    }
    hash.*.created = 0;
    if (context.*.cached_handshake != null) {
        if (context.*.cached_handshake != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.cached_handshake)));
        }
        context.*.cached_handshake = null;
        context.*.cached_handshake_len = 0;
    }
    return hash_size;
}
pub export fn _private_tls_get_hash_idx(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    if (!(context != null)) return -@as(c_int, 1);
    while (true) {
        switch (_private_tls_mac_length(context)) {
            @as(c_uint, @bitCast(@as(c_int, 32))) => return find_hash("sha256"),
            @as(c_uint, @bitCast(@as(c_int, 48))) => return find_hash("sha384"),
            @as(c_uint, @bitCast(@as(c_int, 20))) => return find_hash("sha1"),
            else => {},
        }
        break;
    }
    return -@as(c_int, 1);
}
pub export fn _private_tls_build_random(arg_packet: [*c]struct_TLSPacket) c_int {
    var packet = arg_packet;
    _ = &packet;
    var res: c_int = 0;
    _ = &res;
    var rand_bytes: [48]u8 = undefined;
    _ = &rand_bytes;
    var bytes: c_int = 48;
    _ = &bytes;
    if (!(tls_random(@as([*c]u8, @ptrCast(@alignCast(&rand_bytes))), bytes) != 0)) return -@as(c_int, 1);
    if (packet.*.context.*.is_server != 0) {
        @as([*c]c_ushort, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&rand_bytes)))))).* = htons(packet.*.context.*.version);
    } else if (packet.*.context.*.dtls != 0) {
        @as([*c]c_ushort, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&rand_bytes)))))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(@as(c_int, 65277))))));
    } else {
        @as([*c]c_ushort, @ptrCast(@alignCast(@as([*c]u8, @ptrCast(@alignCast(&rand_bytes)))))).* = htons(@as(u16, @bitCast(@as(c_short, @truncate(@as(c_int, 771))))));
    }
    if (packet.*.context.*.premaster_key != null) {
        free(@as(?*anyopaque, @ptrCast(packet.*.context.*.premaster_key)));
    }
    packet.*.context.*.premaster_key = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, bytes)))))));
    if (!(packet.*.context.*.premaster_key != null)) return -@as(c_int, 9);
    packet.*.context.*.premaster_key_len = @as(c_uint, @bitCast(bytes));
    _ = memcpy(@as(?*anyopaque, @ptrCast(packet.*.context.*.premaster_key)), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&rand_bytes))))), @as(c_ulong, @bitCast(@as(c_ulong, packet.*.context.*.premaster_key_len))));
    var out_len: c_uint = undefined;
    _ = &out_len;
    var random_1: [*c]u8 = _private_tls_encrypt_rsa(packet.*.context, packet.*.context.*.premaster_key, packet.*.context.*.premaster_key_len, &out_len);
    _ = &random_1;
    _ = _private_tls_compute_key(packet.*.context, @as(c_uint, @bitCast(bytes)));
    if ((random_1 != null) and (out_len > @as(c_uint, @bitCast(@as(c_int, 2))))) {
        _ = tls_packet_uint24(packet, out_len +% @as(c_uint, @bitCast(@as(c_int, 2))));
        if (packet.*.context.*.dtls != 0) {
            _private_dtls_handshake_data(packet.*.context, packet, out_len +% @as(c_uint, @bitCast(@as(c_int, 2))));
        }
        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_ushort, @truncate(out_len)))));
        _ = tls_packet_append(packet, random_1, out_len);
    } else {
        res = -@as(c_int, 1);
    }
    if (random_1 != null) {
        free(@as(?*anyopaque, @ptrCast(random_1)));
    }
    if (res != 0) return res;
    return @as(c_int, @bitCast(out_len +% @as(c_uint, @bitCast(@as(c_int, 2)))));
}
pub export fn _private_tls_mac_length(arg_context: [*c]struct_TLSContext) c_uint {
    var context = arg_context;
    _ = &context;
    while (true) {
        switch (@as(c_int, @bitCast(@as(c_uint, context.*.cipher)))) {
            @as(c_int, 47), @as(c_int, 53), @as(c_int, 51), @as(c_int, 57), @as(c_int, 49171), @as(c_int, 49172), @as(c_int, 49161), @as(c_int, 49162) => return 20,
            @as(c_int, 60), @as(c_int, 61), @as(c_int, 156), @as(c_int, 103), @as(c_int, 107), @as(c_int, 158), @as(c_int, 49191), @as(c_int, 49199), @as(c_int, 49187), @as(c_int, 49195), @as(c_int, 52392), @as(c_int, 52393), @as(c_int, 52394), @as(c_int, 4865), @as(c_int, 4867), @as(c_int, 4868), @as(c_int, 4869) => return 32,
            @as(c_int, 157), @as(c_int, 159), @as(c_int, 49200), @as(c_int, 49188), @as(c_int, 49196), @as(c_int, 4866) => return 48,
            else => {},
        }
        break;
    }
    return 0;
}
pub export fn _private_dtls_handshake_data(arg_context: [*c]struct_TLSContext, arg_packet: [*c]struct_TLSPacket, arg_framelength: c_uint) void {
    var context = arg_context;
    _ = &context;
    var packet = arg_packet;
    _ = &packet;
    var framelength = arg_framelength;
    _ = &framelength;
    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_ushort, context.*.dtls_seq))));
    _ = tls_packet_uint24(packet, @as(c_uint, @bitCast(@as(c_int, 0))));
    _ = tls_packet_uint24(packet, framelength);
}
pub export fn _private_tls_dhe_free(arg_context: [*c]struct_TLSContext) void {
    var context = arg_context;
    _ = &context;
    if (context.*.dhe != null) {
        _private_tls_dh_clear_key(context.*.dhe);
        if (context.*.dhe != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.dhe)));
        }
        context.*.dhe = null;
    }
}
pub export fn _private_tls_ecc_dhe_free(arg_context: [*c]struct_TLSContext) void {
    var context = arg_context;
    _ = &context;
    if (context.*.ecc_dhe != null) {
        ecc_free(context.*.ecc_dhe);
        if (context.*.ecc_dhe != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.ecc_dhe)));
        }
        context.*.ecc_dhe = null;
    }
}
pub export fn _private_tls_dh_clear_key(arg_key: [*c]DHKey) void {
    var key = arg_key;
    _ = &key;
    ltc_deinit_multi(key.*.g, key.*.p, key.*.x, key.*.y, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
    key.*.g = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
    key.*.p = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
    key.*.x = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
    key.*.y = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
}
pub export fn tls_build_encrypted_extensions(arg_context: [*c]struct_TLSContext) [*c]struct_TLSPacket {
    var context = arg_context;
    _ = &context;
    var packet: [*c]struct_TLSPacket = tls_create_packet(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 22))))), context.*.version, @as(c_int, 3));
    _ = &packet;
    _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 8))))));
    if (context.*.negotiated_alpn != null) {
        var alpn_negotiated_len: c_int = @as(c_int, @bitCast(@as(c_uint, @truncate(strlen(context.*.negotiated_alpn)))));
        _ = &alpn_negotiated_len;
        var alpn_len: c_int = alpn_negotiated_len + @as(c_int, 1);
        _ = &alpn_len;
        _ = tls_packet_uint24(packet, @as(c_uint, @bitCast(alpn_len + @as(c_int, 8))));
        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(alpn_len + @as(c_int, 6))))));
        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 16))))));
        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(alpn_len + @as(c_int, 2))))));
        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(alpn_len)))));
        _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(alpn_negotiated_len)))));
        _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(context.*.negotiated_alpn))), @as(c_uint, @bitCast(alpn_negotiated_len)));
    } else {
        _ = tls_packet_uint24(packet, @as(c_uint, @bitCast(@as(c_int, 2))));
        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 0))))));
    }
    tls_packet_update(packet);
    return packet;
}
pub export fn tls_build_certificate_verify(arg_context: [*c]struct_TLSContext) [*c]struct_TLSPacket {
    var context = arg_context;
    _ = &context;
    var packet: [*c]struct_TLSPacket = tls_create_packet(context, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 22))))), context.*.version, @as(c_int, 0));
    _ = &packet;
    _ = tls_packet_uint8(packet, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 15))))));
    var size_offset: c_uint = packet.*.len;
    _ = &size_offset;
    _ = tls_packet_uint24(packet, @as(c_uint, @bitCast(@as(c_int, 0))));
    var out: [2048]u8 = undefined;
    _ = &out;
    var out_len: c_ulong = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2048))));
    _ = &out_len;
    var signing_data: [146]u8 = undefined;
    _ = &signing_data;
    var signing_data_len: c_int = undefined;
    _ = &signing_data_len;
    _ = memset(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&signing_data))))), @as(c_int, 32), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 64)))));
    if (context.*.is_server != 0) {
        _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&signing_data))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 64))))))), @as(?*const anyopaque, @ptrCast("TLS 1.3, server CertificateVerify")), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 33)))));
    } else {
        _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&signing_data))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 64))))))), @as(?*const anyopaque, @ptrCast("TLS 1.3, client CertificateVerify")), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 33)))));
    }
    signing_data[@as(c_uint, @intCast(@as(c_int, 97)))] = 0;
    signing_data_len = 98;
    signing_data_len += _private_tls_get_hash(context, @as([*c]u8, @ptrCast(@alignCast(&signing_data))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 98))))));
    var hash_algorithm: c_int = sha256;
    _ = &hash_algorithm;
    if (tls_is_ecdsa(context) != 0) {
        while (true) {
            switch (context.*.ec_private_key.*.ec_algorithm) {
                @as(c_uint, @bitCast(@as(c_int, 23))) => {
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 1027))))));
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 24))) => {
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 1283))))));
                    hash_algorithm = sha384;
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 25))) => {
                    _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 1539))))));
                    hash_algorithm = sha512;
                    break;
                },
                else => {
                    {}
                    packet.*.broken = 1;
                    return packet;
                },
            }
            break;
        }
    } else {
        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, 2052))))));
    }
    var packet_size: c_int = 2;
    _ = &packet_size;
    if (tls_is_ecdsa(context) != 0) {
        if (_private_tls_sign_ecdsa(context, @as(c_uint, @bitCast(hash_algorithm)), @as([*c]u8, @ptrCast(@alignCast(&signing_data))), @as(c_uint, @bitCast(signing_data_len)), @as([*c]u8, @ptrCast(@alignCast(&out))), &out_len) == @as(c_int, 1)) {
            _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_ushort, @truncate(out_len)))));
            _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&out))), @as(c_uint, @bitCast(@as(c_uint, @truncate(out_len)))));
            packet_size += @as(c_int, @bitCast(@as(c_uint, @truncate(out_len +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))))));
        }
    } else if (_private_tls_sign_rsa(context, @as(c_uint, @bitCast(hash_algorithm)), @as([*c]u8, @ptrCast(@alignCast(&signing_data))), @as(c_uint, @bitCast(signing_data_len)), @as([*c]u8, @ptrCast(@alignCast(&out))), &out_len) == @as(c_int, 1)) {
        _ = tls_packet_uint16(packet, @as(c_ushort, @bitCast(@as(c_ushort, @truncate(out_len)))));
        _ = tls_packet_append(packet, @as([*c]u8, @ptrCast(@alignCast(&out))), @as(c_uint, @bitCast(@as(c_uint, @truncate(out_len)))));
        packet_size += @as(c_int, @bitCast(@as(c_uint, @truncate(out_len +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))))));
    }
    packet.*.buf[size_offset] = @as(u8, @bitCast(@as(i8, @truncate(@divTrunc(packet_size, @as(c_int, 65536))))));
    packet_size = @import("std").zig.c_translation.signedRemainder(packet_size, @as(c_int, 65536));
    packet.*.buf[size_offset +% @as(c_uint, @bitCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(i8, @truncate(@divTrunc(packet_size, @as(c_int, 256))))));
    packet_size = @import("std").zig.c_translation.signedRemainder(packet_size, @as(c_int, 256));
    packet.*.buf[size_offset +% @as(c_uint, @bitCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(i8, @truncate(packet_size))));
    tls_packet_update(packet);
    return packet;
}
pub var dtls_secret: [32]u8 = @import("std").mem.zeroes([32]u8);
pub var dependecies_loaded: u8 = 0;
pub const cd64: [80:0]u8 = "|$$$}rstuvwxyz{$$$$$$$>?@ABCDEFGHIJKLMNOPQRSTUVW$$$$$$XYZ[\\]^_`abcdefghijklmnopq".*;
pub export fn _private_b64_decodeblock(arg_in: [*c]u8, arg_out: [*c]u8) void {
    var in = arg_in;
    _ = &in;
    var out = arg_out;
    _ = &out;
    out[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(i8, @truncate((@as(c_int, @bitCast(@as(c_uint, in[@as(c_uint, @intCast(@as(c_int, 0)))]))) << @intCast(2)) | (@as(c_int, @bitCast(@as(c_uint, in[@as(c_uint, @intCast(@as(c_int, 1)))]))) >> @intCast(4))))));
    out[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(i8, @truncate((@as(c_int, @bitCast(@as(c_uint, in[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(4)) | (@as(c_int, @bitCast(@as(c_uint, in[@as(c_uint, @intCast(@as(c_int, 2)))]))) >> @intCast(2))))));
    out[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(i8, @truncate(((@as(c_int, @bitCast(@as(c_uint, in[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(6)) & @as(c_int, 192)) | @as(c_int, @bitCast(@as(c_uint, in[@as(c_uint, @intCast(@as(c_int, 3)))])))))));
}
pub export fn _private_b64_decode(arg_in_buffer: [*c]const u8, arg_in_buffer_size: c_int, arg_out_buffer: [*c]u8) c_int {
    var in_buffer = arg_in_buffer;
    _ = &in_buffer;
    var in_buffer_size = arg_in_buffer_size;
    _ = &in_buffer_size;
    var out_buffer = arg_out_buffer;
    _ = &out_buffer;
    var in: [4]u8 = undefined;
    _ = &in;
    var out: [3]u8 = undefined;
    _ = &out;
    var v: u8 = undefined;
    _ = &v;
    var i: c_int = undefined;
    _ = &i;
    var len: c_int = undefined;
    _ = &len;
    var ptr: [*c]const u8 = in_buffer;
    _ = &ptr;
    var out_ptr: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(out_buffer)));
    _ = &out_ptr;
    while (ptr <= (in_buffer + @as(usize, @bitCast(@as(isize, @intCast(in_buffer_size)))))) {
        {
            _ = blk: {
                len = 0;
                break :blk blk_1: {
                    const tmp = @as(c_int, 0);
                    i = tmp;
                    break :blk_1 tmp;
                };
            };
            while ((i < @as(c_int, 4)) and (ptr <= (in_buffer + @as(usize, @bitCast(@as(isize, @intCast(in_buffer_size))))))) : (i += 1) {
                v = 0;
                while ((ptr <= (in_buffer + @as(usize, @bitCast(@as(isize, @intCast(in_buffer_size)))))) and (@as(c_int, @bitCast(@as(c_uint, v))) == @as(c_int, 0))) {
                    v = @as(u8, @bitCast(ptr[@as(c_uint, @intCast(@as(c_int, 0)))]));
                    ptr += 1;
                    v = @as(u8, @bitCast(@as(i8, @truncate(if ((@as(c_int, @bitCast(@as(c_uint, v))) < @as(c_int, 43)) or (@as(c_int, @bitCast(@as(c_uint, v))) > @as(c_int, 122))) @as(c_int, 0) else @as(c_int, @bitCast(@as(c_uint, cd64[@as(c_uint, @intCast(@as(c_int, @bitCast(@as(c_uint, v))) - @as(c_int, 43)))])))))));
                    if (v != 0) {
                        v = @as(u8, @bitCast(@as(i8, @truncate(if (@as(c_int, @bitCast(@as(c_uint, v))) == @as(c_int, '$')) @as(c_int, 0) else @as(c_int, @bitCast(@as(c_uint, v))) - @as(c_int, 61)))));
                    }
                }
                if (ptr <= (in_buffer + @as(usize, @bitCast(@as(isize, @intCast(in_buffer_size)))))) {
                    len += 1;
                    if (v != 0) {
                        in[@as(c_uint, @intCast(i))] = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, v))) - @as(c_int, 1)))));
                    }
                } else {
                    in[@as(c_uint, @intCast(i))] = 0;
                }
            }
        }
        if (len != 0) {
            _private_b64_decodeblock(@as([*c]u8, @ptrCast(@alignCast(&in))), @as([*c]u8, @ptrCast(@alignCast(&out))));
            {
                i = 0;
                while (i < (len - @as(c_int, 1))) : (i += 1) {
                    out_ptr[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(out[@as(c_uint, @intCast(i))]));
                    out_ptr += 1;
                }
            }
        }
    }
    return @as(c_int, @bitCast(@as(c_int, @truncate(@as(isize, @intCast(@intFromPtr(out_ptr))) - @as(isize, @intCast(@intFromPtr(out_buffer)))))));
}
pub export fn _private_tls_dh_shared_secret(arg_private_key: [*c]DHKey, arg_public_key: [*c]DHKey, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var private_key = arg_private_key;
    _ = &private_key;
    var public_key = arg_public_key;
    _ = &public_key;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var tmp: ?*anyopaque = undefined;
    _ = &tmp;
    var x: c_ulong = undefined;
    _ = &x;
    var err: c_int = undefined;
    _ = &err;
    if (((!(private_key != null) or !(public_key != null)) or !(out != null)) or !(outlen != null)) return -@as(c_int, 1);
    if ((blk: {
        const tmp_1 = ltc_mp.init.?(&tmp);
        err = tmp_1;
        break :blk tmp_1;
    }) != CRYPT_OK) return err;
    if ((blk: {
        const tmp_1 = ltc_mp.exptmod.?(public_key.*.y, private_key.*.x, private_key.*.p, tmp);
        err = tmp_1;
        break :blk tmp_1;
    }) != CRYPT_OK) {
        ltc_mp.deinit.?(tmp);
        return err;
    }
    x = ltc_mp.unsigned_size.?(tmp);
    if (outlen.* < x) {
        err = CRYPT_BUFFER_OVERFLOW;
        ltc_mp.deinit.?(tmp);
        return err;
    }
    if ((blk: {
        const tmp_1 = ltc_mp.unsigned_write.?(tmp, out);
        err = tmp_1;
        break :blk tmp_1;
    }) != CRYPT_OK) {
        ltc_mp.deinit.?(tmp);
        return err;
    }
    outlen.* = x;
    ltc_mp.deinit.?(tmp);
    return 0;
}
pub export fn _private_tls_decrypt_dhe(arg_context: [*c]struct_TLSContext, arg_buffer: [*c]const u8, arg_len: c_uint, arg_size: [*c]c_uint, arg_clear_key: c_int) [*c]u8 {
    var context = arg_context;
    _ = &context;
    var buffer = arg_buffer;
    _ = &buffer;
    var len = arg_len;
    _ = &len;
    var size = arg_size;
    _ = &size;
    var clear_key = arg_clear_key;
    _ = &clear_key;
    size.* = 0;
    if ((!(len != 0) or !(context != null)) or !(context.*.dhe != null)) {
        return null;
    }
    var out_size: c_ulong = @as(c_ulong, @bitCast(@as(c_ulong, len)));
    _ = &out_size;
    var Yc: ?*anyopaque = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
    _ = &Yc;
    if (ltc_mp.init.?(&Yc) != 0) {
        return null;
    }
    if (ltc_mp.unsigned_read.?(Yc, @as([*c]u8, @ptrCast(@volatileCast(@constCast(buffer)))), @as(c_ulong, @bitCast(@as(c_ulong, len)))) != 0) {
        ltc_mp.deinit.?(Yc);
        return null;
    }
    var out: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, len)))))));
    _ = &out;
    var client_key: DHKey = undefined;
    _ = &client_key;
    _ = memset(@as(?*anyopaque, @ptrCast(&client_key)), @as(c_int, 0), @sizeOf(DHKey));
    client_key.p = context.*.dhe.*.p;
    client_key.g = context.*.dhe.*.g;
    client_key.y = Yc;
    var err: c_int = _private_tls_dh_shared_secret(context.*.dhe, &client_key, out, &out_size);
    _ = &err;
    client_key.p = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
    client_key.g = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
    _private_tls_dh_clear_key(&client_key);
    if (clear_key != 0) {
        _private_tls_dhe_free(context);
    }
    if (err != 0) {
        if (out != null) {
            free(@as(?*anyopaque, @ptrCast(out)));
        }
        return null;
    }
    size.* = @as(c_uint, @bitCast(@as(c_uint, @truncate(out_size))));
    return out;
}
pub export fn _private_tls_decrypt_ecc_dhe(arg_context: [*c]struct_TLSContext, arg_buffer: [*c]const u8, arg_len: c_uint, arg_size: [*c]c_uint, arg_clear_key: c_int) [*c]u8 {
    var context = arg_context;
    _ = &context;
    var buffer = arg_buffer;
    _ = &buffer;
    var len = arg_len;
    _ = &len;
    var size = arg_size;
    _ = &size;
    var clear_key = arg_clear_key;
    _ = &clear_key;
    size.* = 0;
    if ((!(len != 0) or !(context != null)) or !(context.*.ecc_dhe != null)) {
        return null;
    }
    var curve: [*c]const struct_ECCCurveParameters = undefined;
    _ = &curve;
    if (context.*.curve != null) {
        curve = context.*.curve;
    } else {
        curve = default_curve;
    }
    var dp: [*c]const ltc_ecc_set_type = &curve.*.dp;
    _ = &dp;
    var client_key: ecc_key = undefined;
    _ = &client_key;
    _ = memset(@as(?*anyopaque, @ptrCast(&client_key)), @as(c_int, 0), @sizeOf(ecc_key));
    if (ecc_ansi_x963_import_ex(buffer, @as(c_ulong, @bitCast(@as(c_ulong, len))), &client_key, dp) != 0) {
        return null;
    }
    var out: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, len)))))));
    _ = &out;
    var out_size: c_ulong = @as(c_ulong, @bitCast(@as(c_ulong, len)));
    _ = &out_size;
    var err: c_int = ecc_shared_secret(context.*.ecc_dhe, &client_key, out, &out_size);
    _ = &err;
    ecc_free(&client_key);
    if (clear_key != 0) {
        _private_tls_ecc_dhe_free(context);
    }
    if (err != 0) {
        if (out != null) {
            free(@as(?*anyopaque, @ptrCast(out)));
        }
        return null;
    }
    size.* = @as(c_uint, @bitCast(@as(c_uint, @truncate(out_size))));
    return out;
}
pub export fn _private_tls_decrypt_rsa(arg_context: [*c]struct_TLSContext, arg_buffer: [*c]const u8, arg_len: c_uint, arg_size: [*c]c_uint) [*c]u8 {
    var context = arg_context;
    _ = &context;
    var buffer = arg_buffer;
    _ = &buffer;
    var len = arg_len;
    _ = &len;
    var size = arg_size;
    _ = &size;
    size.* = 0;
    if ((((!(len != 0) or !(context != null)) or !(context.*.private_key != null)) or !(context.*.private_key.*.der_bytes != null)) or !(context.*.private_key.*.der_len != 0)) {
        return null;
    }
    tls_init();
    var key: rsa_key = undefined;
    _ = &key;
    var err: c_int = undefined;
    _ = &err;
    err = rsa_import(context.*.private_key.*.der_bytes, @as(c_ulong, @bitCast(@as(c_ulong, context.*.private_key.*.der_len))), &key);
    if (err != 0) {
        return null;
    }
    var out: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, len)))))));
    _ = &out;
    var out_size: c_ulong = @as(c_ulong, @bitCast(@as(c_ulong, len)));
    _ = &out_size;
    var res: c_int = 0;
    _ = &res;
    err = rsa_decrypt_key_ex(buffer, @as(c_ulong, @bitCast(@as(c_ulong, len))), out, &out_size, null, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0)))), -@as(c_int, 1), LTC_LTC_PKCS_1_V1_5, &res, &key);
    rsa_free(&key);
    if (((err != 0) or (out_size != @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 48)))))) or (@as(c_int, @bitCast(@as(c_uint, ntohs(@as([*c]c_ushort, @ptrCast(@alignCast(out))).*)))) != @as(c_int, @bitCast(@as(c_uint, context.*.version))))) {
        out_size = 48;
        _ = tls_random(out, @as(c_int, @bitCast(@as(c_uint, @truncate(out_size)))));
        @as([*c]c_ushort, @ptrCast(@alignCast(out))).* = htons(context.*.version);
    }
    size.* = @as(c_uint, @bitCast(@as(c_uint, @truncate(out_size))));
    return out;
}
pub export fn _private_tls_encrypt_rsa(arg_context: [*c]struct_TLSContext, arg_buffer: [*c]const u8, arg_len: c_uint, arg_size: [*c]c_uint) [*c]u8 {
    var context = arg_context;
    _ = &context;
    var buffer = arg_buffer;
    _ = &buffer;
    var len = arg_len;
    _ = &len;
    var size = arg_size;
    _ = &size;
    size.* = 0;
    if ((((((!(len != 0) or !(context != null)) or !(context.*.certificates != null)) or !(context.*.certificates_count != 0)) or !(context.*.certificates[@as(c_uint, @intCast(@as(c_int, 0)))] != null)) or !(context.*.certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.der_bytes != null)) or !(context.*.certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.der_len != 0)) {
        return null;
    }
    tls_init();
    var key: rsa_key = undefined;
    _ = &key;
    var err: c_int = undefined;
    _ = &err;
    err = rsa_import(context.*.certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.der_bytes, @as(c_ulong, @bitCast(@as(c_ulong, context.*.certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.der_len))), &key);
    if (err != 0) {
        return null;
    }
    var out_size: c_ulong = @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2048))));
    _ = &out_size;
    var out: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(malloc(out_size))));
    _ = &out;
    var hash_idx: c_int = find_hash("sha256");
    _ = &hash_idx;
    var prng_idx: c_int = find_prng("sprng");
    _ = &prng_idx;
    err = rsa_encrypt_key_ex(buffer, @as(c_ulong, @bitCast(@as(c_ulong, len))), out, &out_size, @as([*c]u8, @ptrCast(@alignCast("Concept"))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 7)))), null, prng_idx, hash_idx, LTC_LTC_PKCS_1_V1_5, &key);
    rsa_free(&key);
    if ((err != 0) or !(out_size != 0)) {
        if (out != null) {
            free(@as(?*anyopaque, @ptrCast(out)));
        }
        return null;
    }
    size.* = @as(c_uint, @bitCast(@as(c_uint, @truncate(out_size))));
    return out;
}
pub export fn _private_rsa_verify_hash_md5sha1(arg_sig: [*c]const u8, arg_siglen: c_ulong, arg_hash: [*c]u8, arg_hashlen: c_ulong, arg_stat: [*c]c_int, arg_key: [*c]rsa_key) c_int {
    var sig = arg_sig;
    _ = &sig;
    var siglen = arg_siglen;
    _ = &siglen;
    var hash = arg_hash;
    _ = &hash;
    var hashlen = arg_hashlen;
    _ = &hashlen;
    var stat = arg_stat;
    _ = &stat;
    var key = arg_key;
    _ = &key;
    var modulus_bitlen: c_ulong = undefined;
    _ = &modulus_bitlen;
    var modulus_bytelen: c_ulong = undefined;
    _ = &modulus_bytelen;
    var x: c_ulong = undefined;
    _ = &x;
    var err: c_int = undefined;
    _ = &err;
    var tmpbuf: [*c]u8 = null;
    _ = &tmpbuf;
    if ((((((hash == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) or (sig == @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) or (stat == @as([*c]c_int, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) or (key == @as([*c]rsa_key, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) or !(siglen != 0)) or !(hashlen != 0)) return -@as(c_int, 1);
    stat.* = 0;
    modulus_bitlen = @as(c_ulong, @bitCast(@as(c_long, ltc_mp.count_bits.?(key.*.N))));
    modulus_bytelen = ltc_mp.unsigned_size.?(key.*.N);
    if (modulus_bytelen != siglen) return -@as(c_int, 1);
    tmpbuf = @as([*c]u8, @ptrCast(@alignCast(malloc(siglen))));
    if (!(tmpbuf != null)) return -@as(c_int, 1);
    x = siglen;
    if ((blk: {
        const tmp = ltc_mp.rsa_me.?(sig, siglen, tmpbuf, &x, PK_PUBLIC, key);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        if (tmpbuf != null) {
            free(@as(?*anyopaque, @ptrCast(tmpbuf)));
        }
        return err;
    }
    if (x != siglen) {
        if (tmpbuf != null) {
            free(@as(?*anyopaque, @ptrCast(tmpbuf)));
        }
        return CRYPT_INVALID_PACKET;
    }
    var out_len: c_ulong = siglen;
    _ = &out_len;
    var out: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(malloc(siglen))));
    _ = &out;
    if (!(out != null)) {
        if (tmpbuf != null) {
            free(@as(?*anyopaque, @ptrCast(tmpbuf)));
        }
        return -@as(c_int, 1);
    }
    var decoded: c_int = 0;
    _ = &decoded;
    err = pkcs_1_v1_5_decode(tmpbuf, x, LTC_LTC_PKCS_1_EMSA, modulus_bitlen, out, &out_len, &decoded);
    if (decoded != 0) {
        if (out_len == hashlen) {
            if (!(memcmp(@as(?*const anyopaque, @ptrCast(out)), @as(?*const anyopaque, @ptrCast(hash)), hashlen) != 0)) {
                stat.* = 1;
            }
        }
    }
    if (tmpbuf != null) {
        free(@as(?*anyopaque, @ptrCast(tmpbuf)));
    }
    if (out != null) {
        free(@as(?*anyopaque, @ptrCast(out)));
    }
    return err;
}
pub export fn _private_tls_verify_rsa(arg_context: [*c]struct_TLSContext, arg_hash_type: c_uint, arg_buffer: [*c]const u8, arg_len: c_uint, arg_message: [*c]const u8, arg_message_len: c_uint) c_int {
    var context = arg_context;
    _ = &context;
    var hash_type = arg_hash_type;
    _ = &hash_type;
    var buffer = arg_buffer;
    _ = &buffer;
    var len = arg_len;
    _ = &len;
    var message = arg_message;
    _ = &message;
    var message_len = arg_message_len;
    _ = &message_len;
    tls_init();
    var key: rsa_key = undefined;
    _ = &key;
    var err: c_int = undefined;
    _ = &err;
    if (context.*.is_server != 0) {
        if (((((!(len != 0) or !(context.*.client_certificates != null)) or !(context.*.client_certificates_count != 0)) or !(context.*.client_certificates[@as(c_uint, @intCast(@as(c_int, 0)))] != null)) or !(context.*.client_certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.der_bytes != null)) or !(context.*.client_certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.der_len != 0)) {
            return -@as(c_int, 1);
        }
        err = rsa_import(context.*.client_certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.der_bytes, @as(c_ulong, @bitCast(@as(c_ulong, context.*.client_certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.der_len))), &key);
    } else {
        if (((((!(len != 0) or !(context.*.certificates != null)) or !(context.*.certificates_count != 0)) or !(context.*.certificates[@as(c_uint, @intCast(@as(c_int, 0)))] != null)) or !(context.*.certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.der_bytes != null)) or !(context.*.certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.der_len != 0)) {
            return -@as(c_int, 1);
        }
        err = rsa_import(context.*.certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.der_bytes, @as(c_ulong, @bitCast(@as(c_ulong, context.*.certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.der_len))), &key);
    }
    if (err != 0) {
        return -@as(c_int, 1);
    }
    var hash_idx: c_int = -@as(c_int, 1);
    _ = &hash_idx;
    var hash: [64]u8 = undefined;
    _ = &hash;
    var hash_len: c_uint = 0;
    _ = &hash_len;
    var state: hash_state = undefined;
    _ = &state;
    while (true) {
        switch (hash_type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                hash_idx = find_hash("md5");
                err = md5_init(&state);
                if (err != 0) break;
                err = md5_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = md5_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                hash_len = 16;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                hash_idx = find_hash("sha1");
                err = sha1_init(&state);
                if (err != 0) break;
                err = sha1_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha1_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                hash_len = 20;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 3))) => {
                hash_idx = find_hash("sha224");
                err = sha224_init(&state);
                if (err != 0) break;
                err = sha256_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha224_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                hash_len = 28;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 4))) => {
                hash_idx = find_hash("sha256");
                err = sha256_init(&state);
                if (err != 0) break;
                err = sha256_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha256_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                hash_len = 32;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 5))) => {
                hash_idx = find_hash("sha384");
                err = sha384_init(&state);
                if (err != 0) break;
                err = sha512_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha384_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                hash_len = 48;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 6))) => {
                hash_idx = find_hash("sha512");
                err = sha512_init(&state);
                if (err != 0) break;
                err = sha512_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha512_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                hash_len = 64;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 255))) => {
                hash_idx = find_hash("md5");
                err = md5_init(&state);
                if (err != 0) break;
                err = md5_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = md5_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                hash_idx = find_hash("sha1");
                err = sha1_init(&state);
                if (err != 0) break;
                err = sha1_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha1_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))));
                if (err != 0) break;
                hash_len = 36;
                err = sha1_init(&state);
                if (err != 0) break;
                err = sha1_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha1_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))));
                if (err != 0) break;
                hash_len = 36;
                break;
            },
            else => {},
        }
        break;
    }
    if ((hash_idx < @as(c_int, 0)) or (err != 0)) {
        return -@as(c_int, 1);
    }
    var rsa_stat: c_int = 0;
    _ = &rsa_stat;
    if (hash_type == @as(c_uint, @bitCast(_md5_sha1))) {
        err = _private_rsa_verify_hash_md5sha1(buffer, @as(c_ulong, @bitCast(@as(c_ulong, len))), @as([*c]u8, @ptrCast(@alignCast(&hash))), @as(c_ulong, @bitCast(@as(c_ulong, hash_len))), &rsa_stat, &key);
    } else if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
        err = rsa_verify_hash_ex(buffer, @as(c_ulong, @bitCast(@as(c_ulong, len))), @as([*c]u8, @ptrCast(@alignCast(&hash))), @as(c_ulong, @bitCast(@as(c_ulong, hash_len))), LTC_LTC_PKCS_1_PSS, hash_idx, @as(c_ulong, @bitCast(@as(c_ulong, hash_len))), &rsa_stat, &key);
    } else {
        err = rsa_verify_hash_ex(buffer, @as(c_ulong, @bitCast(@as(c_ulong, len))), @as([*c]u8, @ptrCast(@alignCast(&hash))), @as(c_ulong, @bitCast(@as(c_ulong, hash_len))), LTC_LTC_PKCS_1_V1_5, hash_idx, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0)))), &rsa_stat, &key);
    }
    rsa_free(&key);
    if (err != 0) return 0;
    return rsa_stat;
}
pub export fn _private_rsa_sign_hash_md5sha1(arg_in: [*c]const u8, arg_inlen: c_ulong, arg_out: [*c]u8, arg_outlen: [*c]c_ulong, arg_key: [*c]rsa_key) c_int {
    var in = arg_in;
    _ = &in;
    var inlen = arg_inlen;
    _ = &inlen;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    var key = arg_key;
    _ = &key;
    var modulus_bitlen: c_ulong = undefined;
    _ = &modulus_bitlen;
    var modulus_bytelen: c_ulong = undefined;
    _ = &modulus_bytelen;
    var x: c_ulong = undefined;
    _ = &x;
    var err: c_int = undefined;
    _ = &err;
    if ((((in == @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) or (out == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) or (outlen == @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) or (key == @as([*c]rsa_key, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) return -@as(c_int, 1);
    modulus_bitlen = @as(c_ulong, @bitCast(@as(c_long, ltc_mp.count_bits.?(key.*.N))));
    modulus_bytelen = ltc_mp.unsigned_size.?(key.*.N);
    if (modulus_bytelen > outlen.*) {
        outlen.* = modulus_bytelen;
        return CRYPT_BUFFER_OVERFLOW;
    }
    x = modulus_bytelen;
    err = pkcs_1_v1_5_encode(in, inlen, LTC_LTC_PKCS_1_EMSA, modulus_bitlen, null, @as(c_int, 0), out, &x);
    if (err != CRYPT_OK) return err;
    return ltc_mp.rsa_me.?(out, x, out, outlen, PK_PRIVATE, key);
}
pub export fn _private_tls_sign_rsa(arg_context: [*c]struct_TLSContext, arg_hash_type: c_uint, arg_message: [*c]const u8, arg_message_len: c_uint, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var context = arg_context;
    _ = &context;
    var hash_type = arg_hash_type;
    _ = &hash_type;
    var message = arg_message;
    _ = &message;
    var message_len = arg_message_len;
    _ = &message_len;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    if ((((((!(outlen != null) or !(context != null)) or !(out != null)) or !(outlen != null)) or !(context.*.private_key != null)) or !(context.*.private_key.*.der_bytes != null)) or !(context.*.private_key.*.der_len != 0)) {
        return -@as(c_int, 1);
    }
    tls_init();
    var key: rsa_key = undefined;
    _ = &key;
    var err: c_int = undefined;
    _ = &err;
    err = rsa_import(context.*.private_key.*.der_bytes, @as(c_ulong, @bitCast(@as(c_ulong, context.*.private_key.*.der_len))), &key);
    if (err != 0) {
        return -@as(c_int, 1);
    }
    var hash_idx: c_int = -@as(c_int, 1);
    _ = &hash_idx;
    var hash: [64]u8 = undefined;
    _ = &hash;
    var hash_len: c_uint = 0;
    _ = &hash_len;
    var state: hash_state = undefined;
    _ = &state;
    while (true) {
        switch (hash_type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                hash_idx = find_hash("md5");
                err = md5_init(&state);
                if (err != 0) break;
                err = md5_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = md5_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                hash_len = 16;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                hash_idx = find_hash("sha1");
                err = sha1_init(&state);
                if (err != 0) break;
                err = sha1_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha1_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                hash_len = 20;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 4))) => {
                hash_idx = find_hash("sha256");
                err = sha256_init(&state);
                if (err != 0) break;
                err = sha256_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha256_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                hash_len = 32;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 5))) => {
                hash_idx = find_hash("sha384");
                err = sha384_init(&state);
                if (err != 0) break;
                err = sha512_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha384_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                hash_len = 48;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 6))) => {
                hash_idx = find_hash("sha512");
                err = sha512_init(&state);
                if (err != 0) break;
                err = sha512_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha512_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                hash_len = 64;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 255))) => {
                hash_idx = find_hash("md5");
                err = md5_init(&state);
                if (err != 0) break;
                err = md5_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = md5_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                hash_idx = find_hash("sha1");
                err = sha1_init(&state);
                if (err != 0) break;
                err = sha1_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha1_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))));
                if (err != 0) break;
                hash_len = 36;
                err = sha1_init(&state);
                if (err != 0) break;
                err = sha1_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha1_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))));
                if (err != 0) break;
                hash_len = 36;
                break;
            },
            else => {},
        }
        break;
    }
    if (hash_type == @as(c_uint, @bitCast(_md5_sha1))) {
        if (err != 0) {
            return -@as(c_int, 1);
        }
        err = _private_rsa_sign_hash_md5sha1(@as([*c]u8, @ptrCast(@alignCast(&hash))), @as(c_ulong, @bitCast(@as(c_ulong, hash_len))), out, outlen, &key);
    } else {
        if ((hash_idx < @as(c_int, 0)) or (err != 0)) {
            return -@as(c_int, 1);
        }
        if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
            err = rsa_sign_hash_ex(@as([*c]u8, @ptrCast(@alignCast(&hash))), @as(c_ulong, @bitCast(@as(c_ulong, hash_len))), out, outlen, LTC_LTC_PKCS_1_PSS, null, find_prng("sprng"), hash_idx, @as(c_ulong, @bitCast(@as(c_long, if (hash_type == @as(c_uint, @bitCast(sha256))) @as(c_int, 32) else @as(c_int, 48)))), &key);
        } else {
            err = rsa_sign_hash_ex(@as([*c]u8, @ptrCast(@alignCast(&hash))), @as(c_ulong, @bitCast(@as(c_ulong, hash_len))), out, outlen, LTC_LTC_PKCS_1_V1_5, null, find_prng("sprng"), hash_idx, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0)))), &key);
        }
    }
    rsa_free(&key);
    if (err != 0) return 0;
    return 1;
}
// tlse_amalgamated.c:2211:9: warning: TODO implement translation of stmt class GotoStmtClass

// tlse_amalgamated.c:2201:12: warning: unable to translate function, demoted to extern
pub extern fn _private_tls_is_point(arg_key: [*c]ecc_key) callconv(.c) c_int;
pub export fn _private_tls_ecc_import_key(arg_private_key: [*c]const u8, arg_private_len: c_int, arg_public_key: [*c]const u8, arg_public_len: c_int, arg_key: [*c]ecc_key, arg_dp: [*c]const ltc_ecc_set_type) c_int {
    var private_key = arg_private_key;
    _ = &private_key;
    var private_len = arg_private_len;
    _ = &private_len;
    var public_key = arg_public_key;
    _ = &public_key;
    var public_len = arg_public_len;
    _ = &public_len;
    var key = arg_key;
    _ = &key;
    var dp = arg_dp;
    _ = &dp;
    var err: c_int = undefined;
    _ = &err;
    if (!(key != null) or !(ltc_mp.name != null)) return CRYPT_MEM;
    key.*.type = PK_PRIVATE;
    if (ltc_init_multi(&key.*.pubkey.x, &key.*.pubkey.y, &key.*.pubkey.z, &key.*.k, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))) != CRYPT_OK) return CRYPT_MEM;
    if ((public_len != 0) and !(public_key[@as(c_uint, @intCast(@as(c_int, 0)))] != 0)) {
        public_key += 1;
        public_len -= 1;
    }
    if ((blk: {
        const tmp = ltc_mp.unsigned_read.?(key.*.pubkey.x, @as([*c]u8, @ptrCast(@volatileCast(@constCast(public_key)))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))), @as(c_ulong, @bitCast(@as(c_long, (public_len - @as(c_int, 1)) >> @intCast(1)))));
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        ltc_deinit_multi(key.*.pubkey.x, key.*.pubkey.y, key.*.pubkey.z, key.*.k, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
        return err;
    }
    if ((blk: {
        const tmp = ltc_mp.unsigned_read.?(key.*.pubkey.y, (@as([*c]u8, @ptrCast(@volatileCast(@constCast(public_key)))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1)))))) + @as(usize, @bitCast(@as(isize, @intCast((public_len - @as(c_int, 1)) >> @intCast(1))))), @as(c_ulong, @bitCast(@as(c_long, (public_len - @as(c_int, 1)) >> @intCast(1)))));
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        ltc_deinit_multi(key.*.pubkey.x, key.*.pubkey.y, key.*.pubkey.z, key.*.k, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
        return err;
    }
    if ((blk: {
        const tmp = ltc_mp.unsigned_read.?(key.*.k, @as([*c]u8, @ptrCast(@volatileCast(@constCast(private_key)))), @as(c_ulong, @bitCast(@as(c_long, private_len))));
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        ltc_deinit_multi(key.*.pubkey.x, key.*.pubkey.y, key.*.pubkey.z, key.*.k, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
        return err;
    }
    key.*.idx = -@as(c_int, 1);
    key.*.dp = dp;
    if ((blk: {
        const tmp = ltc_mp.set_int.?(key.*.pubkey.z, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))));
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        ltc_deinit_multi(key.*.pubkey.x, key.*.pubkey.y, key.*.pubkey.z, key.*.k, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
        return err;
    }
    if ((blk: {
        const tmp = _private_tls_is_point(key);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        ltc_deinit_multi(key.*.pubkey.x, key.*.pubkey.y, key.*.pubkey.z, key.*.k, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
        return err;
    }
    return CRYPT_OK;
}
pub export fn _private_tls_sign_ecdsa(arg_context: [*c]struct_TLSContext, arg_hash_type: c_uint, arg_message: [*c]const u8, arg_message_len: c_uint, arg_out: [*c]u8, arg_outlen: [*c]c_ulong) c_int {
    var context = arg_context;
    _ = &context;
    var hash_type = arg_hash_type;
    _ = &hash_type;
    var message = arg_message;
    _ = &message;
    var message_len = arg_message_len;
    _ = &message_len;
    var out = arg_out;
    _ = &out;
    var outlen = arg_outlen;
    _ = &outlen;
    if ((((((((!(outlen != null) or !(context != null)) or !(out != null)) or !(outlen != null)) or !(context.*.ec_private_key != null)) or !(context.*.ec_private_key.*.priv != null)) or !(context.*.ec_private_key.*.priv_len != 0)) or !(context.*.ec_private_key.*.pk != null)) or !(context.*.ec_private_key.*.pk_len != 0)) {
        return -@as(c_int, 1);
    }
    var curve: [*c]const struct_ECCCurveParameters = null;
    _ = &curve;
    while (true) {
        switch (context.*.ec_private_key.*.ec_algorithm) {
            @as(c_uint, @bitCast(@as(c_int, 19))) => {
                curve = &secp192r1;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 20))) => {
                curve = &secp224k1;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 21))) => {
                curve = &secp224r1;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 22))) => {
                curve = &secp256k1;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 23))) => {
                curve = &secp256r1;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 24))) => {
                curve = &secp384r1;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 25))) => {
                curve = &secp521r1;
                break;
            },
            else => {
                {}
            },
        }
        break;
    }
    if (!(curve != null)) return -@as(c_int, 1);
    tls_init();
    var key: ecc_key = undefined;
    _ = &key;
    var err: c_int = undefined;
    _ = &err;
    _ = memset(@as(?*anyopaque, @ptrCast(&key)), @as(c_int, 0), @sizeOf(ecc_key));
    var dp: [*c]const ltc_ecc_set_type = &curve.*.dp;
    _ = &dp;
    err = _private_tls_ecc_import_key(context.*.ec_private_key.*.priv, @as(c_int, @bitCast(context.*.ec_private_key.*.priv_len)), context.*.ec_private_key.*.pk, @as(c_int, @bitCast(context.*.ec_private_key.*.pk_len)), &key, dp);
    if (err != 0) {
        return -@as(c_int, 1);
    }
    var hash: [64]u8 = undefined;
    _ = &hash;
    var hash_len: c_uint = 0;
    _ = &hash_len;
    var state: hash_state = undefined;
    _ = &state;
    while (true) {
        switch (hash_type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                err = md5_init(&state);
                if (err != 0) break;
                err = md5_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = md5_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                hash_len = 16;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                err = sha1_init(&state);
                if (err != 0) break;
                err = sha1_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha1_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                hash_len = 20;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 4))) => {
                err = sha256_init(&state);
                if (err != 0) break;
                err = sha256_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha256_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                hash_len = 32;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 5))) => {
                err = sha384_init(&state);
                if (err != 0) break;
                err = sha512_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha384_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                hash_len = 48;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 6))) => {
                err = sha512_init(&state);
                if (err != 0) break;
                err = sha512_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha512_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                hash_len = 64;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 255))) => {
                err = md5_init(&state);
                if (err != 0) break;
                err = md5_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = md5_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                if (err != 0) break;
                err = sha1_init(&state);
                if (err != 0) break;
                err = sha1_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha1_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))));
                if (err != 0) break;
                hash_len = 36;
                err = sha1_init(&state);
                if (err != 0) break;
                err = sha1_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                if (err != 0) break;
                err = sha1_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))));
                if (err != 0) break;
                hash_len = 36;
                break;
            },
            else => {},
        }
        break;
    }
    if (err != 0) {
        return -@as(c_int, 1);
    }
    if (hash_len > @as(c_uint, @bitCast(curve.*.size))) {
        hash_len = @as(c_uint, @bitCast(curve.*.size));
    }
    err = ecc_sign_hash(@as([*c]u8, @ptrCast(@alignCast(&hash))), @as(c_ulong, @bitCast(@as(c_ulong, hash_len))), out, outlen, null, find_prng("sprng"), &key);
    ecc_free(&key);
    if (err != 0) return 0;
    return 1;
}
pub export fn _private_tls_ecc_import_pk(arg_public_key: [*c]const u8, arg_public_len: c_int, arg_key: [*c]ecc_key, arg_dp: [*c]const ltc_ecc_set_type) c_int {
    var public_key = arg_public_key;
    _ = &public_key;
    var public_len = arg_public_len;
    _ = &public_len;
    var key = arg_key;
    _ = &key;
    var dp = arg_dp;
    _ = &dp;
    var err: c_int = undefined;
    _ = &err;
    if (!(key != null) or !(ltc_mp.name != null)) return CRYPT_MEM;
    key.*.type = PK_PUBLIC;
    if (ltc_init_multi(&key.*.pubkey.x, &key.*.pubkey.y, &key.*.pubkey.z, &key.*.k, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))) != CRYPT_OK) return CRYPT_MEM;
    if ((public_len != 0) and !(public_key[@as(c_uint, @intCast(@as(c_int, 0)))] != 0)) {
        public_key += 1;
        public_len -= 1;
    }
    if ((blk: {
        const tmp = ltc_mp.unsigned_read.?(key.*.pubkey.x, @as([*c]u8, @ptrCast(@volatileCast(@constCast(public_key)))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))), @as(c_ulong, @bitCast(@as(c_long, (public_len - @as(c_int, 1)) >> @intCast(1)))));
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        ltc_deinit_multi(key.*.pubkey.x, key.*.pubkey.y, key.*.pubkey.z, key.*.k, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
        return err;
    }
    if ((blk: {
        const tmp = ltc_mp.unsigned_read.?(key.*.pubkey.y, (@as([*c]u8, @ptrCast(@volatileCast(@constCast(public_key)))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1)))))) + @as(usize, @bitCast(@as(isize, @intCast((public_len - @as(c_int, 1)) >> @intCast(1))))), @as(c_ulong, @bitCast(@as(c_long, (public_len - @as(c_int, 1)) >> @intCast(1)))));
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        ltc_deinit_multi(key.*.pubkey.x, key.*.pubkey.y, key.*.pubkey.z, key.*.k, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
        return err;
    }
    key.*.idx = -@as(c_int, 1);
    key.*.dp = dp;
    if ((blk: {
        const tmp = ltc_mp.set_int.?(key.*.pubkey.z, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))));
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        ltc_deinit_multi(key.*.pubkey.x, key.*.pubkey.y, key.*.pubkey.z, key.*.k, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
        return err;
    }
    if ((blk: {
        const tmp = _private_tls_is_point(key);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        ltc_deinit_multi(key.*.pubkey.x, key.*.pubkey.y, key.*.pubkey.z, key.*.k, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
        return err;
    }
    return CRYPT_OK;
}
pub export fn _private_tls_verify_ecdsa(arg_context: [*c]struct_TLSContext, arg_hash_type: c_uint, arg_buffer: [*c]const u8, arg_len: c_uint, arg_message: [*c]const u8, arg_message_len: c_uint, arg_curve_hint: [*c]const struct_ECCCurveParameters) c_int {
    var context = arg_context;
    _ = &context;
    var hash_type = arg_hash_type;
    _ = &hash_type;
    var buffer = arg_buffer;
    _ = &buffer;
    var len = arg_len;
    _ = &len;
    var message = arg_message;
    _ = &message;
    var message_len = arg_message_len;
    _ = &message_len;
    var curve_hint = arg_curve_hint;
    _ = &curve_hint;
    tls_init();
    var key: ecc_key = undefined;
    _ = &key;
    var err: c_int = undefined;
    _ = &err;
    if (!(curve_hint != null)) {
        curve_hint = context.*.curve;
    }
    if (context.*.is_server != 0) {
        if ((((((!(len != 0) or !(context.*.client_certificates != null)) or !(context.*.client_certificates_count != 0)) or !(context.*.client_certificates[@as(c_uint, @intCast(@as(c_int, 0)))] != null)) or !(context.*.client_certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.pk != null)) or !(context.*.client_certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.pk_len != 0)) or !(curve_hint != null)) {
            return -@as(c_int, 1);
        }
        err = _private_tls_ecc_import_pk(context.*.client_certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.pk, @as(c_int, @bitCast(context.*.client_certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.pk_len)), &key, &curve_hint.*.dp);
    } else {
        if ((((((!(len != 0) or !(context.*.certificates != null)) or !(context.*.certificates_count != 0)) or !(context.*.certificates[@as(c_uint, @intCast(@as(c_int, 0)))] != null)) or !(context.*.certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.pk != null)) or !(context.*.certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.pk_len != 0)) or !(curve_hint != null)) {
            return -@as(c_int, 1);
        }
        err = _private_tls_ecc_import_pk(context.*.certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.pk, @as(c_int, @bitCast(context.*.certificates[@as(c_uint, @intCast(@as(c_int, 0)))].*.pk_len)), &key, &curve_hint.*.dp);
    }
    if (err != 0) {
        return -@as(c_int, 1);
    }
    var hash_idx: c_int = -@as(c_int, 1);
    _ = &hash_idx;
    var hash: [64]u8 = undefined;
    _ = &hash;
    var hash_len: c_uint = 0;
    _ = &hash_len;
    var state: hash_state = undefined;
    _ = &state;
    while (true) {
        switch (hash_type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                hash_idx = find_hash("md5");
                err = md5_init(&state);
                if (!(err != 0)) {
                    err = md5_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                    if (!(err != 0)) {
                        err = md5_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                    }
                }
                hash_len = 16;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                hash_idx = find_hash("sha1");
                err = sha1_init(&state);
                if (!(err != 0)) {
                    err = sha1_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                    if (!(err != 0)) {
                        err = sha1_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                    }
                }
                hash_len = 20;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 4))) => {
                hash_idx = find_hash("sha256");
                err = sha256_init(&state);
                if (!(err != 0)) {
                    err = sha256_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                    if (!(err != 0)) {
                        err = sha256_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                    }
                }
                hash_len = 32;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 5))) => {
                hash_idx = find_hash("sha384");
                err = sha384_init(&state);
                if (!(err != 0)) {
                    err = sha512_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                    if (!(err != 0)) {
                        err = sha384_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                    }
                }
                hash_len = 48;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 6))) => {
                hash_idx = find_hash("sha512");
                err = sha512_init(&state);
                if (!(err != 0)) {
                    err = sha512_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                    if (!(err != 0)) {
                        err = sha512_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                    }
                }
                hash_len = 64;
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 255))) => {
                hash_idx = find_hash("md5");
                err = md5_init(&state);
                if (!(err != 0)) {
                    err = md5_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                    if (!(err != 0)) {
                        err = md5_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))));
                    }
                }
                hash_idx = find_hash("sha1");
                err = sha1_init(&state);
                if (!(err != 0)) {
                    err = sha1_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                    if (!(err != 0)) {
                        err = sha1_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))));
                    }
                }
                hash_len = 36;
                err = sha1_init(&state);
                if (!(err != 0)) {
                    err = sha1_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                    if (!(err != 0)) {
                        err = sha1_done(&state, @as([*c]u8, @ptrCast(@alignCast(&hash))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16))))));
                    }
                }
                hash_len = 36;
                break;
            },
            else => {},
        }
        break;
    }
    if ((hash_idx < @as(c_int, 0)) or (err != 0)) {
        return -@as(c_int, 1);
    }
    var ecc_stat: c_int = 0;
    _ = &ecc_stat;
    err = ecc_verify_hash(buffer, @as(c_ulong, @bitCast(@as(c_ulong, len))), @as([*c]u8, @ptrCast(@alignCast(&hash))), @as(c_ulong, @bitCast(@as(c_ulong, hash_len))), &ecc_stat, &key);
    ecc_free(&key);
    if (err != 0) return 0;
    return ecc_stat;
}
pub export fn _private_tls_random_int(arg_limit: c_int) c_uint {
    var limit = arg_limit;
    _ = &limit;
    var res: c_uint = 0;
    _ = &res;
    _ = tls_random(@as([*c]u8, @ptrCast(@alignCast(&res))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf(c_int))))));
    if (limit != 0) {
        res %= @as(c_uint, @bitCast(limit));
    }
    return res;
}
pub export fn _private_tls_sleep(arg_microseconds: c_uint) void {
    var microseconds = arg_microseconds;
    _ = &microseconds;
    var ts: struct_timespec = undefined;
    _ = &ts;
    ts.tv_sec = @as(__time_t, @bitCast(@as(c_ulong, microseconds / @as(c_uint, @bitCast(@as(c_int, 1000000))))));
    ts.tv_nsec = @as(__syscall_slong_t, @bitCast(@as(c_ulong, @bitCast(@as(c_ulong, microseconds % @as(c_uint, @bitCast(@as(c_int, 1000000)))))) *% @as(c_ulong, 1000)));
    _ = nanosleep(&ts, null);
}
pub export fn _private_random_sleep(arg_context: [*c]struct_TLSContext, arg_max_microseconds: c_int) void {
    var context = arg_context;
    _ = &context;
    var max_microseconds = arg_max_microseconds;
    _ = &max_microseconds;
    if (context != null) {
        context.*.sleep_until = @as(c_uint, @bitCast(@as(c_int, @truncate(time(null))))) +% _private_tls_random_int(@divTrunc(max_microseconds, @as(c_int, 1000000)) * @as(c_int, 5));
    } else {
        _private_tls_sleep(_private_tls_random_int(max_microseconds));
    }
}
pub export fn _private_tls_prf_helper(arg_hash_idx: c_int, arg_dlen: c_ulong, arg_output: [*c]u8, arg_outlen: c_uint, arg_secret: [*c]const u8, secret_len: c_uint, arg_label: [*c]const u8, arg_label_len: c_uint, arg_seed: [*c]u8, arg_seed_len: c_uint, arg_seed_b: [*c]u8, arg_seed_b_len: c_uint) void {
    var hash_idx = arg_hash_idx;
    _ = &hash_idx;
    var dlen = arg_dlen;
    _ = &dlen;
    var output = arg_output;
    _ = &output;
    var outlen = arg_outlen;
    _ = &outlen;
    var secret = arg_secret;
    _ = &secret;
    _ = &secret_len;
    var label = arg_label;
    _ = &label;
    var label_len = arg_label_len;
    _ = &label_len;
    var seed = arg_seed;
    _ = &seed;
    var seed_len = arg_seed_len;
    _ = &seed_len;
    var seed_b = arg_seed_b;
    _ = &seed_b;
    var seed_b_len = arg_seed_b_len;
    _ = &seed_b_len;
    var digest_out0: [64]u8 = undefined;
    _ = &digest_out0;
    var digest_out1: [64]u8 = undefined;
    _ = &digest_out1;
    var i: c_uint = undefined;
    _ = &i;
    var hmac: hmac_state = undefined;
    _ = &hmac;
    _ = hmac_init(&hmac, hash_idx, secret, @as(c_ulong, @bitCast(@as(c_ulong, secret_len))));
    _ = hmac_process(&hmac, label, @as(c_ulong, @bitCast(@as(c_ulong, label_len))));
    _ = hmac_process(&hmac, seed, @as(c_ulong, @bitCast(@as(c_ulong, seed_len))));
    if ((seed_b != null) and (seed_b_len != 0)) {
        _ = hmac_process(&hmac, seed_b, @as(c_ulong, @bitCast(@as(c_ulong, seed_b_len))));
    }
    _ = hmac_done(&hmac, @as([*c]u8, @ptrCast(@alignCast(&digest_out0))), &dlen);
    var idx: c_int = 0;
    _ = &idx;
    while (outlen != 0) {
        _ = hmac_init(&hmac, hash_idx, secret, @as(c_ulong, @bitCast(@as(c_ulong, secret_len))));
        _ = hmac_process(&hmac, @as([*c]u8, @ptrCast(@alignCast(&digest_out0))), dlen);
        _ = hmac_process(&hmac, label, @as(c_ulong, @bitCast(@as(c_ulong, label_len))));
        _ = hmac_process(&hmac, seed, @as(c_ulong, @bitCast(@as(c_ulong, seed_len))));
        if ((seed_b != null) and (seed_b_len != 0)) {
            _ = hmac_process(&hmac, seed_b, @as(c_ulong, @bitCast(@as(c_ulong, seed_b_len))));
        }
        _ = hmac_done(&hmac, @as([*c]u8, @ptrCast(@alignCast(&digest_out1))), &dlen);
        var copylen: c_uint = outlen;
        _ = &copylen;
        if (@as(c_ulong, @bitCast(@as(c_ulong, copylen))) > dlen) {
            copylen = @as(c_uint, @bitCast(@as(c_uint, @truncate(dlen))));
        }
        {
            i = 0;
            while (i < copylen) : (i +%= 1) {
                (blk: {
                    const tmp = blk_1: {
                        const ref = &idx;
                        const tmp_2 = ref.*;
                        ref.* += 1;
                        break :blk_1 tmp_2;
                    };
                    if (tmp >= 0) break :blk output + @as(usize, @intCast(tmp)) else break :blk output - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).* ^= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, digest_out1[i])))))));
                outlen -%= 1;
            }
        }
        if (!(outlen != 0)) break;
        _ = hmac_init(&hmac, hash_idx, secret, @as(c_ulong, @bitCast(@as(c_ulong, secret_len))));
        _ = hmac_process(&hmac, @as([*c]u8, @ptrCast(@alignCast(&digest_out0))), dlen);
        _ = hmac_done(&hmac, @as([*c]u8, @ptrCast(@alignCast(&digest_out0))), &dlen);
    }
}
pub export fn _private_tls_hkdf_label(arg_label: [*c]const u8, arg_label_len: u8, arg_data: [*c]const u8, arg_data_len: u8, arg_hkdflabel: [*c]u8, arg_length: c_ushort, arg_prefix: [*c]const u8) c_int {
    var label = arg_label;
    _ = &label;
    var label_len = arg_label_len;
    _ = &label_len;
    var data = arg_data;
    _ = &data;
    var data_len = arg_data_len;
    _ = &data_len;
    var hkdflabel = arg_hkdflabel;
    _ = &hkdflabel;
    var length = arg_length;
    _ = &length;
    var prefix = arg_prefix;
    _ = &prefix;
    @as([*c]c_ushort, @ptrCast(@alignCast(hkdflabel))).* = htons(length);
    var prefix_len: c_int = undefined;
    _ = &prefix_len;
    if (prefix != null) {
        prefix_len = @as(c_int, @bitCast(@as(c_uint, @truncate(strlen(prefix)))));
        _ = memcpy(@as(?*anyopaque, @ptrCast(&hkdflabel[@as(c_uint, @intCast(@as(c_int, 3)))])), @as(?*const anyopaque, @ptrCast(prefix)), @as(c_ulong, @bitCast(@as(c_long, prefix_len))));
    } else {
        _ = memcpy(@as(?*anyopaque, @ptrCast(&hkdflabel[@as(c_uint, @intCast(@as(c_int, 3)))])), @as(?*const anyopaque, @ptrCast("tls13 ")), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 6)))));
        prefix_len = 6;
    }
    hkdflabel[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(prefix_len))))))) + @as(c_int, @bitCast(@as(c_uint, label_len)))))));
    _ = memcpy(@as(?*anyopaque, @ptrCast(&(blk: {
        const tmp = @as(c_int, 3) + prefix_len;
        if (tmp >= 0) break :blk hkdflabel + @as(usize, @intCast(tmp)) else break :blk hkdflabel - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*)), @as(?*const anyopaque, @ptrCast(label)), @as(c_ulong, @bitCast(@as(c_ulong, label_len))));
    (blk: {
        const tmp = (@as(c_int, 3) + prefix_len) + @as(c_int, @bitCast(@as(c_uint, label_len)));
        if (tmp >= 0) break :blk hkdflabel + @as(usize, @intCast(tmp)) else break :blk hkdflabel - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* = data_len;
    if (data_len != 0) {
        _ = memcpy(@as(?*anyopaque, @ptrCast(&(blk: {
            const tmp = (@as(c_int, 4) + prefix_len) + @as(c_int, @bitCast(@as(c_uint, label_len)));
            if (tmp >= 0) break :blk hkdflabel + @as(usize, @intCast(tmp)) else break :blk hkdflabel - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*)), @as(?*const anyopaque, @ptrCast(data)), @as(c_ulong, @bitCast(@as(c_ulong, data_len))));
    }
    return ((@as(c_int, 4) + prefix_len) + @as(c_int, @bitCast(@as(c_uint, label_len)))) + @as(c_int, @bitCast(@as(c_uint, data_len)));
}
pub export fn _private_tls_hkdf_extract(arg_mac_length: c_uint, arg_output: [*c]u8, arg_outlen: c_uint, arg_salt: [*c]const u8, arg_salt_len: c_uint, arg_ikm: [*c]const u8, arg_ikm_len: u8) c_int {
    var mac_length = arg_mac_length;
    _ = &mac_length;
    var output = arg_output;
    _ = &output;
    var outlen = arg_outlen;
    _ = &outlen;
    var salt = arg_salt;
    _ = &salt;
    var salt_len = arg_salt_len;
    _ = &salt_len;
    var ikm = arg_ikm;
    _ = &ikm;
    var ikm_len = arg_ikm_len;
    _ = &ikm_len;
    var dlen: c_ulong = @as(c_ulong, @bitCast(@as(c_ulong, outlen)));
    _ = &dlen;
    const dummy_label = struct {
        var static: [1]u8 = [1]u8{
            0,
        };
    };
    _ = &dummy_label;
    if (!(salt != null) or (salt_len == @as(c_uint, @bitCast(@as(c_int, 0))))) {
        salt_len = 1;
        salt = @as([*c]u8, @ptrCast(@alignCast(&dummy_label.static)));
    }
    var hash_idx: c_int = undefined;
    _ = &hash_idx;
    if (mac_length == @as(c_uint, @bitCast(@as(c_int, 48)))) {
        hash_idx = find_hash("sha384");
        dlen = @as(c_ulong, @bitCast(@as(c_ulong, mac_length)));
    } else {
        hash_idx = find_hash("sha256");
    }
    var hmac: hmac_state = undefined;
    _ = &hmac;
    _ = hmac_init(&hmac, hash_idx, salt, @as(c_ulong, @bitCast(@as(c_ulong, salt_len))));
    _ = hmac_process(&hmac, ikm, @as(c_ulong, @bitCast(@as(c_ulong, ikm_len))));
    _ = hmac_done(&hmac, output, &dlen);
    return @as(c_int, @bitCast(@as(c_uint, @truncate(dlen))));
}
pub export fn _private_tls_hkdf_expand(arg_mac_length: c_uint, arg_output: [*c]u8, arg_outlen: c_uint, arg_secret: [*c]const u8, arg_secret_len: c_uint, arg_info: [*c]const u8, arg_info_len: u8) void {
    var mac_length = arg_mac_length;
    _ = &mac_length;
    var output = arg_output;
    _ = &output;
    var outlen = arg_outlen;
    _ = &outlen;
    var secret = arg_secret;
    _ = &secret;
    var secret_len = arg_secret_len;
    _ = &secret_len;
    var info = arg_info;
    _ = &info;
    var info_len = arg_info_len;
    _ = &info_len;
    var digest_out: [64]u8 = undefined;
    _ = &digest_out;
    var dlen: c_ulong = 32;
    _ = &dlen;
    var hash_idx: c_int = undefined;
    _ = &hash_idx;
    if (mac_length == @as(c_uint, @bitCast(@as(c_int, 48)))) {
        hash_idx = find_hash("sha384");
        dlen = @as(c_ulong, @bitCast(@as(c_ulong, mac_length)));
    } else {
        hash_idx = find_hash("sha256");
    }
    var i: c_uint = undefined;
    _ = &i;
    var idx: c_uint = 0;
    _ = &idx;
    var hmac: hmac_state = undefined;
    _ = &hmac;
    var @"i2": u8 = 0;
    _ = &@"i2";
    while (outlen != 0) {
        _ = hmac_init(&hmac, hash_idx, secret, @as(c_ulong, @bitCast(@as(c_ulong, secret_len))));
        if (@"i2" != 0) {
            _ = hmac_process(&hmac, @as([*c]u8, @ptrCast(@alignCast(&digest_out))), dlen);
        }
        if ((info != null) and (@as(c_int, @bitCast(@as(c_uint, info_len))) != 0)) {
            _ = hmac_process(&hmac, info, @as(c_ulong, @bitCast(@as(c_ulong, info_len))));
        }
        @"i2" +%= 1;
        _ = hmac_process(&hmac, &@"i2", @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))));
        _ = hmac_done(&hmac, @as([*c]u8, @ptrCast(@alignCast(&digest_out))), &dlen);
        var copylen: c_uint = outlen;
        _ = &copylen;
        if (@as(c_ulong, @bitCast(@as(c_ulong, copylen))) > dlen) {
            copylen = @as(c_uint, @bitCast(@as(c_uint, @truncate(dlen))));
        }
        {
            i = 0;
            while (i < copylen) : (i +%= 1) {
                output[blk: {
                    const ref = &idx;
                    const tmp = ref.*;
                    ref.* +%= 1;
                    break :blk tmp;
                }] = digest_out[i];
                outlen -%= 1;
            }
        }
        if (!(outlen != 0)) break;
    }
}
pub export fn _private_tls_hkdf_expand_label(arg_mac_length: c_uint, arg_output: [*c]u8, arg_outlen: c_uint, arg_secret: [*c]const u8, arg_secret_len: c_uint, arg_label: [*c]const u8, arg_label_len: u8, arg_data: [*c]const u8, arg_data_len: u8) void {
    var mac_length = arg_mac_length;
    _ = &mac_length;
    var output = arg_output;
    _ = &output;
    var outlen = arg_outlen;
    _ = &outlen;
    var secret = arg_secret;
    _ = &secret;
    var secret_len = arg_secret_len;
    _ = &secret_len;
    var label = arg_label;
    _ = &label;
    var label_len = arg_label_len;
    _ = &label_len;
    var data = arg_data;
    _ = &data;
    var data_len = arg_data_len;
    _ = &data_len;
    var hkdf_label: [512]u8 = undefined;
    _ = &hkdf_label;
    var len: c_int = _private_tls_hkdf_label(label, label_len, data, data_len, @as([*c]u8, @ptrCast(@alignCast(&hkdf_label))), @as(c_ushort, @bitCast(@as(c_ushort, @truncate(outlen)))), null);
    _ = &len;
    _private_tls_hkdf_expand(mac_length, output, outlen, secret, secret_len, @as([*c]u8, @ptrCast(@alignCast(&hkdf_label))), @as(u8, @bitCast(@as(i8, @truncate(len)))));
}
pub export fn _private_tls_prf(arg_context: [*c]struct_TLSContext, arg_output: [*c]u8, arg_outlen: c_uint, arg_secret: [*c]const u8, secret_len: c_uint, arg_label: [*c]const u8, arg_label_len: c_uint, arg_seed: [*c]u8, arg_seed_len: c_uint, arg_seed_b: [*c]u8, arg_seed_b_len: c_uint) void {
    var context = arg_context;
    _ = &context;
    var output = arg_output;
    _ = &output;
    var outlen = arg_outlen;
    _ = &outlen;
    var secret = arg_secret;
    _ = &secret;
    _ = &secret_len;
    var label = arg_label;
    _ = &label;
    var label_len = arg_label_len;
    _ = &label_len;
    var seed = arg_seed;
    _ = &seed;
    var seed_len = arg_seed_len;
    _ = &seed_len;
    var seed_b = arg_seed_b;
    _ = &seed_b;
    var seed_b_len = arg_seed_b_len;
    _ = &seed_b_len;
    if (!(secret != null) or !(secret_len != 0)) {
        return;
    }
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) != @as(c_int, 771)) and (@as(c_int, @bitCast(@as(c_uint, context.*.version))) != @as(c_int, 65277))) {
        var md5_hash_idx: c_int = find_hash("md5");
        _ = &md5_hash_idx;
        var sha1_hash_idx: c_int = find_hash("sha1");
        _ = &sha1_hash_idx;
        var half_secret: c_int = @as(c_int, @bitCast((secret_len +% @as(c_uint, @bitCast(@as(c_int, 1)))) / @as(c_uint, @bitCast(@as(c_int, 2)))));
        _ = &half_secret;
        _ = memset(@as(?*anyopaque, @ptrCast(output)), @as(c_int, 0), @as(c_ulong, @bitCast(@as(c_ulong, outlen))));
        _private_tls_prf_helper(md5_hash_idx, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16)))), output, outlen, secret, @as(c_uint, @bitCast(half_secret)), label, label_len, seed, seed_len, seed_b, seed_b_len);
        _private_tls_prf_helper(sha1_hash_idx, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 20)))), output, outlen, secret + (secret_len -% @as(c_uint, @bitCast(half_secret))), secret_len -% @as(c_uint, @bitCast(half_secret)), label, label_len, seed, seed_len, seed_b, seed_b_len);
    } else {
        var digest_out0: [64]u8 = undefined;
        _ = &digest_out0;
        var digest_out1: [64]u8 = undefined;
        _ = &digest_out1;
        var dlen: c_ulong = 32;
        _ = &dlen;
        var hash_idx: c_int = undefined;
        _ = &hash_idx;
        var mac_length: c_uint = _private_tls_mac_length(context);
        _ = &mac_length;
        if (mac_length == @as(c_uint, @bitCast(@as(c_int, 48)))) {
            hash_idx = find_hash("sha384");
            dlen = @as(c_ulong, @bitCast(@as(c_ulong, mac_length)));
        } else {
            hash_idx = find_hash("sha256");
        }
        var i: c_uint = undefined;
        _ = &i;
        var hmac: hmac_state = undefined;
        _ = &hmac;
        _ = hmac_init(&hmac, hash_idx, secret, @as(c_ulong, @bitCast(@as(c_ulong, secret_len))));
        _ = hmac_process(&hmac, label, @as(c_ulong, @bitCast(@as(c_ulong, label_len))));
        _ = hmac_process(&hmac, seed, @as(c_ulong, @bitCast(@as(c_ulong, seed_len))));
        if ((seed_b != null) and (seed_b_len != 0)) {
            _ = hmac_process(&hmac, seed_b, @as(c_ulong, @bitCast(@as(c_ulong, seed_b_len))));
        }
        _ = hmac_done(&hmac, @as([*c]u8, @ptrCast(@alignCast(&digest_out0))), &dlen);
        var idx: c_int = 0;
        _ = &idx;
        while (outlen != 0) {
            _ = hmac_init(&hmac, hash_idx, secret, @as(c_ulong, @bitCast(@as(c_ulong, secret_len))));
            _ = hmac_process(&hmac, @as([*c]u8, @ptrCast(@alignCast(&digest_out0))), dlen);
            _ = hmac_process(&hmac, label, @as(c_ulong, @bitCast(@as(c_ulong, label_len))));
            _ = hmac_process(&hmac, seed, @as(c_ulong, @bitCast(@as(c_ulong, seed_len))));
            if ((seed_b != null) and (seed_b_len != 0)) {
                _ = hmac_process(&hmac, seed_b, @as(c_ulong, @bitCast(@as(c_ulong, seed_b_len))));
            }
            _ = hmac_done(&hmac, @as([*c]u8, @ptrCast(@alignCast(&digest_out1))), &dlen);
            var copylen: c_uint = outlen;
            _ = &copylen;
            if (@as(c_ulong, @bitCast(@as(c_ulong, copylen))) > dlen) {
                copylen = @as(c_uint, @bitCast(@as(c_uint, @truncate(dlen))));
            }
            {
                i = 0;
                while (i < copylen) : (i +%= 1) {
                    (blk: {
                        const tmp = blk_1: {
                            const ref = &idx;
                            const tmp_2 = ref.*;
                            ref.* += 1;
                            break :blk_1 tmp_2;
                        };
                        if (tmp >= 0) break :blk output + @as(usize, @intCast(tmp)) else break :blk output - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).* = digest_out1[i];
                    outlen -%= 1;
                }
            }
            if (!(outlen != 0)) break;
            _ = hmac_init(&hmac, hash_idx, secret, @as(c_ulong, @bitCast(@as(c_ulong, secret_len))));
            _ = hmac_process(&hmac, @as([*c]u8, @ptrCast(@alignCast(&digest_out0))), dlen);
            _ = hmac_done(&hmac, @as([*c]u8, @ptrCast(@alignCast(&digest_out0))), &dlen);
        }
    }
}
pub export fn _private_tls_key_length(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    while (true) {
        switch (@as(c_int, @bitCast(@as(c_uint, context.*.cipher)))) {
            @as(c_int, 47), @as(c_int, 60), @as(c_int, 156), @as(c_int, 51), @as(c_int, 103), @as(c_int, 158), @as(c_int, 49171), @as(c_int, 49191), @as(c_int, 49199), @as(c_int, 49161), @as(c_int, 49187), @as(c_int, 49195), @as(c_int, 4865) => return 16,
            @as(c_int, 53), @as(c_int, 61), @as(c_int, 157), @as(c_int, 57), @as(c_int, 107), @as(c_int, 159), @as(c_int, 49172), @as(c_int, 49200), @as(c_int, 49162), @as(c_int, 49188), @as(c_int, 49196), @as(c_int, 52392), @as(c_int, 52393), @as(c_int, 52394), @as(c_int, 4866), @as(c_int, 4867) => return 32,
            else => {},
        }
        break;
    }
    return 0;
}
pub export fn _private_tls_is_aead(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    while (true) {
        switch (@as(c_int, @bitCast(@as(c_uint, context.*.cipher)))) {
            @as(c_int, 156), @as(c_int, 157), @as(c_int, 158), @as(c_int, 159), @as(c_int, 49199), @as(c_int, 49200), @as(c_int, 49195), @as(c_int, 49196), @as(c_int, 4865), @as(c_int, 4866) => return 1,
            @as(c_int, 52392), @as(c_int, 52393), @as(c_int, 52394), @as(c_int, 4867) => return 2,
            else => {},
        }
        break;
    }
    return 0;
}
pub export fn _private_tls13_key(arg_context: [*c]struct_TLSContext, arg_handshake: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var handshake = arg_handshake;
    _ = &handshake;
    tls_init();
    var key_length: c_int = _private_tls_key_length(context);
    _ = &key_length;
    var mac_length: c_uint = _private_tls_mac_length(context);
    _ = &mac_length;
    if (!(context.*.premaster_key != null) or !(context.*.premaster_key_len != 0)) return 0;
    if (!(key_length != 0) or !(mac_length != 0)) {
        return 0;
    }
    var clientkey: [*c]u8 = null;
    _ = &clientkey;
    var serverkey: [*c]u8 = null;
    _ = &serverkey;
    var clientiv: [*c]u8 = null;
    _ = &clientiv;
    var serveriv: [*c]u8 = null;
    _ = &serveriv;
    var is_aead: c_int = _private_tls_is_aead(context);
    _ = &is_aead;
    var local_keybuffer: [32]u8 = undefined;
    _ = &local_keybuffer;
    var local_ivbuffer: [12]u8 = undefined;
    _ = &local_ivbuffer;
    var remote_keybuffer: [32]u8 = undefined;
    _ = &remote_keybuffer;
    var remote_ivbuffer: [12]u8 = undefined;
    _ = &remote_ivbuffer;
    var prk: [48]u8 = undefined;
    _ = &prk;
    var hash: [48]u8 = undefined;
    _ = &hash;
    const earlysecret = struct {
        var static: [48]u8 = @import("std").mem.zeroes([48]u8);
    };
    _ = &earlysecret;
    var server_key: [*c]const u8 = "s ap traffic";
    _ = &server_key;
    var client_key: [*c]const u8 = "c ap traffic";
    _ = &client_key;
    if (handshake != 0) {
        server_key = "s hs traffic";
        client_key = "c hs traffic";
    }
    var salt: [48]u8 = undefined;
    _ = &salt;
    var md: hash_state = undefined;
    _ = &md;
    if (mac_length == @as(c_uint, @bitCast(@as(c_int, 48)))) {
        _ = sha384_init(&md);
        _ = sha384_done(&md, @as([*c]u8, @ptrCast(@alignCast(&hash))));
    } else {
        _ = sha256_init(&md);
        _ = sha256_done(&md, @as([*c]u8, @ptrCast(@alignCast(&hash))));
    }
    if (((context.*.master_key != null) and (context.*.master_key_len != 0)) and !(handshake != 0)) {
        _private_tls_hkdf_expand_label(mac_length, @as([*c]u8, @ptrCast(@alignCast(&salt))), mac_length, context.*.master_key, context.*.master_key_len, "derived", @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 7))))), @as([*c]u8, @ptrCast(@alignCast(&hash))), @as(u8, @bitCast(@as(u8, @truncate(mac_length)))));
        _ = _private_tls_hkdf_extract(mac_length, @as([*c]u8, @ptrCast(@alignCast(&prk))), mac_length, @as([*c]u8, @ptrCast(@alignCast(&salt))), mac_length, @as([*c]u8, @ptrCast(@alignCast(&earlysecret.static))), @as(u8, @bitCast(@as(u8, @truncate(mac_length)))));
    } else {
        _ = _private_tls_hkdf_extract(mac_length, @as([*c]u8, @ptrCast(@alignCast(&prk))), mac_length, null, @as(c_uint, @bitCast(@as(c_int, 0))), @as([*c]u8, @ptrCast(@alignCast(&earlysecret.static))), @as(u8, @bitCast(@as(u8, @truncate(mac_length)))));
        _private_tls_hkdf_expand_label(mac_length, @as([*c]u8, @ptrCast(@alignCast(&salt))), mac_length, @as([*c]u8, @ptrCast(@alignCast(&prk))), mac_length, "derived", @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 7))))), @as([*c]u8, @ptrCast(@alignCast(&hash))), @as(u8, @bitCast(@as(u8, @truncate(mac_length)))));
        _ = _private_tls_hkdf_extract(mac_length, @as([*c]u8, @ptrCast(@alignCast(&prk))), mac_length, @as([*c]u8, @ptrCast(@alignCast(&salt))), mac_length, context.*.premaster_key, @as(u8, @bitCast(@as(u8, @truncate(context.*.premaster_key_len)))));
    }
    if (!(is_aead != 0)) {
        return 0;
    }
    var secret: [48]u8 = undefined;
    _ = &secret;
    var hs_secret: [48]u8 = undefined;
    _ = &hs_secret;
    var hash_size: c_int = undefined;
    _ = &hash_size;
    if (handshake != 0) {
        hash_size = _private_tls_get_hash(context, @as([*c]u8, @ptrCast(@alignCast(&hash))));
    } else {
        hash_size = _private_tls_done_hash(context, @as([*c]u8, @ptrCast(@alignCast(&hash))));
    }
    if (context.*.is_server != 0) {
        _private_tls_hkdf_expand_label(mac_length, @as([*c]u8, @ptrCast(@alignCast(&hs_secret))), mac_length, @as([*c]u8, @ptrCast(@alignCast(&prk))), mac_length, server_key, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 12))))), if (context.*.server_finished_hash != null) context.*.server_finished_hash else @as([*c]u8, @ptrCast(@alignCast(&hash))), @as(u8, @bitCast(@as(i8, @truncate(hash_size)))));
        serverkey = @as([*c]u8, @ptrCast(@alignCast(&local_keybuffer)));
        serveriv = @as([*c]u8, @ptrCast(@alignCast(&local_ivbuffer)));
        clientkey = @as([*c]u8, @ptrCast(@alignCast(&remote_keybuffer)));
        clientiv = @as([*c]u8, @ptrCast(@alignCast(&remote_ivbuffer)));
    } else {
        _private_tls_hkdf_expand_label(mac_length, @as([*c]u8, @ptrCast(@alignCast(&hs_secret))), mac_length, @as([*c]u8, @ptrCast(@alignCast(&prk))), mac_length, client_key, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 12))))), if (context.*.server_finished_hash != null) context.*.server_finished_hash else @as([*c]u8, @ptrCast(@alignCast(&hash))), @as(u8, @bitCast(@as(i8, @truncate(hash_size)))));
        serverkey = @as([*c]u8, @ptrCast(@alignCast(&remote_keybuffer)));
        serveriv = @as([*c]u8, @ptrCast(@alignCast(&remote_ivbuffer)));
        clientkey = @as([*c]u8, @ptrCast(@alignCast(&local_keybuffer)));
        clientiv = @as([*c]u8, @ptrCast(@alignCast(&local_ivbuffer)));
    }
    var iv_length: c_int = 12;
    _ = &iv_length;
    if (is_aead == @as(c_int, 2)) {
        iv_length = 12;
    }
    _private_tls_hkdf_expand_label(mac_length, @as([*c]u8, @ptrCast(@alignCast(&local_keybuffer))), @as(c_uint, @bitCast(key_length)), @as([*c]u8, @ptrCast(@alignCast(&hs_secret))), mac_length, "key", @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 3))))), null, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
    _private_tls_hkdf_expand_label(mac_length, @as([*c]u8, @ptrCast(@alignCast(&local_ivbuffer))), @as(c_uint, @bitCast(iv_length)), @as([*c]u8, @ptrCast(@alignCast(&hs_secret))), mac_length, "iv", @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 2))))), null, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
    if (context.*.is_server != 0) {
        _private_tls_hkdf_expand_label(mac_length, @as([*c]u8, @ptrCast(@alignCast(&secret))), mac_length, @as([*c]u8, @ptrCast(@alignCast(&prk))), mac_length, client_key, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 12))))), if (context.*.server_finished_hash != null) context.*.server_finished_hash else @as([*c]u8, @ptrCast(@alignCast(&hash))), @as(u8, @bitCast(@as(i8, @truncate(hash_size)))));
    } else {
        _private_tls_hkdf_expand_label(mac_length, @as([*c]u8, @ptrCast(@alignCast(&secret))), mac_length, @as([*c]u8, @ptrCast(@alignCast(&prk))), mac_length, server_key, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 12))))), if (context.*.server_finished_hash != null) context.*.server_finished_hash else @as([*c]u8, @ptrCast(@alignCast(&hash))), @as(u8, @bitCast(@as(i8, @truncate(hash_size)))));
    }
    _private_tls_hkdf_expand_label(mac_length, @as([*c]u8, @ptrCast(@alignCast(&remote_keybuffer))), @as(c_uint, @bitCast(key_length)), @as([*c]u8, @ptrCast(@alignCast(&secret))), mac_length, "key", @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 3))))), null, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
    _private_tls_hkdf_expand_label(mac_length, @as([*c]u8, @ptrCast(@alignCast(&remote_ivbuffer))), @as(c_uint, @bitCast(iv_length)), @as([*c]u8, @ptrCast(@alignCast(&secret))), mac_length, "iv", @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 2))))), null, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
    if (context.*.finished_key != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.finished_key)));
    }
    if (context.*.remote_finished_key != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.remote_finished_key)));
    }
    if (handshake != 0) {
        context.*.finished_key = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, mac_length)))))));
        context.*.remote_finished_key = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, mac_length)))))));
        if (context.*.finished_key != null) {
            _private_tls_hkdf_expand_label(mac_length, context.*.finished_key, mac_length, @as([*c]u8, @ptrCast(@alignCast(&hs_secret))), mac_length, "finished", @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 8))))), null, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
        }
        if (context.*.remote_finished_key != null) {
            _private_tls_hkdf_expand_label(mac_length, context.*.remote_finished_key, mac_length, @as([*c]u8, @ptrCast(@alignCast(&secret))), mac_length, "finished", @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 8))))), null, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
        }
    } else {
        context.*.finished_key = null;
        context.*.remote_finished_key = null;
        if (context.*.server_finished_hash != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.server_finished_hash)));
        }
        context.*.server_finished_hash = null;
    }
    if (context.*.is_server != 0) {
        if (is_aead == @as(c_int, 2)) {
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_nonce))))), @as(?*const anyopaque, @ptrCast(clientiv)), @as(c_ulong, @bitCast(@as(c_long, iv_length))));
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_nonce))))), @as(?*const anyopaque, @ptrCast(serveriv)), @as(c_ulong, @bitCast(@as(c_long, iv_length))));
        } else if (is_aead != 0) {
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_iv))))), @as(?*const anyopaque, @ptrCast(clientiv)), @as(c_ulong, @bitCast(@as(c_long, iv_length))));
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_iv))))), @as(?*const anyopaque, @ptrCast(serveriv)), @as(c_ulong, @bitCast(@as(c_long, iv_length))));
        }
        if (_private_tls_crypto_create(context, key_length, serverkey, serveriv, clientkey, clientiv) != 0) return 0;
    } else {
        if (is_aead == @as(c_int, 2)) {
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_nonce))))), @as(?*const anyopaque, @ptrCast(clientiv)), @as(c_ulong, @bitCast(@as(c_long, iv_length))));
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_nonce))))), @as(?*const anyopaque, @ptrCast(serveriv)), @as(c_ulong, @bitCast(@as(c_long, iv_length))));
        } else if (is_aead != 0) {
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_iv))))), @as(?*const anyopaque, @ptrCast(clientiv)), @as(c_ulong, @bitCast(@as(c_long, iv_length))));
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_iv))))), @as(?*const anyopaque, @ptrCast(serveriv)), @as(c_ulong, @bitCast(@as(c_long, iv_length))));
        }
        if (_private_tls_crypto_create(context, key_length, clientkey, clientiv, serverkey, serveriv) != 0) return 0;
    }
    context.*.crypto.created = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 1) + is_aead))));
    if (context.*.exportable != 0) {
        if (context.*.exportable_keys != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.exportable_keys)));
        }
        context.*.exportable_keys = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, key_length * @as(c_int, 2))))))));
        if (context.*.exportable_keys != null) {
            if (context.*.is_server != 0) {
                _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.exportable_keys)), @as(?*const anyopaque, @ptrCast(serverkey)), @as(c_ulong, @bitCast(@as(c_long, key_length))));
                _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.exportable_keys + @as(usize, @bitCast(@as(isize, @intCast(key_length)))))), @as(?*const anyopaque, @ptrCast(clientkey)), @as(c_ulong, @bitCast(@as(c_long, key_length))));
            } else {
                _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.exportable_keys)), @as(?*const anyopaque, @ptrCast(clientkey)), @as(c_ulong, @bitCast(@as(c_long, key_length))));
                _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.exportable_keys + @as(usize, @bitCast(@as(isize, @intCast(key_length)))))), @as(?*const anyopaque, @ptrCast(serverkey)), @as(c_ulong, @bitCast(@as(c_long, key_length))));
            }
            context.*.exportable_size = @as(u8, @bitCast(@as(i8, @truncate(key_length * @as(c_int, 2)))));
        }
    }
    if (context.*.master_key != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.master_key)));
    }
    context.*.master_key = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, mac_length)))))));
    if (context.*.master_key != null) {
        _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.master_key)), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&prk))))), @as(c_ulong, @bitCast(@as(c_ulong, mac_length))));
        context.*.master_key_len = mac_length;
    }
    context.*.local_sequence_number = 0;
    context.*.remote_sequence_number = 0;
    return 1;
}
pub export fn _private_tls_expand_key(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    var key: [192]u8 = undefined;
    _ = &key;
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) return 0;
    if (!(context.*.master_key != null) or !(context.*.master_key_len != 0)) return 0;
    var key_length: c_int = _private_tls_key_length(context);
    _ = &key_length;
    var mac_length: c_int = @as(c_int, @bitCast(_private_tls_mac_length(context)));
    _ = &mac_length;
    if (!(key_length != 0) or !(mac_length != 0)) {
        return 0;
    }
    var clientkey: [*c]u8 = null;
    _ = &clientkey;
    var serverkey: [*c]u8 = null;
    _ = &serverkey;
    var clientiv: [*c]u8 = null;
    _ = &clientiv;
    var serveriv: [*c]u8 = null;
    _ = &serveriv;
    var iv_length: c_int = 16;
    _ = &iv_length;
    var is_aead: c_int = _private_tls_is_aead(context);
    _ = &is_aead;
    if (context.*.is_server != 0) {
        _private_tls_prf(context, @as([*c]u8, @ptrCast(@alignCast(&key))), @as(c_uint, @bitCast(@as(c_uint, @truncate(@sizeOf([192]u8))))), context.*.master_key, context.*.master_key_len, @as([*c]u8, @ptrCast(@alignCast("key expansion"))), @as(c_uint, @bitCast(@as(c_int, 13))), @as([*c]u8, @ptrCast(@alignCast(&context.*.local_random))), @as(c_uint, @bitCast(@as(c_int, 32))), @as([*c]u8, @ptrCast(@alignCast(&context.*.remote_random))), @as(c_uint, @bitCast(@as(c_int, 32))));
    } else {
        _private_tls_prf(context, @as([*c]u8, @ptrCast(@alignCast(&key))), @as(c_uint, @bitCast(@as(c_uint, @truncate(@sizeOf([192]u8))))), context.*.master_key, context.*.master_key_len, @as([*c]u8, @ptrCast(@alignCast("key expansion"))), @as(c_uint, @bitCast(@as(c_int, 13))), @as([*c]u8, @ptrCast(@alignCast(&context.*.remote_random))), @as(c_uint, @bitCast(@as(c_int, 32))), @as([*c]u8, @ptrCast(@alignCast(&context.*.local_random))), @as(c_uint, @bitCast(@as(c_int, 32))));
    }
    var pos: c_int = 0;
    _ = &pos;
    if (is_aead == @as(c_int, 2)) {
        iv_length = 12;
    } else if (is_aead != 0) {
        iv_length = 4;
    } else {
        if (context.*.is_server != 0) {
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_mac))))), @as(?*const anyopaque, @ptrCast(&key[@as(c_uint, @intCast(pos))])), @as(c_ulong, @bitCast(@as(c_long, mac_length))));
            pos += mac_length;
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_mac))))), @as(?*const anyopaque, @ptrCast(&key[@as(c_uint, @intCast(pos))])), @as(c_ulong, @bitCast(@as(c_long, mac_length))));
            pos += mac_length;
        } else {
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_mac))))), @as(?*const anyopaque, @ptrCast(&key[@as(c_uint, @intCast(pos))])), @as(c_ulong, @bitCast(@as(c_long, mac_length))));
            pos += mac_length;
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_mac))))), @as(?*const anyopaque, @ptrCast(&key[@as(c_uint, @intCast(pos))])), @as(c_ulong, @bitCast(@as(c_long, mac_length))));
            pos += mac_length;
        }
    }
    clientkey = &key[@as(c_uint, @intCast(pos))];
    pos += key_length;
    serverkey = &key[@as(c_uint, @intCast(pos))];
    pos += key_length;
    clientiv = &key[@as(c_uint, @intCast(pos))];
    pos += iv_length;
    serveriv = &key[@as(c_uint, @intCast(pos))];
    pos += iv_length;
    if (context.*.is_server != 0) {
        if (is_aead == @as(c_int, 2)) {
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_nonce))))), @as(?*const anyopaque, @ptrCast(clientiv)), @as(c_ulong, @bitCast(@as(c_long, iv_length))));
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_nonce))))), @as(?*const anyopaque, @ptrCast(serveriv)), @as(c_ulong, @bitCast(@as(c_long, iv_length))));
        } else if (is_aead != 0) {
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_aead_iv))))), @as(?*const anyopaque, @ptrCast(clientiv)), @as(c_ulong, @bitCast(@as(c_long, iv_length))));
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_aead_iv))))), @as(?*const anyopaque, @ptrCast(serveriv)), @as(c_ulong, @bitCast(@as(c_long, iv_length))));
        }
        if (_private_tls_crypto_create(context, key_length, serverkey, serveriv, clientkey, clientiv) != 0) return 0;
    } else {
        if (is_aead == @as(c_int, 2)) {
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_nonce))))), @as(?*const anyopaque, @ptrCast(clientiv)), @as(c_ulong, @bitCast(@as(c_long, iv_length))));
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_nonce))))), @as(?*const anyopaque, @ptrCast(serveriv)), @as(c_ulong, @bitCast(@as(c_long, iv_length))));
        } else if (is_aead != 0) {
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_local_mac.local_aead_iv))))), @as(?*const anyopaque, @ptrCast(clientiv)), @as(c_ulong, @bitCast(@as(c_long, iv_length))));
            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.crypto.ctx_remote_mac.remote_aead_iv))))), @as(?*const anyopaque, @ptrCast(serveriv)), @as(c_ulong, @bitCast(@as(c_long, iv_length))));
        }
        if (_private_tls_crypto_create(context, key_length, clientkey, clientiv, serverkey, serveriv) != 0) return 0;
    }
    if (context.*.exportable != 0) {
        if (context.*.exportable_keys != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.exportable_keys)));
        }
        context.*.exportable_keys = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, key_length * @as(c_int, 2))))))));
        if (context.*.exportable_keys != null) {
            if (context.*.is_server != 0) {
                _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.exportable_keys)), @as(?*const anyopaque, @ptrCast(serverkey)), @as(c_ulong, @bitCast(@as(c_long, key_length))));
                _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.exportable_keys + @as(usize, @bitCast(@as(isize, @intCast(key_length)))))), @as(?*const anyopaque, @ptrCast(clientkey)), @as(c_ulong, @bitCast(@as(c_long, key_length))));
            } else {
                _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.exportable_keys)), @as(?*const anyopaque, @ptrCast(clientkey)), @as(c_ulong, @bitCast(@as(c_long, key_length))));
                _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.exportable_keys + @as(usize, @bitCast(@as(isize, @intCast(key_length)))))), @as(?*const anyopaque, @ptrCast(serverkey)), @as(c_ulong, @bitCast(@as(c_long, key_length))));
            }
            context.*.exportable_size = @as(u8, @bitCast(@as(i8, @truncate(key_length * @as(c_int, 2)))));
        }
    }
    return 1;
}
pub export fn _private_tls_compute_key(arg_context: [*c]struct_TLSContext, arg_key_len: c_uint) c_int {
    var context = arg_context;
    _ = &context;
    var key_len = arg_key_len;
    _ = &key_len;
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) return 0;
    if ((!(context.*.premaster_key != null) or !(context.*.premaster_key_len != 0)) or (key_len < @as(c_uint, @bitCast(@as(c_int, 48))))) {
        return 0;
    }
    var master_secret_label: [13:0]u8 = "master secret".*;
    _ = &master_secret_label;
    if (context.*.master_key != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.master_key)));
    }
    context.*.master_key_len = 0;
    context.*.master_key = null;
    if (((((((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 770))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 769))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65277))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65279))) {
        context.*.master_key = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, key_len)))))));
        if (!(context.*.master_key != null)) return 0;
        context.*.master_key_len = key_len;
        if (context.*.is_server != 0) {
            _private_tls_prf(context, context.*.master_key, context.*.master_key_len, context.*.premaster_key, context.*.premaster_key_len, @as([*c]u8, @ptrCast(@alignCast(&master_secret_label))), @as(c_uint, @bitCast(@as(c_int, 13))), @as([*c]u8, @ptrCast(@alignCast(&context.*.remote_random))), @as(c_uint, @bitCast(@as(c_int, 32))), @as([*c]u8, @ptrCast(@alignCast(&context.*.local_random))), @as(c_uint, @bitCast(@as(c_int, 32))));
        } else {
            _private_tls_prf(context, context.*.master_key, context.*.master_key_len, context.*.premaster_key, context.*.premaster_key_len, @as([*c]u8, @ptrCast(@alignCast(&master_secret_label))), @as(c_uint, @bitCast(@as(c_int, 13))), @as([*c]u8, @ptrCast(@alignCast(&context.*.local_random))), @as(c_uint, @bitCast(@as(c_int, 32))), @as([*c]u8, @ptrCast(@alignCast(&context.*.remote_random))), @as(c_uint, @bitCast(@as(c_int, 32))));
        }
        if (context.*.premaster_key != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.premaster_key)));
        }
        context.*.premaster_key = null;
        context.*.premaster_key_len = 0;
        _ = _private_tls_expand_key(context);
        return 1;
    }
    return 0;
}
pub export fn _is_oid(arg_oid: [*c]const u8, arg_compare_to: [*c]const u8, arg_compare_to_len: c_int) c_int {
    var oid = arg_oid;
    _ = &oid;
    var compare_to = arg_compare_to;
    _ = &compare_to;
    var compare_to_len = arg_compare_to_len;
    _ = &compare_to_len;
    var i: c_int = 0;
    _ = &i;
    while ((@as(c_int, @bitCast(@as(c_uint, (blk: {
        const tmp = i;
        if (tmp >= 0) break :blk oid + @as(usize, @intCast(tmp)) else break :blk oid - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*))) != 0) and (i < compare_to_len)) {
        if (@as(c_int, @bitCast(@as(c_uint, (blk: {
            const tmp = i;
            if (tmp >= 0) break :blk oid + @as(usize, @intCast(tmp)) else break :blk oid - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))) != @as(c_int, @bitCast(@as(c_uint, (blk: {
            const tmp = i;
            if (tmp >= 0) break :blk compare_to + @as(usize, @intCast(tmp)) else break :blk compare_to - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*)))) return 0;
        i += 1;
    }
    return 1;
}
pub export fn _is_oid2(arg_oid: [*c]const u8, arg_compare_to: [*c]const u8, arg_compare_to_len: c_int, arg_oid_len: c_int) c_int {
    var oid = arg_oid;
    _ = &oid;
    var compare_to = arg_compare_to;
    _ = &compare_to;
    var compare_to_len = arg_compare_to_len;
    _ = &compare_to_len;
    var oid_len = arg_oid_len;
    _ = &oid_len;
    var i: c_int = 0;
    _ = &i;
    if (oid_len < compare_to_len) {
        compare_to_len = oid_len;
    }
    while (i < compare_to_len) {
        if (@as(c_int, @bitCast(@as(c_uint, (blk: {
            const tmp = i;
            if (tmp >= 0) break :blk oid + @as(usize, @intCast(tmp)) else break :blk oid - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))) != @as(c_int, @bitCast(@as(c_uint, (blk: {
            const tmp = i;
            if (tmp >= 0) break :blk compare_to + @as(usize, @intCast(tmp)) else break :blk compare_to - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*)))) return 0;
        i += 1;
    }
    return 1;
}
pub export fn _private_tls_crypto_encrypt(arg_context: [*c]struct_TLSContext, arg_buf: [*c]u8, arg_ct: [*c]u8, arg_len: c_uint) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var ct = arg_ct;
    _ = &ct;
    var len = arg_len;
    _ = &len;
    if (@as(c_int, @bitCast(@as(c_uint, context.*.crypto.created))) == @as(c_int, 1)) return cbc_encrypt(buf, ct, @as(c_ulong, @bitCast(@as(c_ulong, len))), &context.*.crypto.ctx_local.aes_local);
    _ = memset(@as(?*anyopaque, @ptrCast(ct)), @as(c_int, 0), @as(c_ulong, @bitCast(@as(c_ulong, len))));
    return -@as(c_int, 1);
}
pub export fn _private_tls_crypto_decrypt(arg_context: [*c]struct_TLSContext, arg_buf: [*c]u8, arg_pt: [*c]u8, arg_len: c_uint) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var pt = arg_pt;
    _ = &pt;
    var len = arg_len;
    _ = &len;
    if (@as(c_int, @bitCast(@as(c_uint, context.*.crypto.created))) == @as(c_int, 1)) return cbc_decrypt(buf, pt, @as(c_ulong, @bitCast(@as(c_ulong, len))), &context.*.crypto.ctx_remote.aes_remote);
    _ = memset(@as(?*anyopaque, @ptrCast(pt)), @as(c_int, 0), @as(c_ulong, @bitCast(@as(c_ulong, len))));
    return -@as(c_int, 1);
}
pub export fn _private_tls_crypto_done(arg_context: [*c]struct_TLSContext) void {
    var context = arg_context;
    _ = &context;
    var dummy_buffer: [32]u8 = undefined;
    _ = &dummy_buffer;
    var tag_len: c_ulong = 0;
    _ = &tag_len;
    while (true) {
        switch (@as(c_int, @bitCast(@as(c_uint, context.*.crypto.created)))) {
            @as(c_int, 1) => {
                _ = cbc_done(&context.*.crypto.ctx_remote.aes_remote);
                _ = cbc_done(&context.*.crypto.ctx_local.aes_local);
                break;
            },
            @as(c_int, 2) => {
                _ = gcm_done(&context.*.crypto.ctx_remote.aes_gcm_remote, @as([*c]u8, @ptrCast(@alignCast(&dummy_buffer))), &tag_len);
                _ = gcm_done(&context.*.crypto.ctx_local.aes_gcm_local, @as([*c]u8, @ptrCast(@alignCast(&dummy_buffer))), &tag_len);
                break;
            },
            else => {},
        }
        break;
    }
    context.*.crypto.created = 0;
}
pub export fn _private_tls_ensure_hash(arg_context: [*c]struct_TLSContext) [*c]TLSHash {
    var context = arg_context;
    _ = &context;
    var hash: [*c]TLSHash = context.*.handshake_hash;
    _ = &hash;
    if (!(hash != null)) {
        hash = @as([*c]TLSHash, @ptrCast(@alignCast(malloc(@sizeOf(TLSHash)))));
        if (hash != null) {
            _ = memset(@as(?*anyopaque, @ptrCast(hash)), @as(c_int, 0), @sizeOf(TLSHash));
        }
        context.*.handshake_hash = hash;
    }
    return hash;
}
pub export fn _private_tls_destroy_hash(arg_context: [*c]struct_TLSContext) void {
    var context = arg_context;
    _ = &context;
    if (context != null) {
        if (context.*.handshake_hash != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.handshake_hash)));
        }
        context.*.handshake_hash = null;
    }
}
pub export fn _private_tls_create_hash(arg_context: [*c]struct_TLSContext) void {
    var context = arg_context;
    _ = &context;
    if (!(context != null)) return;
    var hash: [*c]TLSHash = _private_tls_ensure_hash(context);
    _ = &hash;
    if ((((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65277))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
        var hash_size: c_int = @as(c_int, @bitCast(_private_tls_mac_length(context)));
        _ = &hash_size;
        if (hash.*.created != 0) {
            var temp: [48]u8 = undefined;
            _ = &temp;
            _ = sha384_done(&hash.*.hash32, @as([*c]u8, @ptrCast(@alignCast(&temp))));
            _ = sha256_done(&hash.*.hash48, @as([*c]u8, @ptrCast(@alignCast(&temp))));
        }
        _ = sha384_init(&hash.*.hash48);
        _ = sha256_init(&hash.*.hash32);
        hash.*.created = 1;
    } else {
        if (hash.*.created != 0) {
            var temp: [36]u8 = undefined;
            _ = &temp;
            _ = md5_done(&hash.*.hash32, @as([*c]u8, @ptrCast(@alignCast(&temp))));
            _ = sha1_done(&hash.*.hash2, @as([*c]u8, @ptrCast(@alignCast(&temp))));
        }
        _ = md5_init(&hash.*.hash32);
        _ = sha1_init(&hash.*.hash2);
        hash.*.created = 1;
    }
}
pub export fn _private_tls_update_handshake_list(arg_context: [*c]struct_TLSContext, arg_in: [*c]const u8, arg_len: c_uint, arg_direction: u8, arg_connection_status: u8) void {
    var context = arg_context;
    _ = &context;
    var in = arg_in;
    _ = &in;
    var len = arg_len;
    _ = &len;
    var direction = arg_direction;
    _ = &direction;
    var connection_status = arg_connection_status;
    _ = &connection_status;
    if (((!(context != null) or !(context.*.dtls != 0)) or !(in != null)) or !(len != 0)) return;
    var msg: [*c]struct_TLSHandshakeList = @as([*c]struct_TLSHandshakeList, @ptrCast(@alignCast(malloc(@sizeOf(struct_TLSHandshakeList)))));
    _ = &msg;
    if (!(msg != null)) return;
    msg.*.msg = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, len)))))));
    if (!(msg != null)) {
        if (msg != null) {
            free(@as(?*anyopaque, @ptrCast(msg)));
        }
        return;
    }
    _ = memcpy(@as(?*anyopaque, @ptrCast(msg.*.msg)), @as(?*const anyopaque, @ptrCast(in)), @as(c_ulong, @bitCast(@as(c_ulong, len))));
    msg.*.len = len;
    msg.*.direction = direction;
    msg.*.connection_status = @as(u8, @bitCast(@as(i8, @truncate(if (@as(c_int, @bitCast(@as(c_uint, connection_status))) != 0) @as(c_int, @bitCast(@as(c_uint, connection_status))) else @as(c_int, @bitCast(@as(c_uint, context.*.connection_status)))))));
    msg.*.next = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
    if (!(context.*.dtls_data.*.dtls_handshake_list != null)) {
        context.*.dtls_data.*.dtls_handshake_list = msg;
        return;
    }
    var last: [*c]struct_TLSHandshakeList = context.*.dtls_data.*.dtls_handshake_list;
    _ = &last;
    while (last.*.next != null) {
        last = @as([*c]struct_TLSHandshakeList, @ptrCast(@alignCast(last.*.next)));
    }
    last.*.next = @as(?*anyopaque, @ptrCast(msg));
}
pub export fn _private_tls_change_hash_type(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    if (!(context != null)) return 0;
    var hash: [*c]TLSHash = _private_tls_ensure_hash(context);
    _ = &hash;
    if ((((hash != null) and (@as(c_int, @bitCast(@as(c_uint, hash.*.created))) != 0)) and (context.*.cached_handshake != null)) and (context.*.cached_handshake_len != 0)) {
        _private_tls_destroy_hash(context);
        var res: c_int = _private_tls_update_hash(context, context.*.cached_handshake, context.*.cached_handshake_len, @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 0))))));
        _ = &res;
        if (context.*.cached_handshake != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.cached_handshake)));
        }
        context.*.cached_handshake = null;
        context.*.cached_handshake_len = 0;
        return res;
    }
    return 0;
}
pub export fn _private_tls_write_packet(arg_packet: [*c]struct_TLSPacket) c_int {
    var packet = arg_packet;
    _ = &packet;
    if (!(packet != null)) return -@as(c_int, 1);
    var context: [*c]struct_TLSContext = packet.*.context;
    _ = &context;
    if (!(context != null)) return -@as(c_int, 1);
    if (context.*.tls_buffer != null) {
        var len: c_int = @as(c_int, @bitCast(context.*.tls_buffer_len +% packet.*.len));
        _ = &len;
        context.*.tls_buffer = @as([*c]u8, @ptrCast(@alignCast(realloc(@as(?*anyopaque, @ptrCast(context.*.tls_buffer)), @as(c_ulong, @bitCast(@as(c_long, len)))))));
        if (!(context.*.tls_buffer != null)) {
            context.*.tls_buffer_len = 0;
            return -@as(c_int, 1);
        }
        _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.tls_buffer + context.*.tls_buffer_len)), @as(?*const anyopaque, @ptrCast(packet.*.buf)), @as(c_ulong, @bitCast(@as(c_ulong, packet.*.len))));
        context.*.tls_buffer_len = @as(c_uint, @bitCast(len));
        var written: c_int = @as(c_int, @bitCast(packet.*.len));
        _ = &written;
        tls_destroy_packet(packet);
        return written;
    }
    context.*.tls_buffer_len = packet.*.len;
    context.*.tls_buffer = packet.*.buf;
    packet.*.buf = null;
    packet.*.len = 0;
    packet.*.size = 0;
    tls_destroy_packet(packet);
    return @as(c_int, @bitCast(context.*.tls_buffer_len));
}
pub export fn _private_tls_write_app_data(arg_context: [*c]struct_TLSContext, arg_buf: [*c]const u8, arg_buf_len: c_uint) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    if (!(context != null)) return -@as(c_int, 1);
    if (!(buf != null) or !(buf_len != 0)) return 0;
    var len: c_int = @as(c_int, @bitCast(context.*.application_buffer_len +% buf_len));
    _ = &len;
    context.*.application_buffer = @as([*c]u8, @ptrCast(@alignCast(realloc(@as(?*anyopaque, @ptrCast(context.*.application_buffer)), @as(c_ulong, @bitCast(@as(c_long, len)))))));
    if (!(context.*.application_buffer != null)) {
        context.*.application_buffer_len = 0;
        return -@as(c_int, 1);
    }
    _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.application_buffer + context.*.application_buffer_len)), @as(?*const anyopaque, @ptrCast(buf)), @as(c_ulong, @bitCast(@as(c_ulong, buf_len))));
    context.*.application_buffer_len = @as(c_uint, @bitCast(len));
    return @as(c_int, @bitCast(buf_len));
}
pub export fn tls_get_message(arg_context: [*c]struct_TLSContext, arg_outlen: [*c]c_uint, arg_offset: c_uint) [*c]const u8 {
    var context = arg_context;
    _ = &context;
    var outlen = arg_outlen;
    _ = &outlen;
    var offset = arg_offset;
    _ = &offset;
    if (!(outlen != null)) return null;
    if (!(context != null) or !(context.*.tls_buffer != null)) {
        outlen.* = 0;
        return null;
    }
    if (offset >= context.*.tls_buffer_len) {
        outlen.* = 0;
        return null;
    }
    if (context.*.sleep_until != 0) {
        if (@as(time_t, @bitCast(@as(c_ulong, context.*.sleep_until))) < time(null)) {
            outlen.* = 0;
            return null;
        }
        context.*.sleep_until = 0;
    }
    var tls_buffer: [*c]u8 = &context.*.tls_buffer[offset];
    _ = &tls_buffer;
    var tls_buffer_len: c_uint = context.*.tls_buffer_len -% offset;
    _ = &tls_buffer_len;
    var len: c_uint = 0;
    _ = &len;
    if (context.*.dtls != 0) {
        if (tls_buffer_len < @as(c_uint, @bitCast(@as(c_int, 13)))) {
            outlen.* = 0;
            return null;
        }
        len = @as(c_uint, @bitCast(@as(c_int, @bitCast(@as(c_uint, ntohs(@as([*c]c_ushort, @ptrCast(@alignCast(&tls_buffer[@as(c_uint, @intCast(@as(c_int, 11)))]))).*)))) + @as(c_int, 13)));
    } else {
        if (tls_buffer_len < @as(c_uint, @bitCast(@as(c_int, 5)))) {
            outlen.* = 0;
            return null;
        }
        len = @as(c_uint, @bitCast(@as(c_int, @bitCast(@as(c_uint, ntohs(@as([*c]c_ushort, @ptrCast(@alignCast(&tls_buffer[@as(c_uint, @intCast(@as(c_int, 3)))]))).*)))) + @as(c_int, 5)));
    }
    if (len > tls_buffer_len) {
        outlen.* = 0;
        return null;
    }
    outlen.* = len;
    return tls_buffer;
}
pub export fn _private_tls_dhe_create(arg_context: [*c]struct_TLSContext) void {
    var context = arg_context;
    _ = &context;
    _private_tls_dhe_free(context);
    context.*.dhe = @as([*c]DHKey, @ptrCast(@alignCast(malloc(@sizeOf(DHKey)))));
    if (context.*.dhe != null) {
        _ = memset(@as(?*anyopaque, @ptrCast(context.*.dhe)), @as(c_int, 0), @sizeOf(DHKey));
    }
}
pub export fn _private_tls_ecc_dhe_create(arg_context: [*c]struct_TLSContext) void {
    var context = arg_context;
    _ = &context;
    _private_tls_ecc_dhe_free(context);
    context.*.ecc_dhe = @as([*c]ecc_key, @ptrCast(@alignCast(malloc(@sizeOf(ecc_key)))));
    _ = memset(@as(?*anyopaque, @ptrCast(context.*.ecc_dhe)), @as(c_int, 0), @sizeOf(ecc_key));
}
pub export fn _private_tls_dh_export_Y(arg_Ybuf: [*c]u8, arg_Ylen: [*c]c_ulong, arg_key: [*c]DHKey) c_int {
    var Ybuf = arg_Ybuf;
    _ = &Ybuf;
    var Ylen = arg_Ylen;
    _ = &Ylen;
    var key = arg_key;
    _ = &key;
    var len: c_ulong = undefined;
    _ = &len;
    if (((Ybuf == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) or (Ylen == @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) or (key == @as([*c]DHKey, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) return -@as(c_int, 1);
    len = ltc_mp.unsigned_size.?(key.*.y);
    if (len > Ylen.*) return -@as(c_int, 1);
    Ylen.* = len;
    return 0;
}
pub export fn _private_tls_dh_export_pqY(arg_pbuf: [*c]u8, arg_plen: [*c]c_ulong, arg_gbuf: [*c]u8, arg_glen: [*c]c_ulong, arg_Ybuf: [*c]u8, arg_Ylen: [*c]c_ulong, arg_key: [*c]DHKey) c_int {
    var pbuf = arg_pbuf;
    _ = &pbuf;
    var plen = arg_plen;
    _ = &plen;
    var gbuf = arg_gbuf;
    _ = &gbuf;
    var glen = arg_glen;
    _ = &glen;
    var Ybuf = arg_Ybuf;
    _ = &Ybuf;
    var Ylen = arg_Ylen;
    _ = &Ylen;
    var key = arg_key;
    _ = &key;
    var len: c_ulong = undefined;
    _ = &len;
    var err: c_int = undefined;
    _ = &err;
    if (((((((pbuf == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) or (plen == @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) or (gbuf == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) or (glen == @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) or (Ybuf == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) or (Ylen == @as([*c]c_ulong, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) or (key == @as([*c]DHKey, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) return -@as(c_int, 1);
    len = ltc_mp.unsigned_size.?(key.*.y);
    if (len > Ylen.*) return -@as(c_int, 1);
    if ((blk: {
        const tmp = ltc_mp.unsigned_write.?(key.*.y, Ybuf);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) return err;
    Ylen.* = len;
    len = ltc_mp.unsigned_size.?(key.*.p);
    if (len > plen.*) return -@as(c_int, 1);
    if ((blk: {
        const tmp = ltc_mp.unsigned_write.?(key.*.p, pbuf);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) return err;
    plen.* = len;
    len = ltc_mp.unsigned_size.?(key.*.g);
    if (len > glen.*) return -@as(c_int, 1);
    if ((blk: {
        const tmp = ltc_mp.unsigned_write.?(key.*.g, gbuf);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) return err;
    glen.* = len;
    return 0;
}
pub export fn _private_tls_dh_make_key(arg_keysize: c_int, arg_key: [*c]DHKey, arg_pbuf: [*c]const u8, arg_gbuf: [*c]const u8, arg_pbuf_len: c_int, arg_gbuf_len: c_int) c_int {
    var keysize = arg_keysize;
    _ = &keysize;
    var key = arg_key;
    _ = &key;
    var pbuf = arg_pbuf;
    _ = &pbuf;
    var gbuf = arg_gbuf;
    _ = &gbuf;
    var pbuf_len = arg_pbuf_len;
    _ = &pbuf_len;
    var gbuf_len = arg_gbuf_len;
    _ = &gbuf_len;
    var buf: [*c]u8 = undefined;
    _ = &buf;
    var err: c_int = undefined;
    _ = &err;
    if (!(key != null)) return -@as(c_int, 1);
    const prng = struct {
        var static: prng_state = @import("std").mem.zeroes(prng_state);
    };
    _ = &prng;
    var wprng: c_int = find_prng("sprng");
    _ = &wprng;
    if ((blk: {
        const tmp = prng_is_valid(wprng);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) return err;
    buf = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, keysize)))))));
    if (!(buf != null)) return -@as(c_int, 9);
    if (rng_make_prng(keysize, wprng, &prng.static, null) != CRYPT_OK) {
        if (buf != null) {
            free(@as(?*anyopaque, @ptrCast(buf)));
        }
        return -@as(c_int, 1);
    }
    if (prng_descriptor[@as(c_uint, @intCast(wprng))].read.?(buf, @as(c_ulong, @bitCast(@as(c_long, keysize))), &prng.static) != @as(c_ulong, @bitCast(@as(c_long, keysize)))) {
        if (buf != null) {
            free(@as(?*anyopaque, @ptrCast(buf)));
        }
        return -@as(c_int, 1);
    }
    if ((blk: {
        const tmp = ltc_init_multi(&key.*.g, &key.*.p, &key.*.x, &key.*.y, @as(?*anyopaque, @ptrFromInt(@as(c_int, 0))));
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        if (buf != null) {
            free(@as(?*anyopaque, @ptrCast(buf)));
        }
        return -@as(c_int, 1);
    }
    if (gbuf_len <= @as(c_int, 0)) {
        if ((blk: {
            const tmp = ltc_mp.read_radix.?(key.*.g, gbuf, @as(c_int, 16));
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            if (buf != null) {
                free(@as(?*anyopaque, @ptrCast(buf)));
            }
            _private_tls_dh_clear_key(key);
            return -@as(c_int, 1);
        }
    } else {
        if ((blk: {
            const tmp = ltc_mp.unsigned_read.?(key.*.g, @as([*c]u8, @ptrCast(@volatileCast(@constCast(gbuf)))), @as(c_ulong, @bitCast(@as(c_long, gbuf_len))));
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            if (buf != null) {
                free(@as(?*anyopaque, @ptrCast(buf)));
            }
            _private_tls_dh_clear_key(key);
            return -@as(c_int, 1);
        }
    }
    if (pbuf_len <= @as(c_int, 0)) {
        if ((blk: {
            const tmp = ltc_mp.read_radix.?(key.*.p, pbuf, @as(c_int, 16));
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            if (buf != null) {
                free(@as(?*anyopaque, @ptrCast(buf)));
            }
            _private_tls_dh_clear_key(key);
            return -@as(c_int, 1);
        }
    } else {
        if ((blk: {
            const tmp = ltc_mp.unsigned_read.?(key.*.p, @as([*c]u8, @ptrCast(@volatileCast(@constCast(pbuf)))), @as(c_ulong, @bitCast(@as(c_long, pbuf_len))));
            err = tmp;
            break :blk tmp;
        }) != CRYPT_OK) {
            if (buf != null) {
                free(@as(?*anyopaque, @ptrCast(buf)));
            }
            _private_tls_dh_clear_key(key);
            return -@as(c_int, 1);
        }
    }
    if ((blk: {
        const tmp = ltc_mp.unsigned_read.?(key.*.x, buf, @as(c_ulong, @bitCast(@as(c_long, keysize))));
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        if (buf != null) {
            free(@as(?*anyopaque, @ptrCast(buf)));
        }
        _private_tls_dh_clear_key(key);
        return -@as(c_int, 1);
    }
    if ((blk: {
        const tmp = ltc_mp.exptmod.?(key.*.g, key.*.x, key.*.p, key.*.y);
        err = tmp;
        break :blk tmp;
    }) != CRYPT_OK) {
        if (buf != null) {
            free(@as(?*anyopaque, @ptrCast(buf)));
        }
        _private_tls_dh_clear_key(key);
        return -@as(c_int, 1);
    }
    if (buf != null) {
        free(@as(?*anyopaque, @ptrCast(buf)));
    }
    return 0;
}
pub export fn _private_dtls_handshake_copyframesize(arg_packet: [*c]struct_TLSPacket) void {
    var packet = arg_packet;
    _ = &packet;
    packet.*.buf[@as(c_uint, @intCast(@as(c_int, 22)))] = packet.*.buf[@as(c_uint, @intCast(@as(c_int, 14)))];
    packet.*.buf[@as(c_uint, @intCast(@as(c_int, 23)))] = packet.*.buf[@as(c_uint, @intCast(@as(c_int, 15)))];
    packet.*.buf[@as(c_uint, @intCast(@as(c_int, 24)))] = packet.*.buf[@as(c_uint, @intCast(@as(c_int, 16)))];
}
pub export fn _private_tls_set_session_id(arg_context: [*c]struct_TLSContext) void {
    var context = arg_context;
    _ = &context;
    if (((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) and (@as(c_int, @bitCast(@as(c_uint, context.*.session_size))) == @as(c_int, 32))) return;
    if (tls_random(@as([*c]u8, @ptrCast(@alignCast(&context.*.session))), @as(c_int, 32)) != 0) {
        context.*.session_size = 32;
    } else {
        context.*.session_size = 0;
    }
}
pub export fn _private_dtls_build_cookie(arg_context: [*c]struct_TLSContext) c_int {
    var context = arg_context;
    _ = &context;
    if (!(context.*.dtls_cookie != null) or !(context.*.dtls_cookie_len != 0)) {
        context.*.dtls_cookie = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32))))))));
        if (!(context.*.dtls_cookie != null)) return 0;
        var hmac: hmac_state = undefined;
        _ = &hmac;
        _ = hmac_init(&hmac, find_hash("sha256"), @as([*c]u8, @ptrCast(@alignCast(&dtls_secret))), @sizeOf([32]u8));
        _ = hmac_process(&hmac, @as([*c]u8, @ptrCast(@alignCast(&context.*.remote_random))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))));
        var out_size: c_ulong = 32;
        _ = &out_size;
        _ = hmac_done(&hmac, context.*.dtls_cookie, &out_size);
        context.*.dtls_cookie_len = @as(u8, @bitCast(@as(u8, @truncate(out_size))));
    }
    return 1;
}
pub export fn _private_dtls_check_packet(arg_context: [*c]struct_TLSContext, arg_buf: [*c]const u8, arg_buf_len: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    if ((@as(c_int, 11) > buf_len) or (buf_len < @as(c_int, 0))) {
        return 0;
    }
    var bytes_to_follow: c_uint = @as(c_uint, @bitCast(((@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 0)))]))) * @as(c_int, 65536)) + (@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 1)))]))) * @as(c_int, 256))) + @as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 2)))])))));
    _ = &bytes_to_follow;
    var fragment_offset: c_uint = @as(c_uint, @bitCast(((@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 5)))]))) * @as(c_int, 65536)) + (@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 6)))]))) * @as(c_int, 256))) + @as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 7)))])))));
    _ = &fragment_offset;
    var fragment_length: c_uint = @as(c_uint, @bitCast(((@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 8)))]))) * @as(c_int, 65536)) + (@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 9)))]))) * @as(c_int, 256))) + @as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 10)))])))));
    _ = &fragment_length;
    if ((fragment_offset != 0) or (fragment_length != bytes_to_follow)) {
        if ((context.*.dtls_data.*.fragment != null) and (@as(c_uint, @bitCast(context.*.dtls_data.*.fragment.*.written)) == bytes_to_follow)) return @as(c_int, @bitCast(bytes_to_follow));
        return -@as(c_int, 17);
    }
    return @as(c_int, @bitCast(bytes_to_follow));
}
pub export fn _private_dtls_reset(arg_context: [*c]struct_TLSContext) void {
    var context = arg_context;
    _ = &context;
    context.*.dtls_epoch_local = 0;
    context.*.dtls_epoch_remote = 0;
    context.*.dtls_seq = 0;
    _private_tls_destroy_hash(context);
    context.*.connection_status = 0;
}
pub export fn tls_parse_verify_request(arg_context: [*c]struct_TLSContext, arg_buf: [*c]const u8, arg_buf_len: c_int, arg_write_packets: [*c]c_uint) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var write_packets = arg_write_packets;
    _ = &write_packets;
    write_packets.* = 0;
    if ((@as(c_int, @bitCast(@as(c_uint, context.*.connection_status))) != @as(c_int, 0)) or !(context.*.dtls != 0)) {
        return -@as(c_int, 6);
    }
    var res: c_int = 11;
    _ = &res;
    var bytes_to_follow: c_int = _private_dtls_check_packet(context, buf, buf_len);
    _ = &bytes_to_follow;
    if (bytes_to_follow < @as(c_int, 0)) return bytes_to_follow;
    if ((bytes_to_follow > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
        return 0;
    }
    res += @as(c_int, 2);
    var len: u8 = (blk: {
        const tmp = res;
        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    _ = &len;
    res += 1;
    if (context.*.dtls_cookie != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.dtls_cookie)));
    }
    context.*.dtls_cookie_len = 0;
    if (len != 0) {
        if ((@as(c_int, @bitCast(@as(c_uint, len))) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
            return 0;
        }
        context.*.dtls_cookie = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, len)))))));
        if (!(context.*.dtls_cookie != null)) return -@as(c_int, 9);
        context.*.dtls_cookie_len = len;
        _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.dtls_cookie)), @as(?*const anyopaque, @ptrCast(&(blk: {
            const tmp = res;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*)), @as(c_ulong, @bitCast(@as(c_ulong, len))));
        res += @as(c_int, @bitCast(@as(c_uint, len)));
        write_packets.* = 4;
    }
    _private_dtls_reset(context);
    return res;
}
pub export fn _private_dtls_reset_cookie(arg_context: [*c]struct_TLSContext) void {
    var context = arg_context;
    _ = &context;
    if (context.*.dtls_cookie != null) {
        free(@as(?*anyopaque, @ptrCast(context.*.dtls_cookie)));
    }
    context.*.dtls_cookie = null;
    context.*.dtls_cookie_len = 0;
}
pub export fn _private_tls_parse_key_share(arg_context: [*c]struct_TLSContext, arg_buf: [*c]const u8, arg_buf_len: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var i: c_int = 0;
    _ = &i;
    var curve: [*c]struct_ECCCurveParameters = null;
    _ = &curve;
    var dhkey: [*c]DHKey = null;
    _ = &dhkey;
    var dhe_key_size: c_int = 0;
    _ = &dhe_key_size;
    var buffer: [*c]const u8 = null;
    _ = &buffer;
    var out2: [*c]u8 = undefined;
    _ = &out2;
    var out_size: c_ulong = undefined;
    _ = &out_size;
    var key_size: c_ushort = 0;
    _ = &key_size;
    while (buf_len >= @as(c_int, 4)) {
        var named_group: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
            const tmp = i;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).*);
        _ = &named_group;
        i += @as(c_int, 2);
        buf_len -= @as(c_int, 2);
        key_size = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
            const tmp = i;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))).*);
        i += @as(c_int, 2);
        buf_len -= @as(c_int, 2);
        if (@as(c_int, @bitCast(@as(c_uint, key_size))) > buf_len) return -@as(c_int, 2);
        while (true) {
            switch (@as(c_int, @bitCast(@as(c_uint, named_group)))) {
                @as(c_int, 23) => {
                    curve = &secp256r1;
                    buffer = &(blk: {
                        const tmp = i;
                        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).*;
                    {}
                    buf_len = 0;
                    continue;
                    curve = &secp384r1;
                    buffer = &(blk: {
                        const tmp = i;
                        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).*;
                    {}
                    buf_len = 0;
                    continue;
                    break;
                },
                @as(c_int, 24) => {
                    curve = &secp384r1;
                    buffer = &(blk: {
                        const tmp = i;
                        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).*;
                    {}
                    buf_len = 0;
                    continue;
                    break;
                },
                @as(c_int, 25) => break,
                @as(c_int, 29) => {
                    if (@as(c_int, @bitCast(@as(c_uint, key_size))) != @as(c_int, 32)) {
                        continue;
                    }
                    curve = &x25519;
                    buffer = &(blk: {
                        const tmp = i;
                        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).*;
                    {}
                    buf_len = 0;
                    continue;
                    break;
                },
                @as(c_int, 30) => break,
                @as(c_int, 256) => {
                    dhkey = &ffdhe2048;
                    dhe_key_size = 2048;
                    break;
                },
                @as(c_int, 257) => {
                    dhkey = &ffdhe3072;
                    dhe_key_size = 3072;
                    break;
                },
                @as(c_int, 258) => {
                    dhkey = &ffdhe4096;
                    dhe_key_size = 4096;
                    break;
                },
                @as(c_int, 259) => {
                    dhkey = &ffdhe6144;
                    dhe_key_size = 6144;
                    break;
                },
                @as(c_int, 260) => {
                    dhkey = &ffdhe8192;
                    dhe_key_size = 8192;
                    break;
                },
                else => {},
            }
            break;
        }
        i += @as(c_int, @bitCast(@as(c_uint, key_size)));
        buf_len -= @as(c_int, @bitCast(@as(c_uint, key_size)));
        if (!(context.*.is_server != 0)) break;
    }
    tls_init();
    if (curve != null) {
        context.*.curve = curve;
        if (curve == (&x25519)) {
            if ((@as(c_int, @bitCast(@as(c_uint, context.*.is_server))) != 0) and !(tls_random(@as([*c]u8, @ptrCast(@alignCast(&context.*.local_random))), @as(c_int, 32)) != 0)) return -@as(c_int, 1);
            var secret: [32]u8 = undefined;
            _ = &secret;
            if ((@as(c_int, @bitCast(@as(c_uint, context.*.is_server))) != 0) or !(context.*.client_secret != null)) {
                _ = tls_random(@as([*c]u8, @ptrCast(@alignCast(&secret))), @as(c_int, 32));
                secret[@as(c_uint, @intCast(@as(c_int, 0)))] &= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 248)))));
                secret[@as(c_uint, @intCast(@as(c_int, 31)))] &= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 127)))));
                secret[@as(c_uint, @intCast(@as(c_int, 31)))] |= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 64)))));
                if (context.*.finished_key != null) {
                    free(@as(?*anyopaque, @ptrCast(context.*.finished_key)));
                }
                context.*.finished_key = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32))))))));
                if (!(context.*.finished_key != null)) return -@as(c_int, 1);
                var secret_key: curve25519_key = undefined;
                _ = &secret_key;
                _ = x25519_import_raw(@as([*c]u8, @ptrCast(@alignCast(&secret))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))), PK_PRIVATE, &secret_key);
                _ = memcpy(@as(?*anyopaque, @ptrCast(context.*.finished_key)), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&secret_key.@"pub"))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))));
                if (context.*.premaster_key != null) {
                    free(@as(?*anyopaque, @ptrCast(context.*.premaster_key)));
                }
                context.*.premaster_key = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32))))))));
                if (!(context.*.premaster_key != null)) return -@as(c_int, 1);
                var public_key: curve25519_key = undefined;
                _ = &public_key;
                _ = x25519_import_raw(buffer, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))), PK_PUBLIC, &public_key);
                context.*.premaster_key_len = 32;
                _ = x25519_shared_secret(&secret_key, &public_key, context.*.premaster_key, @as([*c]c_ulong, @ptrCast(@alignCast(&context.*.premaster_key_len))));
            } else {
                if (context.*.premaster_key != null) {
                    free(@as(?*anyopaque, @ptrCast(context.*.premaster_key)));
                }
                context.*.premaster_key = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32))))))));
                if (!(context.*.premaster_key != null)) return -@as(c_int, 1);
                var secret_key: curve25519_key = undefined;
                _ = &secret_key;
                _ = x25519_import_raw(context.*.client_secret, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))), PK_PRIVATE, &secret_key);
                var public_key: curve25519_key = undefined;
                _ = &public_key;
                _ = x25519_import_raw(buffer, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32)))), PK_PUBLIC, &public_key);
                context.*.premaster_key_len = 32;
                _ = x25519_shared_secret(&secret_key, &public_key, context.*.premaster_key, @as([*c]c_ulong, @ptrCast(@alignCast(&context.*.premaster_key_len))));
                if (context.*.client_secret != null) {
                    free(@as(?*anyopaque, @ptrCast(context.*.client_secret)));
                }
                context.*.client_secret = null;
            }
            return 0;
        }
        if (context.*.is_server != 0) {
            _private_tls_ecc_dhe_create(context);
            if (ecc_make_key_ex(null, find_prng("sprng"), context.*.ecc_dhe, &context.*.curve.*.dp) != 0) {
                if (context.*.ecc_dhe != null) {
                    free(@as(?*anyopaque, @ptrCast(context.*.ecc_dhe)));
                }
                context.*.ecc_dhe = null;
                return -@as(c_int, 1);
            }
        }
        var dp: [*c]const ltc_ecc_set_type = &context.*.curve.*.dp;
        _ = &dp;
        if ((@as(c_int, @bitCast(@as(c_uint, context.*.is_server))) != 0) and !(tls_random(@as([*c]u8, @ptrCast(@alignCast(&context.*.local_random))), @as(c_int, 32)) != 0)) return -@as(c_int, 1);
        var client_key: ecc_key = undefined;
        _ = &client_key;
        _ = memset(@as(?*anyopaque, @ptrCast(&client_key)), @as(c_int, 0), @sizeOf(ecc_key));
        if (ecc_ansi_x963_import_ex(buffer, @as(c_ulong, @bitCast(@as(c_ulong, key_size))), &client_key, dp) != 0) {
            return -@as(c_int, 1);
        }
        out2 = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, key_size)))))));
        out_size = @as(c_ulong, @bitCast(@as(c_ulong, key_size)));
        var err: c_int = ecc_shared_secret(context.*.ecc_dhe, &client_key, out2, &out_size);
        _ = &err;
        ecc_free(&client_key);
        if (err != 0) {
            if (out2 != null) {
                free(@as(?*anyopaque, @ptrCast(out2)));
            }
            return -@as(c_int, 1);
        }
        if (context.*.premaster_key != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.premaster_key)));
        }
        context.*.premaster_key = out2;
        context.*.premaster_key_len = @as(c_uint, @bitCast(@as(c_uint, @truncate(out_size))));
        return 0;
    } else if ((dhkey != null) and (buffer != null)) {
        _private_tls_dhe_create(context);
        if (!(tls_random(@as([*c]u8, @ptrCast(@alignCast(&context.*.local_random))), @as(c_int, 32)) != 0)) return -@as(c_int, 1);
        if (_private_tls_dh_make_key(@divTrunc(dhe_key_size, @as(c_int, 8)), context.*.dhe, @as([*c]const u8, @ptrCast(@alignCast(dhkey.*.p))), @as([*c]const u8, @ptrCast(@alignCast(dhkey.*.g))), @as(c_int, 0), @as(c_int, 0)) != 0) {
            if (context.*.dhe != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.dhe)));
            }
            context.*.dhe = null;
            return -@as(c_int, 1);
        }
        var dhe_out_size: c_uint = undefined;
        _ = &dhe_out_size;
        out2 = _private_tls_decrypt_dhe(context, buffer, @as(c_uint, @bitCast(@as(c_uint, key_size))), &dhe_out_size, @as(c_int, 0));
        if (!(out2 != null)) {
            return -@as(c_int, 1);
        }
        if (context.*.premaster_key != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.premaster_key)));
        }
        context.*.premaster_key = out2;
        context.*.premaster_key_len = dhe_out_size;
        if (context.*.dhe != null) {
            context.*.dhe.*.iana = dhkey.*.iana;
        }
        return 0;
    }
    return -@as(c_int, 5);
}
pub export fn _private_tls_parse_dh(arg_buf: [*c]const u8, arg_buf_len: c_int, arg_out: [*c][*c]const u8, arg_out_size: [*c]c_int) c_int {
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var out = arg_out;
    _ = &out;
    var out_size = arg_out_size;
    _ = &out_size;
    var res: c_int = 0;
    _ = &res;
    out.* = null;
    out_size.* = 0;
    if ((@as(c_int, 2) > buf_len) or (buf_len < @as(c_int, 0))) {
        return 0;
    }
    var size: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(buf))).*);
    _ = &size;
    res += @as(c_int, 2);
    if ((@as(c_int, @bitCast(@as(c_uint, size))) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
        return 0;
    }
    out.* = &(blk: {
        const tmp = res;
        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    out_size.* = @as(c_int, @bitCast(@as(c_uint, size)));
    res += @as(c_int, @bitCast(@as(c_uint, size)));
    return res;
}
pub export fn _private_tls_parse_random(arg_context: [*c]struct_TLSContext, arg_buf: [*c]const u8, arg_buf_len: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var res: c_int = 0;
    _ = &res;
    var ephemeral: c_int = tls_cipher_is_ephemeral(context);
    _ = &ephemeral;
    var size: c_ushort = undefined;
    _ = &size;
    if (ephemeral == @as(c_int, 2)) {
        if ((@as(c_int, 1) > buf_len) or (buf_len < @as(c_int, 0))) {
            return 0;
        }
        size = @as(c_ushort, @bitCast(@as(c_ushort, buf[@as(c_uint, @intCast(@as(c_int, 0)))])));
        res += @as(c_int, 1);
    } else {
        if ((@as(c_int, 2) > buf_len) or (buf_len < @as(c_int, 0))) {
            return 0;
        }
        size = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(buf))).*);
        res += @as(c_int, 2);
    }
    if ((@as(c_int, @bitCast(@as(c_uint, size))) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
        return 0;
    }
    var out_len: c_uint = 0;
    _ = &out_len;
    var random_1: [*c]u8 = null;
    _ = &random_1;
    while (true) {
        switch (ephemeral) {
            @as(c_int, 1) => {
                random_1 = _private_tls_decrypt_dhe(context, &(blk: {
                    const tmp = res;
                    if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*, @as(c_uint, @bitCast(@as(c_uint, size))), &out_len, @intFromBool(!(context.*.dtls != 0)));
                break;
            },
            @as(c_int, 2) => {
                random_1 = _private_tls_decrypt_ecc_dhe(context, &(blk: {
                    const tmp = res;
                    if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*, @as(c_uint, @bitCast(@as(c_uint, size))), &out_len, @intFromBool(!(context.*.dtls != 0)));
                break;
            },
            else => {
                random_1 = _private_tls_decrypt_rsa(context, &(blk: {
                    const tmp = res;
                    if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*, @as(c_uint, @bitCast(@as(c_uint, size))), &out_len);
            },
        }
        break;
    }
    if ((random_1 != null) and (out_len > @as(c_uint, @bitCast(@as(c_int, 2))))) {
        if (context.*.premaster_key != null) {
            free(@as(?*anyopaque, @ptrCast(context.*.premaster_key)));
        }
        context.*.premaster_key = random_1;
        context.*.premaster_key_len = out_len;
        _ = _private_tls_compute_key(context, @as(c_uint, @bitCast(@as(c_int, 48))));
    } else {
        if (random_1 != null) {
            free(@as(?*anyopaque, @ptrCast(random_1)));
        }
        return 0;
    }
    res += @as(c_int, @bitCast(@as(c_uint, size)));
    return res;
}
pub export fn _private_tls_parse_signature(arg_context: [*c]struct_TLSContext, arg_buf: [*c]const u8, arg_buf_len: c_int, arg_hash_algorithm: [*c]c_int, arg_sign_algorithm: [*c]c_int, arg_sig_size: [*c]c_int, arg_offset: [*c]c_int) [*c]const u8 {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var hash_algorithm = arg_hash_algorithm;
    _ = &hash_algorithm;
    var sign_algorithm = arg_sign_algorithm;
    _ = &sign_algorithm;
    var sig_size = arg_sig_size;
    _ = &sig_size;
    var offset = arg_offset;
    _ = &offset;
    var res: c_int = 0;
    _ = &res;
    if ((@as(c_int, 2) > buf_len) or (buf_len < @as(c_int, 0))) {
        return null;
    }
    hash_algorithm.* = _md5_sha1;
    sign_algorithm.* = rsa_sign;
    sig_size.* = 0;
    if ((((@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 771)) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65277))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 772))) or (@as(c_int, @bitCast(@as(c_uint, context.*.version))) == @as(c_int, 65276))) {
        hash_algorithm.* = @as(c_int, @bitCast(@as(c_uint, (blk: {
            const tmp = res;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*)));
        res += 1;
        sign_algorithm.* = @as(c_int, @bitCast(@as(c_uint, (blk: {
            const tmp = res;
            if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*)));
        res += 1;
    }
    var size: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&(blk: {
        const tmp = res;
        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*))).*);
    _ = &size;
    res += @as(c_int, 2);
    if ((@as(c_int, @bitCast(@as(c_uint, size))) > (buf_len - res)) or ((buf_len - res) < @as(c_int, 0))) {
        return null;
    }
    sig_size.* = @as(c_int, @bitCast(@as(c_uint, size)));
    offset.* = res + @as(c_int, @bitCast(@as(c_uint, size)));
    return &(blk: {
        const tmp = res;
        if (tmp >= 0) break :blk buf + @as(usize, @intCast(tmp)) else break :blk buf - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
}
pub export fn tls_parse_verify_tls13(arg_context: [*c]struct_TLSContext, arg_buf: [*c]const u8, arg_buf_len: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var buf = arg_buf;
    _ = &buf;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    if ((@as(c_int, 7) > buf_len) or (buf_len < @as(c_int, 0))) {
        return 0;
    }
    var size: c_uint = @as(c_uint, @bitCast(((@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 0)))]))) * @as(c_int, 65536)) + (@as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 1)))]))) * @as(c_int, 256))) + @as(c_int, @bitCast(@as(c_uint, buf[@as(c_uint, @intCast(@as(c_int, 2)))])))));
    _ = &size;
    if (size < @as(c_uint, @bitCast(@as(c_int, 2)))) return buf_len;
    var signing_data: [146]u8 = undefined;
    _ = &signing_data;
    var signing_data_len: c_int = undefined;
    _ = &signing_data_len;
    _ = memset(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&signing_data))))), @as(c_int, 32), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 64)))));
    if (context.*.is_server != 0) {
        _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&signing_data))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 64))))))), @as(?*const anyopaque, @ptrCast("TLS 1.3, client CertificateVerify")), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 33)))));
    } else {
        _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&signing_data))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 64))))))), @as(?*const anyopaque, @ptrCast("TLS 1.3, server CertificateVerify")), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 33)))));
    }
    signing_data[@as(c_uint, @intCast(@as(c_int, 97)))] = 0;
    signing_data_len = 98;
    signing_data_len += _private_tls_get_hash(context, @as([*c]u8, @ptrCast(@alignCast(&signing_data))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 98))))));
    var signature: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&buf[@as(c_uint, @intCast(@as(c_int, 3)))]))).*);
    _ = &signature;
    var signature_size: c_ushort = ntohs(@as([*c]const c_ushort, @ptrCast(@alignCast(&buf[@as(c_uint, @intCast(@as(c_int, 5)))]))).*);
    _ = &signature_size;
    var valid: c_int = 0;
    _ = &valid;
    if (((@as(c_int, 7) + @as(c_int, @bitCast(@as(c_uint, signature_size)))) > buf_len) or (buf_len < @as(c_int, 0))) {
        return 0;
    }
    while (true) {
        switch (@as(c_int, @bitCast(@as(c_uint, signature)))) {
            @as(c_int, 1027) => {
                valid = _private_tls_verify_ecdsa(context, @as(c_uint, @bitCast(sha256)), buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 7))))), @as(c_uint, @bitCast(@as(c_uint, signature_size))), @as([*c]u8, @ptrCast(@alignCast(&signing_data))), @as(c_uint, @bitCast(signing_data_len)), &secp256r1);
                break;
            },
            @as(c_int, 1283) => {
                valid = _private_tls_verify_ecdsa(context, @as(c_uint, @bitCast(sha384)), buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 7))))), @as(c_uint, @bitCast(@as(c_uint, signature_size))), @as([*c]u8, @ptrCast(@alignCast(&signing_data))), @as(c_uint, @bitCast(signing_data_len)), &secp384r1);
                break;
            },
            @as(c_int, 1539) => {
                valid = _private_tls_verify_ecdsa(context, @as(c_uint, @bitCast(sha512)), buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 7))))), @as(c_uint, @bitCast(@as(c_uint, signature_size))), @as([*c]u8, @ptrCast(@alignCast(&signing_data))), @as(c_uint, @bitCast(signing_data_len)), &secp521r1);
                break;
            },
            @as(c_int, 2052) => {
                valid = _private_tls_verify_rsa(context, @as(c_uint, @bitCast(sha256)), buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 7))))), @as(c_uint, @bitCast(@as(c_uint, signature_size))), @as([*c]u8, @ptrCast(@alignCast(&signing_data))), @as(c_uint, @bitCast(signing_data_len)));
                break;
            },
            @as(c_int, 2053) => {
                valid = _private_tls_verify_rsa(context, @as(c_uint, @bitCast(sha384)), buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 7))))), @as(c_uint, @bitCast(@as(c_uint, signature_size))), @as([*c]u8, @ptrCast(@alignCast(&signing_data))), @as(c_uint, @bitCast(signing_data_len)));
                break;
            },
            @as(c_int, 2054) => {
                valid = _private_tls_verify_rsa(context, @as(c_uint, @bitCast(sha512)), buf + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 7))))), @as(c_uint, @bitCast(@as(c_uint, signature_size))), @as([*c]u8, @ptrCast(@alignCast(&signing_data))), @as(c_uint, @bitCast(signing_data_len)));
                break;
            },
            else => {
                {}
                return -@as(c_int, 15);
            },
        }
        break;
    }
    if (valid != @as(c_int, 1)) {
        return -@as(c_int, 20);
    }
    return buf_len;
}
pub export fn _private_dtls_reset_handshake(arg_context: [*c]struct_TLSContext) void {
    var context = arg_context;
    _ = &context;
    if ((context != null) and (@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) != 0)) {
        _ = memset(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&context.*.hs_messages))))), @as(c_int, 0), @sizeOf([11]u8));
        context.*.connection_status = 0;
        context.*.cipher_spec_set = 0;
        context.*.dtls_seq = 0;
        if (context.*.cached_handshake != null) {
            if (context.*.cached_handshake != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.cached_handshake)));
            }
            context.*.cached_handshake = null;
            context.*.cached_handshake_len = 0;
        }
        _ = _private_tls_done_hash(context, null);
        if (context.*.is_server != 0) {
            if (context.*.client_certificates != null) {
                var i: c_uint = undefined;
                _ = &i;
                {
                    i = 0;
                    while (i < context.*.client_certificates_count) : (i +%= 1) {
                        tls_destroy_certificate(context.*.client_certificates[i]);
                    }
                }
                if (context.*.client_certificates != null) {
                    free(@as(?*anyopaque, @ptrCast(context.*.client_certificates)));
                }
                context.*.client_certificates_count = 0;
                context.*.client_certificates = null;
            }
        }
        while (context.*.dtls_data.*.dtls_handshake_list != null) {
            var next: [*c]struct_TLSHandshakeList = @as([*c]struct_TLSHandshakeList, @ptrCast(@alignCast(context.*.dtls_data.*.dtls_handshake_list.*.next)));
            _ = &next;
            if (context.*.dtls_data.*.dtls_handshake_list.*.msg != null) {
                if (context.*.dtls_data.*.dtls_handshake_list.*.msg != null) {
                    free(@as(?*anyopaque, @ptrCast(context.*.dtls_data.*.dtls_handshake_list.*.msg)));
                }
            }
            if (context.*.dtls_data.*.dtls_handshake_list != null) {
                free(@as(?*anyopaque, @ptrCast(context.*.dtls_data.*.dtls_handshake_list)));
            }
            context.*.dtls_data.*.dtls_handshake_list = next;
        }
        context.*.dtls_data.*.dtls_handshake_list = null;
    }
}
pub export fn _private_dtls_rehash(arg_context: [*c]struct_TLSContext, arg_msg_type: u8) void {
    var context = arg_context;
    _ = &context;
    var msg_type = arg_msg_type;
    _ = &msg_type;
    if (((context != null) and (@as(c_int, @bitCast(@as(c_uint, context.*.dtls))) != 0)) and (@as(c_int, @bitCast(@as(c_uint, msg_type))) != 0)) {
        var handshake_list: [*c]struct_TLSHandshakeList = context.*.dtls_data.*.dtls_handshake_list;
        _ = &handshake_list;
        var found: c_int = 0;
        _ = &found;
        while (handshake_list != null) {
            var next: [*c]struct_TLSHandshakeList = @as([*c]struct_TLSHandshakeList, @ptrCast(@alignCast(handshake_list.*.next)));
            _ = &next;
            if ((@as(c_int, @bitCast(@as(c_uint, handshake_list.*.direction))) == @as(c_int, 0)) and (@as(c_int, @bitCast(@as(c_uint, handshake_list.*.msg[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, @bitCast(@as(c_uint, msg_type))))) {
                found = 1;
                context.*.connection_status = handshake_list.*.connection_status;
                break;
            }
            handshake_list = next;
        }
        if (!(found != 0)) {
            return;
        }
        handshake_list = context.*.dtls_data.*.dtls_handshake_list;
        var to_delete: [*c]struct_TLSHandshakeList = handshake_list;
        _ = &to_delete;
        context.*.dtls_data.*.dtls_handshake_list = null;
        _ = _private_tls_done_hash(context, null);
        while (handshake_list != null) {
            var next: [*c]struct_TLSHandshakeList = @as([*c]struct_TLSHandshakeList, @ptrCast(@alignCast(handshake_list.*.next)));
            _ = &next;
            if (handshake_list.*.direction != 0) {
                context.*.connection_status = handshake_list.*.connection_status;
            }
            if ((@as(c_int, @bitCast(@as(c_uint, handshake_list.*.direction))) == @as(c_int, 0)) and (@as(c_int, @bitCast(@as(c_uint, handshake_list.*.msg[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, @bitCast(@as(c_uint, msg_type))))) break;
            _ = _private_tls_update_hash(context, handshake_list.*.msg, handshake_list.*.len, handshake_list.*.direction, handshake_list.*.connection_status);
            handshake_list = next;
        }
        handshake_list = to_delete;
        while (handshake_list != null) {
            var next: [*c]struct_TLSHandshakeList = @as([*c]struct_TLSHandshakeList, @ptrCast(@alignCast(handshake_list.*.next)));
            _ = &next;
            if (handshake_list.*.msg != null) {
                if (handshake_list.*.msg != null) {
                    free(@as(?*anyopaque, @ptrCast(handshake_list.*.msg)));
                }
            }
            if (handshake_list != null) {
                free(@as(?*anyopaque, @ptrCast(handshake_list)));
            }
            handshake_list = next;
        }
    }
}
pub export fn asn1_get_len(arg_buffer: [*c]const u8, arg_buf_len: c_int, arg_octets: [*c]c_uint) c_uint {
    var buffer = arg_buffer;
    _ = &buffer;
    var buf_len = arg_buf_len;
    _ = &buf_len;
    var octets = arg_octets;
    _ = &octets;
    octets.* = 0;
    if (buf_len < @as(c_int, 1)) return 0;
    var size: u8 = buffer[@as(c_uint, @intCast(@as(c_int, 0)))];
    _ = &size;
    var i: c_int = undefined;
    _ = &i;
    if ((@as(c_int, @bitCast(@as(c_uint, size))) & @as(c_int, 128)) != 0) {
        octets.* = @as(c_uint, @bitCast(@as(c_int, @bitCast(@as(c_uint, size))) & @as(c_int, 127)));
        if (@as(c_int, @bitCast(octets.*)) > (buf_len - @as(c_int, 1))) return 0;
        var ref_octets: c_uint = octets.*;
        _ = &ref_octets;
        if (octets.* > @as(c_uint, @bitCast(@as(c_int, 4)))) {
            ref_octets = 4;
        }
        if (@as(c_int, @bitCast(octets.*)) > (buf_len - @as(c_int, 1))) return 0;
        var long_size: c_uint = 0;
        _ = &long_size;
        var coef: c_uint = 1;
        _ = &coef;
        {
            i = @as(c_int, @bitCast(ref_octets));
            while (i > @as(c_int, 0)) : (i -= 1) {
                long_size +%= @as(c_uint, @bitCast(@as(c_uint, (blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*))) *% coef;
                coef *%= @as(c_uint, @bitCast(@as(c_int, 256)));
            }
        }
        octets.* +%= 1;
        return long_size;
    }
    octets.* +%= 1;
    return @as(c_uint, @bitCast(@as(c_uint, size)));
}
pub export fn print_index(arg_fields: [*c]const c_uint) void {
    var fields = arg_fields;
    _ = &fields;
    var i: c_int = 0;
    _ = &i;
    while ((blk: {
        const tmp = i;
        if (tmp >= 0) break :blk fields + @as(usize, @intCast(tmp)) else break :blk fields - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* != 0) {
        if (i != 0) {}
        i += 1;
    }
    while (i < @as(c_int, 6)) {
        i += 1;
    }
}
pub export fn _is_field(arg_fields: [*c]const c_uint, arg_prefix: [*c]const c_uint) c_int {
    var fields = arg_fields;
    _ = &fields;
    var prefix = arg_prefix;
    _ = &prefix;
    var i: c_int = 0;
    _ = &i;
    while ((blk: {
        const tmp = i;
        if (tmp >= 0) break :blk prefix + @as(usize, @intCast(tmp)) else break :blk prefix - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* != 0) {
        if ((blk: {
            const tmp = i;
            if (tmp >= 0) break :blk fields + @as(usize, @intCast(tmp)) else break :blk fields - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* != (blk: {
            const tmp = i;
            if (tmp >= 0) break :blk prefix + @as(usize, @intCast(tmp)) else break :blk prefix - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*) return 0;
        i += 1;
    }
    return 1;
}
pub export fn _private_tls_hash_len(arg_algorithm: c_int) c_int {
    var algorithm = arg_algorithm;
    _ = &algorithm;
    while (true) {
        switch (algorithm) {
            @as(c_int, 4) => return 16,
            @as(c_int, 5) => return 20,
            @as(c_int, 10), @as(c_int, 15) => return 28,
            @as(c_int, 11), @as(c_int, 14) => return 32,
            @as(c_int, 12), @as(c_int, 16) => return 48,
            @as(c_int, 13), @as(c_int, 26) => return 64,
            else => {},
        }
        break;
    }
    return 0;
}
pub export fn _private_tls_compute_hash(arg_algorithm: c_int, arg_message: [*c]const u8, arg_message_len: c_uint) [*c]u8 {
    var algorithm = arg_algorithm;
    _ = &algorithm;
    var message = arg_message;
    _ = &message;
    var message_len = arg_message_len;
    _ = &message_len;
    var hash: [*c]u8 = null;
    _ = &hash;
    if (!(message != null) or !(message_len != 0)) return hash;
    var err: c_int = undefined;
    _ = &err;
    var state: hash_state = undefined;
    _ = &state;
    while (true) {
        switch (algorithm) {
            @as(c_int, 4) => {
                {}
                hash = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16))))))));
                if (!(hash != null)) return null;
                err = md5_init(&state);
                if (!(err != 0)) {
                    err = md5_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                    if (!(err != 0)) {
                        err = md5_done(&state, hash);
                    }
                }
                break;
            },
            @as(c_int, 5) => {
                {}
                hash = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 20))))))));
                if (!(hash != null)) return null;
                err = sha1_init(&state);
                if (!(err != 0)) {
                    err = sha1_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                    if (!(err != 0)) {
                        err = sha1_done(&state, hash);
                    }
                }
                break;
            },
            @as(c_int, 10), @as(c_int, 15) => {
                {}
                hash = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 28))))))));
                if (!(hash != null)) return null;
                err = sha224_init(&state);
                if (!(err != 0)) {
                    err = sha256_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                    if (!(err != 0)) {
                        err = sha224_done(&state, hash);
                    }
                }
                break;
            },
            @as(c_int, 11), @as(c_int, 14) => {
                {}
                hash = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 32))))))));
                if (!(hash != null)) return null;
                err = sha256_init(&state);
                if (!(err != 0)) {
                    err = sha256_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                    if (!(err != 0)) {
                        err = sha256_done(&state, hash);
                    }
                }
                break;
            },
            @as(c_int, 12), @as(c_int, 16) => {
                {}
                hash = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 48))))))));
                if (!(hash != null)) return null;
                err = sha384_init(&state);
                if (!(err != 0)) {
                    err = sha512_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                    if (!(err != 0)) {
                        err = sha384_done(&state, hash);
                    }
                }
                break;
            },
            @as(c_int, 13), @as(c_int, 26) => {
                {}
                hash = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 64))))))));
                if (!(hash != null)) return null;
                err = sha512_init(&state);
                if (!(err != 0)) {
                    err = sha512_process(&state, message, @as(c_ulong, @bitCast(@as(c_ulong, message_len))));
                    if (!(err != 0)) {
                        err = sha512_done(&state, hash);
                    }
                }
                break;
            },
            else => {
                {}
            },
        }
        break;
    }
    return hash;
}
pub export fn _private_is_oid(arg_ref_chain: [*c]struct__private_OID_chain, arg_looked_oid: [*c]const u8, arg_looked_oid_len: c_int) c_int {
    var ref_chain = arg_ref_chain;
    _ = &ref_chain;
    var looked_oid = arg_looked_oid;
    _ = &looked_oid;
    var looked_oid_len = arg_looked_oid_len;
    _ = &looked_oid_len;
    while (ref_chain != null) {
        if (ref_chain.*.oid != null) {
            if (_is_oid2(ref_chain.*.oid, looked_oid, @as(c_int, 16), looked_oid_len) != 0) return 1;
        }
        ref_chain = @as([*c]struct__private_OID_chain, @ptrCast(@alignCast(ref_chain.*.top)));
    }
    return 0;
}
pub export fn _private_asn1_parse(arg_context: [*c]struct_TLSContext, arg_cert: [*c]struct_TLSCertificate, arg_buffer: [*c]const u8, arg_size: c_uint, arg_level: c_int, arg_fields: [*c]c_uint, arg_has_key: [*c]u8, arg_client_cert: c_int, arg_top_oid: [*c]u8, arg_chain: [*c]struct__private_OID_chain) c_int {
    var context = arg_context;
    _ = &context;
    var cert = arg_cert;
    _ = &cert;
    var buffer = arg_buffer;
    _ = &buffer;
    var size = arg_size;
    _ = &size;
    var level = arg_level;
    _ = &level;
    var fields = arg_fields;
    _ = &fields;
    var has_key = arg_has_key;
    _ = &has_key;
    var client_cert = arg_client_cert;
    _ = &client_cert;
    var top_oid = arg_top_oid;
    _ = &top_oid;
    var chain = arg_chain;
    _ = &chain;
    var local_chain: struct__private_OID_chain = undefined;
    _ = &local_chain;
    local_chain.top = @as(?*anyopaque, @ptrCast(chain));
    var pos: c_uint = 0;
    _ = &pos;
    var idx: c_int = 0;
    _ = &idx;
    var oid: [16]u8 = undefined;
    _ = &oid;
    _ = memset(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&oid))))), @as(c_int, 0), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16)))));
    local_chain.oid = @as([*c]u8, @ptrCast(@alignCast(&oid)));
    if (has_key != null) {
        has_key.* = 0;
    }
    var local_has_key: u8 = 0;
    _ = &local_has_key;
    var cert_data: [*c]const u8 = null;
    _ = &cert_data;
    var cert_len: c_uint = 0;
    _ = &cert_len;
    while (pos < size) {
        var start_pos: c_uint = pos;
        _ = &start_pos;
        if ((@as(c_int, 2) > @as(c_int, @bitCast(size -% pos))) or (@as(c_int, @bitCast(size -% pos)) < @as(c_int, 0))) {
            return 0;
        }
        var first: u8 = buffer[blk: {
            const ref = &pos;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        }];
        _ = &first;
        var @"type": u8 = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, first))) & @as(c_int, 31)))));
        _ = &@"type";
        var constructed: u8 = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, first))) & @as(c_int, 32)))));
        _ = &constructed;
        var element_class: u8 = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, first))) >> @intCast(6)))));
        _ = &element_class;
        var octets: c_uint = 0;
        _ = &octets;
        var temp: c_uint = undefined;
        _ = &temp;
        idx += 1;
        if (level <= @as(c_int, 255)) {
            (blk: {
                const tmp = level - @as(c_int, 1);
                if (tmp >= 0) break :blk fields + @as(usize, @intCast(tmp)) else break :blk fields - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = @as(c_uint, @bitCast(idx));
        }
        var length: c_uint = asn1_get_len(&buffer[pos], @as(c_int, @bitCast(size -% pos)), &octets);
        _ = &length;
        if ((octets > @as(c_uint, @bitCast(@as(c_int, 4)))) or (octets > (size -% pos))) {
            return @as(c_int, @bitCast(pos));
        }
        pos +%= octets;
        if ((@as(c_int, @bitCast(length)) > @as(c_int, @bitCast(size -% pos))) or (@as(c_int, @bitCast(size -% pos)) < @as(c_int, 0))) {
            return 0;
        }
        if ((length != 0) and (@as(c_int, @bitCast(@as(c_uint, constructed))) != 0)) {
            while (true) {
                switch (@as(c_int, @bitCast(@as(c_uint, @"type")))) {
                    @as(c_int, 3) => {
                        {}
                        break;
                    },
                    @as(c_int, 16) => {
                        {}
                        if ((level == @as(c_int, 2)) and (idx == @as(c_int, 1))) {
                            cert_len = length +% (pos -% start_pos);
                            cert_data = &buffer[start_pos];
                        }
                        if (!(cert.*.version != 0) and (_is_field(fields, @as([*c]const c_uint, @ptrCast(@alignCast(&priv_der_id)))) != 0)) {
                            if (cert.*.der_bytes != null) {
                                free(@as(?*anyopaque, @ptrCast(cert.*.der_bytes)));
                            }
                            temp = length +% (pos -% start_pos);
                            cert.*.der_bytes = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, temp)))))));
                            if (cert.*.der_bytes != null) {
                                _ = memcpy(@as(?*anyopaque, @ptrCast(cert.*.der_bytes)), @as(?*const anyopaque, @ptrCast(&buffer[start_pos])), @as(c_ulong, @bitCast(@as(c_ulong, temp))));
                                cert.*.der_len = temp;
                            } else {
                                cert.*.der_len = 0;
                            }
                        }
                        break;
                    },
                    @as(c_int, 17) => {
                        {}
                        break;
                    },
                    @as(c_int, 0) => {
                        if (@as(c_int, @bitCast(@as(c_uint, element_class))) == @as(c_int, 2)) {
                            break;
                        }
                        {}
                    },
                    else => {
                        {}
                    },
                }
                break;
            }
            local_has_key = 0;
            _ = _private_asn1_parse(context, cert, &buffer[pos], length, level + @as(c_int, 1), fields, &local_has_key, client_cert, top_oid, &local_chain);
            if (((((@as(c_int, @bitCast(@as(c_uint, local_has_key))) != 0) and (context != null)) and (!(context.*.is_server != 0) or (client_cert != 0))) or !(context != null)) and (_is_field(fields, @as([*c]const c_uint, @ptrCast(@alignCast(&pk_id)))) != 0)) {
                if (cert.*.der_bytes != null) {
                    free(@as(?*anyopaque, @ptrCast(cert.*.der_bytes)));
                }
                temp = length +% (pos -% start_pos);
                cert.*.der_bytes = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_ulong, temp)))))));
                if (cert.*.der_bytes != null) {
                    _ = memcpy(@as(?*anyopaque, @ptrCast(cert.*.der_bytes)), @as(?*const anyopaque, @ptrCast(&buffer[start_pos])), @as(c_ulong, @bitCast(@as(c_ulong, temp))));
                    cert.*.der_len = temp;
                } else {
                    cert.*.der_len = 0;
                }
            }
        } else {
            while (true) {
                switch (@as(c_int, @bitCast(@as(c_uint, @"type")))) {
                    @as(c_int, 0) => {
                        {}
                        return @as(c_int, @bitCast(pos));
                    },
                    @as(c_int, 1) => {
                        temp = @as(c_uint, @bitCast(@as(c_uint, buffer[pos])));
                        {}
                        break;
                    },
                    @as(c_int, 2) => {
                        if (_is_field(fields, @as([*c]const c_uint, @ptrCast(@alignCast(&pk_id)))) != 0) {
                            if (has_key != null) {
                                has_key.* = 1;
                            }
                            if (idx == @as(c_int, 1)) {
                                tls_certificate_set_key(cert, &buffer[pos], @as(c_int, @bitCast(length)));
                            } else if (idx == @as(c_int, 2)) {
                                tls_certificate_set_exponent(cert, &buffer[pos], @as(c_int, @bitCast(length)));
                            }
                        } else if (_is_field(fields, @as([*c]const c_uint, @ptrCast(@alignCast(&serial_id)))) != 0) {
                            tls_certificate_set_serial(cert, &buffer[pos], @as(c_int, @bitCast(length)));
                        }
                        if (_is_field(fields, @as([*c]const c_uint, @ptrCast(@alignCast(&version_id)))) != 0) {
                            if (length == @as(c_uint, @bitCast(@as(c_int, 1)))) {
                                cert.*.version = @as(c_ushort, @bitCast(@as(c_ushort, buffer[pos])));
                            } else {
                                cert.*.version = 0;
                            }
                            idx += 1;
                        }
                        if (level >= @as(c_int, 2)) {
                            var fields_temp: [3]c_uint = undefined;
                            _ = &fields_temp;
                            fields_temp[@as(c_uint, @intCast(@as(c_int, 0)))] = (blk: {
                                const tmp = level - @as(c_int, 2);
                                if (tmp >= 0) break :blk fields + @as(usize, @intCast(tmp)) else break :blk fields - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                            }).*;
                            fields_temp[@as(c_uint, @intCast(@as(c_int, 1)))] = (blk: {
                                const tmp = level - @as(c_int, 1);
                                if (tmp >= 0) break :blk fields + @as(usize, @intCast(tmp)) else break :blk fields - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                            }).*;
                            fields_temp[@as(c_uint, @intCast(@as(c_int, 2)))] = 0;
                            if (_is_field(@as([*c]c_uint, @ptrCast(@alignCast(&fields_temp))), @as([*c]const c_uint, @ptrCast(@alignCast(&priv_id)))) != 0) {
                                tls_certificate_set_priv(cert, &buffer[pos], @as(c_int, @bitCast(length)));
                            }
                        }
                        {}
                        {}
                        if ((chain != null) and (length > @as(c_uint, @bitCast(@as(c_int, 2))))) {
                            if (_private_is_oid(chain, @as([*c]const u8, @ptrCast(@alignCast(&san_oid))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([4]u8) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))))))) != 0) {
                                cert.*.san = @as([*c][*c]u8, @ptrCast(@alignCast(realloc(@as(?*anyopaque, @ptrCast(cert.*.san)), @sizeOf([*c]u8) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, @bitCast(@as(c_uint, cert.*.san_length))) + @as(c_int, 1))))))));
                                if (cert.*.san != null) {
                                    cert.*.san[cert.*.san_length] = null;
                                    tls_certificate_set_copy(&cert.*.san[cert.*.san_length], &buffer[pos], @as(c_int, @bitCast(length)));
                                    cert.*.san_length +%= 1;
                                } else {
                                    cert.*.san_length = 0;
                                }
                            }
                        }
                        {}
                        break;
                    },
                    @as(c_int, 3) => {
                        if (_is_field(fields, @as([*c]const c_uint, @ptrCast(@alignCast(&pk_id)))) != 0) {
                            if (has_key != null) {
                                has_key.* = 1;
                            }
                        }
                        {}
                        {}
                        {}
                        if (_is_field(fields, @as([*c]const c_uint, @ptrCast(@alignCast(&sign_id)))) != 0) {
                            tls_certificate_set_sign_key(cert, &buffer[pos], @as(c_int, @bitCast(length)));
                        } else if ((cert.*.ec_algorithm != 0) and (_is_field(fields, @as([*c]const c_uint, @ptrCast(@alignCast(&pk_id)))) != 0)) {
                            tls_certificate_set_key(cert, &buffer[pos], @as(c_int, @bitCast(length)));
                        } else {
                            if ((@as(c_int, @bitCast(@as(c_uint, buffer[pos]))) == @as(c_int, 0)) and (length > @as(c_uint, @bitCast(@as(c_int, 256))))) {
                                _ = _private_asn1_parse(context, cert, (&buffer[pos]) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))), length -% @as(c_uint, @bitCast(@as(c_int, 1))), level + @as(c_int, 1), fields, &local_has_key, client_cert, top_oid, &local_chain);
                            } else {
                                _ = _private_asn1_parse(context, cert, &buffer[pos], length, level + @as(c_int, 1), fields, &local_has_key, client_cert, top_oid, &local_chain);
                            }
                            if (top_oid != null) {
                                if (_is_oid2(top_oid, @as([*c]const u8, @ptrCast(@alignCast(&TLS_EC_prime256v1_OID))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([16]u8))))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf(c_int) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))))))) != 0) {
                                    cert.*.ec_algorithm = @as(c_uint, @bitCast(secp256r1.iana));
                                } else if (_is_oid2(top_oid, @as([*c]const u8, @ptrCast(@alignCast(&TLS_EC_secp224r1_OID))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([16]u8))))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([6]u8) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))))))) != 0) {
                                    cert.*.ec_algorithm = @as(c_uint, @bitCast(secp224r1.iana));
                                } else if (_is_oid2(top_oid, @as([*c]const u8, @ptrCast(@alignCast(&TLS_EC_secp384r1_OID))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([16]u8))))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([6]u8) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))))))) != 0) {
                                    cert.*.ec_algorithm = @as(c_uint, @bitCast(secp384r1.iana));
                                } else if (_is_oid2(top_oid, @as([*c]const u8, @ptrCast(@alignCast(&TLS_EC_secp521r1_OID))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([16]u8))))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([6]u8) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))))))) != 0) {
                                    cert.*.ec_algorithm = @as(c_uint, @bitCast(secp521r1.iana));
                                }
                                if ((cert.*.ec_algorithm != 0) and !(cert.*.pk != null)) {
                                    tls_certificate_set_key(cert, &buffer[pos], @as(c_int, @bitCast(length)));
                                }
                            }
                        }
                        break;
                    },
                    @as(c_int, 4) => {
                        if (((top_oid != null) and (_is_field(fields, @as([*c]const c_uint, @ptrCast(@alignCast(&ecc_priv_id)))) != 0)) and !(cert.*.priv != null)) {
                            tls_certificate_set_priv(cert, &buffer[pos], @as(c_int, @bitCast(length)));
                        } else {
                            _ = _private_asn1_parse(context, cert, &buffer[pos], length, level + @as(c_int, 1), fields, &local_has_key, client_cert, top_oid, &local_chain);
                        }
                        break;
                    },
                    @as(c_int, 5) => {
                        {}
                        break;
                    },
                    @as(c_int, 6) => {
                        if (_is_field(fields, @as([*c]const c_uint, @ptrCast(@alignCast(&pk_id)))) != 0) {
                            if ((length == @as(c_uint, @bitCast(@as(c_int, 8)))) or (length == @as(c_uint, @bitCast(@as(c_int, 5))))) {
                                tls_certificate_set_algorithm(context, &cert.*.ec_algorithm, &buffer[pos], @as(c_int, @bitCast(length)));
                            } else {
                                tls_certificate_set_algorithm(context, &cert.*.key_algorithm, &buffer[pos], @as(c_int, @bitCast(length)));
                            }
                        }
                        if (_is_field(fields, @as([*c]const c_uint, @ptrCast(@alignCast(&algorithm_id)))) != 0) {
                            tls_certificate_set_algorithm(context, &cert.*.algorithm, &buffer[pos], @as(c_int, @bitCast(length)));
                        }
                        {}
                        {}
                        {}
                        if (_is_oid2(@as([*c]u8, @ptrCast(@alignCast(&oid))), @as([*c]const u8, @ptrCast(@alignCast(&ocsp_oid))), @as(c_int, 16), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([9]u8) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))))))))) != 0) {
                            tls_certificate_set_copy(&cert.*.ocsp, &buffer[pos], @as(c_int, @bitCast(length)));
                        }
                        if (length < @as(c_uint, @bitCast(@as(c_int, 16)))) {
                            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&oid))))), @as(?*const anyopaque, @ptrCast(&buffer[pos])), @as(c_ulong, @bitCast(@as(c_ulong, length))));
                        } else {
                            _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&oid))))), @as(?*const anyopaque, @ptrCast(&buffer[pos])), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16)))));
                        }
                        if (top_oid != null) {
                            _ = memcpy(@as(?*anyopaque, @ptrCast(top_oid)), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&oid))))), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 16)))));
                        }
                        break;
                    },
                    @as(c_int, 9) => {
                        {}
                        {}
                        {}
                        break;
                    },
                    @as(c_int, 23) => {
                        {}
                        {}
                        {}
                        if (_is_field(fields, @as([*c]const c_uint, @ptrCast(@alignCast(&validity_id)))) != 0) {
                            if (idx == @as(c_int, 1)) {
                                tls_certificate_set_copy_date(&cert.*.not_before, &buffer[pos], @as(c_int, @bitCast(length)));
                            } else {
                                tls_certificate_set_copy_date(&cert.*.not_after, &buffer[pos], @as(c_int, @bitCast(length)));
                            }
                        }
                        break;
                    },
                    @as(c_int, 24) => {
                        {}
                        {}
                        {}
                        break;
                    },
                    @as(c_int, 19), @as(c_int, 12), @as(c_int, 20), @as(c_int, 21), @as(c_int, 22), @as(c_int, 25), @as(c_int, 26), @as(c_int, 27), @as(c_int, 28), @as(c_int, 29), @as(c_int, 30) => {
                        if (_is_field(fields, @as([*c]const c_uint, @ptrCast(@alignCast(&issurer_id)))) != 0) {
                            if (_is_oid(@as([*c]u8, @ptrCast(@alignCast(&oid))), @as([*c]const u8, @ptrCast(@alignCast(&country_oid))), @as(c_int, 3)) != 0) {
                                tls_certificate_set_copy(&cert.*.issuer_country, &buffer[pos], @as(c_int, @bitCast(length)));
                            } else if (_is_oid(@as([*c]u8, @ptrCast(@alignCast(&oid))), @as([*c]const u8, @ptrCast(@alignCast(&state_oid))), @as(c_int, 3)) != 0) {
                                tls_certificate_set_copy(&cert.*.issuer_state, &buffer[pos], @as(c_int, @bitCast(length)));
                            } else if (_is_oid(@as([*c]u8, @ptrCast(@alignCast(&oid))), @as([*c]const u8, @ptrCast(@alignCast(&location_oid))), @as(c_int, 3)) != 0) {
                                tls_certificate_set_copy(&cert.*.issuer_location, &buffer[pos], @as(c_int, @bitCast(length)));
                            } else if (_is_oid(@as([*c]u8, @ptrCast(@alignCast(&oid))), @as([*c]const u8, @ptrCast(@alignCast(&entity_oid))), @as(c_int, 3)) != 0) {
                                tls_certificate_set_copy(&cert.*.issuer_entity, &buffer[pos], @as(c_int, @bitCast(length)));
                            } else if (_is_oid(@as([*c]u8, @ptrCast(@alignCast(&oid))), @as([*c]const u8, @ptrCast(@alignCast(&subject_oid))), @as(c_int, 3)) != 0) {
                                tls_certificate_set_copy(&cert.*.issuer_subject, &buffer[pos], @as(c_int, @bitCast(length)));
                            }
                        } else if (_is_field(fields, @as([*c]const c_uint, @ptrCast(@alignCast(&owner_id)))) != 0) {
                            if (_is_oid(@as([*c]u8, @ptrCast(@alignCast(&oid))), @as([*c]const u8, @ptrCast(@alignCast(&country_oid))), @as(c_int, 3)) != 0) {
                                tls_certificate_set_copy(&cert.*.country, &buffer[pos], @as(c_int, @bitCast(length)));
                            } else if (_is_oid(@as([*c]u8, @ptrCast(@alignCast(&oid))), @as([*c]const u8, @ptrCast(@alignCast(&state_oid))), @as(c_int, 3)) != 0) {
                                tls_certificate_set_copy(&cert.*.state, &buffer[pos], @as(c_int, @bitCast(length)));
                            } else if (_is_oid(@as([*c]u8, @ptrCast(@alignCast(&oid))), @as([*c]const u8, @ptrCast(@alignCast(&location_oid))), @as(c_int, 3)) != 0) {
                                tls_certificate_set_copy(&cert.*.location, &buffer[pos], @as(c_int, @bitCast(length)));
                            } else if (_is_oid(@as([*c]u8, @ptrCast(@alignCast(&oid))), @as([*c]const u8, @ptrCast(@alignCast(&entity_oid))), @as(c_int, 3)) != 0) {
                                tls_certificate_set_copy(&cert.*.entity, &buffer[pos], @as(c_int, @bitCast(length)));
                            } else if (_is_oid(@as([*c]u8, @ptrCast(@alignCast(&oid))), @as([*c]const u8, @ptrCast(@alignCast(&subject_oid))), @as(c_int, 3)) != 0) {
                                tls_certificate_set_copy(&cert.*.subject, &buffer[pos], @as(c_int, @bitCast(length)));
                            }
                        }
                        {}
                        {}
                        {}
                        break;
                    },
                    @as(c_int, 16) => {
                        {}
                        break;
                    },
                    @as(c_int, 10) => {
                        {}
                        {}
                        {}
                        break;
                    },
                    else => {
                        {}
                        break;
                    },
                }
                break;
            }
        }
        pos +%= length;
    }
    if (((((level == @as(c_int, 2)) and (cert.*.sign_key != null)) and (cert.*.sign_len != 0)) and (cert_len != 0)) and (cert_data != null)) {
        if (cert.*.fingerprint != null) {
            free(@as(?*anyopaque, @ptrCast(cert.*.fingerprint)));
        }
        cert.*.fingerprint = _private_tls_compute_hash(@as(c_int, @bitCast(cert.*.algorithm)), cert_data, cert_len);
    }
    return @as(c_int, @bitCast(pos));
}
pub export fn _private_tls_read_from_file(arg_fname: [*c]const u8, arg_buf: ?*anyopaque, arg_max_len: c_int) c_int {
    var fname = arg_fname;
    _ = &fname;
    var buf = arg_buf;
    _ = &buf;
    var max_len = arg_max_len;
    _ = &max_len;
    var f: [*c]FILE = fopen(fname, "rb");
    _ = &f;
    if (f != null) {
        var size: c_int = @as(c_int, @bitCast(@as(c_uint, @truncate(fread(buf, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))), @as(c_ulong, @bitCast(@as(c_long, max_len))), f)))));
        _ = &size;
        _ = fclose(f);
        return size;
    }
    return 0;
}
pub export fn _private_tls_crc32(arg_s: [*c]const u8, arg_n: c_int) u32 {
    var s = arg_s;
    _ = &s;
    var n = arg_n;
    _ = &n;
    var crc: u32 = 4294967295;
    _ = &crc;
    var i: c_int = undefined;
    _ = &i;
    var j: c_int = undefined;
    _ = &j;
    {
        i = 0;
        while (i < n) : (i += 1) {
            var ch: u8 = @as(u8, @bitCast((blk: {
                const tmp = i;
                if (tmp >= 0) break :blk s + @as(usize, @intCast(tmp)) else break :blk s - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*));
            _ = &ch;
            {
                j = 0;
                while (j < @as(c_int, 8)) : (j += 1) {
                    var b: u32 = (@as(u32, @bitCast(@as(c_uint, ch))) ^ crc) & @as(u32, @bitCast(@as(c_int, 1)));
                    _ = &b;
                    crc >>= @intCast(@as(c_int, 1));
                    if (b != 0) {
                        crc = crc ^ @as(c_uint, 3988292384);
                    }
                    ch >>= @intCast(@as(c_int, 1));
                }
            }
        }
    }
    return ~crc;
}
pub export fn _private_tls_peerconnection_buffer_add(arg_use_buffer: [*c][*c]struct_TLSRTCPeerBuffer, arg_buf: [*c]const u8, arg_len: c_int) c_int {
    var use_buffer = arg_use_buffer;
    _ = &use_buffer;
    var buf = arg_buf;
    _ = &buf;
    var len = arg_len;
    _ = &len;
    if ((!(use_buffer != null) or !(buf != null)) or !(len != 0)) return -@as(c_int, 1);
    var buffer: [*c]struct_TLSRTCPeerBuffer = @as([*c]struct_TLSRTCPeerBuffer, @ptrCast(@alignCast(malloc(@sizeOf(struct_TLSRTCPeerBuffer)))));
    _ = &buffer;
    if (!(buffer != null)) return -@as(c_int, 9);
    buffer.*.buf = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(@as(c_long, len)))))));
    if (!(buffer.*.buf != null)) {
        if (buffer != null) {
            free(@as(?*anyopaque, @ptrCast(buffer)));
        }
        return -@as(c_int, 9);
    }
    _ = memcpy(@as(?*anyopaque, @ptrCast(buffer.*.buf)), @as(?*const anyopaque, @ptrCast(buf)), @as(c_ulong, @bitCast(@as(c_long, len))));
    buffer.*.len = @as(c_uint, @bitCast(len));
    buffer.*.next = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
    if (use_buffer.* != null) {
        var next: [*c]struct_TLSRTCPeerBuffer = use_buffer.*;
        _ = &next;
        while ((next != null) and (next.*.next != null)) {
            next = @as([*c]struct_TLSRTCPeerBuffer, @ptrCast(@alignCast(next.*.next)));
        }
        next.*.next = @as(?*anyopaque, @ptrCast(buffer));
    } else {
        use_buffer.* = buffer;
    }
    return len;
}
pub export fn _private_dtls_ensure_keys(arg_channel: [*c]struct_TLSRTCPeerConnection) void {
    var channel = arg_channel;
    _ = &channel;
}
pub export fn _tls_ssl_private_send_pending(arg_client_sock: c_int, arg_context: [*c]struct_TLSContext) c_int {
    var client_sock = arg_client_sock;
    _ = &client_sock;
    var context = arg_context;
    _ = &context;
    var out_buffer_len: c_uint = 0;
    _ = &out_buffer_len;
    var out_buffer: [*c]const u8 = tls_get_write_buffer(context, &out_buffer_len);
    _ = &out_buffer;
    var out_buffer_index: c_uint = 0;
    _ = &out_buffer_index;
    var send_res: c_int = 0;
    _ = &send_res;
    var write_cb: SOCKET_SEND_CALLBACK = null;
    _ = &write_cb;
    var ssl_data: [*c]SSLUserData = @as([*c]SSLUserData, @ptrCast(@alignCast(context.*.user_data)));
    _ = &ssl_data;
    if (ssl_data != null) {
        write_cb = ssl_data.*.send;
    }
    while ((out_buffer != null) and (out_buffer_len > @as(c_uint, @bitCast(@as(c_int, 0))))) {
        var res: c_int = undefined;
        _ = &res;
        if (write_cb != null) {
            res = write_cb.?(client_sock, @as(?*const anyopaque, @ptrCast(@as([*c]const u8, @ptrCast(@alignCast(&out_buffer[out_buffer_index]))))), @as(usize, @bitCast(@as(c_ulong, out_buffer_len))), @as(c_int, 0));
        } else {
            res = @as(c_int, @bitCast(@as(c_int, @truncate(send(client_sock, @as(?*const anyopaque, @ptrCast(@as([*c]const u8, @ptrCast(@alignCast(&out_buffer[out_buffer_index]))))), @as(usize, @bitCast(@as(c_ulong, out_buffer_len))), @as(c_int, 0))))));
        }
        if (res <= @as(c_int, 0)) {
            if (!(write_cb != null) and (res < @as(c_int, 0))) {
                if ((__errno_location().* == @as(c_int, 11)) or (__errno_location().* == @as(c_int, 4))) {
                    context.*.tls_buffer_len = out_buffer_len;
                    _ = memmove(@as(?*anyopaque, @ptrCast(context.*.tls_buffer)), @as(?*const anyopaque, @ptrCast(out_buffer + out_buffer_index)), @as(c_ulong, @bitCast(@as(c_ulong, out_buffer_len))));
                    return res;
                }
            }
            send_res = res;
            break;
        }
        out_buffer_len -%= @as(c_uint, @bitCast(res));
        out_buffer_index +%= @as(c_uint, @bitCast(res));
        send_res += res;
    }
    tls_buffer_clear(context);
    return send_res;
}
pub export fn _private_tls_safe_read(arg_context: [*c]struct_TLSContext, arg_buffer: ?*anyopaque, arg_buf_size: c_int) c_int {
    var context = arg_context;
    _ = &context;
    var buffer = arg_buffer;
    _ = &buffer;
    var buf_size = arg_buf_size;
    _ = &buf_size;
    var ssl_data: [*c]SSLUserData = @as([*c]SSLUserData, @ptrCast(@alignCast(context.*.user_data)));
    _ = &ssl_data;
    if (!(ssl_data != null) or (ssl_data.*.fd < @as(c_int, 0))) return -@as(c_int, 1);
    var read_cb: SOCKET_RECV_CALLBACK = ssl_data.*.recv;
    _ = &read_cb;
    if (read_cb != null) return read_cb.?(ssl_data.*.fd, @as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(buffer))))), @as(usize, @bitCast(@as(c_long, buf_size))), @as(c_int, 0));
    return @as(c_int, @bitCast(@as(c_int, @truncate(recv(ssl_data.*.fd, @as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(buffer))))), @as(usize, @bitCast(@as(c_long, buf_size))), @as(c_int, 0))))));
}
pub const __llvm__ = @as(c_int, 1);
pub const __clang__ = @as(c_int, 1);
pub const __clang_major__ = @as(c_int, 19);
pub const __clang_minor__ = @as(c_int, 1);
pub const __clang_patchlevel__ = @as(c_int, 7);
pub const __clang_version__ = "19.1.7 (https://github.com/ziglang/zig-bootstrap 1c3c59435891bc9caf8cd1d3783773369d191c5f)";
pub const __GNUC__ = @as(c_int, 4);
pub const __GNUC_MINOR__ = @as(c_int, 2);
pub const __GNUC_PATCHLEVEL__ = @as(c_int, 1);
pub const __GXX_ABI_VERSION = @as(c_int, 1002);
pub const __ATOMIC_RELAXED = @as(c_int, 0);
pub const __ATOMIC_CONSUME = @as(c_int, 1);
pub const __ATOMIC_ACQUIRE = @as(c_int, 2);
pub const __ATOMIC_RELEASE = @as(c_int, 3);
pub const __ATOMIC_ACQ_REL = @as(c_int, 4);
pub const __ATOMIC_SEQ_CST = @as(c_int, 5);
pub const __MEMORY_SCOPE_SYSTEM = @as(c_int, 0);
pub const __MEMORY_SCOPE_DEVICE = @as(c_int, 1);
pub const __MEMORY_SCOPE_WRKGRP = @as(c_int, 2);
pub const __MEMORY_SCOPE_WVFRNT = @as(c_int, 3);
pub const __MEMORY_SCOPE_SINGLE = @as(c_int, 4);
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM = @as(c_int, 0);
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP = @as(c_int, 1);
pub const __OPENCL_MEMORY_SCOPE_DEVICE = @as(c_int, 2);
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES = @as(c_int, 3);
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP = @as(c_int, 4);
pub const __FPCLASS_SNAN = @as(c_int, 0x0001);
pub const __FPCLASS_QNAN = @as(c_int, 0x0002);
pub const __FPCLASS_NEGINF = @as(c_int, 0x0004);
pub const __FPCLASS_NEGNORMAL = @as(c_int, 0x0008);
pub const __FPCLASS_NEGSUBNORMAL = @as(c_int, 0x0010);
pub const __FPCLASS_NEGZERO = @as(c_int, 0x0020);
pub const __FPCLASS_POSZERO = @as(c_int, 0x0040);
pub const __FPCLASS_POSSUBNORMAL = @as(c_int, 0x0080);
pub const __FPCLASS_POSNORMAL = @as(c_int, 0x0100);
pub const __FPCLASS_POSINF = @as(c_int, 0x0200);
pub const __PRAGMA_REDEFINE_EXTNAME = @as(c_int, 1);
pub const __VERSION__ = "Clang 19.1.7 (https://github.com/ziglang/zig-bootstrap 1c3c59435891bc9caf8cd1d3783773369d191c5f)";
pub const __OBJC_BOOL_IS_BOOL = @as(c_int, 0);
pub const __CONSTANT_CFSTRINGS__ = @as(c_int, 1);
pub const __clang_literal_encoding__ = "UTF-8";
pub const __clang_wide_literal_encoding__ = "UTF-32";
pub const __ORDER_LITTLE_ENDIAN__ = @as(c_int, 1234);
pub const __ORDER_BIG_ENDIAN__ = @as(c_int, 4321);
pub const __ORDER_PDP_ENDIAN__ = @as(c_int, 3412);
pub const __BYTE_ORDER__ = __ORDER_LITTLE_ENDIAN__;
pub const __LITTLE_ENDIAN__ = @as(c_int, 1);
pub const _LP64 = @as(c_int, 1);
pub const __LP64__ = @as(c_int, 1);
pub const __CHAR_BIT__ = @as(c_int, 8);
pub const __BOOL_WIDTH__ = @as(c_int, 8);
pub const __SHRT_WIDTH__ = @as(c_int, 16);
pub const __INT_WIDTH__ = @as(c_int, 32);
pub const __LONG_WIDTH__ = @as(c_int, 64);
pub const __LLONG_WIDTH__ = @as(c_int, 64);
pub const __BITINT_MAXWIDTH__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 8388608, .decimal);
pub const __SCHAR_MAX__ = @as(c_int, 127);
pub const __SHRT_MAX__ = @as(c_int, 32767);
pub const __INT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __LONG_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __LONG_LONG_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __WCHAR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __WCHAR_WIDTH__ = @as(c_int, 32);
pub const __WINT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __WINT_WIDTH__ = @as(c_int, 32);
pub const __INTMAX_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INTMAX_WIDTH__ = @as(c_int, 64);
pub const __SIZE_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __SIZE_WIDTH__ = @as(c_int, 64);
pub const __UINTMAX_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINTMAX_WIDTH__ = @as(c_int, 64);
pub const __PTRDIFF_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __PTRDIFF_WIDTH__ = @as(c_int, 64);
pub const __INTPTR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INTPTR_WIDTH__ = @as(c_int, 64);
pub const __UINTPTR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINTPTR_WIDTH__ = @as(c_int, 64);
pub const __SIZEOF_DOUBLE__ = @as(c_int, 8);
pub const __SIZEOF_FLOAT__ = @as(c_int, 4);
pub const __SIZEOF_INT__ = @as(c_int, 4);
pub const __SIZEOF_LONG__ = @as(c_int, 8);
pub const __SIZEOF_LONG_DOUBLE__ = @as(c_int, 16);
pub const __SIZEOF_LONG_LONG__ = @as(c_int, 8);
pub const __SIZEOF_POINTER__ = @as(c_int, 8);
pub const __SIZEOF_SHORT__ = @as(c_int, 2);
pub const __SIZEOF_PTRDIFF_T__ = @as(c_int, 8);
pub const __SIZEOF_SIZE_T__ = @as(c_int, 8);
pub const __SIZEOF_WCHAR_T__ = @as(c_int, 4);
pub const __SIZEOF_WINT_T__ = @as(c_int, 4);
pub const __SIZEOF_INT128__ = @as(c_int, 16);
pub const __INTMAX_TYPE__ = c_long;
pub const __INTMAX_FMTd__ = "ld";
pub const __INTMAX_FMTi__ = "li";
pub const __INTMAX_C_SUFFIX__ = L;
pub const __UINTMAX_TYPE__ = c_ulong;
pub const __UINTMAX_FMTo__ = "lo";
pub const __UINTMAX_FMTu__ = "lu";
pub const __UINTMAX_FMTx__ = "lx";
pub const __UINTMAX_FMTX__ = "lX";
pub const __UINTMAX_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `UL`");
// (no file):101:9
pub const __PTRDIFF_TYPE__ = c_long;
pub const __PTRDIFF_FMTd__ = "ld";
pub const __PTRDIFF_FMTi__ = "li";
pub const __INTPTR_TYPE__ = c_long;
pub const __INTPTR_FMTd__ = "ld";
pub const __INTPTR_FMTi__ = "li";
pub const __SIZE_TYPE__ = c_ulong;
pub const __SIZE_FMTo__ = "lo";
pub const __SIZE_FMTu__ = "lu";
pub const __SIZE_FMTx__ = "lx";
pub const __SIZE_FMTX__ = "lX";
pub const __WCHAR_TYPE__ = c_int;
pub const __WINT_TYPE__ = c_uint;
pub const __SIG_ATOMIC_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __SIG_ATOMIC_WIDTH__ = @as(c_int, 32);
pub const __CHAR16_TYPE__ = c_ushort;
pub const __CHAR32_TYPE__ = c_uint;
pub const __UINTPTR_TYPE__ = c_ulong;
pub const __UINTPTR_FMTo__ = "lo";
pub const __UINTPTR_FMTu__ = "lu";
pub const __UINTPTR_FMTx__ = "lx";
pub const __UINTPTR_FMTX__ = "lX";
pub const __FLT16_DENORM_MIN__ = @as(f16, 5.9604644775390625e-8);
pub const __FLT16_NORM_MAX__ = @as(f16, 6.5504e+4);
pub const __FLT16_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT16_DIG__ = @as(c_int, 3);
pub const __FLT16_DECIMAL_DIG__ = @as(c_int, 5);
pub const __FLT16_EPSILON__ = @as(f16, 9.765625e-4);
pub const __FLT16_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT16_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT16_MANT_DIG__ = @as(c_int, 11);
pub const __FLT16_MAX_10_EXP__ = @as(c_int, 4);
pub const __FLT16_MAX_EXP__ = @as(c_int, 16);
pub const __FLT16_MAX__ = @as(f16, 6.5504e+4);
pub const __FLT16_MIN_10_EXP__ = -@as(c_int, 4);
pub const __FLT16_MIN_EXP__ = -@as(c_int, 13);
pub const __FLT16_MIN__ = @as(f16, 6.103515625e-5);
pub const __FLT_DENORM_MIN__ = @as(f32, 1.40129846e-45);
pub const __FLT_NORM_MAX__ = @as(f32, 3.40282347e+38);
pub const __FLT_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT_DIG__ = @as(c_int, 6);
pub const __FLT_DECIMAL_DIG__ = @as(c_int, 9);
pub const __FLT_EPSILON__ = @as(f32, 1.19209290e-7);
pub const __FLT_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT_MANT_DIG__ = @as(c_int, 24);
pub const __FLT_MAX_10_EXP__ = @as(c_int, 38);
pub const __FLT_MAX_EXP__ = @as(c_int, 128);
pub const __FLT_MAX__ = @as(f32, 3.40282347e+38);
pub const __FLT_MIN_10_EXP__ = -@as(c_int, 37);
pub const __FLT_MIN_EXP__ = -@as(c_int, 125);
pub const __FLT_MIN__ = @as(f32, 1.17549435e-38);
pub const __DBL_DENORM_MIN__ = @as(f64, 4.9406564584124654e-324);
pub const __DBL_NORM_MAX__ = @as(f64, 1.7976931348623157e+308);
pub const __DBL_HAS_DENORM__ = @as(c_int, 1);
pub const __DBL_DIG__ = @as(c_int, 15);
pub const __DBL_DECIMAL_DIG__ = @as(c_int, 17);
pub const __DBL_EPSILON__ = @as(f64, 2.2204460492503131e-16);
pub const __DBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __DBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __DBL_MANT_DIG__ = @as(c_int, 53);
pub const __DBL_MAX_10_EXP__ = @as(c_int, 308);
pub const __DBL_MAX_EXP__ = @as(c_int, 1024);
pub const __DBL_MAX__ = @as(f64, 1.7976931348623157e+308);
pub const __DBL_MIN_10_EXP__ = -@as(c_int, 307);
pub const __DBL_MIN_EXP__ = -@as(c_int, 1021);
pub const __DBL_MIN__ = @as(f64, 2.2250738585072014e-308);
pub const __LDBL_DENORM_MIN__ = @as(c_longdouble, 3.64519953188247460253e-4951);
pub const __LDBL_NORM_MAX__ = @as(c_longdouble, 1.18973149535723176502e+4932);
pub const __LDBL_HAS_DENORM__ = @as(c_int, 1);
pub const __LDBL_DIG__ = @as(c_int, 18);
pub const __LDBL_DECIMAL_DIG__ = @as(c_int, 21);
pub const __LDBL_EPSILON__ = @as(c_longdouble, 1.08420217248550443401e-19);
pub const __LDBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __LDBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __LDBL_MANT_DIG__ = @as(c_int, 64);
pub const __LDBL_MAX_10_EXP__ = @as(c_int, 4932);
pub const __LDBL_MAX_EXP__ = @as(c_int, 16384);
pub const __LDBL_MAX__ = @as(c_longdouble, 1.18973149535723176502e+4932);
pub const __LDBL_MIN_10_EXP__ = -@as(c_int, 4931);
pub const __LDBL_MIN_EXP__ = -@as(c_int, 16381);
pub const __LDBL_MIN__ = @as(c_longdouble, 3.36210314311209350626e-4932);
pub const __POINTER_WIDTH__ = @as(c_int, 64);
pub const __BIGGEST_ALIGNMENT__ = @as(c_int, 16);
pub const __WINT_UNSIGNED__ = @as(c_int, 1);
pub const __INT8_TYPE__ = i8;
pub const __INT8_FMTd__ = "hhd";
pub const __INT8_FMTi__ = "hhi";
pub const __INT8_C_SUFFIX__ = "";
pub const __INT16_TYPE__ = c_short;
pub const __INT16_FMTd__ = "hd";
pub const __INT16_FMTi__ = "hi";
pub const __INT16_C_SUFFIX__ = "";
pub const __INT32_TYPE__ = c_int;
pub const __INT32_FMTd__ = "d";
pub const __INT32_FMTi__ = "i";
pub const __INT32_C_SUFFIX__ = "";
pub const __INT64_TYPE__ = c_long;
pub const __INT64_FMTd__ = "ld";
pub const __INT64_FMTi__ = "li";
pub const __INT64_C_SUFFIX__ = L;
pub const __UINT8_TYPE__ = u8;
pub const __UINT8_FMTo__ = "hho";
pub const __UINT8_FMTu__ = "hhu";
pub const __UINT8_FMTx__ = "hhx";
pub const __UINT8_FMTX__ = "hhX";
pub const __UINT8_C_SUFFIX__ = "";
pub const __UINT8_MAX__ = @as(c_int, 255);
pub const __INT8_MAX__ = @as(c_int, 127);
pub const __UINT16_TYPE__ = c_ushort;
pub const __UINT16_FMTo__ = "ho";
pub const __UINT16_FMTu__ = "hu";
pub const __UINT16_FMTx__ = "hx";
pub const __UINT16_FMTX__ = "hX";
pub const __UINT16_C_SUFFIX__ = "";
pub const __UINT16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __INT16_MAX__ = @as(c_int, 32767);
pub const __UINT32_TYPE__ = c_uint;
pub const __UINT32_FMTo__ = "o";
pub const __UINT32_FMTu__ = "u";
pub const __UINT32_FMTx__ = "x";
pub const __UINT32_FMTX__ = "X";
pub const __UINT32_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `U`");
// (no file):224:9
pub const __UINT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __INT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __UINT64_TYPE__ = c_ulong;
pub const __UINT64_FMTo__ = "lo";
pub const __UINT64_FMTu__ = "lu";
pub const __UINT64_FMTx__ = "lx";
pub const __UINT64_FMTX__ = "lX";
pub const __UINT64_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `UL`");
// (no file):232:9
pub const __UINT64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __INT64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INT_LEAST8_TYPE__ = i8;
pub const __INT_LEAST8_MAX__ = @as(c_int, 127);
pub const __INT_LEAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_LEAST8_FMTd__ = "hhd";
pub const __INT_LEAST8_FMTi__ = "hhi";
pub const __UINT_LEAST8_TYPE__ = u8;
pub const __UINT_LEAST8_MAX__ = @as(c_int, 255);
pub const __UINT_LEAST8_FMTo__ = "hho";
pub const __UINT_LEAST8_FMTu__ = "hhu";
pub const __UINT_LEAST8_FMTx__ = "hhx";
pub const __UINT_LEAST8_FMTX__ = "hhX";
pub const __INT_LEAST16_TYPE__ = c_short;
pub const __INT_LEAST16_MAX__ = @as(c_int, 32767);
pub const __INT_LEAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_LEAST16_FMTd__ = "hd";
pub const __INT_LEAST16_FMTi__ = "hi";
pub const __UINT_LEAST16_TYPE__ = c_ushort;
pub const __UINT_LEAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_LEAST16_FMTo__ = "ho";
pub const __UINT_LEAST16_FMTu__ = "hu";
pub const __UINT_LEAST16_FMTx__ = "hx";
pub const __UINT_LEAST16_FMTX__ = "hX";
pub const __INT_LEAST32_TYPE__ = c_int;
pub const __INT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_LEAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_LEAST32_FMTd__ = "d";
pub const __INT_LEAST32_FMTi__ = "i";
pub const __UINT_LEAST32_TYPE__ = c_uint;
pub const __UINT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_LEAST32_FMTo__ = "o";
pub const __UINT_LEAST32_FMTu__ = "u";
pub const __UINT_LEAST32_FMTx__ = "x";
pub const __UINT_LEAST32_FMTX__ = "X";
pub const __INT_LEAST64_TYPE__ = c_long;
pub const __INT_LEAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INT_LEAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_LEAST64_FMTd__ = "ld";
pub const __INT_LEAST64_FMTi__ = "li";
pub const __UINT_LEAST64_TYPE__ = c_ulong;
pub const __UINT_LEAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINT_LEAST64_FMTo__ = "lo";
pub const __UINT_LEAST64_FMTu__ = "lu";
pub const __UINT_LEAST64_FMTx__ = "lx";
pub const __UINT_LEAST64_FMTX__ = "lX";
pub const __INT_FAST8_TYPE__ = i8;
pub const __INT_FAST8_MAX__ = @as(c_int, 127);
pub const __INT_FAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_FAST8_FMTd__ = "hhd";
pub const __INT_FAST8_FMTi__ = "hhi";
pub const __UINT_FAST8_TYPE__ = u8;
pub const __UINT_FAST8_MAX__ = @as(c_int, 255);
pub const __UINT_FAST8_FMTo__ = "hho";
pub const __UINT_FAST8_FMTu__ = "hhu";
pub const __UINT_FAST8_FMTx__ = "hhx";
pub const __UINT_FAST8_FMTX__ = "hhX";
pub const __INT_FAST16_TYPE__ = c_short;
pub const __INT_FAST16_MAX__ = @as(c_int, 32767);
pub const __INT_FAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_FAST16_FMTd__ = "hd";
pub const __INT_FAST16_FMTi__ = "hi";
pub const __UINT_FAST16_TYPE__ = c_ushort;
pub const __UINT_FAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_FAST16_FMTo__ = "ho";
pub const __UINT_FAST16_FMTu__ = "hu";
pub const __UINT_FAST16_FMTx__ = "hx";
pub const __UINT_FAST16_FMTX__ = "hX";
pub const __INT_FAST32_TYPE__ = c_int;
pub const __INT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_FAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_FAST32_FMTd__ = "d";
pub const __INT_FAST32_FMTi__ = "i";
pub const __UINT_FAST32_TYPE__ = c_uint;
pub const __UINT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_FAST32_FMTo__ = "o";
pub const __UINT_FAST32_FMTu__ = "u";
pub const __UINT_FAST32_FMTx__ = "x";
pub const __UINT_FAST32_FMTX__ = "X";
pub const __INT_FAST64_TYPE__ = c_long;
pub const __INT_FAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INT_FAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_FAST64_FMTd__ = "ld";
pub const __INT_FAST64_FMTi__ = "li";
pub const __UINT_FAST64_TYPE__ = c_ulong;
pub const __UINT_FAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINT_FAST64_FMTo__ = "lo";
pub const __UINT_FAST64_FMTu__ = "lu";
pub const __UINT_FAST64_FMTx__ = "lx";
pub const __UINT_FAST64_FMTX__ = "lX";
pub const __USER_LABEL_PREFIX__ = "";
pub const __FINITE_MATH_ONLY__ = @as(c_int, 0);
pub const __GNUC_STDC_INLINE__ = @as(c_int, 1);
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL = @as(c_int, 1);
pub const __GCC_DESTRUCTIVE_SIZE = @as(c_int, 64);
pub const __GCC_CONSTRUCTIVE_SIZE = @as(c_int, 64);
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __NO_INLINE__ = @as(c_int, 1);
pub const __PIC__ = @as(c_int, 2);
pub const __pic__ = @as(c_int, 2);
pub const __FLT_RADIX__ = @as(c_int, 2);
pub const __DECIMAL_DIG__ = __LDBL_DECIMAL_DIG__;
pub const __SSP_STRONG__ = @as(c_int, 2);
pub const __ELF__ = @as(c_int, 1);
pub const __GCC_ASM_FLAG_OUTPUTS__ = @as(c_int, 1);
pub const __code_model_small__ = @as(c_int, 1);
pub const __amd64__ = @as(c_int, 1);
pub const __amd64 = @as(c_int, 1);
pub const __x86_64 = @as(c_int, 1);
pub const __x86_64__ = @as(c_int, 1);
pub const __SEG_GS = @as(c_int, 1);
pub const __SEG_FS = @as(c_int, 1);
pub const __seg_gs = @compileError("unable to translate macro: undefined identifier `address_space`");
// (no file):366:9
pub const __seg_fs = @compileError("unable to translate macro: undefined identifier `address_space`");
// (no file):367:9
pub const __znver4 = @as(c_int, 1);
pub const __znver4__ = @as(c_int, 1);
pub const __tune_znver4__ = @as(c_int, 1);
pub const __REGISTER_PREFIX__ = "";
pub const __NO_MATH_INLINES = @as(c_int, 1);
pub const __AES__ = @as(c_int, 1);
pub const __VAES__ = @as(c_int, 1);
pub const __PCLMUL__ = @as(c_int, 1);
pub const __VPCLMULQDQ__ = @as(c_int, 1);
pub const __LAHF_SAHF__ = @as(c_int, 1);
pub const __LZCNT__ = @as(c_int, 1);
pub const __RDRND__ = @as(c_int, 1);
pub const __FSGSBASE__ = @as(c_int, 1);
pub const __BMI__ = @as(c_int, 1);
pub const __BMI2__ = @as(c_int, 1);
pub const __POPCNT__ = @as(c_int, 1);
pub const __PRFCHW__ = @as(c_int, 1);
pub const __RDSEED__ = @as(c_int, 1);
pub const __ADX__ = @as(c_int, 1);
pub const __MOVBE__ = @as(c_int, 1);
pub const __SSE4A__ = @as(c_int, 1);
pub const __FMA__ = @as(c_int, 1);
pub const __F16C__ = @as(c_int, 1);
pub const __GFNI__ = @as(c_int, 1);
pub const __EVEX512__ = @as(c_int, 1);
pub const __AVX512CD__ = @as(c_int, 1);
pub const __AVX512VPOPCNTDQ__ = @as(c_int, 1);
pub const __AVX512VNNI__ = @as(c_int, 1);
pub const __AVX512BF16__ = @as(c_int, 1);
pub const __AVX512DQ__ = @as(c_int, 1);
pub const __AVX512BITALG__ = @as(c_int, 1);
pub const __AVX512BW__ = @as(c_int, 1);
pub const __AVX512VL__ = @as(c_int, 1);
pub const __EVEX256__ = @as(c_int, 1);
pub const __AVX512VBMI__ = @as(c_int, 1);
pub const __AVX512VBMI2__ = @as(c_int, 1);
pub const __AVX512IFMA__ = @as(c_int, 1);
pub const __SHA__ = @as(c_int, 1);
pub const __FXSR__ = @as(c_int, 1);
pub const __XSAVE__ = @as(c_int, 1);
pub const __XSAVEOPT__ = @as(c_int, 1);
pub const __XSAVEC__ = @as(c_int, 1);
pub const __XSAVES__ = @as(c_int, 1);
pub const __PKU__ = @as(c_int, 1);
pub const __CLFLUSHOPT__ = @as(c_int, 1);
pub const __CLWB__ = @as(c_int, 1);
pub const __WBNOINVD__ = @as(c_int, 1);
pub const __CLZERO__ = @as(c_int, 1);
pub const __RDPID__ = @as(c_int, 1);
pub const __RDPRU__ = @as(c_int, 1);
pub const __INVPCID__ = @as(c_int, 1);
pub const __CRC32__ = @as(c_int, 1);
pub const __AVX512F__ = @as(c_int, 1);
pub const __AVX2__ = @as(c_int, 1);
pub const __AVX__ = @as(c_int, 1);
pub const __SSE4_2__ = @as(c_int, 1);
pub const __SSE4_1__ = @as(c_int, 1);
pub const __SSSE3__ = @as(c_int, 1);
pub const __SSE3__ = @as(c_int, 1);
pub const __SSE2__ = @as(c_int, 1);
pub const __SSE2_MATH__ = @as(c_int, 1);
pub const __SSE__ = @as(c_int, 1);
pub const __SSE_MATH__ = @as(c_int, 1);
pub const __MMX__ = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16 = @as(c_int, 1);
pub const __SIZEOF_FLOAT128__ = @as(c_int, 16);
pub const unix = @as(c_int, 1);
pub const __unix = @as(c_int, 1);
pub const __unix__ = @as(c_int, 1);
pub const linux = @as(c_int, 1);
pub const __linux = @as(c_int, 1);
pub const __linux__ = @as(c_int, 1);
pub const __gnu_linux__ = @as(c_int, 1);
pub const __FLOAT128__ = @as(c_int, 1);
pub const __STDC__ = @as(c_int, 1);
pub const __STDC_HOSTED__ = @as(c_int, 1);
pub const __STDC_VERSION__ = @as(c_long, 201710);
pub const __STDC_UTF_16__ = @as(c_int, 1);
pub const __STDC_UTF_32__ = @as(c_int, 1);
pub const __STDC_EMBED_NOT_FOUND__ = @as(c_int, 0);
pub const __STDC_EMBED_FOUND__ = @as(c_int, 1);
pub const __STDC_EMBED_EMPTY__ = @as(c_int, 2);
pub const __GLIBC_MINOR__ = @as(c_int, 39);
pub const _DEBUG = @as(c_int, 1);
pub const __GCC_HAVE_DWARF2_CFI_ASM = @as(c_int, 1);
pub const TLS_AMALGAMATION = @as(c_int, 1);
pub const TLSE_C = "";
pub const __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION = "";
pub const _FEATURES_H = @as(c_int, 1);
pub const __KERNEL_STRICT_NAMES = "";
pub inline fn __GNUC_PREREQ(maj: anytype, min: anytype) @TypeOf(((__GNUC__ << @as(c_int, 16)) + __GNUC_MINOR__) >= ((maj << @as(c_int, 16)) + min)) {
    _ = &maj;
    _ = &min;
    return ((__GNUC__ << @as(c_int, 16)) + __GNUC_MINOR__) >= ((maj << @as(c_int, 16)) + min);
}
pub inline fn __glibc_clang_prereq(maj: anytype, min: anytype) @TypeOf(((__clang_major__ << @as(c_int, 16)) + __clang_minor__) >= ((maj << @as(c_int, 16)) + min)) {
    _ = &maj;
    _ = &min;
    return ((__clang_major__ << @as(c_int, 16)) + __clang_minor__) >= ((maj << @as(c_int, 16)) + min);
}
pub const __GLIBC_USE = @compileError("unable to translate macro: undefined identifier `__GLIBC_USE_`");
// /usr/include/features.h:188:9
pub const _DEFAULT_SOURCE = @as(c_int, 1);
pub const __GLIBC_USE_ISOC2X = @as(c_int, 0);
pub const __USE_ISOC11 = @as(c_int, 1);
pub const __USE_ISOC99 = @as(c_int, 1);
pub const __USE_ISOC95 = @as(c_int, 1);
pub const __USE_POSIX_IMPLICITLY = @as(c_int, 1);
pub const _POSIX_SOURCE = @as(c_int, 1);
pub const _POSIX_C_SOURCE = @as(c_long, 200809);
pub const __USE_POSIX = @as(c_int, 1);
pub const __USE_POSIX2 = @as(c_int, 1);
pub const __USE_POSIX199309 = @as(c_int, 1);
pub const __USE_POSIX199506 = @as(c_int, 1);
pub const __USE_XOPEN2K = @as(c_int, 1);
pub const __USE_XOPEN2K8 = @as(c_int, 1);
pub const _ATFILE_SOURCE = @as(c_int, 1);
pub const __WORDSIZE = @as(c_int, 64);
pub const __WORDSIZE_TIME64_COMPAT32 = @as(c_int, 1);
pub const __SYSCALL_WORDSIZE = @as(c_int, 64);
pub const __TIMESIZE = __WORDSIZE;
pub const __USE_MISC = @as(c_int, 1);
pub const __USE_ATFILE = @as(c_int, 1);
pub const __USE_FORTIFY_LEVEL = @as(c_int, 0);
pub const __GLIBC_USE_DEPRECATED_GETS = @as(c_int, 0);
pub const __GLIBC_USE_DEPRECATED_SCANF = @as(c_int, 0);
pub const __GLIBC_USE_C2X_STRTOL = @as(c_int, 0);
pub const _STDC_PREDEF_H = @as(c_int, 1);
pub const __STDC_IEC_559__ = @as(c_int, 1);
pub const __STDC_IEC_60559_BFP__ = @as(c_long, 201404);
pub const __STDC_IEC_559_COMPLEX__ = @as(c_int, 1);
pub const __STDC_IEC_60559_COMPLEX__ = @as(c_long, 201404);
pub const __STDC_ISO_10646__ = @as(c_long, 201706);
pub const __GNU_LIBRARY__ = @as(c_int, 6);
pub const __GLIBC__ = @as(c_int, 2);
pub inline fn __GLIBC_PREREQ(maj: anytype, min: anytype) @TypeOf(((__GLIBC__ << @as(c_int, 16)) + __GLIBC_MINOR__) >= ((maj << @as(c_int, 16)) + min)) {
    _ = &maj;
    _ = &min;
    return ((__GLIBC__ << @as(c_int, 16)) + __GLIBC_MINOR__) >= ((maj << @as(c_int, 16)) + min);
}
pub const _SYS_CDEFS_H = @as(c_int, 1);
pub const __glibc_has_attribute = @compileError("unable to translate macro: undefined identifier `__has_attribute`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:45:10
pub inline fn __glibc_has_builtin(name: anytype) @TypeOf(__has_builtin(name)) {
    _ = &name;
    return __has_builtin(name);
}
pub const __glibc_has_extension = @compileError("unable to translate macro: undefined identifier `__has_extension`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:55:10
pub const __LEAF = "";
pub const __LEAF_ATTR = "";
pub const __THROW = @compileError("unable to translate macro: undefined identifier `__nothrow__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:79:11
pub const __THROWNL = @compileError("unable to translate macro: undefined identifier `__nothrow__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:80:11
pub const __NTH = @compileError("unable to translate macro: undefined identifier `__nothrow__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:81:11
pub const __NTHNL = @compileError("unable to translate macro: undefined identifier `__nothrow__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:82:11
pub const __COLD = @compileError("unable to translate macro: undefined identifier `__cold__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:102:11
pub inline fn __P(args: anytype) @TypeOf(args) {
    _ = &args;
    return args;
}
pub inline fn __PMT(args: anytype) @TypeOf(args) {
    _ = &args;
    return args;
}
pub const __CONCAT = @compileError("unable to translate C expr: unexpected token '##'");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:131:9
pub const __STRING = @compileError("unable to translate C expr: unexpected token '#'");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:132:9
pub const __ptr_t = ?*anyopaque;
pub const __BEGIN_DECLS = "";
pub const __END_DECLS = "";
pub inline fn __bos(ptr: anytype) @TypeOf(__builtin_object_size(ptr, __USE_FORTIFY_LEVEL > @as(c_int, 1))) {
    _ = &ptr;
    return __builtin_object_size(ptr, __USE_FORTIFY_LEVEL > @as(c_int, 1));
}
pub inline fn __bos0(ptr: anytype) @TypeOf(__builtin_object_size(ptr, @as(c_int, 0))) {
    _ = &ptr;
    return __builtin_object_size(ptr, @as(c_int, 0));
}
pub inline fn __glibc_objsize0(__o: anytype) @TypeOf(__bos0(__o)) {
    _ = &__o;
    return __bos0(__o);
}
pub inline fn __glibc_objsize(__o: anytype) @TypeOf(__bos(__o)) {
    _ = &__o;
    return __bos(__o);
}
pub const __warnattr = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:216:10
pub const __errordecl = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:217:10
pub const __flexarr = @compileError("unable to translate C expr: unexpected token '['");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:225:10
pub const __glibc_c99_flexarr_available = @as(c_int, 1);
pub const __REDIRECT = @compileError("unable to translate C expr: unexpected token '__asm__'");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:256:10
pub const __REDIRECT_NTH = @compileError("unable to translate C expr: unexpected token '__asm__'");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:263:11
pub const __REDIRECT_NTHNL = @compileError("unable to translate C expr: unexpected token '__asm__'");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:265:11
pub const __ASMNAME = @compileError("unable to translate C expr: unexpected token ','");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:268:10
pub inline fn __ASMNAME2(prefix: anytype, cname: anytype) @TypeOf(__STRING(prefix) ++ cname) {
    _ = &prefix;
    _ = &cname;
    return __STRING(prefix) ++ cname;
}
pub const __REDIRECT_FORTIFY = __REDIRECT;
pub const __REDIRECT_FORTIFY_NTH = __REDIRECT_NTH;
pub const __attribute_malloc__ = @compileError("unable to translate macro: undefined identifier `__malloc__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:298:10
pub const __attribute_alloc_size__ = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:309:10
pub const __attribute_alloc_align__ = @compileError("unable to translate macro: undefined identifier `__alloc_align__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:315:10
pub const __attribute_pure__ = @compileError("unable to translate macro: undefined identifier `__pure__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:325:10
pub const __attribute_const__ = @compileError("unable to translate C expr: unexpected token '__attribute__'");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:332:10
pub const __attribute_maybe_unused__ = @compileError("unable to translate macro: undefined identifier `__unused__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:338:10
pub const __attribute_used__ = @compileError("unable to translate macro: undefined identifier `__used__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:347:10
pub const __attribute_noinline__ = @compileError("unable to translate macro: undefined identifier `__noinline__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:348:10
pub const __attribute_deprecated__ = @compileError("unable to translate macro: undefined identifier `__deprecated__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:356:10
pub const __attribute_deprecated_msg__ = @compileError("unable to translate macro: undefined identifier `__deprecated__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:366:10
pub const __attribute_format_arg__ = @compileError("unable to translate macro: undefined identifier `__format_arg__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:379:10
pub const __attribute_format_strfmon__ = @compileError("unable to translate macro: undefined identifier `__format__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:389:10
pub const __attribute_nonnull__ = @compileError("unable to translate macro: undefined identifier `__nonnull__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:401:11
pub inline fn __nonnull(params: anytype) @TypeOf(__attribute_nonnull__(params)) {
    _ = &params;
    return __attribute_nonnull__(params);
}
pub const __returns_nonnull = @compileError("unable to translate macro: undefined identifier `__returns_nonnull__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:414:10
pub const __attribute_warn_unused_result__ = @compileError("unable to translate macro: undefined identifier `__warn_unused_result__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:423:10
pub const __wur = "";
pub const __always_inline = @compileError("unable to translate macro: undefined identifier `__always_inline__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:441:10
pub const __attribute_artificial__ = @compileError("unable to translate macro: undefined identifier `__artificial__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:450:10
pub const __extern_inline = @compileError("unable to translate macro: undefined identifier `__gnu_inline__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:468:11
pub const __extern_always_inline = @compileError("unable to translate macro: undefined identifier `__gnu_inline__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:469:11
pub const __fortify_function = __extern_always_inline ++ __attribute_artificial__;
pub const __restrict_arr = @compileError("unable to translate C expr: unexpected token '__restrict'");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:512:10
pub inline fn __glibc_unlikely(cond: anytype) @TypeOf(__builtin_expect(cond, @as(c_int, 0))) {
    _ = &cond;
    return __builtin_expect(cond, @as(c_int, 0));
}
pub inline fn __glibc_likely(cond: anytype) @TypeOf(__builtin_expect(cond, @as(c_int, 1))) {
    _ = &cond;
    return __builtin_expect(cond, @as(c_int, 1));
}
pub const __attribute_nonstring__ = "";
pub const __attribute_copy__ = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:561:10
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = @as(c_int, 0);
pub inline fn __LDBL_REDIR1(name: anytype, proto: anytype, alias: anytype) @TypeOf(name ++ proto) {
    _ = &name;
    _ = &proto;
    _ = &alias;
    return name ++ proto;
}
pub inline fn __LDBL_REDIR(name: anytype, proto: anytype) @TypeOf(name ++ proto) {
    _ = &name;
    _ = &proto;
    return name ++ proto;
}
pub inline fn __LDBL_REDIR1_NTH(name: anytype, proto: anytype, alias: anytype) @TypeOf(name ++ proto ++ __THROW) {
    _ = &name;
    _ = &proto;
    _ = &alias;
    return name ++ proto ++ __THROW;
}
pub inline fn __LDBL_REDIR_NTH(name: anytype, proto: anytype) @TypeOf(name ++ proto ++ __THROW) {
    _ = &name;
    _ = &proto;
    return name ++ proto ++ __THROW;
}
pub const __LDBL_REDIR2_DECL = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:638:10
pub const __LDBL_REDIR_DECL = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:639:10
pub inline fn __REDIRECT_LDBL(name: anytype, proto: anytype, alias: anytype) @TypeOf(__REDIRECT(name, proto, alias)) {
    _ = &name;
    _ = &proto;
    _ = &alias;
    return __REDIRECT(name, proto, alias);
}
pub inline fn __REDIRECT_NTH_LDBL(name: anytype, proto: anytype, alias: anytype) @TypeOf(__REDIRECT_NTH(name, proto, alias)) {
    _ = &name;
    _ = &proto;
    _ = &alias;
    return __REDIRECT_NTH(name, proto, alias);
}
pub const __glibc_macro_warning1 = @compileError("unable to translate macro: undefined identifier `_Pragma`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:653:10
pub const __glibc_macro_warning = @compileError("unable to translate macro: undefined identifier `GCC`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:654:10
pub const __HAVE_GENERIC_SELECTION = @as(c_int, 1);
pub const __fortified_attr_access = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:699:11
pub const __attr_access = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:700:11
pub const __attr_access_none = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:701:11
pub const __attr_dealloc = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:711:10
pub const __attr_dealloc_free = "";
pub const __attribute_returns_twice__ = @compileError("unable to translate macro: undefined identifier `__returns_twice__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:718:10
pub const __stub___compat_bdflush = "";
pub const __stub_chflags = "";
pub const __stub_fchflags = "";
pub const __stub_gtty = "";
pub const __stub_revoke = "";
pub const __stub_setlogin = "";
pub const __stub_sigreturn = "";
pub const __stub_stty = "";
pub const __GLIBC_USE_LIB_EXT2 = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_BFP_EXT = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_EXT = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_TYPES_EXT = @as(c_int, 0);
pub const __need_size_t = "";
pub const __need_wchar_t = "";
pub const __need_NULL = "";
pub const _SIZE_T = "";
pub const _WCHAR_T = "";
pub const NULL = @import("std").zig.c_translation.cast(?*anyopaque, @as(c_int, 0));
pub const _STDLIB_H = @as(c_int, 1);
pub const WNOHANG = @as(c_int, 1);
pub const WUNTRACED = @as(c_int, 2);
pub const WSTOPPED = @as(c_int, 2);
pub const WEXITED = @as(c_int, 4);
pub const WCONTINUED = @as(c_int, 8);
pub const WNOWAIT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x01000000, .hex);
pub const __WNOTHREAD = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000000, .hex);
pub const __WALL = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000000, .hex);
pub const __WCLONE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex);
pub inline fn __WEXITSTATUS(status: anytype) @TypeOf((status & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff00, .hex)) >> @as(c_int, 8)) {
    _ = &status;
    return (status & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff00, .hex)) >> @as(c_int, 8);
}
pub inline fn __WTERMSIG(status: anytype) @TypeOf(status & @as(c_int, 0x7f)) {
    _ = &status;
    return status & @as(c_int, 0x7f);
}
pub inline fn __WSTOPSIG(status: anytype) @TypeOf(__WEXITSTATUS(status)) {
    _ = &status;
    return __WEXITSTATUS(status);
}
pub inline fn __WIFEXITED(status: anytype) @TypeOf(__WTERMSIG(status) == @as(c_int, 0)) {
    _ = &status;
    return __WTERMSIG(status) == @as(c_int, 0);
}
pub inline fn __WIFSIGNALED(status: anytype) @TypeOf((@import("std").zig.c_translation.cast(i8, (status & @as(c_int, 0x7f)) + @as(c_int, 1)) >> @as(c_int, 1)) > @as(c_int, 0)) {
    _ = &status;
    return (@import("std").zig.c_translation.cast(i8, (status & @as(c_int, 0x7f)) + @as(c_int, 1)) >> @as(c_int, 1)) > @as(c_int, 0);
}
pub inline fn __WIFSTOPPED(status: anytype) @TypeOf((status & @as(c_int, 0xff)) == @as(c_int, 0x7f)) {
    _ = &status;
    return (status & @as(c_int, 0xff)) == @as(c_int, 0x7f);
}
pub inline fn __WIFCONTINUED(status: anytype) @TypeOf(status == __W_CONTINUED) {
    _ = &status;
    return status == __W_CONTINUED;
}
pub inline fn __WCOREDUMP(status: anytype) @TypeOf(status & __WCOREFLAG) {
    _ = &status;
    return status & __WCOREFLAG;
}
pub inline fn __W_EXITCODE(ret: anytype, sig: anytype) @TypeOf((ret << @as(c_int, 8)) | sig) {
    _ = &ret;
    _ = &sig;
    return (ret << @as(c_int, 8)) | sig;
}
pub inline fn __W_STOPCODE(sig: anytype) @TypeOf((sig << @as(c_int, 8)) | @as(c_int, 0x7f)) {
    _ = &sig;
    return (sig << @as(c_int, 8)) | @as(c_int, 0x7f);
}
pub const __W_CONTINUED = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffff, .hex);
pub const __WCOREFLAG = @as(c_int, 0x80);
pub inline fn WEXITSTATUS(status: anytype) @TypeOf(__WEXITSTATUS(status)) {
    _ = &status;
    return __WEXITSTATUS(status);
}
pub inline fn WTERMSIG(status: anytype) @TypeOf(__WTERMSIG(status)) {
    _ = &status;
    return __WTERMSIG(status);
}
pub inline fn WSTOPSIG(status: anytype) @TypeOf(__WSTOPSIG(status)) {
    _ = &status;
    return __WSTOPSIG(status);
}
pub inline fn WIFEXITED(status: anytype) @TypeOf(__WIFEXITED(status)) {
    _ = &status;
    return __WIFEXITED(status);
}
pub inline fn WIFSIGNALED(status: anytype) @TypeOf(__WIFSIGNALED(status)) {
    _ = &status;
    return __WIFSIGNALED(status);
}
pub inline fn WIFSTOPPED(status: anytype) @TypeOf(__WIFSTOPPED(status)) {
    _ = &status;
    return __WIFSTOPPED(status);
}
pub inline fn WIFCONTINUED(status: anytype) @TypeOf(__WIFCONTINUED(status)) {
    _ = &status;
    return __WIFCONTINUED(status);
}
pub const _BITS_FLOATN_H = "";
pub const __HAVE_FLOAT128 = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT128 = @as(c_int, 0);
pub const __HAVE_FLOAT64X = @as(c_int, 1);
pub const __HAVE_FLOAT64X_LONG_DOUBLE = @as(c_int, 1);
pub const _BITS_FLOATN_COMMON_H = "";
pub const __HAVE_FLOAT16 = @as(c_int, 0);
pub const __HAVE_FLOAT32 = @as(c_int, 1);
pub const __HAVE_FLOAT64 = @as(c_int, 1);
pub const __HAVE_FLOAT32X = @as(c_int, 1);
pub const __HAVE_FLOAT128X = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT16 = __HAVE_FLOAT16;
pub const __HAVE_DISTINCT_FLOAT32 = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT64 = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT32X = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT64X = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT128X = __HAVE_FLOAT128X;
pub const __HAVE_FLOAT128_UNLIKE_LDBL = (__HAVE_DISTINCT_FLOAT128 != 0) and (__LDBL_MANT_DIG__ != @as(c_int, 113));
pub const __HAVE_FLOATN_NOT_TYPEDEF = @as(c_int, 0);
pub const __f32 = @import("std").zig.c_translation.Macros.F_SUFFIX;
pub inline fn __f64(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __f32x(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub const __f64x = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub const __CFLOAT32 = @compileError("unable to translate: TODO _Complex");
// /usr/include/x86_64-linux-gnu/bits/floatn-common.h:149:12
pub const __CFLOAT64 = @compileError("unable to translate: TODO _Complex");
// /usr/include/x86_64-linux-gnu/bits/floatn-common.h:160:13
pub const __CFLOAT32X = @compileError("unable to translate: TODO _Complex");
// /usr/include/x86_64-linux-gnu/bits/floatn-common.h:169:12
pub const __CFLOAT64X = @compileError("unable to translate: TODO _Complex");
// /usr/include/x86_64-linux-gnu/bits/floatn-common.h:178:13
pub inline fn __builtin_huge_valf32() @TypeOf(__builtin_huge_valf()) {
    return __builtin_huge_valf();
}
pub inline fn __builtin_inff32() @TypeOf(__builtin_inff()) {
    return __builtin_inff();
}
pub inline fn __builtin_nanf32(x: anytype) @TypeOf(__builtin_nanf(x)) {
    _ = &x;
    return __builtin_nanf(x);
}
pub const __builtin_nansf32 = @compileError("unable to translate macro: undefined identifier `__builtin_nansf`");
// /usr/include/x86_64-linux-gnu/bits/floatn-common.h:221:12
pub const __builtin_huge_valf64 = @compileError("unable to translate macro: undefined identifier `__builtin_huge_val`");
// /usr/include/x86_64-linux-gnu/bits/floatn-common.h:255:13
pub const __builtin_inff64 = @compileError("unable to translate macro: undefined identifier `__builtin_inf`");
// /usr/include/x86_64-linux-gnu/bits/floatn-common.h:256:13
pub const __builtin_nanf64 = @compileError("unable to translate macro: undefined identifier `__builtin_nan`");
// /usr/include/x86_64-linux-gnu/bits/floatn-common.h:257:13
pub const __builtin_nansf64 = @compileError("unable to translate macro: undefined identifier `__builtin_nans`");
// /usr/include/x86_64-linux-gnu/bits/floatn-common.h:258:13
pub const __builtin_huge_valf32x = @compileError("unable to translate macro: undefined identifier `__builtin_huge_val`");
// /usr/include/x86_64-linux-gnu/bits/floatn-common.h:272:12
pub const __builtin_inff32x = @compileError("unable to translate macro: undefined identifier `__builtin_inf`");
// /usr/include/x86_64-linux-gnu/bits/floatn-common.h:273:12
pub const __builtin_nanf32x = @compileError("unable to translate macro: undefined identifier `__builtin_nan`");
// /usr/include/x86_64-linux-gnu/bits/floatn-common.h:274:12
pub const __builtin_nansf32x = @compileError("unable to translate macro: undefined identifier `__builtin_nans`");
// /usr/include/x86_64-linux-gnu/bits/floatn-common.h:275:12
pub const __builtin_huge_valf64x = @compileError("unable to translate macro: undefined identifier `__builtin_huge_vall`");
// /usr/include/x86_64-linux-gnu/bits/floatn-common.h:289:13
pub const __builtin_inff64x = @compileError("unable to translate macro: undefined identifier `__builtin_infl`");
// /usr/include/x86_64-linux-gnu/bits/floatn-common.h:290:13
pub const __builtin_nanf64x = @compileError("unable to translate macro: undefined identifier `__builtin_nanl`");
// /usr/include/x86_64-linux-gnu/bits/floatn-common.h:291:13
pub const __builtin_nansf64x = @compileError("unable to translate macro: undefined identifier `__builtin_nansl`");
// /usr/include/x86_64-linux-gnu/bits/floatn-common.h:292:13
pub const __ldiv_t_defined = @as(c_int, 1);
pub const __lldiv_t_defined = @as(c_int, 1);
pub const RAND_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const EXIT_FAILURE = @as(c_int, 1);
pub const EXIT_SUCCESS = @as(c_int, 0);
pub const MB_CUR_MAX = __ctype_get_mb_cur_max();
pub const _SYS_TYPES_H = @as(c_int, 1);
pub const _BITS_TYPES_H = @as(c_int, 1);
pub const __S16_TYPE = c_short;
pub const __U16_TYPE = c_ushort;
pub const __S32_TYPE = c_int;
pub const __U32_TYPE = c_uint;
pub const __SLONGWORD_TYPE = c_long;
pub const __ULONGWORD_TYPE = c_ulong;
pub const __SQUAD_TYPE = c_long;
pub const __UQUAD_TYPE = c_ulong;
pub const __SWORD_TYPE = c_long;
pub const __UWORD_TYPE = c_ulong;
pub const __SLONG32_TYPE = c_int;
pub const __ULONG32_TYPE = c_uint;
pub const __S64_TYPE = c_long;
pub const __U64_TYPE = c_ulong;
pub const __STD_TYPE = @compileError("unable to translate C expr: unexpected token 'typedef'");
// /usr/include/x86_64-linux-gnu/bits/types.h:137:10
pub const _BITS_TYPESIZES_H = @as(c_int, 1);
pub const __SYSCALL_SLONG_TYPE = __SLONGWORD_TYPE;
pub const __SYSCALL_ULONG_TYPE = __ULONGWORD_TYPE;
pub const __DEV_T_TYPE = __UQUAD_TYPE;
pub const __UID_T_TYPE = __U32_TYPE;
pub const __GID_T_TYPE = __U32_TYPE;
pub const __INO_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __INO64_T_TYPE = __UQUAD_TYPE;
pub const __MODE_T_TYPE = __U32_TYPE;
pub const __NLINK_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __FSWORD_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __OFF_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __OFF64_T_TYPE = __SQUAD_TYPE;
pub const __PID_T_TYPE = __S32_TYPE;
pub const __RLIM_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __RLIM64_T_TYPE = __UQUAD_TYPE;
pub const __BLKCNT_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __BLKCNT64_T_TYPE = __SQUAD_TYPE;
pub const __FSBLKCNT_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __FSBLKCNT64_T_TYPE = __UQUAD_TYPE;
pub const __FSFILCNT_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __FSFILCNT64_T_TYPE = __UQUAD_TYPE;
pub const __ID_T_TYPE = __U32_TYPE;
pub const __CLOCK_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __TIME_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __USECONDS_T_TYPE = __U32_TYPE;
pub const __SUSECONDS_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __SUSECONDS64_T_TYPE = __SQUAD_TYPE;
pub const __DADDR_T_TYPE = __S32_TYPE;
pub const __KEY_T_TYPE = __S32_TYPE;
pub const __CLOCKID_T_TYPE = __S32_TYPE;
pub const __TIMER_T_TYPE = ?*anyopaque;
pub const __BLKSIZE_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __FSID_T_TYPE = @compileError("unable to translate macro: undefined identifier `__val`");
// /usr/include/x86_64-linux-gnu/bits/typesizes.h:73:9
pub const __SSIZE_T_TYPE = __SWORD_TYPE;
pub const __CPU_MASK_TYPE = __SYSCALL_ULONG_TYPE;
pub const __OFF_T_MATCHES_OFF64_T = @as(c_int, 1);
pub const __INO_T_MATCHES_INO64_T = @as(c_int, 1);
pub const __RLIM_T_MATCHES_RLIM64_T = @as(c_int, 1);
pub const __STATFS_MATCHES_STATFS64 = @as(c_int, 1);
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = @as(c_int, 1);
pub const __FD_SETSIZE = @as(c_int, 1024);
pub const _BITS_TIME64_H = @as(c_int, 1);
pub const __TIME64_T_TYPE = __TIME_T_TYPE;
pub const __u_char_defined = "";
pub const __ino_t_defined = "";
pub const __dev_t_defined = "";
pub const __gid_t_defined = "";
pub const __mode_t_defined = "";
pub const __nlink_t_defined = "";
pub const __uid_t_defined = "";
pub const __off_t_defined = "";
pub const __pid_t_defined = "";
pub const __id_t_defined = "";
pub const __ssize_t_defined = "";
pub const __daddr_t_defined = "";
pub const __key_t_defined = "";
pub const __clock_t_defined = @as(c_int, 1);
pub const __clockid_t_defined = @as(c_int, 1);
pub const __time_t_defined = @as(c_int, 1);
pub const __timer_t_defined = @as(c_int, 1);
pub const _BITS_STDINT_INTN_H = @as(c_int, 1);
pub const __BIT_TYPES_DEFINED__ = @as(c_int, 1);
pub const _ENDIAN_H = @as(c_int, 1);
pub const _BITS_ENDIAN_H = @as(c_int, 1);
pub const __LITTLE_ENDIAN = @as(c_int, 1234);
pub const __BIG_ENDIAN = @as(c_int, 4321);
pub const __PDP_ENDIAN = @as(c_int, 3412);
pub const _BITS_ENDIANNESS_H = @as(c_int, 1);
pub const __BYTE_ORDER = __LITTLE_ENDIAN;
pub const __FLOAT_WORD_ORDER = __BYTE_ORDER;
pub inline fn __LONG_LONG_PAIR(HI: anytype, LO: anytype) @TypeOf(HI) {
    _ = &HI;
    _ = &LO;
    return blk: {
        _ = &LO;
        break :blk HI;
    };
}
pub const LITTLE_ENDIAN = __LITTLE_ENDIAN;
pub const BIG_ENDIAN = __BIG_ENDIAN;
pub const PDP_ENDIAN = __PDP_ENDIAN;
pub const BYTE_ORDER = __BYTE_ORDER;
pub const _BITS_BYTESWAP_H = @as(c_int, 1);
pub inline fn __bswap_constant_16(x: anytype) __uint16_t {
    _ = &x;
    return @import("std").zig.c_translation.cast(__uint16_t, ((x >> @as(c_int, 8)) & @as(c_int, 0xff)) | ((x & @as(c_int, 0xff)) << @as(c_int, 8)));
}
pub inline fn __bswap_constant_32(x: anytype) @TypeOf(((((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xff000000, .hex)) >> @as(c_int, 24)) | ((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00ff0000, .hex)) >> @as(c_int, 8))) | ((x & @as(c_uint, 0x0000ff00)) << @as(c_int, 8))) | ((x & @as(c_uint, 0x000000ff)) << @as(c_int, 24))) {
    _ = &x;
    return ((((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xff000000, .hex)) >> @as(c_int, 24)) | ((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00ff0000, .hex)) >> @as(c_int, 8))) | ((x & @as(c_uint, 0x0000ff00)) << @as(c_int, 8))) | ((x & @as(c_uint, 0x000000ff)) << @as(c_int, 24));
}
pub inline fn __bswap_constant_64(x: anytype) @TypeOf(((((((((x & @as(c_ulonglong, 0xff00000000000000)) >> @as(c_int, 56)) | ((x & @as(c_ulonglong, 0x00ff000000000000)) >> @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x0000ff0000000000)) >> @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000ff00000000)) >> @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x00000000ff000000)) << @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x0000000000ff0000)) << @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000000000ff00)) << @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x00000000000000ff)) << @as(c_int, 56))) {
    _ = &x;
    return ((((((((x & @as(c_ulonglong, 0xff00000000000000)) >> @as(c_int, 56)) | ((x & @as(c_ulonglong, 0x00ff000000000000)) >> @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x0000ff0000000000)) >> @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000ff00000000)) >> @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x00000000ff000000)) << @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x0000000000ff0000)) << @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000000000ff00)) << @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x00000000000000ff)) << @as(c_int, 56));
}
pub const _BITS_UINTN_IDENTITY_H = @as(c_int, 1);
pub inline fn htobe16(x: anytype) @TypeOf(__bswap_16(x)) {
    _ = &x;
    return __bswap_16(x);
}
pub inline fn htole16(x: anytype) @TypeOf(__uint16_identity(x)) {
    _ = &x;
    return __uint16_identity(x);
}
pub inline fn be16toh(x: anytype) @TypeOf(__bswap_16(x)) {
    _ = &x;
    return __bswap_16(x);
}
pub inline fn le16toh(x: anytype) @TypeOf(__uint16_identity(x)) {
    _ = &x;
    return __uint16_identity(x);
}
pub inline fn htobe32(x: anytype) @TypeOf(__bswap_32(x)) {
    _ = &x;
    return __bswap_32(x);
}
pub inline fn htole32(x: anytype) @TypeOf(__uint32_identity(x)) {
    _ = &x;
    return __uint32_identity(x);
}
pub inline fn be32toh(x: anytype) @TypeOf(__bswap_32(x)) {
    _ = &x;
    return __bswap_32(x);
}
pub inline fn le32toh(x: anytype) @TypeOf(__uint32_identity(x)) {
    _ = &x;
    return __uint32_identity(x);
}
pub inline fn htobe64(x: anytype) @TypeOf(__bswap_64(x)) {
    _ = &x;
    return __bswap_64(x);
}
pub inline fn htole64(x: anytype) @TypeOf(__uint64_identity(x)) {
    _ = &x;
    return __uint64_identity(x);
}
pub inline fn be64toh(x: anytype) @TypeOf(__bswap_64(x)) {
    _ = &x;
    return __bswap_64(x);
}
pub inline fn le64toh(x: anytype) @TypeOf(__uint64_identity(x)) {
    _ = &x;
    return __uint64_identity(x);
}
pub const _SYS_SELECT_H = @as(c_int, 1);
pub const __FD_ZERO = @compileError("unable to translate macro: undefined identifier `__i`");
// /usr/include/x86_64-linux-gnu/bits/select.h:25:9
pub const __FD_SET = @compileError("unable to translate C expr: expected ')' instead got '|='");
// /usr/include/x86_64-linux-gnu/bits/select.h:32:9
pub const __FD_CLR = @compileError("unable to translate C expr: expected ')' instead got '&='");
// /usr/include/x86_64-linux-gnu/bits/select.h:34:9
pub inline fn __FD_ISSET(d: anytype, s: anytype) @TypeOf((__FDS_BITS(s)[@as(usize, @intCast(__FD_ELT(d)))] & __FD_MASK(d)) != @as(c_int, 0)) {
    _ = &d;
    _ = &s;
    return (__FDS_BITS(s)[@as(usize, @intCast(__FD_ELT(d)))] & __FD_MASK(d)) != @as(c_int, 0);
}
pub const __sigset_t_defined = @as(c_int, 1);
pub const ____sigset_t_defined = "";
pub const _SIGSET_NWORDS = @import("std").zig.c_translation.MacroArithmetic.div(@as(c_int, 1024), @as(c_int, 8) * @import("std").zig.c_translation.sizeof(c_ulong));
pub const __timeval_defined = @as(c_int, 1);
pub const _STRUCT_TIMESPEC = @as(c_int, 1);
pub const __suseconds_t_defined = "";
pub const __NFDBITS = @as(c_int, 8) * @import("std").zig.c_translation.cast(c_int, @import("std").zig.c_translation.sizeof(__fd_mask));
pub inline fn __FD_ELT(d: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div(d, __NFDBITS)) {
    _ = &d;
    return @import("std").zig.c_translation.MacroArithmetic.div(d, __NFDBITS);
}
pub inline fn __FD_MASK(d: anytype) __fd_mask {
    _ = &d;
    return @import("std").zig.c_translation.cast(__fd_mask, @as(c_ulong, 1) << @import("std").zig.c_translation.MacroArithmetic.rem(d, __NFDBITS));
}
pub inline fn __FDS_BITS(set: anytype) @TypeOf(set.*.__fds_bits) {
    _ = &set;
    return set.*.__fds_bits;
}
pub const FD_SETSIZE = __FD_SETSIZE;
pub const NFDBITS = __NFDBITS;
pub inline fn FD_SET(fd: anytype, fdsetp: anytype) @TypeOf(__FD_SET(fd, fdsetp)) {
    _ = &fd;
    _ = &fdsetp;
    return __FD_SET(fd, fdsetp);
}
pub inline fn FD_CLR(fd: anytype, fdsetp: anytype) @TypeOf(__FD_CLR(fd, fdsetp)) {
    _ = &fd;
    _ = &fdsetp;
    return __FD_CLR(fd, fdsetp);
}
pub inline fn FD_ISSET(fd: anytype, fdsetp: anytype) @TypeOf(__FD_ISSET(fd, fdsetp)) {
    _ = &fd;
    _ = &fdsetp;
    return __FD_ISSET(fd, fdsetp);
}
pub inline fn FD_ZERO(fdsetp: anytype) @TypeOf(__FD_ZERO(fdsetp)) {
    _ = &fdsetp;
    return __FD_ZERO(fdsetp);
}
pub const __blksize_t_defined = "";
pub const __blkcnt_t_defined = "";
pub const __fsblkcnt_t_defined = "";
pub const __fsfilcnt_t_defined = "";
pub const _BITS_PTHREADTYPES_COMMON_H = @as(c_int, 1);
pub const _THREAD_SHARED_TYPES_H = @as(c_int, 1);
pub const _BITS_PTHREADTYPES_ARCH_H = @as(c_int, 1);
pub const __SIZEOF_PTHREAD_MUTEX_T = @as(c_int, 40);
pub const __SIZEOF_PTHREAD_ATTR_T = @as(c_int, 56);
pub const __SIZEOF_PTHREAD_RWLOCK_T = @as(c_int, 56);
pub const __SIZEOF_PTHREAD_BARRIER_T = @as(c_int, 32);
pub const __SIZEOF_PTHREAD_MUTEXATTR_T = @as(c_int, 4);
pub const __SIZEOF_PTHREAD_COND_T = @as(c_int, 48);
pub const __SIZEOF_PTHREAD_CONDATTR_T = @as(c_int, 4);
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T = @as(c_int, 8);
pub const __SIZEOF_PTHREAD_BARRIERATTR_T = @as(c_int, 4);
pub const __LOCK_ALIGNMENT = "";
pub const __ONCE_ALIGNMENT = "";
pub const _BITS_ATOMIC_WIDE_COUNTER_H = "";
pub const _THREAD_MUTEX_INTERNAL_H = @as(c_int, 1);
pub const __PTHREAD_MUTEX_HAVE_PREV = @as(c_int, 1);
pub const __PTHREAD_MUTEX_INITIALIZER = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/x86_64-linux-gnu/bits/struct_mutex.h:56:10
pub const _RWLOCK_INTERNAL_H = "";
pub const __PTHREAD_RWLOCK_ELISION_EXTRA = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h:40:11
pub inline fn __PTHREAD_RWLOCK_INITIALIZER(__flags: anytype) @TypeOf(__flags) {
    _ = &__flags;
    return blk: {
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = &__PTHREAD_RWLOCK_ELISION_EXTRA;
        _ = @as(c_int, 0);
        break :blk __flags;
    };
}
pub const __ONCE_FLAG_INIT = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h:113:9
pub const __have_pthread_attr_t = @as(c_int, 1);
pub const _ALLOCA_H = @as(c_int, 1);
pub const __COMPAR_FN_T = "";
pub const _STDIO_H = @as(c_int, 1);
pub const __need___va_list = "";
pub const __GNUC_VA_LIST = "";
pub const _____fpos_t_defined = @as(c_int, 1);
pub const ____mbstate_t_defined = @as(c_int, 1);
pub const _____fpos64_t_defined = @as(c_int, 1);
pub const ____FILE_defined = @as(c_int, 1);
pub const __FILE_defined = @as(c_int, 1);
pub const __struct_FILE_defined = @as(c_int, 1);
pub const __getc_unlocked_body = @compileError("TODO postfix inc/dec expr");
// /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h:102:9
pub const __putc_unlocked_body = @compileError("TODO postfix inc/dec expr");
// /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h:106:9
pub const _IO_EOF_SEEN = @as(c_int, 0x0010);
pub inline fn __feof_unlocked_body(_fp: anytype) @TypeOf((_fp.*._flags & _IO_EOF_SEEN) != @as(c_int, 0)) {
    _ = &_fp;
    return (_fp.*._flags & _IO_EOF_SEEN) != @as(c_int, 0);
}
pub const _IO_ERR_SEEN = @as(c_int, 0x0020);
pub inline fn __ferror_unlocked_body(_fp: anytype) @TypeOf((_fp.*._flags & _IO_ERR_SEEN) != @as(c_int, 0)) {
    _ = &_fp;
    return (_fp.*._flags & _IO_ERR_SEEN) != @as(c_int, 0);
}
pub const _IO_USER_LOCK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const __cookie_io_functions_t_defined = @as(c_int, 1);
pub const _VA_LIST_DEFINED = "";
pub const _IOFBF = @as(c_int, 0);
pub const _IOLBF = @as(c_int, 1);
pub const _IONBF = @as(c_int, 2);
pub const BUFSIZ = @as(c_int, 8192);
pub const EOF = -@as(c_int, 1);
pub const SEEK_SET = @as(c_int, 0);
pub const SEEK_CUR = @as(c_int, 1);
pub const SEEK_END = @as(c_int, 2);
pub const P_tmpdir = "/tmp";
pub const L_tmpnam = @as(c_int, 20);
pub const TMP_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 238328, .decimal);
pub const _BITS_STDIO_LIM_H = @as(c_int, 1);
pub const FILENAME_MAX = @as(c_int, 4096);
pub const L_ctermid = @as(c_int, 9);
pub const FOPEN_MAX = @as(c_int, 16);
pub const __attr_dealloc_fclose = __attr_dealloc(fclose, @as(c_int, 1));
pub const _STRING_H = @as(c_int, 1);
pub const _BITS_TYPES_LOCALE_T_H = @as(c_int, 1);
pub const _BITS_TYPES___LOCALE_T_H = @as(c_int, 1);
pub const _STRINGS_H = @as(c_int, 1);
pub const __CLANG_STDINT_H = "";
pub const _STDINT_H = @as(c_int, 1);
pub const _BITS_WCHAR_H = @as(c_int, 1);
pub const __WCHAR_MAX = __WCHAR_MAX__;
pub const __WCHAR_MIN = -__WCHAR_MAX - @as(c_int, 1);
pub const _BITS_STDINT_UINTN_H = @as(c_int, 1);
pub const _BITS_STDINT_LEAST_H = @as(c_int, 1);
pub const __intptr_t_defined = "";
pub const __INT64_C = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub const __UINT64_C = @import("std").zig.c_translation.Macros.UL_SUFFIX;
pub const INT8_MIN = -@as(c_int, 128);
pub const INT16_MIN = -@as(c_int, 32767) - @as(c_int, 1);
pub const INT32_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const INT64_MIN = -__INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal)) - @as(c_int, 1);
pub const INT8_MAX = @as(c_int, 127);
pub const INT16_MAX = @as(c_int, 32767);
pub const INT32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const INT64_MAX = __INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal));
pub const UINT8_MAX = @as(c_int, 255);
pub const UINT16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const UINT32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const UINT64_MAX = __UINT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 18446744073709551615, .decimal));
pub const INT_LEAST8_MIN = -@as(c_int, 128);
pub const INT_LEAST16_MIN = -@as(c_int, 32767) - @as(c_int, 1);
pub const INT_LEAST32_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const INT_LEAST64_MIN = -__INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal)) - @as(c_int, 1);
pub const INT_LEAST8_MAX = @as(c_int, 127);
pub const INT_LEAST16_MAX = @as(c_int, 32767);
pub const INT_LEAST32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const INT_LEAST64_MAX = __INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal));
pub const UINT_LEAST8_MAX = @as(c_int, 255);
pub const UINT_LEAST16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const UINT_LEAST32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const UINT_LEAST64_MAX = __UINT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 18446744073709551615, .decimal));
pub const INT_FAST8_MIN = -@as(c_int, 128);
pub const INT_FAST16_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal) - @as(c_int, 1);
pub const INT_FAST32_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal) - @as(c_int, 1);
pub const INT_FAST64_MIN = -__INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal)) - @as(c_int, 1);
pub const INT_FAST8_MAX = @as(c_int, 127);
pub const INT_FAST16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const INT_FAST32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const INT_FAST64_MAX = __INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal));
pub const UINT_FAST8_MAX = @as(c_int, 255);
pub const UINT_FAST16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const UINT_FAST32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const UINT_FAST64_MAX = __UINT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 18446744073709551615, .decimal));
pub const INTPTR_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal) - @as(c_int, 1);
pub const INTPTR_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const UINTPTR_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const INTMAX_MIN = -__INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal)) - @as(c_int, 1);
pub const INTMAX_MAX = __INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal));
pub const UINTMAX_MAX = __UINT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 18446744073709551615, .decimal));
pub const PTRDIFF_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal) - @as(c_int, 1);
pub const PTRDIFF_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const SIG_ATOMIC_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const SIG_ATOMIC_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const SIZE_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const WCHAR_MIN = __WCHAR_MIN;
pub const WCHAR_MAX = __WCHAR_MAX;
pub const WINT_MIN = @as(c_uint, 0);
pub const WINT_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub inline fn INT8_C(c: anytype) @TypeOf(c) {
    _ = &c;
    return c;
}
pub inline fn INT16_C(c: anytype) @TypeOf(c) {
    _ = &c;
    return c;
}
pub inline fn INT32_C(c: anytype) @TypeOf(c) {
    _ = &c;
    return c;
}
pub const INT64_C = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub inline fn UINT8_C(c: anytype) @TypeOf(c) {
    _ = &c;
    return c;
}
pub inline fn UINT16_C(c: anytype) @TypeOf(c) {
    _ = &c;
    return c;
}
pub const UINT32_C = @import("std").zig.c_translation.Macros.U_SUFFIX;
pub const UINT64_C = @import("std").zig.c_translation.Macros.UL_SUFFIX;
pub const INTMAX_C = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub const UINTMAX_C = @import("std").zig.c_translation.Macros.UL_SUFFIX;
pub const _TIME_H = @as(c_int, 1);
pub const _BITS_TIME_H = @as(c_int, 1);
pub const CLOCKS_PER_SEC = @import("std").zig.c_translation.cast(__clock_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal));
pub const CLOCK_REALTIME = @as(c_int, 0);
pub const CLOCK_MONOTONIC = @as(c_int, 1);
pub const CLOCK_PROCESS_CPUTIME_ID = @as(c_int, 2);
pub const CLOCK_THREAD_CPUTIME_ID = @as(c_int, 3);
pub const CLOCK_MONOTONIC_RAW = @as(c_int, 4);
pub const CLOCK_REALTIME_COARSE = @as(c_int, 5);
pub const CLOCK_MONOTONIC_COARSE = @as(c_int, 6);
pub const CLOCK_BOOTTIME = @as(c_int, 7);
pub const CLOCK_REALTIME_ALARM = @as(c_int, 8);
pub const CLOCK_BOOTTIME_ALARM = @as(c_int, 9);
pub const CLOCK_TAI = @as(c_int, 11);
pub const TIMER_ABSTIME = @as(c_int, 1);
pub const __struct_tm_defined = @as(c_int, 1);
pub const __itimerspec_defined = @as(c_int, 1);
pub const TIME_UTC = @as(c_int, 1);
pub inline fn __isleap(year: anytype) @TypeOf((@import("std").zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 4)) == @as(c_int, 0)) and ((@import("std").zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 100)) != @as(c_int, 0)) or (@import("std").zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 400)) == @as(c_int, 0)))) {
    _ = &year;
    return (@import("std").zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 4)) == @as(c_int, 0)) and ((@import("std").zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 100)) != @as(c_int, 0)) or (@import("std").zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 400)) == @as(c_int, 0)));
}
pub const _ARPA_INET_H = @as(c_int, 1);
pub const _NETINET_IN_H = @as(c_int, 1);
pub const _SYS_SOCKET_H = @as(c_int, 1);
pub const __iovec_defined = @as(c_int, 1);
pub const __BITS_SOCKET_H = "";
pub const __socklen_t_defined = "";
pub const PF_UNSPEC = @as(c_int, 0);
pub const PF_LOCAL = @as(c_int, 1);
pub const PF_UNIX = PF_LOCAL;
pub const PF_FILE = PF_LOCAL;
pub const PF_INET = @as(c_int, 2);
pub const PF_AX25 = @as(c_int, 3);
pub const PF_IPX = @as(c_int, 4);
pub const PF_APPLETALK = @as(c_int, 5);
pub const PF_NETROM = @as(c_int, 6);
pub const PF_BRIDGE = @as(c_int, 7);
pub const PF_ATMPVC = @as(c_int, 8);
pub const PF_X25 = @as(c_int, 9);
pub const PF_INET6 = @as(c_int, 10);
pub const PF_ROSE = @as(c_int, 11);
pub const PF_DECnet = @as(c_int, 12);
pub const PF_NETBEUI = @as(c_int, 13);
pub const PF_SECURITY = @as(c_int, 14);
pub const PF_KEY = @as(c_int, 15);
pub const PF_NETLINK = @as(c_int, 16);
pub const PF_ROUTE = PF_NETLINK;
pub const PF_PACKET = @as(c_int, 17);
pub const PF_ASH = @as(c_int, 18);
pub const PF_ECONET = @as(c_int, 19);
pub const PF_ATMSVC = @as(c_int, 20);
pub const PF_RDS = @as(c_int, 21);
pub const PF_SNA = @as(c_int, 22);
pub const PF_IRDA = @as(c_int, 23);
pub const PF_PPPOX = @as(c_int, 24);
pub const PF_WANPIPE = @as(c_int, 25);
pub const PF_LLC = @as(c_int, 26);
pub const PF_IB = @as(c_int, 27);
pub const PF_MPLS = @as(c_int, 28);
pub const PF_CAN = @as(c_int, 29);
pub const PF_TIPC = @as(c_int, 30);
pub const PF_BLUETOOTH = @as(c_int, 31);
pub const PF_IUCV = @as(c_int, 32);
pub const PF_RXRPC = @as(c_int, 33);
pub const PF_ISDN = @as(c_int, 34);
pub const PF_PHONET = @as(c_int, 35);
pub const PF_IEEE802154 = @as(c_int, 36);
pub const PF_CAIF = @as(c_int, 37);
pub const PF_ALG = @as(c_int, 38);
pub const PF_NFC = @as(c_int, 39);
pub const PF_VSOCK = @as(c_int, 40);
pub const PF_KCM = @as(c_int, 41);
pub const PF_QIPCRTR = @as(c_int, 42);
pub const PF_SMC = @as(c_int, 43);
pub const PF_XDP = @as(c_int, 44);
pub const PF_MCTP = @as(c_int, 45);
pub const PF_MAX = @as(c_int, 46);
pub const AF_UNSPEC = PF_UNSPEC;
pub const AF_LOCAL = PF_LOCAL;
pub const AF_UNIX = PF_UNIX;
pub const AF_FILE = PF_FILE;
pub const AF_INET = PF_INET;
pub const AF_AX25 = PF_AX25;
pub const AF_IPX = PF_IPX;
pub const AF_APPLETALK = PF_APPLETALK;
pub const AF_NETROM = PF_NETROM;
pub const AF_BRIDGE = PF_BRIDGE;
pub const AF_ATMPVC = PF_ATMPVC;
pub const AF_X25 = PF_X25;
pub const AF_INET6 = PF_INET6;
pub const AF_ROSE = PF_ROSE;
pub const AF_DECnet = PF_DECnet;
pub const AF_NETBEUI = PF_NETBEUI;
pub const AF_SECURITY = PF_SECURITY;
pub const AF_KEY = PF_KEY;
pub const AF_NETLINK = PF_NETLINK;
pub const AF_ROUTE = PF_ROUTE;
pub const AF_PACKET = PF_PACKET;
pub const AF_ASH = PF_ASH;
pub const AF_ECONET = PF_ECONET;
pub const AF_ATMSVC = PF_ATMSVC;
pub const AF_RDS = PF_RDS;
pub const AF_SNA = PF_SNA;
pub const AF_IRDA = PF_IRDA;
pub const AF_PPPOX = PF_PPPOX;
pub const AF_WANPIPE = PF_WANPIPE;
pub const AF_LLC = PF_LLC;
pub const AF_IB = PF_IB;
pub const AF_MPLS = PF_MPLS;
pub const AF_CAN = PF_CAN;
pub const AF_TIPC = PF_TIPC;
pub const AF_BLUETOOTH = PF_BLUETOOTH;
pub const AF_IUCV = PF_IUCV;
pub const AF_RXRPC = PF_RXRPC;
pub const AF_ISDN = PF_ISDN;
pub const AF_PHONET = PF_PHONET;
pub const AF_IEEE802154 = PF_IEEE802154;
pub const AF_CAIF = PF_CAIF;
pub const AF_ALG = PF_ALG;
pub const AF_NFC = PF_NFC;
pub const AF_VSOCK = PF_VSOCK;
pub const AF_KCM = PF_KCM;
pub const AF_QIPCRTR = PF_QIPCRTR;
pub const AF_SMC = PF_SMC;
pub const AF_XDP = PF_XDP;
pub const AF_MCTP = PF_MCTP;
pub const AF_MAX = PF_MAX;
pub const SOL_RAW = @as(c_int, 255);
pub const SOL_DECNET = @as(c_int, 261);
pub const SOL_X25 = @as(c_int, 262);
pub const SOL_PACKET = @as(c_int, 263);
pub const SOL_ATM = @as(c_int, 264);
pub const SOL_AAL = @as(c_int, 265);
pub const SOL_IRDA = @as(c_int, 266);
pub const SOL_NETBEUI = @as(c_int, 267);
pub const SOL_LLC = @as(c_int, 268);
pub const SOL_DCCP = @as(c_int, 269);
pub const SOL_NETLINK = @as(c_int, 270);
pub const SOL_TIPC = @as(c_int, 271);
pub const SOL_RXRPC = @as(c_int, 272);
pub const SOL_PPPOL2TP = @as(c_int, 273);
pub const SOL_BLUETOOTH = @as(c_int, 274);
pub const SOL_PNPIPE = @as(c_int, 275);
pub const SOL_RDS = @as(c_int, 276);
pub const SOL_IUCV = @as(c_int, 277);
pub const SOL_CAIF = @as(c_int, 278);
pub const SOL_ALG = @as(c_int, 279);
pub const SOL_NFC = @as(c_int, 280);
pub const SOL_KCM = @as(c_int, 281);
pub const SOL_TLS = @as(c_int, 282);
pub const SOL_XDP = @as(c_int, 283);
pub const SOL_MPTCP = @as(c_int, 284);
pub const SOL_MCTP = @as(c_int, 285);
pub const SOL_SMC = @as(c_int, 286);
pub const SOMAXCONN = @as(c_int, 4096);
pub const _BITS_SOCKADDR_H = @as(c_int, 1);
pub const __SOCKADDR_COMMON = @compileError("unable to translate macro: undefined identifier `family`");
// /usr/include/x86_64-linux-gnu/bits/sockaddr.h:34:9
pub const __SOCKADDR_COMMON_SIZE = @import("std").zig.c_translation.sizeof(c_ushort);
pub const _SS_SIZE = @as(c_int, 128);
pub const __ss_aligntype = c_ulong;
pub const _SS_PADSIZE = (_SS_SIZE - __SOCKADDR_COMMON_SIZE) - @import("std").zig.c_translation.sizeof(__ss_aligntype);
pub inline fn CMSG_DATA(cmsg: anytype) @TypeOf(cmsg.*.__cmsg_data) {
    _ = &cmsg;
    return cmsg.*.__cmsg_data;
}
pub inline fn CMSG_NXTHDR(mhdr: anytype, cmsg: anytype) @TypeOf(__cmsg_nxthdr(mhdr, cmsg)) {
    _ = &mhdr;
    _ = &cmsg;
    return __cmsg_nxthdr(mhdr, cmsg);
}
pub inline fn CMSG_FIRSTHDR(mhdr: anytype) @TypeOf(if (@import("std").zig.c_translation.cast(usize, mhdr.*.msg_controllen) >= @import("std").zig.c_translation.sizeof(struct_cmsghdr)) @import("std").zig.c_translation.cast([*c]struct_cmsghdr, mhdr.*.msg_control) else @import("std").zig.c_translation.cast([*c]struct_cmsghdr, @as(c_int, 0))) {
    _ = &mhdr;
    return if (@import("std").zig.c_translation.cast(usize, mhdr.*.msg_controllen) >= @import("std").zig.c_translation.sizeof(struct_cmsghdr)) @import("std").zig.c_translation.cast([*c]struct_cmsghdr, mhdr.*.msg_control) else @import("std").zig.c_translation.cast([*c]struct_cmsghdr, @as(c_int, 0));
}
pub inline fn CMSG_ALIGN(len: anytype) @TypeOf(((len + @import("std").zig.c_translation.sizeof(usize)) - @as(c_int, 1)) & @import("std").zig.c_translation.cast(usize, ~(@import("std").zig.c_translation.sizeof(usize) - @as(c_int, 1)))) {
    _ = &len;
    return ((len + @import("std").zig.c_translation.sizeof(usize)) - @as(c_int, 1)) & @import("std").zig.c_translation.cast(usize, ~(@import("std").zig.c_translation.sizeof(usize) - @as(c_int, 1)));
}
pub inline fn CMSG_SPACE(len: anytype) @TypeOf(CMSG_ALIGN(len) + CMSG_ALIGN(@import("std").zig.c_translation.sizeof(struct_cmsghdr))) {
    _ = &len;
    return CMSG_ALIGN(len) + CMSG_ALIGN(@import("std").zig.c_translation.sizeof(struct_cmsghdr));
}
pub inline fn CMSG_LEN(len: anytype) @TypeOf(CMSG_ALIGN(@import("std").zig.c_translation.sizeof(struct_cmsghdr)) + len) {
    _ = &len;
    return CMSG_ALIGN(@import("std").zig.c_translation.sizeof(struct_cmsghdr)) + len;
}
pub inline fn __CMSG_PADDING(len: anytype) @TypeOf((@import("std").zig.c_translation.sizeof(usize) - (len & (@import("std").zig.c_translation.sizeof(usize) - @as(c_int, 1)))) & (@import("std").zig.c_translation.sizeof(usize) - @as(c_int, 1))) {
    _ = &len;
    return (@import("std").zig.c_translation.sizeof(usize) - (len & (@import("std").zig.c_translation.sizeof(usize) - @as(c_int, 1)))) & (@import("std").zig.c_translation.sizeof(usize) - @as(c_int, 1));
}
pub const __ASM_GENERIC_SOCKET_H = "";
pub const _LINUX_POSIX_TYPES_H = "";
pub const _LINUX_STDDEF_H = "";
pub const __struct_group = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /usr/include/linux/stddef.h:26:9
pub const __DECLARE_FLEX_ARRAY = @compileError("unable to translate macro: undefined identifier `__empty_`");
// /usr/include/linux/stddef.h:47:9
pub const __counted_by = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/linux/stddef.h:55:9
pub const _ASM_X86_POSIX_TYPES_64_H = "";
pub const __ASM_GENERIC_POSIX_TYPES_H = "";
pub const __ASM_X86_BITSPERLONG_H = "";
pub const __BITS_PER_LONG = @as(c_int, 64);
pub const __ASM_GENERIC_BITS_PER_LONG = "";
pub const __ASM_GENERIC_SOCKIOS_H = "";
pub const FIOSETOWN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8901, .hex);
pub const SIOCSPGRP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8902, .hex);
pub const FIOGETOWN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8903, .hex);
pub const SIOCGPGRP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8904, .hex);
pub const SIOCATMARK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8905, .hex);
pub const SIOCGSTAMP_OLD = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8906, .hex);
pub const SIOCGSTAMPNS_OLD = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8907, .hex);
pub const SOL_SOCKET = @as(c_int, 1);
pub const SO_DEBUG = @as(c_int, 1);
pub const SO_REUSEADDR = @as(c_int, 2);
pub const SO_TYPE = @as(c_int, 3);
pub const SO_ERROR = @as(c_int, 4);
pub const SO_DONTROUTE = @as(c_int, 5);
pub const SO_BROADCAST = @as(c_int, 6);
pub const SO_SNDBUF = @as(c_int, 7);
pub const SO_RCVBUF = @as(c_int, 8);
pub const SO_SNDBUFFORCE = @as(c_int, 32);
pub const SO_RCVBUFFORCE = @as(c_int, 33);
pub const SO_KEEPALIVE = @as(c_int, 9);
pub const SO_OOBINLINE = @as(c_int, 10);
pub const SO_NO_CHECK = @as(c_int, 11);
pub const SO_PRIORITY = @as(c_int, 12);
pub const SO_LINGER = @as(c_int, 13);
pub const SO_BSDCOMPAT = @as(c_int, 14);
pub const SO_REUSEPORT = @as(c_int, 15);
pub const SO_PASSCRED = @as(c_int, 16);
pub const SO_PEERCRED = @as(c_int, 17);
pub const SO_RCVLOWAT = @as(c_int, 18);
pub const SO_SNDLOWAT = @as(c_int, 19);
pub const SO_RCVTIMEO_OLD = @as(c_int, 20);
pub const SO_SNDTIMEO_OLD = @as(c_int, 21);
pub const SO_SECURITY_AUTHENTICATION = @as(c_int, 22);
pub const SO_SECURITY_ENCRYPTION_TRANSPORT = @as(c_int, 23);
pub const SO_SECURITY_ENCRYPTION_NETWORK = @as(c_int, 24);
pub const SO_BINDTODEVICE = @as(c_int, 25);
pub const SO_ATTACH_FILTER = @as(c_int, 26);
pub const SO_DETACH_FILTER = @as(c_int, 27);
pub const SO_GET_FILTER = SO_ATTACH_FILTER;
pub const SO_PEERNAME = @as(c_int, 28);
pub const SO_ACCEPTCONN = @as(c_int, 30);
pub const SO_PEERSEC = @as(c_int, 31);
pub const SO_PASSSEC = @as(c_int, 34);
pub const SO_MARK = @as(c_int, 36);
pub const SO_PROTOCOL = @as(c_int, 38);
pub const SO_DOMAIN = @as(c_int, 39);
pub const SO_RXQ_OVFL = @as(c_int, 40);
pub const SO_WIFI_STATUS = @as(c_int, 41);
pub const SCM_WIFI_STATUS = SO_WIFI_STATUS;
pub const SO_PEEK_OFF = @as(c_int, 42);
pub const SO_NOFCS = @as(c_int, 43);
pub const SO_LOCK_FILTER = @as(c_int, 44);
pub const SO_SELECT_ERR_QUEUE = @as(c_int, 45);
pub const SO_BUSY_POLL = @as(c_int, 46);
pub const SO_MAX_PACING_RATE = @as(c_int, 47);
pub const SO_BPF_EXTENSIONS = @as(c_int, 48);
pub const SO_INCOMING_CPU = @as(c_int, 49);
pub const SO_ATTACH_BPF = @as(c_int, 50);
pub const SO_DETACH_BPF = SO_DETACH_FILTER;
pub const SO_ATTACH_REUSEPORT_CBPF = @as(c_int, 51);
pub const SO_ATTACH_REUSEPORT_EBPF = @as(c_int, 52);
pub const SO_CNX_ADVICE = @as(c_int, 53);
pub const SCM_TIMESTAMPING_OPT_STATS = @as(c_int, 54);
pub const SO_MEMINFO = @as(c_int, 55);
pub const SO_INCOMING_NAPI_ID = @as(c_int, 56);
pub const SO_COOKIE = @as(c_int, 57);
pub const SCM_TIMESTAMPING_PKTINFO = @as(c_int, 58);
pub const SO_PEERGROUPS = @as(c_int, 59);
pub const SO_ZEROCOPY = @as(c_int, 60);
pub const SO_TXTIME = @as(c_int, 61);
pub const SCM_TXTIME = SO_TXTIME;
pub const SO_BINDTOIFINDEX = @as(c_int, 62);
pub const SO_TIMESTAMP_OLD = @as(c_int, 29);
pub const SO_TIMESTAMPNS_OLD = @as(c_int, 35);
pub const SO_TIMESTAMPING_OLD = @as(c_int, 37);
pub const SO_TIMESTAMP_NEW = @as(c_int, 63);
pub const SO_TIMESTAMPNS_NEW = @as(c_int, 64);
pub const SO_TIMESTAMPING_NEW = @as(c_int, 65);
pub const SO_RCVTIMEO_NEW = @as(c_int, 66);
pub const SO_SNDTIMEO_NEW = @as(c_int, 67);
pub const SO_DETACH_REUSEPORT_BPF = @as(c_int, 68);
pub const SO_PREFER_BUSY_POLL = @as(c_int, 69);
pub const SO_BUSY_POLL_BUDGET = @as(c_int, 70);
pub const SO_NETNS_COOKIE = @as(c_int, 71);
pub const SO_BUF_LOCK = @as(c_int, 72);
pub const SO_RESERVE_MEM = @as(c_int, 73);
pub const SO_TXREHASH = @as(c_int, 74);
pub const SO_RCVMARK = @as(c_int, 75);
pub const SO_PASSPIDFD = @as(c_int, 76);
pub const SO_PEERPIDFD = @as(c_int, 77);
pub const SO_TIMESTAMP = SO_TIMESTAMP_OLD;
pub const SO_TIMESTAMPNS = SO_TIMESTAMPNS_OLD;
pub const SO_TIMESTAMPING = SO_TIMESTAMPING_OLD;
pub const SO_RCVTIMEO = SO_RCVTIMEO_OLD;
pub const SO_SNDTIMEO = SO_SNDTIMEO_OLD;
pub const SCM_TIMESTAMP = SO_TIMESTAMP;
pub const SCM_TIMESTAMPNS = SO_TIMESTAMPNS;
pub const SCM_TIMESTAMPING = SO_TIMESTAMPING;
pub const __osockaddr_defined = @as(c_int, 1);
pub const __SOCKADDR_ARG = @compileError("unable to translate C expr: unexpected token '__restrict'");
// /usr/include/x86_64-linux-gnu/sys/socket.h:58:10
pub const __CONST_SOCKADDR_ARG = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/x86_64-linux-gnu/sys/socket.h:59:10
pub const __USE_KERNEL_IPV6_DEFS = @as(c_int, 0);
pub const IP_OPTIONS = @as(c_int, 4);
pub const IP_HDRINCL = @as(c_int, 3);
pub const IP_TOS = @as(c_int, 1);
pub const IP_TTL = @as(c_int, 2);
pub const IP_RECVOPTS = @as(c_int, 6);
pub const IP_RECVRETOPTS = IP_RETOPTS;
pub const IP_RETOPTS = @as(c_int, 7);
pub const IP_MULTICAST_IF = @as(c_int, 32);
pub const IP_MULTICAST_TTL = @as(c_int, 33);
pub const IP_MULTICAST_LOOP = @as(c_int, 34);
pub const IP_ADD_MEMBERSHIP = @as(c_int, 35);
pub const IP_DROP_MEMBERSHIP = @as(c_int, 36);
pub const IP_UNBLOCK_SOURCE = @as(c_int, 37);
pub const IP_BLOCK_SOURCE = @as(c_int, 38);
pub const IP_ADD_SOURCE_MEMBERSHIP = @as(c_int, 39);
pub const IP_DROP_SOURCE_MEMBERSHIP = @as(c_int, 40);
pub const IP_MSFILTER = @as(c_int, 41);
pub const MCAST_JOIN_GROUP = @as(c_int, 42);
pub const MCAST_BLOCK_SOURCE = @as(c_int, 43);
pub const MCAST_UNBLOCK_SOURCE = @as(c_int, 44);
pub const MCAST_LEAVE_GROUP = @as(c_int, 45);
pub const MCAST_JOIN_SOURCE_GROUP = @as(c_int, 46);
pub const MCAST_LEAVE_SOURCE_GROUP = @as(c_int, 47);
pub const MCAST_MSFILTER = @as(c_int, 48);
pub const IP_MULTICAST_ALL = @as(c_int, 49);
pub const IP_UNICAST_IF = @as(c_int, 50);
pub const MCAST_EXCLUDE = @as(c_int, 0);
pub const MCAST_INCLUDE = @as(c_int, 1);
pub const IP_ROUTER_ALERT = @as(c_int, 5);
pub const IP_PKTINFO = @as(c_int, 8);
pub const IP_PKTOPTIONS = @as(c_int, 9);
pub const IP_PMTUDISC = @as(c_int, 10);
pub const IP_MTU_DISCOVER = @as(c_int, 10);
pub const IP_RECVERR = @as(c_int, 11);
pub const IP_RECVTTL = @as(c_int, 12);
pub const IP_RECVTOS = @as(c_int, 13);
pub const IP_MTU = @as(c_int, 14);
pub const IP_FREEBIND = @as(c_int, 15);
pub const IP_IPSEC_POLICY = @as(c_int, 16);
pub const IP_XFRM_POLICY = @as(c_int, 17);
pub const IP_PASSSEC = @as(c_int, 18);
pub const IP_TRANSPARENT = @as(c_int, 19);
pub const IP_ORIGDSTADDR = @as(c_int, 20);
pub const IP_RECVORIGDSTADDR = IP_ORIGDSTADDR;
pub const IP_MINTTL = @as(c_int, 21);
pub const IP_NODEFRAG = @as(c_int, 22);
pub const IP_CHECKSUM = @as(c_int, 23);
pub const IP_BIND_ADDRESS_NO_PORT = @as(c_int, 24);
pub const IP_RECVFRAGSIZE = @as(c_int, 25);
pub const IP_RECVERR_RFC4884 = @as(c_int, 26);
pub const IP_PMTUDISC_DONT = @as(c_int, 0);
pub const IP_PMTUDISC_WANT = @as(c_int, 1);
pub const IP_PMTUDISC_DO = @as(c_int, 2);
pub const IP_PMTUDISC_PROBE = @as(c_int, 3);
pub const IP_PMTUDISC_INTERFACE = @as(c_int, 4);
pub const IP_PMTUDISC_OMIT = @as(c_int, 5);
pub const IP_LOCAL_PORT_RANGE = @as(c_int, 51);
pub const IP_PROTOCOL = @as(c_int, 52);
pub const SOL_IP = @as(c_int, 0);
pub const IP_DEFAULT_MULTICAST_TTL = @as(c_int, 1);
pub const IP_DEFAULT_MULTICAST_LOOP = @as(c_int, 1);
pub const IP_MAX_MEMBERSHIPS = @as(c_int, 20);
pub const IPV6_ADDRFORM = @as(c_int, 1);
pub const IPV6_2292PKTINFO = @as(c_int, 2);
pub const IPV6_2292HOPOPTS = @as(c_int, 3);
pub const IPV6_2292DSTOPTS = @as(c_int, 4);
pub const IPV6_2292RTHDR = @as(c_int, 5);
pub const IPV6_2292PKTOPTIONS = @as(c_int, 6);
pub const IPV6_CHECKSUM = @as(c_int, 7);
pub const IPV6_2292HOPLIMIT = @as(c_int, 8);
pub const SCM_SRCRT = @compileError("unable to translate macro: undefined identifier `IPV6_RXSRCRT`");
// /usr/include/x86_64-linux-gnu/bits/in.h:172:9
pub const IPV6_NEXTHOP = @as(c_int, 9);
pub const IPV6_AUTHHDR = @as(c_int, 10);
pub const IPV6_UNICAST_HOPS = @as(c_int, 16);
pub const IPV6_MULTICAST_IF = @as(c_int, 17);
pub const IPV6_MULTICAST_HOPS = @as(c_int, 18);
pub const IPV6_MULTICAST_LOOP = @as(c_int, 19);
pub const IPV6_JOIN_GROUP = @as(c_int, 20);
pub const IPV6_LEAVE_GROUP = @as(c_int, 21);
pub const IPV6_ROUTER_ALERT = @as(c_int, 22);
pub const IPV6_MTU_DISCOVER = @as(c_int, 23);
pub const IPV6_MTU = @as(c_int, 24);
pub const IPV6_RECVERR = @as(c_int, 25);
pub const IPV6_V6ONLY = @as(c_int, 26);
pub const IPV6_JOIN_ANYCAST = @as(c_int, 27);
pub const IPV6_LEAVE_ANYCAST = @as(c_int, 28);
pub const IPV6_MULTICAST_ALL = @as(c_int, 29);
pub const IPV6_ROUTER_ALERT_ISOLATE = @as(c_int, 30);
pub const IPV6_RECVERR_RFC4884 = @as(c_int, 31);
pub const IPV6_IPSEC_POLICY = @as(c_int, 34);
pub const IPV6_XFRM_POLICY = @as(c_int, 35);
pub const IPV6_HDRINCL = @as(c_int, 36);
pub const IPV6_RECVPKTINFO = @as(c_int, 49);
pub const IPV6_PKTINFO = @as(c_int, 50);
pub const IPV6_RECVHOPLIMIT = @as(c_int, 51);
pub const IPV6_HOPLIMIT = @as(c_int, 52);
pub const IPV6_RECVHOPOPTS = @as(c_int, 53);
pub const IPV6_HOPOPTS = @as(c_int, 54);
pub const IPV6_RTHDRDSTOPTS = @as(c_int, 55);
pub const IPV6_RECVRTHDR = @as(c_int, 56);
pub const IPV6_RTHDR = @as(c_int, 57);
pub const IPV6_RECVDSTOPTS = @as(c_int, 58);
pub const IPV6_DSTOPTS = @as(c_int, 59);
pub const IPV6_RECVPATHMTU = @as(c_int, 60);
pub const IPV6_PATHMTU = @as(c_int, 61);
pub const IPV6_DONTFRAG = @as(c_int, 62);
pub const IPV6_RECVTCLASS = @as(c_int, 66);
pub const IPV6_TCLASS = @as(c_int, 67);
pub const IPV6_AUTOFLOWLABEL = @as(c_int, 70);
pub const IPV6_ADDR_PREFERENCES = @as(c_int, 72);
pub const IPV6_MINHOPCOUNT = @as(c_int, 73);
pub const IPV6_ORIGDSTADDR = @as(c_int, 74);
pub const IPV6_RECVORIGDSTADDR = IPV6_ORIGDSTADDR;
pub const IPV6_TRANSPARENT = @as(c_int, 75);
pub const IPV6_UNICAST_IF = @as(c_int, 76);
pub const IPV6_RECVFRAGSIZE = @as(c_int, 77);
pub const IPV6_FREEBIND = @as(c_int, 78);
pub const IPV6_ADD_MEMBERSHIP = IPV6_JOIN_GROUP;
pub const IPV6_DROP_MEMBERSHIP = IPV6_LEAVE_GROUP;
pub const IPV6_RXHOPOPTS = IPV6_HOPOPTS;
pub const IPV6_RXDSTOPTS = IPV6_DSTOPTS;
pub const IPV6_PMTUDISC_DONT = @as(c_int, 0);
pub const IPV6_PMTUDISC_WANT = @as(c_int, 1);
pub const IPV6_PMTUDISC_DO = @as(c_int, 2);
pub const IPV6_PMTUDISC_PROBE = @as(c_int, 3);
pub const IPV6_PMTUDISC_INTERFACE = @as(c_int, 4);
pub const IPV6_PMTUDISC_OMIT = @as(c_int, 5);
pub const SOL_IPV6 = @as(c_int, 41);
pub const SOL_ICMPV6 = @as(c_int, 58);
pub const IPV6_RTHDR_LOOSE = @as(c_int, 0);
pub const IPV6_RTHDR_STRICT = @as(c_int, 1);
pub const IPV6_RTHDR_TYPE_0 = @as(c_int, 0);
pub inline fn IN_CLASSA(a: anytype) @TypeOf((@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex)) == @as(c_int, 0)) {
    _ = &a;
    return (@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex)) == @as(c_int, 0);
}
pub const IN_CLASSA_NET = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff000000, .hex);
pub const IN_CLASSA_NSHIFT = @as(c_int, 24);
pub const IN_CLASSA_HOST = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hex) & ~IN_CLASSA_NET;
pub const IN_CLASSA_MAX = @as(c_int, 128);
pub inline fn IN_CLASSB(a: anytype) @TypeOf((@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xc0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex)) {
    _ = &a;
    return (@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xc0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex);
}
pub const IN_CLASSB_NET = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffff0000, .hex);
pub const IN_CLASSB_NSHIFT = @as(c_int, 16);
pub const IN_CLASSB_HOST = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hex) & ~IN_CLASSB_NET;
pub const IN_CLASSB_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub inline fn IN_CLASSC(a: anytype) @TypeOf((@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xc0000000, .hex)) {
    _ = &a;
    return (@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xc0000000, .hex);
}
pub const IN_CLASSC_NET = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffff00, .hex);
pub const IN_CLASSC_NSHIFT = @as(c_int, 8);
pub const IN_CLASSC_HOST = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hex) & ~IN_CLASSC_NET;
pub inline fn IN_CLASSD(a: anytype) @TypeOf((@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xf0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hex)) {
    _ = &a;
    return (@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xf0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hex);
}
pub inline fn IN_MULTICAST(a: anytype) @TypeOf(IN_CLASSD(a)) {
    _ = &a;
    return IN_CLASSD(a);
}
pub inline fn IN_EXPERIMENTAL(a: anytype) @TypeOf((@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hex)) {
    _ = &a;
    return (@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hex);
}
pub inline fn IN_BADCLASS(a: anytype) @TypeOf((@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xf0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xf0000000, .hex)) {
    _ = &a;
    return (@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xf0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xf0000000, .hex);
}
pub const INADDR_ANY = @import("std").zig.c_translation.cast(in_addr_t, @as(c_int, 0x00000000));
pub const INADDR_BROADCAST = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hex));
pub const INADDR_NONE = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hex));
pub const INADDR_DUMMY = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xc0000008, .hex));
pub const IN_LOOPBACKNET = @as(c_int, 127);
pub const INADDR_LOOPBACK = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7f000001, .hex));
pub const INADDR_UNSPEC_GROUP = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hex));
pub const INADDR_ALLHOSTS_GROUP = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000001, .hex));
pub const INADDR_ALLRTRS_GROUP = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000002, .hex));
pub const INADDR_ALLSNOOPERS_GROUP = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe000006a, .hex));
pub const INADDR_MAX_LOCAL_GROUP = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe00000ff, .hex));
pub const s6_addr = @compileError("unable to translate macro: undefined identifier `__in6_u`");
// /usr/include/netinet/in.h:229:9
pub const s6_addr16 = @compileError("unable to translate macro: undefined identifier `__in6_u`");
// /usr/include/netinet/in.h:231:10
pub const s6_addr32 = @compileError("unable to translate macro: undefined identifier `__in6_u`");
// /usr/include/netinet/in.h:232:10
pub const IN6ADDR_ANY_INIT = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/netinet/in.h:239:9
pub const IN6ADDR_LOOPBACK_INIT = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/netinet/in.h:240:9
pub const INET_ADDRSTRLEN = @as(c_int, 16);
pub const INET6_ADDRSTRLEN = @as(c_int, 46);
pub inline fn IP_MSFILTER_SIZE(numsrc: anytype) @TypeOf((@import("std").zig.c_translation.sizeof(struct_ip_msfilter) - @import("std").zig.c_translation.sizeof(struct_in_addr)) + (numsrc * @import("std").zig.c_translation.sizeof(struct_in_addr))) {
    _ = &numsrc;
    return (@import("std").zig.c_translation.sizeof(struct_ip_msfilter) - @import("std").zig.c_translation.sizeof(struct_in_addr)) + (numsrc * @import("std").zig.c_translation.sizeof(struct_in_addr));
}
pub inline fn GROUP_FILTER_SIZE(numsrc: anytype) @TypeOf((@import("std").zig.c_translation.sizeof(struct_group_filter) - @import("std").zig.c_translation.sizeof(struct_sockaddr_storage)) + (numsrc * @import("std").zig.c_translation.sizeof(struct_sockaddr_storage))) {
    _ = &numsrc;
    return (@import("std").zig.c_translation.sizeof(struct_group_filter) - @import("std").zig.c_translation.sizeof(struct_sockaddr_storage)) + (numsrc * @import("std").zig.c_translation.sizeof(struct_sockaddr_storage));
}
pub const IN6_IS_ADDR_UNSPECIFIED = @compileError("unable to translate macro: undefined identifier `__a`");
// /usr/include/netinet/in.h:433:10
pub const IN6_IS_ADDR_LOOPBACK = @compileError("unable to translate macro: undefined identifier `__a`");
// /usr/include/netinet/in.h:441:10
pub const IN6_IS_ADDR_LINKLOCAL = @compileError("unable to translate macro: undefined identifier `__a`");
// /usr/include/netinet/in.h:449:10
pub const IN6_IS_ADDR_SITELOCAL = @compileError("unable to translate macro: undefined identifier `__a`");
// /usr/include/netinet/in.h:454:10
pub const IN6_IS_ADDR_V4MAPPED = @compileError("unable to translate macro: undefined identifier `__a`");
// /usr/include/netinet/in.h:459:10
pub const IN6_IS_ADDR_V4COMPAT = @compileError("unable to translate macro: undefined identifier `__a`");
// /usr/include/netinet/in.h:466:10
pub const IN6_ARE_ADDR_EQUAL = @compileError("unable to translate macro: undefined identifier `__a`");
// /usr/include/netinet/in.h:474:10
pub const IN6_IS_ADDR_MULTICAST = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/netinet/in.h:521:9
pub const IN6_IS_ADDR_MC_NODELOCAL = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/netinet/in.h:533:9
pub const IN6_IS_ADDR_MC_LINKLOCAL = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/netinet/in.h:537:9
pub const IN6_IS_ADDR_MC_SITELOCAL = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/netinet/in.h:541:9
pub const IN6_IS_ADDR_MC_ORGLOCAL = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/netinet/in.h:545:9
pub const IN6_IS_ADDR_MC_GLOBAL = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/netinet/in.h:549:9
pub const _UNISTD_H = @as(c_int, 1);
pub const _POSIX_VERSION = @as(c_long, 200809);
pub const __POSIX2_THIS_VERSION = @as(c_long, 200809);
pub const _POSIX2_VERSION = __POSIX2_THIS_VERSION;
pub const _POSIX2_C_VERSION = __POSIX2_THIS_VERSION;
pub const _POSIX2_C_BIND = __POSIX2_THIS_VERSION;
pub const _POSIX2_C_DEV = __POSIX2_THIS_VERSION;
pub const _POSIX2_SW_DEV = __POSIX2_THIS_VERSION;
pub const _POSIX2_LOCALEDEF = __POSIX2_THIS_VERSION;
pub const _XOPEN_VERSION = @as(c_int, 700);
pub const _XOPEN_XCU_VERSION = @as(c_int, 4);
pub const _XOPEN_XPG2 = @as(c_int, 1);
pub const _XOPEN_XPG3 = @as(c_int, 1);
pub const _XOPEN_XPG4 = @as(c_int, 1);
pub const _XOPEN_UNIX = @as(c_int, 1);
pub const _XOPEN_ENH_I18N = @as(c_int, 1);
pub const _XOPEN_LEGACY = @as(c_int, 1);
pub const _BITS_POSIX_OPT_H = @as(c_int, 1);
pub const _POSIX_JOB_CONTROL = @as(c_int, 1);
pub const _POSIX_SAVED_IDS = @as(c_int, 1);
pub const _POSIX_PRIORITY_SCHEDULING = @as(c_long, 200809);
pub const _POSIX_SYNCHRONIZED_IO = @as(c_long, 200809);
pub const _POSIX_FSYNC = @as(c_long, 200809);
pub const _POSIX_MAPPED_FILES = @as(c_long, 200809);
pub const _POSIX_MEMLOCK = @as(c_long, 200809);
pub const _POSIX_MEMLOCK_RANGE = @as(c_long, 200809);
pub const _POSIX_MEMORY_PROTECTION = @as(c_long, 200809);
pub const _POSIX_CHOWN_RESTRICTED = @as(c_int, 0);
pub const _POSIX_VDISABLE = '\x00';
pub const _POSIX_NO_TRUNC = @as(c_int, 1);
pub const _XOPEN_REALTIME = @as(c_int, 1);
pub const _XOPEN_REALTIME_THREADS = @as(c_int, 1);
pub const _XOPEN_SHM = @as(c_int, 1);
pub const _POSIX_THREADS = @as(c_long, 200809);
pub const _POSIX_REENTRANT_FUNCTIONS = @as(c_int, 1);
pub const _POSIX_THREAD_SAFE_FUNCTIONS = @as(c_long, 200809);
pub const _POSIX_THREAD_PRIORITY_SCHEDULING = @as(c_long, 200809);
pub const _POSIX_THREAD_ATTR_STACKSIZE = @as(c_long, 200809);
pub const _POSIX_THREAD_ATTR_STACKADDR = @as(c_long, 200809);
pub const _POSIX_THREAD_PRIO_INHERIT = @as(c_long, 200809);
pub const _POSIX_THREAD_PRIO_PROTECT = @as(c_long, 200809);
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT = @as(c_long, 200809);
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT = -@as(c_int, 1);
pub const _POSIX_SEMAPHORES = @as(c_long, 200809);
pub const _POSIX_REALTIME_SIGNALS = @as(c_long, 200809);
pub const _POSIX_ASYNCHRONOUS_IO = @as(c_long, 200809);
pub const _POSIX_ASYNC_IO = @as(c_int, 1);
pub const _LFS_ASYNCHRONOUS_IO = @as(c_int, 1);
pub const _POSIX_PRIORITIZED_IO = @as(c_long, 200809);
pub const _LFS64_ASYNCHRONOUS_IO = @as(c_int, 1);
pub const _LFS_LARGEFILE = @as(c_int, 1);
pub const _LFS64_LARGEFILE = @as(c_int, 1);
pub const _LFS64_STDIO = @as(c_int, 1);
pub const _POSIX_SHARED_MEMORY_OBJECTS = @as(c_long, 200809);
pub const _POSIX_CPUTIME = @as(c_int, 0);
pub const _POSIX_THREAD_CPUTIME = @as(c_int, 0);
pub const _POSIX_REGEXP = @as(c_int, 1);
pub const _POSIX_READER_WRITER_LOCKS = @as(c_long, 200809);
pub const _POSIX_SHELL = @as(c_int, 1);
pub const _POSIX_TIMEOUTS = @as(c_long, 200809);
pub const _POSIX_SPIN_LOCKS = @as(c_long, 200809);
pub const _POSIX_SPAWN = @as(c_long, 200809);
pub const _POSIX_TIMERS = @as(c_long, 200809);
pub const _POSIX_BARRIERS = @as(c_long, 200809);
pub const _POSIX_MESSAGE_PASSING = @as(c_long, 200809);
pub const _POSIX_THREAD_PROCESS_SHARED = @as(c_long, 200809);
pub const _POSIX_MONOTONIC_CLOCK = @as(c_int, 0);
pub const _POSIX_CLOCK_SELECTION = @as(c_long, 200809);
pub const _POSIX_ADVISORY_INFO = @as(c_long, 200809);
pub const _POSIX_IPV6 = @as(c_long, 200809);
pub const _POSIX_RAW_SOCKETS = @as(c_long, 200809);
pub const _POSIX2_CHAR_TERM = @as(c_long, 200809);
pub const _POSIX_SPORADIC_SERVER = -@as(c_int, 1);
pub const _POSIX_THREAD_SPORADIC_SERVER = -@as(c_int, 1);
pub const _POSIX_TRACE = -@as(c_int, 1);
pub const _POSIX_TRACE_EVENT_FILTER = -@as(c_int, 1);
pub const _POSIX_TRACE_INHERIT = -@as(c_int, 1);
pub const _POSIX_TRACE_LOG = -@as(c_int, 1);
pub const _POSIX_TYPED_MEMORY_OBJECTS = -@as(c_int, 1);
pub const _POSIX_V7_LPBIG_OFFBIG = -@as(c_int, 1);
pub const _POSIX_V6_LPBIG_OFFBIG = -@as(c_int, 1);
pub const _XBS5_LPBIG_OFFBIG = -@as(c_int, 1);
pub const _POSIX_V7_LP64_OFF64 = @as(c_int, 1);
pub const _POSIX_V6_LP64_OFF64 = @as(c_int, 1);
pub const _XBS5_LP64_OFF64 = @as(c_int, 1);
pub const __ILP32_OFF32_CFLAGS = "-m32";
pub const __ILP32_OFF32_LDFLAGS = "-m32";
pub const __ILP32_OFFBIG_CFLAGS = "-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64";
pub const __ILP32_OFFBIG_LDFLAGS = "-m32";
pub const __LP64_OFF64_CFLAGS = "-m64";
pub const __LP64_OFF64_LDFLAGS = "-m64";
pub const STDIN_FILENO = @as(c_int, 0);
pub const STDOUT_FILENO = @as(c_int, 1);
pub const STDERR_FILENO = @as(c_int, 2);
pub const __useconds_t_defined = "";
pub const R_OK = @as(c_int, 4);
pub const W_OK = @as(c_int, 2);
pub const X_OK = @as(c_int, 1);
pub const F_OK = @as(c_int, 0);
pub const L_SET = SEEK_SET;
pub const L_INCR = SEEK_CUR;
pub const L_XTND = SEEK_END;
pub const _SC_PAGE_SIZE = _SC_PAGESIZE;
pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = _CS_V6_WIDTH_RESTRICTED_ENVS;
pub const _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS = _CS_V5_WIDTH_RESTRICTED_ENVS;
pub const _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS = _CS_V7_WIDTH_RESTRICTED_ENVS;
pub const _GETOPT_POSIX_H = @as(c_int, 1);
pub const _GETOPT_CORE_H = @as(c_int, 1);
pub const F_ULOCK = @as(c_int, 0);
pub const F_LOCK = @as(c_int, 1);
pub const F_TLOCK = @as(c_int, 2);
pub const F_TEST = @as(c_int, 3);
pub const _ERRNO_H = @as(c_int, 1);
pub const _BITS_ERRNO_H = @as(c_int, 1);
pub const _ASM_GENERIC_ERRNO_H = "";
pub const _ASM_GENERIC_ERRNO_BASE_H = "";
pub const EPERM = @as(c_int, 1);
pub const ENOENT = @as(c_int, 2);
pub const ESRCH = @as(c_int, 3);
pub const EINTR = @as(c_int, 4);
pub const EIO = @as(c_int, 5);
pub const ENXIO = @as(c_int, 6);
pub const E2BIG = @as(c_int, 7);
pub const ENOEXEC = @as(c_int, 8);
pub const EBADF = @as(c_int, 9);
pub const ECHILD = @as(c_int, 10);
pub const EAGAIN = @as(c_int, 11);
pub const ENOMEM = @as(c_int, 12);
pub const EACCES = @as(c_int, 13);
pub const EFAULT = @as(c_int, 14);
pub const ENOTBLK = @as(c_int, 15);
pub const EBUSY = @as(c_int, 16);
pub const EEXIST = @as(c_int, 17);
pub const EXDEV = @as(c_int, 18);
pub const ENODEV = @as(c_int, 19);
pub const ENOTDIR = @as(c_int, 20);
pub const EISDIR = @as(c_int, 21);
pub const EINVAL = @as(c_int, 22);
pub const ENFILE = @as(c_int, 23);
pub const EMFILE = @as(c_int, 24);
pub const ENOTTY = @as(c_int, 25);
pub const ETXTBSY = @as(c_int, 26);
pub const EFBIG = @as(c_int, 27);
pub const ENOSPC = @as(c_int, 28);
pub const ESPIPE = @as(c_int, 29);
pub const EROFS = @as(c_int, 30);
pub const EMLINK = @as(c_int, 31);
pub const EPIPE = @as(c_int, 32);
pub const EDOM = @as(c_int, 33);
pub const ERANGE = @as(c_int, 34);
pub const EDEADLK = @as(c_int, 35);
pub const ENAMETOOLONG = @as(c_int, 36);
pub const ENOLCK = @as(c_int, 37);
pub const ENOSYS = @as(c_int, 38);
pub const ENOTEMPTY = @as(c_int, 39);
pub const ELOOP = @as(c_int, 40);
pub const EWOULDBLOCK = EAGAIN;
pub const ENOMSG = @as(c_int, 42);
pub const EIDRM = @as(c_int, 43);
pub const ECHRNG = @as(c_int, 44);
pub const EL2NSYNC = @as(c_int, 45);
pub const EL3HLT = @as(c_int, 46);
pub const EL3RST = @as(c_int, 47);
pub const ELNRNG = @as(c_int, 48);
pub const EUNATCH = @as(c_int, 49);
pub const ENOCSI = @as(c_int, 50);
pub const EL2HLT = @as(c_int, 51);
pub const EBADE = @as(c_int, 52);
pub const EBADR = @as(c_int, 53);
pub const EXFULL = @as(c_int, 54);
pub const ENOANO = @as(c_int, 55);
pub const EBADRQC = @as(c_int, 56);
pub const EBADSLT = @as(c_int, 57);
pub const EDEADLOCK = EDEADLK;
pub const EBFONT = @as(c_int, 59);
pub const ENOSTR = @as(c_int, 60);
pub const ENODATA = @as(c_int, 61);
pub const ETIME = @as(c_int, 62);
pub const ENOSR = @as(c_int, 63);
pub const ENONET = @as(c_int, 64);
pub const ENOPKG = @as(c_int, 65);
pub const EREMOTE = @as(c_int, 66);
pub const ENOLINK = @as(c_int, 67);
pub const EADV = @as(c_int, 68);
pub const ESRMNT = @as(c_int, 69);
pub const ECOMM = @as(c_int, 70);
pub const EPROTO = @as(c_int, 71);
pub const EMULTIHOP = @as(c_int, 72);
pub const EDOTDOT = @as(c_int, 73);
pub const EBADMSG = @as(c_int, 74);
pub const EOVERFLOW = @as(c_int, 75);
pub const ENOTUNIQ = @as(c_int, 76);
pub const EBADFD = @as(c_int, 77);
pub const EREMCHG = @as(c_int, 78);
pub const ELIBACC = @as(c_int, 79);
pub const ELIBBAD = @as(c_int, 80);
pub const ELIBSCN = @as(c_int, 81);
pub const ELIBMAX = @as(c_int, 82);
pub const ELIBEXEC = @as(c_int, 83);
pub const EILSEQ = @as(c_int, 84);
pub const ERESTART = @as(c_int, 85);
pub const ESTRPIPE = @as(c_int, 86);
pub const EUSERS = @as(c_int, 87);
pub const ENOTSOCK = @as(c_int, 88);
pub const EDESTADDRREQ = @as(c_int, 89);
pub const EMSGSIZE = @as(c_int, 90);
pub const EPROTOTYPE = @as(c_int, 91);
pub const ENOPROTOOPT = @as(c_int, 92);
pub const EPROTONOSUPPORT = @as(c_int, 93);
pub const ESOCKTNOSUPPORT = @as(c_int, 94);
pub const EOPNOTSUPP = @as(c_int, 95);
pub const EPFNOSUPPORT = @as(c_int, 96);
pub const EAFNOSUPPORT = @as(c_int, 97);
pub const EADDRINUSE = @as(c_int, 98);
pub const EADDRNOTAVAIL = @as(c_int, 99);
pub const ENETDOWN = @as(c_int, 100);
pub const ENETUNREACH = @as(c_int, 101);
pub const ENETRESET = @as(c_int, 102);
pub const ECONNABORTED = @as(c_int, 103);
pub const ECONNRESET = @as(c_int, 104);
pub const ENOBUFS = @as(c_int, 105);
pub const EISCONN = @as(c_int, 106);
pub const ENOTCONN = @as(c_int, 107);
pub const ESHUTDOWN = @as(c_int, 108);
pub const ETOOMANYREFS = @as(c_int, 109);
pub const ETIMEDOUT = @as(c_int, 110);
pub const ECONNREFUSED = @as(c_int, 111);
pub const EHOSTDOWN = @as(c_int, 112);
pub const EHOSTUNREACH = @as(c_int, 113);
pub const EALREADY = @as(c_int, 114);
pub const EINPROGRESS = @as(c_int, 115);
pub const ESTALE = @as(c_int, 116);
pub const EUCLEAN = @as(c_int, 117);
pub const ENOTNAM = @as(c_int, 118);
pub const ENAVAIL = @as(c_int, 119);
pub const EISNAM = @as(c_int, 120);
pub const EREMOTEIO = @as(c_int, 121);
pub const EDQUOT = @as(c_int, 122);
pub const ENOMEDIUM = @as(c_int, 123);
pub const EMEDIUMTYPE = @as(c_int, 124);
pub const ECANCELED = @as(c_int, 125);
pub const ENOKEY = @as(c_int, 126);
pub const EKEYEXPIRED = @as(c_int, 127);
pub const EKEYREVOKED = @as(c_int, 128);
pub const EKEYREJECTED = @as(c_int, 129);
pub const EOWNERDEAD = @as(c_int, 130);
pub const ENOTRECOVERABLE = @as(c_int, 131);
pub const ERFKILL = @as(c_int, 132);
pub const EHWPOISON = @as(c_int, 133);
pub const ENOTSUP = EOPNOTSUPP;
pub const errno = __errno_location().*;
pub const CRYPT = @as(c_int, 0x0117);
pub const LTC_NO_ROLC = "";
pub const BN_H_ = "";
pub const __CLANG_LIMITS_H = "";
pub const _GCC_LIMITS_H_ = "";
pub const _LIBC_LIMITS_H_ = @as(c_int, 1);
pub const MB_LEN_MAX = @as(c_int, 16);
pub const LLONG_MIN = -LLONG_MAX - @as(c_int, 1);
pub const LLONG_MAX = __LONG_LONG_MAX__;
pub const ULLONG_MAX = (LLONG_MAX * @as(c_ulonglong, 2)) + @as(c_int, 1);
pub const _BITS_POSIX1_LIM_H = @as(c_int, 1);
pub const _POSIX_AIO_LISTIO_MAX = @as(c_int, 2);
pub const _POSIX_AIO_MAX = @as(c_int, 1);
pub const _POSIX_ARG_MAX = @as(c_int, 4096);
pub const _POSIX_CHILD_MAX = @as(c_int, 25);
pub const _POSIX_DELAYTIMER_MAX = @as(c_int, 32);
pub const _POSIX_HOST_NAME_MAX = @as(c_int, 255);
pub const _POSIX_LINK_MAX = @as(c_int, 8);
pub const _POSIX_LOGIN_NAME_MAX = @as(c_int, 9);
pub const _POSIX_MAX_CANON = @as(c_int, 255);
pub const _POSIX_MAX_INPUT = @as(c_int, 255);
pub const _POSIX_MQ_OPEN_MAX = @as(c_int, 8);
pub const _POSIX_MQ_PRIO_MAX = @as(c_int, 32);
pub const _POSIX_NAME_MAX = @as(c_int, 14);
pub const _POSIX_NGROUPS_MAX = @as(c_int, 8);
pub const _POSIX_OPEN_MAX = @as(c_int, 20);
pub const _POSIX_PATH_MAX = @as(c_int, 256);
pub const _POSIX_PIPE_BUF = @as(c_int, 512);
pub const _POSIX_RE_DUP_MAX = @as(c_int, 255);
pub const _POSIX_RTSIG_MAX = @as(c_int, 8);
pub const _POSIX_SEM_NSEMS_MAX = @as(c_int, 256);
pub const _POSIX_SEM_VALUE_MAX = @as(c_int, 32767);
pub const _POSIX_SIGQUEUE_MAX = @as(c_int, 32);
pub const _POSIX_SSIZE_MAX = @as(c_int, 32767);
pub const _POSIX_STREAM_MAX = @as(c_int, 8);
pub const _POSIX_SYMLINK_MAX = @as(c_int, 255);
pub const _POSIX_SYMLOOP_MAX = @as(c_int, 8);
pub const _POSIX_TIMER_MAX = @as(c_int, 32);
pub const _POSIX_TTY_NAME_MAX = @as(c_int, 9);
pub const _POSIX_TZNAME_MAX = @as(c_int, 6);
pub const _POSIX_CLOCKRES_MIN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 20000000, .decimal);
pub const __undef_NR_OPEN = "";
pub const __undef_LINK_MAX = "";
pub const __undef_OPEN_MAX = "";
pub const __undef_ARG_MAX = "";
pub const _LINUX_LIMITS_H = "";
pub const NR_OPEN = @as(c_int, 1024);
pub const NGROUPS_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub const ARG_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 131072, .decimal);
pub const LINK_MAX = @as(c_int, 127);
pub const MAX_CANON = @as(c_int, 255);
pub const MAX_INPUT = @as(c_int, 255);
pub const NAME_MAX = @as(c_int, 255);
pub const PATH_MAX = @as(c_int, 4096);
pub const PIPE_BUF = @as(c_int, 4096);
pub const XATTR_NAME_MAX = @as(c_int, 255);
pub const XATTR_SIZE_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub const XATTR_LIST_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub const RTSIG_MAX = @as(c_int, 32);
pub const _POSIX_THREAD_KEYS_MAX = @as(c_int, 128);
pub const PTHREAD_KEYS_MAX = @as(c_int, 1024);
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS = @as(c_int, 4);
pub const PTHREAD_DESTRUCTOR_ITERATIONS = _POSIX_THREAD_DESTRUCTOR_ITERATIONS;
pub const _POSIX_THREAD_THREADS_MAX = @as(c_int, 64);
pub const AIO_PRIO_DELTA_MAX = @as(c_int, 20);
pub const PTHREAD_STACK_MIN = @as(c_int, 16384);
pub const DELAYTIMER_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const TTY_NAME_MAX = @as(c_int, 32);
pub const LOGIN_NAME_MAX = @as(c_int, 256);
pub const HOST_NAME_MAX = @as(c_int, 64);
pub const MQ_PRIO_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 32768, .decimal);
pub const SEM_VALUE_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const SSIZE_MAX = LONG_MAX;
pub const _BITS_POSIX2_LIM_H = @as(c_int, 1);
pub const _POSIX2_BC_BASE_MAX = @as(c_int, 99);
pub const _POSIX2_BC_DIM_MAX = @as(c_int, 2048);
pub const _POSIX2_BC_SCALE_MAX = @as(c_int, 99);
pub const _POSIX2_BC_STRING_MAX = @as(c_int, 1000);
pub const _POSIX2_COLL_WEIGHTS_MAX = @as(c_int, 2);
pub const _POSIX2_EXPR_NEST_MAX = @as(c_int, 32);
pub const _POSIX2_LINE_MAX = @as(c_int, 2048);
pub const _POSIX2_RE_DUP_MAX = @as(c_int, 255);
pub const _POSIX2_CHARCLASS_NAME_MAX = @as(c_int, 14);
pub const BC_BASE_MAX = _POSIX2_BC_BASE_MAX;
pub const BC_DIM_MAX = _POSIX2_BC_DIM_MAX;
pub const BC_SCALE_MAX = _POSIX2_BC_SCALE_MAX;
pub const BC_STRING_MAX = _POSIX2_BC_STRING_MAX;
pub const COLL_WEIGHTS_MAX = @as(c_int, 255);
pub const EXPR_NEST_MAX = _POSIX2_EXPR_NEST_MAX;
pub const LINE_MAX = _POSIX2_LINE_MAX;
pub const CHARCLASS_NAME_MAX = @as(c_int, 2048);
pub const RE_DUP_MAX = @as(c_int, 0x7fff);
pub const SCHAR_MAX = __SCHAR_MAX__;
pub const SHRT_MAX = __SHRT_MAX__;
pub const INT_MAX = __INT_MAX__;
pub const LONG_MAX = __LONG_MAX__;
pub const SCHAR_MIN = -__SCHAR_MAX__ - @as(c_int, 1);
pub const SHRT_MIN = -__SHRT_MAX__ - @as(c_int, 1);
pub const INT_MIN = -__INT_MAX__ - @as(c_int, 1);
pub const LONG_MIN = -__LONG_MAX__ - @as(c_long, 1);
pub const UCHAR_MAX = (__SCHAR_MAX__ * @as(c_int, 2)) + @as(c_int, 1);
pub const USHRT_MAX = (__SHRT_MAX__ * @as(c_int, 2)) + @as(c_int, 1);
pub const UINT_MAX = (__INT_MAX__ * @as(c_uint, 2)) + @as(c_uint, 1);
pub const ULONG_MAX = (__LONG_MAX__ * @as(c_ulong, 2)) + @as(c_ulong, 1);
pub const CHAR_BIT = __CHAR_BIT__;
pub const CHAR_MIN = SCHAR_MIN;
pub const CHAR_MAX = __SCHAR_MAX__;
pub const LTM1 = "";
pub const LTM_ALL = "";
pub const LTM2 = "";
pub const BN_ERROR_C = "";
pub const BN_FAST_MP_INVMOD_C = "";
pub const BN_FAST_MP_MONTGOMERY_REDUCE_C = "";
pub const BN_FAST_S_MP_MUL_DIGS_C = "";
pub const BN_FAST_S_MP_MUL_HIGH_DIGS_C = "";
pub const BN_FAST_S_MP_SQR_C = "";
pub const BN_MP_2EXPT_C = "";
pub const BN_MP_ABS_C = "";
pub const BN_MP_ADD_C = "";
pub const BN_MP_ADD_D_C = "";
pub const BN_MP_ADDMOD_C = "";
pub const BN_MP_AND_C = "";
pub const BN_MP_CLAMP_C = "";
pub const BN_MP_CLEAR_C = "";
pub const BN_MP_CLEAR_MULTI_C = "";
pub const BN_MP_CMP_C = "";
pub const BN_MP_CMP_D_C = "";
pub const BN_MP_CMP_MAG_C = "";
pub const BN_MP_CNT_LSB_C = "";
pub const BN_MP_COPY_C = "";
pub const BN_MP_COUNT_BITS_C = "";
pub const BN_MP_DIV_C = "";
pub const BN_MP_DIV_2_C = "";
pub const BN_MP_DIV_2D_C = "";
pub const BN_MP_DIV_3_C = "";
pub const BN_MP_DIV_D_C = "";
pub const BN_MP_DR_IS_MODULUS_C = "";
pub const BN_MP_DR_REDUCE_C = "";
pub const BN_MP_DR_SETUP_C = "";
pub const BN_MP_EXCH_C = "";
pub const BN_MP_EXPORT_C = "";
pub const BN_MP_EXPT_D_C = "";
pub const BN_MP_EXPT_D_EX_C = "";
pub const BN_MP_EXPTMOD_C = "";
pub const BN_MP_EXPTMOD_FAST_C = "";
pub const BN_MP_EXTEUCLID_C = "";
pub const BN_MP_FREAD_C = "";
pub const BN_MP_FWRITE_C = "";
pub const BN_MP_GCD_C = "";
pub const BN_MP_GET_INT_C = "";
pub const BN_MP_GET_LONG_C = "";
pub const BN_MP_GET_LONG_LONG_C = "";
pub const BN_MP_GROW_C = "";
pub const BN_MP_IMPORT_C = "";
pub const BN_MP_INIT_C = "";
pub const BN_MP_INIT_COPY_C = "";
pub const BN_MP_INIT_MULTI_C = "";
pub const BN_MP_INIT_SET_C = "";
pub const BN_MP_INIT_SET_INT_C = "";
pub const BN_MP_INIT_SIZE_C = "";
pub const BN_MP_INVMOD_C = "";
pub const BN_MP_INVMOD_SLOW_C = "";
pub const BN_MP_IS_SQUARE_C = "";
pub const BN_MP_JACOBI_C = "";
pub const BN_MP_KARATSUBA_MUL_C = "";
pub const BN_MP_KARATSUBA_SQR_C = "";
pub const BN_MP_LCM_C = "";
pub const BN_MP_LSHD_C = "";
pub const BN_MP_MOD_C = "";
pub const BN_MP_MOD_2D_C = "";
pub const BN_MP_MOD_D_C = "";
pub const BN_MP_MONTGOMERY_CALC_NORMALIZATION_C = "";
pub const BN_MP_MONTGOMERY_REDUCE_C = "";
pub const BN_MP_MONTGOMERY_SETUP_C = "";
pub const BN_MP_MUL_C = "";
pub const BN_MP_MUL_2_C = "";
pub const BN_MP_MUL_2D_C = "";
pub const BN_MP_MUL_D_C = "";
pub const BN_MP_MULMOD_C = "";
pub const BN_MP_N_ROOT_C = "";
pub const BN_MP_N_ROOT_EX_C = "";
pub const BN_MP_NEG_C = "";
pub const BN_MP_OR_C = "";
pub const BN_MP_PRIME_FERMAT_C = "";
pub const BN_MP_PRIME_IS_DIVISIBLE_C = "";
pub const BN_MP_PRIME_IS_PRIME_C = "";
pub const BN_MP_PRIME_MILLER_RABIN_C = "";
pub const BN_MP_PRIME_NEXT_PRIME_C = "";
pub const BN_MP_PRIME_RABIN_MILLER_TRIALS_C = "";
pub const BN_MP_PRIME_RANDOM_EX_C = "";
pub const BN_MP_RADIX_SIZE_C = "";
pub const BN_MP_RADIX_SMAP_C = "";
pub const BN_MP_RAND_C = "";
pub const BN_MP_READ_RADIX_C = "";
pub const BN_MP_READ_SIGNED_BIN_C = "";
pub const BN_MP_READ_UNSIGNED_BIN_C = "";
pub const BN_MP_REDUCE_C = "";
pub const BN_MP_REDUCE_2K_C = "";
pub const BN_MP_REDUCE_2K_L_C = "";
pub const BN_MP_REDUCE_2K_SETUP_C = "";
pub const BN_MP_REDUCE_2K_SETUP_L_C = "";
pub const BN_MP_REDUCE_IS_2K_C = "";
pub const BN_MP_REDUCE_IS_2K_L_C = "";
pub const BN_MP_REDUCE_SETUP_C = "";
pub const BN_MP_RSHD_C = "";
pub const BN_MP_SET_C = "";
pub const BN_MP_SET_INT_C = "";
pub const BN_MP_SET_LONG_C = "";
pub const BN_MP_SET_LONG_LONG_C = "";
pub const BN_MP_SHRINK_C = "";
pub const BN_MP_SIGNED_BIN_SIZE_C = "";
pub const BN_MP_SQR_C = "";
pub const BN_MP_SQRMOD_C = "";
pub const BN_MP_SQRT_C = "";
pub const BN_MP_SQRTMOD_PRIME_C = "";
pub const BN_MP_SUB_C = "";
pub const BN_MP_SUB_D_C = "";
pub const BN_MP_SUBMOD_C = "";
pub const BN_MP_TO_SIGNED_BIN_C = "";
pub const BN_MP_TO_SIGNED_BIN_N_C = "";
pub const BN_MP_TO_UNSIGNED_BIN_C = "";
pub const BN_MP_TO_UNSIGNED_BIN_N_C = "";
pub const BN_MP_TOOM_MUL_C = "";
pub const BN_MP_TOOM_SQR_C = "";
pub const BN_MP_TORADIX_C = "";
pub const BN_MP_TORADIX_N_C = "";
pub const BN_MP_UNSIGNED_BIN_SIZE_C = "";
pub const BN_MP_XOR_C = "";
pub const BN_MP_ZERO_C = "";
pub const BN_PRIME_TAB_C = "";
pub const BN_REVERSE_C = "";
pub const BN_S_MP_ADD_C = "";
pub const BN_S_MP_EXPTMOD_C = "";
pub const BN_S_MP_MUL_DIGS_C = "";
pub const BN_S_MP_MUL_HIGH_DIGS_C = "";
pub const BN_S_MP_SQR_C = "";
pub const BN_S_MP_SUB_C = "";
pub const BNCORE_C = "";
pub const BN_MP_ERROR_TO_STRING_C = "";
pub const BN_MP_ISEVEN_C = "";
pub const BN_MP_ISODD_C = "";
pub const BN_MP_ISZERO_C = "";
pub const BN_MP_S_RMAP_C = "";
pub const BN_MP_ERR_C = "";
pub const BN_S_MP_MUL_C = "";
pub const MP_64BIT = "";
pub const DIGIT_BIT = @as(c_int, 60);
pub inline fn MP_GEN_RANDOM() @TypeOf(rand()) {
    return rand();
}
pub const MP_DIGIT_BIT = DIGIT_BIT;
pub const MP_MASK = (@import("std").zig.c_translation.cast(mp_digit, @as(c_int, 1)) << @import("std").zig.c_translation.cast(mp_digit, DIGIT_BIT)) - @import("std").zig.c_translation.cast(mp_digit, @as(c_int, 1));
pub const MP_DIGIT_MAX = MP_MASK;
pub const MP_LT = -@as(c_int, 1);
pub const MP_EQ = @as(c_int, 0);
pub const MP_GT = @as(c_int, 1);
pub const MP_ZPOS = @as(c_int, 0);
pub const MP_NEG = @as(c_int, 1);
pub const MP_OKAY = @as(c_int, 0);
pub const MP_MEM = -@as(c_int, 2);
pub const MP_VAL = -@as(c_int, 3);
pub const MP_RANGE = MP_VAL;
pub const MP_YES = @as(c_int, 1);
pub const MP_NO = @as(c_int, 0);
pub const LTM_PRIME_BBS = @as(c_int, 0x0001);
pub const LTM_PRIME_SAFE = @as(c_int, 0x0002);
pub const LTM_PRIME_2MSB_ON = @as(c_int, 0x0008);
pub const MP_PREC = @as(c_int, 32);
pub const MP_WARRAY = @as(c_int, 1) << (((@import("std").zig.c_translation.sizeof(mp_word) * CHAR_BIT) - (@as(c_int, 2) * DIGIT_BIT)) + @as(c_int, 1));
pub inline fn USED(m: anytype) @TypeOf(m.*.used) {
    _ = &m;
    return m.*.used;
}
pub inline fn DIGIT(m: anytype, k: anytype) @TypeOf(m.*.dp[@as(usize, @intCast(k))]) {
    _ = &m;
    _ = &k;
    return m.*.dp[@as(usize, @intCast(k))];
}
pub inline fn SIGN(m: anytype) @TypeOf(m.*.sign) {
    _ = &m;
    return m.*.sign;
}
pub inline fn mp_iszero(a: anytype) @TypeOf(if (a.*.used == @as(c_int, 0)) MP_YES else MP_NO) {
    _ = &a;
    return if (a.*.used == @as(c_int, 0)) MP_YES else MP_NO;
}
pub inline fn mp_iseven(a: anytype) @TypeOf(if ((a.*.used > @as(c_int, 0)) and ((a.*.dp[@as(usize, @intCast(@as(c_int, 0)))] & @as(c_uint, 1)) == @as(c_uint, 0))) MP_YES else MP_NO) {
    _ = &a;
    return if ((a.*.used > @as(c_int, 0)) and ((a.*.dp[@as(usize, @intCast(@as(c_int, 0)))] & @as(c_uint, 1)) == @as(c_uint, 0))) MP_YES else MP_NO;
}
pub inline fn mp_isodd(a: anytype) @TypeOf(if ((a.*.used > @as(c_int, 0)) and ((a.*.dp[@as(usize, @intCast(@as(c_int, 0)))] & @as(c_uint, 1)) == @as(c_uint, 1))) MP_YES else MP_NO) {
    _ = &a;
    return if ((a.*.used > @as(c_int, 0)) and ((a.*.dp[@as(usize, @intCast(@as(c_int, 0)))] & @as(c_uint, 1)) == @as(c_uint, 1))) MP_YES else MP_NO;
}
pub inline fn mp_isneg(a: anytype) @TypeOf(if (a.*.sign != MP_ZPOS) MP_YES else MP_NO) {
    _ = &a;
    return if (a.*.sign != MP_ZPOS) MP_YES else MP_NO;
}
pub const PRIME_SIZE = @as(c_int, 256);
pub inline fn mp_prime_random(a: anytype, t: anytype, size: anytype, bbs: anytype, cb: anytype, dat: anytype) @TypeOf(mp_prime_random_ex(a, t, (size * @as(c_int, 8)) + @as(c_int, 1), if (bbs == @as(c_int, 1)) LTM_PRIME_BBS else @as(c_int, 0), cb, dat)) {
    _ = &a;
    _ = &t;
    _ = &size;
    _ = &bbs;
    _ = &cb;
    _ = &dat;
    return mp_prime_random_ex(a, t, (size * @as(c_int, 8)) + @as(c_int, 1), if (bbs == @as(c_int, 1)) LTM_PRIME_BBS else @as(c_int, 0), cb, dat);
}
pub inline fn mp_read_raw(mp: anytype, str: anytype, len: anytype) @TypeOf(mp_read_signed_bin(mp, str, len)) {
    _ = &mp;
    _ = &str;
    _ = &len;
    return mp_read_signed_bin(mp, str, len);
}
pub inline fn mp_raw_size(mp: anytype) @TypeOf(mp_signed_bin_size(mp)) {
    _ = &mp;
    return mp_signed_bin_size(mp);
}
pub inline fn mp_toraw(mp: anytype, str: anytype) @TypeOf(mp_to_signed_bin(mp, str)) {
    _ = &mp;
    _ = &str;
    return mp_to_signed_bin(mp, str);
}
pub inline fn mp_read_mag(mp: anytype, str: anytype, len: anytype) @TypeOf(mp_read_unsigned_bin(mp, str, len)) {
    _ = &mp;
    _ = &str;
    _ = &len;
    return mp_read_unsigned_bin(mp, str, len);
}
pub inline fn mp_mag_size(mp: anytype) @TypeOf(mp_unsigned_bin_size(mp)) {
    _ = &mp;
    return mp_unsigned_bin_size(mp);
}
pub inline fn mp_tomag(mp: anytype, str: anytype) @TypeOf(mp_to_unsigned_bin(mp, str)) {
    _ = &mp;
    _ = &str;
    return mp_to_unsigned_bin(mp, str);
}
pub inline fn mp_tobinary(M_1: anytype, S_2: anytype) @TypeOf(mp_toradix(M_1, S_2, @as(c_int, 2))) {
    _ = &M_1;
    _ = &S_2;
    return mp_toradix(M_1, S_2, @as(c_int, 2));
}
pub inline fn mp_tooctal(M_1: anytype, S_2: anytype) @TypeOf(mp_toradix(M_1, S_2, @as(c_int, 8))) {
    _ = &M_1;
    _ = &S_2;
    return mp_toradix(M_1, S_2, @as(c_int, 8));
}
pub inline fn mp_todecimal(M_1: anytype, S_2: anytype) @TypeOf(mp_toradix(M_1, S_2, @as(c_int, 10))) {
    _ = &M_1;
    _ = &S_2;
    return mp_toradix(M_1, S_2, @as(c_int, 10));
}
pub inline fn mp_tohex(M_1: anytype, S_2: anytype) @TypeOf(mp_toradix(M_1, S_2, @as(c_int, 16))) {
    _ = &M_1;
    _ = &S_2;
    return mp_toradix(M_1, S_2, @as(c_int, 16));
}
pub const TOMMATH_PRIV_H_ = "";
pub const _CTYPE_H = @as(c_int, 1);
pub inline fn _ISbit(bit: anytype) @TypeOf(if (bit < @as(c_int, 8)) (@as(c_int, 1) << bit) << @as(c_int, 8) else (@as(c_int, 1) << bit) >> @as(c_int, 8)) {
    _ = &bit;
    return if (bit < @as(c_int, 8)) (@as(c_int, 1) << bit) << @as(c_int, 8) else (@as(c_int, 1) << bit) >> @as(c_int, 8);
}
pub inline fn __isctype(c: anytype, @"type": anytype) @TypeOf(__ctype_b_loc().*[@as(usize, @intCast(@import("std").zig.c_translation.cast(c_int, c)))] & @import("std").zig.c_translation.cast(c_ushort, @"type")) {
    _ = &c;
    _ = &@"type";
    return __ctype_b_loc().*[@as(usize, @intCast(@import("std").zig.c_translation.cast(c_int, c)))] & @import("std").zig.c_translation.cast(c_ushort, @"type");
}
pub inline fn __isascii(c: anytype) @TypeOf((c & ~@as(c_int, 0x7f)) == @as(c_int, 0)) {
    _ = &c;
    return (c & ~@as(c_int, 0x7f)) == @as(c_int, 0);
}
pub inline fn __toascii(c: anytype) @TypeOf(c & @as(c_int, 0x7f)) {
    _ = &c;
    return c & @as(c_int, 0x7f);
}
pub const __exctype = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/ctype.h:102:9
pub const __tobody = @compileError("unable to translate macro: undefined identifier `__res`");
// /usr/include/ctype.h:155:9
pub inline fn __isctype_l(c: anytype, @"type": anytype, locale: anytype) @TypeOf(locale.*.__ctype_b[@as(usize, @intCast(@import("std").zig.c_translation.cast(c_int, c)))] & @import("std").zig.c_translation.cast(c_ushort, @"type")) {
    _ = &c;
    _ = &@"type";
    _ = &locale;
    return locale.*.__ctype_b[@as(usize, @intCast(@import("std").zig.c_translation.cast(c_int, c)))] & @import("std").zig.c_translation.cast(c_ushort, @"type");
}
pub const __exctype_l = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/ctype.h:244:10
pub inline fn __isalnum_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISalnum, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISalnum, l);
}
pub inline fn __isalpha_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISalpha, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISalpha, l);
}
pub inline fn __iscntrl_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _IScntrl, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _IScntrl, l);
}
pub inline fn __isdigit_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISdigit, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISdigit, l);
}
pub inline fn __islower_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISlower, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISlower, l);
}
pub inline fn __isgraph_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISgraph, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISgraph, l);
}
pub inline fn __isprint_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISprint, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISprint, l);
}
pub inline fn __ispunct_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISpunct, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISpunct, l);
}
pub inline fn __isspace_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISspace, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISspace, l);
}
pub inline fn __isupper_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISupper, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISupper, l);
}
pub inline fn __isxdigit_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISxdigit, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISxdigit, l);
}
pub inline fn __isblank_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISblank, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISblank, l);
}
pub inline fn __isascii_l(c: anytype, l: anytype) @TypeOf(__isascii(c)) {
    _ = &c;
    _ = &l;
    return blk_1: {
        _ = &l;
        break :blk_1 __isascii(c);
    };
}
pub inline fn __toascii_l(c: anytype, l: anytype) @TypeOf(__toascii(c)) {
    _ = &c;
    _ = &l;
    return blk_1: {
        _ = &l;
        break :blk_1 __toascii(c);
    };
}
pub inline fn isascii_l(c: anytype, l: anytype) @TypeOf(__isascii_l(c, l)) {
    _ = &c;
    _ = &l;
    return __isascii_l(c, l);
}
pub inline fn toascii_l(c: anytype, l: anytype) @TypeOf(__toascii_l(c, l)) {
    _ = &c;
    _ = &l;
    return __toascii_l(c, l);
}
pub inline fn MIN(x: anytype, y: anytype) @TypeOf(if (x < y) x else y) {
    _ = &x;
    _ = &y;
    return if (x < y) x else y;
}
pub inline fn MAX(x: anytype, y: anytype) @TypeOf(if (x > y) x else y) {
    _ = &x;
    _ = &y;
    return if (x > y) x else y;
}
pub const OPT_CAST = @compileError("unable to translate C expr: unexpected token ''");
// ./libtomcrypt.c:2795:11
pub const XMALLOC = malloc;
pub const XFREE = free;
pub const XREALLOC = realloc;
pub const XCALLOC = calloc;
pub inline fn s_mp_mul(a: anytype, b: anytype, c: anytype) @TypeOf(s_mp_mul_digs(a, b, c, (a.*.used + b.*.used) + @as(c_int, 1))) {
    _ = &a;
    _ = &b;
    _ = &c;
    return s_mp_mul_digs(a, b, c, (a.*.used + b.*.used) + @as(c_int, 1));
}
pub const MP_SET_XLONG = @compileError("unable to translate macro: undefined identifier `a`");
// ./libtomcrypt.c:2843:9
pub const __need_va_list = "";
pub const __need_va_arg = "";
pub const __need___va_copy = "";
pub const __need_va_copy = "";
pub const __STDARG_H = "";
pub const _VA_LIST = "";
pub const va_start = @compileError("unable to translate macro: undefined identifier `__builtin_va_start`");
// /snap/zig/13822/lib/include/__stdarg_va_arg.h:17:9
pub const va_end = @compileError("unable to translate macro: undefined identifier `__builtin_va_end`");
// /snap/zig/13822/lib/include/__stdarg_va_arg.h:19:9
pub const va_arg = @compileError("unable to translate C expr: unexpected token 'an identifier'");
// /snap/zig/13822/lib/include/__stdarg_va_arg.h:20:9
pub const __va_copy = @compileError("unable to translate macro: undefined identifier `__builtin_va_copy`");
// /snap/zig/13822/lib/include/__stdarg___va_copy.h:11:9
pub const va_copy = @compileError("unable to translate macro: undefined identifier `__builtin_va_copy`");
// /snap/zig/13822/lib/include/__stdarg_va_copy.h:11:9
pub const TAB_SIZE = @as(c_int, 256);
pub const _SIGNAL_H = "";
pub const _BITS_SIGNUM_GENERIC_H = @as(c_int, 1);
pub const SIG_ERR = @import("std").zig.c_translation.cast(__sighandler_t, -@as(c_int, 1));
pub const SIG_DFL = @import("std").zig.c_translation.cast(__sighandler_t, @as(c_int, 0));
pub const SIG_IGN = @import("std").zig.c_translation.cast(__sighandler_t, @as(c_int, 1));
pub const SIGINT = @as(c_int, 2);
pub const SIGILL = @as(c_int, 4);
pub const SIGABRT = @as(c_int, 6);
pub const SIGFPE = @as(c_int, 8);
pub const SIGSEGV = @as(c_int, 11);
pub const SIGTERM = @as(c_int, 15);
pub const SIGHUP = @as(c_int, 1);
pub const SIGQUIT = @as(c_int, 3);
pub const SIGTRAP = @as(c_int, 5);
pub const SIGKILL = @as(c_int, 9);
pub const SIGPIPE = @as(c_int, 13);
pub const SIGALRM = @as(c_int, 14);
pub const SIGIO = SIGPOLL;
pub const SIGIOT = SIGABRT;
pub const SIGCLD = SIGCHLD;
pub const _BITS_SIGNUM_ARCH_H = @as(c_int, 1);
pub const SIGSTKFLT = @as(c_int, 16);
pub const SIGPWR = @as(c_int, 30);
pub const SIGBUS = @as(c_int, 7);
pub const SIGSYS = @as(c_int, 31);
pub const SIGURG = @as(c_int, 23);
pub const SIGSTOP = @as(c_int, 19);
pub const SIGTSTP = @as(c_int, 20);
pub const SIGCONT = @as(c_int, 18);
pub const SIGCHLD = @as(c_int, 17);
pub const SIGTTIN = @as(c_int, 21);
pub const SIGTTOU = @as(c_int, 22);
pub const SIGPOLL = @as(c_int, 29);
pub const SIGXFSZ = @as(c_int, 25);
pub const SIGXCPU = @as(c_int, 24);
pub const SIGVTALRM = @as(c_int, 26);
pub const SIGPROF = @as(c_int, 27);
pub const SIGUSR1 = @as(c_int, 10);
pub const SIGUSR2 = @as(c_int, 12);
pub const SIGWINCH = @as(c_int, 28);
pub const __SIGRTMIN = @as(c_int, 32);
pub const __SIGRTMAX = @as(c_int, 64);
pub const _NSIG = __SIGRTMAX + @as(c_int, 1);
pub const __sig_atomic_t_defined = @as(c_int, 1);
pub const __siginfo_t_defined = @as(c_int, 1);
pub const ____sigval_t_defined = "";
pub const __SI_MAX_SIZE = @as(c_int, 128);
pub const __SI_PAD_SIZE = @import("std").zig.c_translation.MacroArithmetic.div(__SI_MAX_SIZE, @import("std").zig.c_translation.sizeof(c_int)) - @as(c_int, 4);
pub const _BITS_SIGINFO_ARCH_H = @as(c_int, 1);
pub const __SI_ALIGNMENT = "";
pub const __SI_BAND_TYPE = c_long;
pub const __SI_CLOCK_T = __clock_t;
pub const __SI_ERRNO_THEN_CODE = @as(c_int, 1);
pub const __SI_HAVE_SIGSYS = @as(c_int, 1);
pub const __SI_SIGFAULT_ADDL = "";
pub const si_pid = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:128:9
pub const si_uid = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:129:9
pub const si_timerid = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:130:9
pub const si_overrun = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:131:9
pub const si_status = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:132:9
pub const si_utime = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:133:9
pub const si_stime = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:134:9
pub const si_value = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:135:9
pub const si_int = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:136:9
pub const si_ptr = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:137:9
pub const si_addr = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:138:9
pub const si_addr_lsb = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:139:9
pub const si_lower = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:140:9
pub const si_upper = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:141:9
pub const si_pkey = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:142:9
pub const si_band = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:143:9
pub const si_fd = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:144:9
pub const si_call_addr = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:146:10
pub const si_syscall = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:147:10
pub const si_arch = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h:148:10
pub const _BITS_SIGINFO_CONSTS_H = @as(c_int, 1);
pub const __SI_ASYNCIO_AFTER_SIGIO = @as(c_int, 1);
pub const __sigval_t_defined = "";
pub const __sigevent_t_defined = @as(c_int, 1);
pub const __SIGEV_MAX_SIZE = @as(c_int, 64);
pub const __SIGEV_PAD_SIZE = @import("std").zig.c_translation.MacroArithmetic.div(__SIGEV_MAX_SIZE, @import("std").zig.c_translation.sizeof(c_int)) - @as(c_int, 4);
pub const sigev_notify_function = @compileError("unable to translate macro: undefined identifier `_sigev_un`");
// /usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h:45:9
pub const sigev_notify_attributes = @compileError("unable to translate macro: undefined identifier `_sigev_un`");
// /usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h:46:9
pub const _BITS_SIGEVENT_CONSTS_H = @as(c_int, 1);
pub inline fn sigmask(sig: anytype) @TypeOf(__glibc_macro_warning("sigmask is deprecated")(@import("std").zig.c_translation.cast(c_int, @as(c_uint, 1) << (sig - @as(c_int, 1))))) {
    _ = &sig;
    return __glibc_macro_warning("sigmask is deprecated")(@import("std").zig.c_translation.cast(c_int, @as(c_uint, 1) << (sig - @as(c_int, 1))));
}
pub const NSIG = _NSIG;
pub const _BITS_SIGACTION_H = @as(c_int, 1);
pub const sa_handler = @compileError("unable to translate macro: undefined identifier `__sigaction_handler`");
// /usr/include/x86_64-linux-gnu/bits/sigaction.h:39:10
pub const sa_sigaction = @compileError("unable to translate macro: undefined identifier `__sigaction_handler`");
// /usr/include/x86_64-linux-gnu/bits/sigaction.h:40:10
pub const SA_NOCLDSTOP = @as(c_int, 1);
pub const SA_NOCLDWAIT = @as(c_int, 2);
pub const SA_SIGINFO = @as(c_int, 4);
pub const SA_ONSTACK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x08000000, .hex);
pub const SA_RESTART = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000000, .hex);
pub const SA_NODEFER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000000, .hex);
pub const SA_RESETHAND = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex);
pub const SA_INTERRUPT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000000, .hex);
pub const SA_NOMASK = SA_NODEFER;
pub const SA_ONESHOT = SA_RESETHAND;
pub const SA_STACK = SA_ONSTACK;
pub const SIG_BLOCK = @as(c_int, 0);
pub const SIG_UNBLOCK = @as(c_int, 1);
pub const SIG_SETMASK = @as(c_int, 2);
pub const _BITS_SIGCONTEXT_H = @as(c_int, 1);
pub const FP_XSTATE_MAGIC1 = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x46505853, .hex);
pub const FP_XSTATE_MAGIC2 = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x46505845, .hex);
pub const FP_XSTATE_MAGIC2_SIZE = @import("std").zig.c_translation.sizeof(FP_XSTATE_MAGIC2);
pub const __stack_t_defined = @as(c_int, 1);
pub const _SYS_UCONTEXT_H = @as(c_int, 1);
pub inline fn __ctx(fld: anytype) @TypeOf(fld) {
    _ = &fld;
    return fld;
}
pub const __NGREG = @as(c_int, 23);
pub const NGREG = __NGREG;
pub const _BITS_SIGSTACK_H = @as(c_int, 1);
pub const MINSIGSTKSZ = @as(c_int, 2048);
pub const SIGSTKSZ = @as(c_int, 8192);
pub const _BITS_SS_FLAGS_H = @as(c_int, 1);
pub const __sigstack_defined = @as(c_int, 1);
pub const _BITS_SIGTHREAD_H = @as(c_int, 1);
pub const SIGRTMIN = __libc_current_sigrtmin();
pub const SIGRTMAX = __libc_current_sigrtmax();
pub const TOMCRYPT_H_ = "";
pub const USE_LTM = "";
pub const LTM_DESC = "";
pub const LTC_SHA1 = "";
pub const _ASSERT_H = @as(c_int, 1);
pub const __ASSERT_VOID_CAST = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/assert.h:40:10
pub const _ASSERT_H_DECLS = "";
pub const assert = @compileError("unable to translate macro: undefined identifier `__FILE__`");
// /usr/include/assert.h:118:11
pub const __ASSERT_FUNCTION = @compileError("unable to translate C expr: unexpected token '__extension__'");
// /usr/include/assert.h:140:12
pub const static_assert = @compileError("unable to translate C expr: unexpected token '_Static_assert'");
// /usr/include/assert.h:158:10
pub const TOMCRYPT_CUSTOM_H_ = "";
pub const XMEMSET = memset;
pub const XMEMCPY = memcpy;
pub const XMEMMOVE = memmove;
pub const XMEMCMP = memcmp;
pub const XSTRCMP = strcmp;
pub const XCLOCK = clock;
pub const XCLOCKS_PER_SEC = CLOCKS_PER_SEC;
pub const XQSORT = qsort;
pub const LTC_TEST = "";
pub const LTC_BLOWFISH = "";
pub const LTC_RC2 = "";
pub const LTC_RC5 = "";
pub const LTC_RC6 = "";
pub const LTC_SAFERP = "";
pub const LTC_RIJNDAEL = "";
pub const LTC_XTEA = "";
pub const LTC_TWOFISH = "";
pub const LTC_TWOFISH_TABLES = "";
pub const LTC_DES = "";
pub const LTC_CAST5 = "";
pub const LTC_NOEKEON = "";
pub const LTC_SKIPJACK = "";
pub const LTC_SAFER = "";
pub const LTC_KHAZAD = "";
pub const LTC_ANUBIS = "";
pub const LTC_ANUBIS_TWEAK = "";
pub const LTC_KSEED = "";
pub const LTC_KASUMI = "";
pub const LTC_CFB_MODE = "";
pub const LTC_OFB_MODE = "";
pub const LTC_ECB_MODE = "";
pub const LTC_CBC_MODE = "";
pub const LTC_CTR_MODE = "";
pub const LTC_F8_MODE = "";
pub const LTC_LRW_MODE = "";
pub const LRW_TABLES = "";
pub const LTC_XTS_MODE = "";
pub const LTC_CHC_HASH = "";
pub const LTC_WHIRLPOOL = "";
pub const LTC_SHA512 = "";
pub const LTC_SHA384 = "";
pub const LTC_SHA256 = "";
pub const LTC_SHA224 = "";
pub const LTC_TIGER = "";
pub const LTC_MD5 = "";
pub const LTC_MD4 = "";
pub const LTC_MD2 = "";
pub const LTC_RIPEMD128 = "";
pub const LTC_RIPEMD160 = "";
pub const LTC_RIPEMD256 = "";
pub const LTC_RIPEMD320 = "";
pub const LTC_HMAC = "";
pub const LTC_OMAC = "";
pub const LTC_PMAC = "";
pub const LTC_XCBC = "";
pub const LTC_F9_MODE = "";
pub const LTC_PELICAN = "";
pub const LTC_EAX_MODE = "";
pub const LTC_OCB_MODE = "";
pub const LTC_CCM_MODE = "";
pub const LTC_GCM_MODE = "";
pub const LTC_GCM_TABLES = "";
pub const LTC_BASE64 = "";
pub const LTC_YARROW = "";
pub const LTC_YARROW_AES = @as(c_int, 0);
pub const LTC_SPRNG = "";
pub const LTC_RC4 = "";
pub const LTC_FORTUNA = "";
pub const LTC_FORTUNA_WD = @as(c_int, 10);
pub const LTC_FORTUNA_POOLS = @as(c_int, 32);
pub const LTC_SOBER128 = "";
pub const LTC_DEVRANDOM = "";
pub const TRY_URANDOM_FIRST = "";
pub const LTC_MRSA = "";
pub const LTC_MDSA = "";
pub const LTC_CURVE25519 = "";
pub const LTC_MECC = "";
pub const LTC_ECC_SHAMIR = "";
pub const LTC_PKCS_1 = "";
pub const LTC_PKCS_5 = "";
pub const LTC_DER = "";
pub const ECC112 = "";
pub const ECC128 = "";
pub const ECC160 = "";
pub const ECC192 = "";
pub const ECC224 = "";
pub const ECC256 = "";
pub const ECC384 = "";
pub const ECC521 = "";
pub const MPI = "";
pub const LTC_MUTEX_GLOBAL = @compileError("unable to translate C expr: unexpected token ''");
// ./libtomcrypt.c:13362:10
pub const LTC_MUTEX_PROTO = @compileError("unable to translate C expr: unexpected token ''");
// ./libtomcrypt.c:13363:10
pub const LTC_MUTEX_TYPE = @compileError("unable to translate C expr: unexpected token ''");
// ./libtomcrypt.c:13364:10
pub const LTC_MUTEX_INIT = @compileError("unable to translate C expr: unexpected token ''");
// ./libtomcrypt.c:13365:10
pub const LTC_MUTEX_LOCK = @compileError("unable to translate C expr: unexpected token ''");
// ./libtomcrypt.c:13366:10
pub const LTC_MUTEX_UNLOCK = @compileError("unable to translate C expr: unexpected token ''");
// ./libtomcrypt.c:13367:10
pub const SCRYPT = "1.17";
pub const MAXBLOCKSIZE = @as(c_int, 128);
pub const TOMCRYPT_CFG_H = "";
pub const LTC_CALL = "";
pub const LTC_EXPORT = "";
pub const LTC_INLINE = @compileError("unable to translate C expr: unexpected token '__inline__'");
// ./libtomcrypt.c:13487:12
pub const ARGTYPE = @as(c_int, 0);
pub const ENDIAN_LITTLE = "";
pub const ENDIAN_64BITWORD = "";
pub const LTC_FAST = "";
pub const LTC_FAST_TYPE = c_ulong;
pub const CONST64 = @import("std").zig.c_translation.Macros.ULL_SUFFIX;
pub const STORE32H = @compileError("unable to translate C expr: unexpected token 'asm'");
// ./libtomcrypt.c:13659:11
pub const LOAD32H = @compileError("unable to translate C expr: unexpected token 'asm'");
// ./libtomcrypt.c:13666:11
pub const STORE64H = @compileError("unable to translate C expr: unexpected token 'asm'");
// ./libtomcrypt.c:13689:11
pub const LOAD64H = @compileError("unable to translate C expr: unexpected token 'asm'");
// ./libtomcrypt.c:13696:11
pub const STORE32L = @compileError("unable to translate macro: undefined identifier `__t`");
// ./libtomcrypt.c:13739:11
pub const LOAD32L = @compileError("unable to translate C expr: unexpected token '{'");
// ./libtomcrypt.c:13742:11
pub const STORE64L = @compileError("unable to translate macro: undefined identifier `__t`");
// ./libtomcrypt.c:13745:11
pub const LOAD64L = @compileError("unable to translate C expr: unexpected token '{'");
// ./libtomcrypt.c:13748:11
pub inline fn BSWAP(x: anytype) @TypeOf(((((x >> @as(c_int, 24)) & @as(c_ulong, 0x000000FF)) | ((x << @as(c_int, 24)) & @as(c_ulong, 0xFF000000))) | ((x >> @as(c_int, 8)) & @as(c_ulong, 0x0000FF00))) | ((x << @as(c_int, 8)) & @as(c_ulong, 0x00FF0000))) {
    _ = &x;
    return ((((x >> @as(c_int, 24)) & @as(c_ulong, 0x000000FF)) | ((x << @as(c_int, 24)) & @as(c_ulong, 0xFF000000))) | ((x >> @as(c_int, 8)) & @as(c_ulong, 0x0000FF00))) | ((x << @as(c_int, 8)) & @as(c_ulong, 0x00FF0000));
}
pub const ROLc = ROL;
pub const RORc = ROR;
pub const ROL64c = ROL64;
pub const ROR64c = ROR64;
pub inline fn byte(x: anytype, n: anytype) @TypeOf((x >> (@as(c_int, 8) * n)) & @as(c_int, 255)) {
    _ = &x;
    _ = &n;
    return (x >> (@as(c_int, 8) * n)) & @as(c_int, 255);
}
pub const LTC_SAFER_K64_DEFAULT_NOF_ROUNDS = @as(c_int, 6);
pub const LTC_SAFER_K128_DEFAULT_NOF_ROUNDS = @as(c_int, 10);
pub const LTC_SAFER_SK64_DEFAULT_NOF_ROUNDS = @as(c_int, 8);
pub const LTC_SAFER_SK128_DEFAULT_NOF_ROUNDS = @as(c_int, 10);
pub const LTC_SAFER_MAX_NOF_ROUNDS = @as(c_int, 13);
pub const LTC_SAFER_BLOCK_LEN = @as(c_int, 8);
pub const LTC_SAFER_KEY_LEN = @as(c_int, 1) + (LTC_SAFER_BLOCK_LEN * (@as(c_int, 1) + (@as(c_int, 2) * LTC_SAFER_MAX_NOF_ROUNDS)));
pub const aes_setup = rijndael_setup;
pub const aes_ecb_encrypt = rijndael_ecb_encrypt;
pub const aes_ecb_decrypt = rijndael_ecb_decrypt;
pub const aes_test = rijndael_test;
pub const aes_done = rijndael_done;
pub const aes_keysize = rijndael_keysize;
pub const aes_enc_setup = rijndael_enc_setup;
pub const aes_enc_ecb_encrypt = rijndael_enc_ecb_encrypt;
pub const aes_enc_keysize = rijndael_enc_keysize;
pub const CTR_COUNTER_LITTLE_ENDIAN = @as(c_int, 0x0000);
pub const CTR_COUNTER_BIG_ENDIAN = @as(c_int, 0x1000);
pub const LTC_CTR_RFC3686 = @as(c_int, 0x2000);
pub const LRW_ENCRYPT = @as(c_int, 0);
pub const LRW_DECRYPT = @as(c_int, 1);
pub const sha384_process = sha512_process;
pub const sha224_process = sha256_process;
pub const HASH_PROCESS = @compileError("unable to translate macro: undefined identifier `md`");
// ./libtomcrypt.c:15271:9
pub const CCM_ENCRYPT = @as(c_int, 0);
pub const CCM_DECRYPT = @as(c_int, 1);
pub const GCM_ENCRYPT = @as(c_int, 0);
pub const GCM_DECRYPT = @as(c_int, 1);
pub const LTC_GCM_MODE_IV = @as(c_int, 0);
pub const LTC_GCM_MODE_AAD = @as(c_int, 1);
pub const LTC_GCM_MODE_TEXT = @as(c_int, 2);
pub const LTC_XCBC_PURE = @as(c_ulong, 0x8000);
pub const MIN_RSA_SIZE = @as(c_int, 1024);
pub const MAX_RSA_SIZE = @as(c_int, 4096);
pub inline fn rsa_encrypt_key(_in: anytype, _inlen: anytype, _out: anytype, _outlen: anytype, _lparam: anytype, _lparamlen: anytype, _prng: anytype, _prng_idx: anytype, _hash_idx: anytype, _key: anytype) @TypeOf(rsa_encrypt_key_ex(_in, _inlen, _out, _outlen, _lparam, _lparamlen, _prng, _prng_idx, _hash_idx, LTC_LTC_PKCS_1_OAEP, _key)) {
    _ = &_in;
    _ = &_inlen;
    _ = &_out;
    _ = &_outlen;
    _ = &_lparam;
    _ = &_lparamlen;
    _ = &_prng;
    _ = &_prng_idx;
    _ = &_hash_idx;
    _ = &_key;
    return rsa_encrypt_key_ex(_in, _inlen, _out, _outlen, _lparam, _lparamlen, _prng, _prng_idx, _hash_idx, LTC_LTC_PKCS_1_OAEP, _key);
}
pub inline fn rsa_decrypt_key(_in: anytype, _inlen: anytype, _out: anytype, _outlen: anytype, _lparam: anytype, _lparamlen: anytype, _hash_idx: anytype, _stat: anytype, _key: anytype) @TypeOf(rsa_decrypt_key_ex(_in, _inlen, _out, _outlen, _lparam, _lparamlen, _hash_idx, LTC_LTC_PKCS_1_OAEP, _stat, _key)) {
    _ = &_in;
    _ = &_inlen;
    _ = &_out;
    _ = &_outlen;
    _ = &_lparam;
    _ = &_lparamlen;
    _ = &_hash_idx;
    _ = &_stat;
    _ = &_key;
    return rsa_decrypt_key_ex(_in, _inlen, _out, _outlen, _lparam, _lparamlen, _hash_idx, LTC_LTC_PKCS_1_OAEP, _stat, _key);
}
pub inline fn rsa_sign_hash(_in: anytype, _inlen: anytype, _out: anytype, _outlen: anytype, _prng: anytype, _prng_idx: anytype, _hash_idx: anytype, _saltlen: anytype, _key: anytype) @TypeOf(rsa_sign_hash_ex(_in, _inlen, _out, _outlen, LTC_LTC_PKCS_1_PSS, _prng, _prng_idx, _hash_idx, _saltlen, _key)) {
    _ = &_in;
    _ = &_inlen;
    _ = &_out;
    _ = &_outlen;
    _ = &_prng;
    _ = &_prng_idx;
    _ = &_hash_idx;
    _ = &_saltlen;
    _ = &_key;
    return rsa_sign_hash_ex(_in, _inlen, _out, _outlen, LTC_LTC_PKCS_1_PSS, _prng, _prng_idx, _hash_idx, _saltlen, _key);
}
pub inline fn rsa_verify_hash(_sig: anytype, _siglen: anytype, _hash: anytype, _hashlen: anytype, _hash_idx: anytype, _saltlen: anytype, _stat: anytype, _key: anytype) @TypeOf(rsa_verify_hash_ex(_sig, _siglen, _hash, _hashlen, LTC_LTC_PKCS_1_PSS, _hash_idx, _saltlen, _stat, _key)) {
    _ = &_sig;
    _ = &_siglen;
    _ = &_hash;
    _ = &_hashlen;
    _ = &_hash_idx;
    _ = &_saltlen;
    _ = &_stat;
    _ = &_key;
    return rsa_verify_hash_ex(_sig, _siglen, _hash, _hashlen, LTC_LTC_PKCS_1_PSS, _hash_idx, _saltlen, _stat, _key);
}
pub const ECC_BUF_SIZE = @as(c_int, 256);
pub const ECC_MAXSIZE = @as(c_int, 66);
pub const LTC_MDSA_DELTA = @as(c_int, 512);
pub const LTC_MDSA_MAX_GROUP = @as(c_int, 512);
pub const LTC_SET_ASN1 = @compileError("unable to translate macro: undefined identifier `LTC_MACRO_temp`");
// ./libtomcrypt.c:16340:10
pub inline fn der_encode_sequence(list: anytype, inlen: anytype, out: anytype, outlen: anytype) @TypeOf(der_encode_sequence_ex(list, inlen, out, outlen, LTC_ASN1_SEQUENCE)) {
    _ = &list;
    _ = &inlen;
    _ = &out;
    _ = &outlen;
    return der_encode_sequence_ex(list, inlen, out, outlen, LTC_ASN1_SEQUENCE);
}
pub inline fn der_decode_sequence(in: anytype, inlen: anytype, list: anytype, outlen: anytype) @TypeOf(der_decode_sequence_ex(in, inlen, list, outlen, @as(c_int, 1))) {
    _ = &in;
    _ = &inlen;
    _ = &list;
    _ = &outlen;
    return der_decode_sequence_ex(in, inlen, list, outlen, @as(c_int, 1));
}
pub inline fn der_decode_set(in: anytype, inlen: anytype, list: anytype, outlen: anytype) @TypeOf(der_decode_sequence_ex(in, inlen, list, outlen, @as(c_int, 0))) {
    _ = &in;
    _ = &inlen;
    _ = &list;
    _ = &outlen;
    return der_decode_sequence_ex(in, inlen, list, outlen, @as(c_int, 0));
}
pub const der_length_set = der_length_sequence;
pub const _WCHAR_H = @as(c_int, 1);
pub const __wint_t_defined = @as(c_int, 1);
pub const _WINT_T = @as(c_int, 1);
pub const __mbstate_t_defined = @as(c_int, 1);
pub const WEOF = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xffffffff, .hex);
pub const LTC_SOURCE = "";
pub const LTC_MP_LT = -@as(c_int, 1);
pub const LTC_MP_EQ = @as(c_int, 0);
pub const LTC_MP_GT = @as(c_int, 1);
pub const LTC_MP_NO = @as(c_int, 0);
pub const LTC_MP_YES = @as(c_int, 1);
pub inline fn mp_get_digit(a: anytype, n: anytype) @TypeOf(ltc_mp.get_digit(a, n)) {
    _ = &a;
    _ = &n;
    return ltc_mp.get_digit(a, n);
}
pub inline fn mp_get_digit_count(a: anytype) @TypeOf(ltc_mp.get_digit_count(a)) {
    _ = &a;
    return ltc_mp.get_digit_count(a);
}
pub inline fn mp_montgomery_normalization(a: anytype, b: anytype) @TypeOf(ltc_mp.montgomery_normalization(a, b)) {
    _ = &a;
    _ = &b;
    return ltc_mp.montgomery_normalization(a, b);
}
pub inline fn mp_montgomery_free(a: anytype) @TypeOf(ltc_mp.montgomery_deinit(a)) {
    _ = &a;
    return ltc_mp.montgomery_deinit(a);
}
pub const LTC_ARGCHK = @compileError("unable to translate macro: undefined identifier `__FILE__`");
// ./libtomcrypt.c:17024:10
pub inline fn LTC_ARGCHKVD(x: anytype) @TypeOf(LTC_ARGCHK(x)) {
    _ = &x;
    return LTC_ARGCHK(x);
}
pub const DECODE_V = @compileError("unable to translate macro: undefined identifier `buf`");
// ./libtomcrypt.c:19864:10
pub const STORE_V = @compileError("unable to translate macro: undefined identifier `out`");
// ./libtomcrypt.c:21585:10
pub const DESC_DEF_ONLY = "";
pub const WINSIZE = @as(c_int, 4);
pub const USE_BBS = @as(c_int, 1);
pub const ANSI_RNG = "";
pub inline fn F0(x: anytype, y: anytype, z: anytype) @TypeOf(z ^ (x & (y ^ z))) {
    _ = &x;
    _ = &y;
    _ = &z;
    return z ^ (x & (y ^ z));
}
pub inline fn F1(x: anytype, y: anytype, z: anytype) @TypeOf((x ^ y) ^ z) {
    _ = &x;
    _ = &y;
    _ = &z;
    return (x ^ y) ^ z;
}
pub inline fn F2(x: anytype, y: anytype, z: anytype) @TypeOf((x & y) | (z & (x | y))) {
    _ = &x;
    _ = &y;
    _ = &z;
    return (x & y) | (z & (x | y));
}
pub inline fn F3(x: anytype, y: anytype, z: anytype) @TypeOf((x ^ y) ^ z) {
    _ = &x;
    _ = &y;
    _ = &z;
    return (x ^ y) ^ z;
}
pub const FF0 = @compileError("unable to translate macro: undefined identifier `W`");
// ./libtomcrypt.c:29677:10
pub const FF1 = @compileError("unable to translate macro: undefined identifier `W`");
// ./libtomcrypt.c:29678:10
pub const FF2 = @compileError("unable to translate macro: undefined identifier `W`");
// ./libtomcrypt.c:29679:10
pub const FF3 = @compileError("unable to translate macro: undefined identifier `W`");
// ./libtomcrypt.c:29680:10
pub inline fn Ch(x: anytype, y: anytype, z: anytype) @TypeOf(z ^ (x & (y ^ z))) {
    _ = &x;
    _ = &y;
    _ = &z;
    return z ^ (x & (y ^ z));
}
pub inline fn Maj(x: anytype, y: anytype, z: anytype) @TypeOf(((x | y) & z) | (x & y)) {
    _ = &x;
    _ = &y;
    _ = &z;
    return ((x | y) & z) | (x & y);
}
pub inline fn R(x: anytype, n: anytype) @TypeOf((x & @as(c_ulong, 0xFFFFFFFF)) >> n) {
    _ = &x;
    _ = &n;
    return (x & @as(c_ulong, 0xFFFFFFFF)) >> n;
}
pub inline fn Sigma0(x: anytype) @TypeOf((S(x, @as(c_int, 2)) ^ S(x, @as(c_int, 13))) ^ S(x, @as(c_int, 22))) {
    _ = &x;
    return (S(x, @as(c_int, 2)) ^ S(x, @as(c_int, 13))) ^ S(x, @as(c_int, 22));
}
pub inline fn Sigma1(x: anytype) @TypeOf((S(x, @as(c_int, 6)) ^ S(x, @as(c_int, 11))) ^ S(x, @as(c_int, 25))) {
    _ = &x;
    return (S(x, @as(c_int, 6)) ^ S(x, @as(c_int, 11))) ^ S(x, @as(c_int, 25));
}
pub inline fn Gamma0(x: anytype) @TypeOf((S(x, @as(c_int, 7)) ^ S(x, @as(c_int, 18))) ^ R(x, @as(c_int, 3))) {
    _ = &x;
    return (S(x, @as(c_int, 7)) ^ S(x, @as(c_int, 18))) ^ R(x, @as(c_int, 3));
}
pub inline fn Gamma1(x: anytype) @TypeOf((S(x, @as(c_int, 17)) ^ S(x, @as(c_int, 19))) ^ R(x, @as(c_int, 10))) {
    _ = &x;
    return (S(x, @as(c_int, 17)) ^ S(x, @as(c_int, 19))) ^ R(x, @as(c_int, 10));
}
pub const RND = @compileError("unable to translate macro: undefined identifier `t0`");
// ./libtomcrypt.c:30127:9
pub const LTC_HMAC_BLOCKSIZE = @compileError("unable to translate macro: undefined identifier `hash`");
// ./libtomcrypt.c:30838:9
pub const __LTC_AES_TAB_C__ = "";
pub inline fn Te0(x: anytype) @TypeOf(TE0[@as(usize, @intCast(x))]) {
    _ = &x;
    return TE0[@as(usize, @intCast(x))];
}
pub inline fn Te1(x: anytype) @TypeOf(TE1[@as(usize, @intCast(x))]) {
    _ = &x;
    return TE1[@as(usize, @intCast(x))];
}
pub inline fn Te2(x: anytype) @TypeOf(TE2[@as(usize, @intCast(x))]) {
    _ = &x;
    return TE2[@as(usize, @intCast(x))];
}
pub inline fn Te3(x: anytype) @TypeOf(TE3[@as(usize, @intCast(x))]) {
    _ = &x;
    return TE3[@as(usize, @intCast(x))];
}
pub inline fn Td0(x: anytype) @TypeOf(TD0[@as(usize, @intCast(x))]) {
    _ = &x;
    return TD0[@as(usize, @intCast(x))];
}
pub inline fn Td1(x: anytype) @TypeOf(TD1[@as(usize, @intCast(x))]) {
    _ = &x;
    return TD1[@as(usize, @intCast(x))];
}
pub inline fn Td2(x: anytype) @TypeOf(TD2[@as(usize, @intCast(x))]) {
    _ = &x;
    return TD2[@as(usize, @intCast(x))];
}
pub inline fn Td3(x: anytype) @TypeOf(TD3[@as(usize, @intCast(x))]) {
    _ = &x;
    return TD3[@as(usize, @intCast(x))];
}
pub const SETUP = rijndael_setup;
pub const ECB_ENC = rijndael_ecb_encrypt;
pub const ECB_DEC = rijndael_ecb_decrypt;
pub const ECB_DONE = rijndael_done;
pub const ECB_TEST = rijndael_test;
pub const ECB_KS = rijndael_keysize;
pub const BPD = @import("std").zig.c_translation.sizeof(LTC_FAST_TYPE) * @as(c_int, 8);
pub const WPV = @as(c_int, 1) + @import("std").zig.c_translation.MacroArithmetic.div(@as(c_int, 16), @import("std").zig.c_translation.sizeof(LTC_FAST_TYPE));
pub inline fn F(x: anytype, y: anytype, z: anytype) @TypeOf(z ^ (x & (y ^ z))) {
    _ = &x;
    _ = &y;
    _ = &z;
    return z ^ (x & (y ^ z));
}
pub inline fn G(x: anytype, y: anytype, z: anytype) @TypeOf(y ^ (z & (y ^ x))) {
    _ = &x;
    _ = &y;
    _ = &z;
    return y ^ (z & (y ^ x));
}
pub inline fn H(x: anytype, y: anytype, z: anytype) @TypeOf((x ^ y) ^ z) {
    _ = &x;
    _ = &y;
    _ = &z;
    return (x ^ y) ^ z;
}
pub const FF = @compileError("unable to translate C expr: unexpected token '='");
// ./libtomcrypt.c:34266:9
pub const GG = @compileError("unable to translate C expr: unexpected token '='");
// ./libtomcrypt.c:34269:9
pub const HH = @compileError("unable to translate C expr: unexpected token '='");
// ./libtomcrypt.c:34272:9
pub const II = @compileError("unable to translate C expr: unexpected token '='");
// ./libtomcrypt.c:34275:9
pub const FOR = @compileError("unable to translate C expr: unexpected token 'for'");
// ./libtomcrypt.c:34958:9
pub const sv = @compileError("unable to translate C expr: unexpected token 'static'");
// ./libtomcrypt.c:34959:9
pub const LTC_PKCS_1_EMSA = LTC_LTC_PKCS_1_EMSA;
pub const LTC_PKCS_1_V1_5 = LTC_LTC_PKCS_1_V1_5;
pub const LTC_PKCS_1_PSS = LTC_LTC_PKCS_1_PSS;
pub const TLSE_H = "";
pub const TLS_LEGACY_SUPPORT = "";
pub const SSL_COMPATIBLE_INTERFACE = "";
pub const TLS_WITH_CHACHA20_POLY1305 = "";
pub const WITH_TLS_13 = "";
pub const TLS_FORWARD_SECRECY = "";
pub const TLS_CLIENT_ECDHE = "";
pub const TLS_ECDSA_SUPPORTED = "";
pub const TLS_CURVE25519 = "";
pub const TLS_CLIENT_ECDSA = "";
pub const TLS_X509_V1_SUPPORT = "";
pub const TLS_ROBOT_MITIGATION = "";
pub const SSL_V30 = @as(c_int, 0x0300);
pub const TLS_V10 = @as(c_int, 0x0301);
pub const TLS_V11 = @as(c_int, 0x0302);
pub const TLS_V12 = @as(c_int, 0x0303);
pub const TLS_V13 = @as(c_int, 0x0304);
pub const DTLS_V10 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFEFF, .hex);
pub const DTLS_V12 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFEFD, .hex);
pub const DTLS_V13 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFEFC, .hex);
pub const TLS_NEED_MORE_DATA = @as(c_int, 0);
pub const TLS_GENERIC_ERROR = -@as(c_int, 1);
pub const TLS_BROKEN_PACKET = -@as(c_int, 2);
pub const TLS_NOT_UNDERSTOOD = -@as(c_int, 3);
pub const TLS_NOT_SAFE = -@as(c_int, 4);
pub const TLS_NO_COMMON_CIPHER = -@as(c_int, 5);
pub const TLS_UNEXPECTED_MESSAGE = -@as(c_int, 6);
pub const TLS_CLOSE_CONNECTION = -@as(c_int, 7);
pub const TLS_COMPRESSION_NOT_SUPPORTED = -@as(c_int, 8);
pub const TLS_NO_MEMORY = -@as(c_int, 9);
pub const TLS_NOT_VERIFIED = -@as(c_int, 10);
pub const TLS_INTEGRITY_FAILED = -@as(c_int, 11);
pub const TLS_ERROR_ALERT = -@as(c_int, 12);
pub const TLS_BROKEN_CONNECTION = -@as(c_int, 13);
pub const TLS_BAD_CERTIFICATE = -@as(c_int, 14);
pub const TLS_UNSUPPORTED_CERTIFICATE = -@as(c_int, 15);
pub const TLS_NO_RENEGOTIATION = -@as(c_int, 16);
pub const TLS_FEATURE_NOT_SUPPORTED = -@as(c_int, 17);
pub const TLS_DECRYPTION_FAILED = -@as(c_int, 20);
pub const TLS_AES_128_GCM_SHA256 = @as(c_int, 0x1301);
pub const TLS_AES_256_GCM_SHA384 = @as(c_int, 0x1302);
pub const TLS_CHACHA20_POLY1305_SHA256 = @as(c_int, 0x1303);
pub const TLS_AES_128_CCM_SHA256 = @as(c_int, 0x1304);
pub const TLS_AES_128_CCM_8_SHA256 = @as(c_int, 0x1305);
pub const TLS_RSA_WITH_AES_128_CBC_SHA = @as(c_int, 0x002F);
pub const TLS_RSA_WITH_AES_256_CBC_SHA = @as(c_int, 0x0035);
pub const TLS_RSA_WITH_AES_128_CBC_SHA256 = @as(c_int, 0x003C);
pub const TLS_RSA_WITH_AES_256_CBC_SHA256 = @as(c_int, 0x003D);
pub const TLS_RSA_WITH_AES_128_GCM_SHA256 = @as(c_int, 0x009C);
pub const TLS_RSA_WITH_AES_256_GCM_SHA384 = @as(c_int, 0x009D);
pub const TLS_DHE_RSA_WITH_AES_128_CBC_SHA = @as(c_int, 0x0033);
pub const TLS_DHE_RSA_WITH_AES_256_CBC_SHA = @as(c_int, 0x0039);
pub const TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = @as(c_int, 0x0067);
pub const TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = @as(c_int, 0x006B);
pub const TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = @as(c_int, 0x009E);
pub const TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = @as(c_int, 0x009F);
pub const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC013, .hex);
pub const TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC014, .hex);
pub const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC027, .hex);
pub const TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC02F, .hex);
pub const TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC030, .hex);
pub const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC009, .hex);
pub const TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC00A, .hex);
pub const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC023, .hex);
pub const TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC024, .hex);
pub const TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC02B, .hex);
pub const TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC02C, .hex);
pub const TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xCCA8, .hex);
pub const TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xCCA9, .hex);
pub const TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xCCAA, .hex);
pub const TLS_FALLBACK_SCSV = @as(c_int, 0x5600);
pub const TLS_UNSUPPORTED_ALGORITHM = @as(c_int, 0x00);
pub const TLS_RSA_SIGN_RSA = @as(c_int, 0x01);
pub const TLS_RSA_SIGN_MD5 = @as(c_int, 0x04);
pub const TLS_RSA_SIGN_SHA1 = @as(c_int, 0x05);
pub const TLS_RSA_SIGN_SHA224 = @as(c_int, 0x0A);
pub const TLS_RSA_SIGN_SHA256 = @as(c_int, 0x0B);
pub const TLS_RSA_SIGN_SHA384 = @as(c_int, 0x0C);
pub const TLS_RSA_SIGN_SHA512 = @as(c_int, 0x0D);
pub const TLS_ECDSA_SIGN_SHA256 = @as(c_int, 0x0E);
pub const TLS_ECDSA_SIGN_SHA224 = @as(c_int, 0x0F);
pub const TLS_ECDSA_SIGN_SHA384 = @as(c_int, 0x10);
pub const TLS_ECDSA_SIGN_SHA512 = @as(c_int, 0x1A);
pub const TLS_EC_PUBLIC_KEY = @as(c_int, 0x11);
pub const TLS_EC_prime192v1 = @as(c_int, 0x12);
pub const TLS_EC_prime192v2 = @as(c_int, 0x13);
pub const TLS_EC_prime192v3 = @as(c_int, 0x14);
pub const TLS_EC_prime239v1 = @as(c_int, 0x15);
pub const TLS_EC_prime239v2 = @as(c_int, 0x16);
pub const TLS_EC_prime239v3 = @as(c_int, 0x17);
pub const TLS_EC_prime256v1 = @as(c_int, 0x18);
pub const TLS_EC_secp224r1 = @as(c_int, 21);
pub const TLS_EC_secp256r1 = @as(c_int, 23);
pub const TLS_EC_secp384r1 = @as(c_int, 24);
pub const TLS_EC_secp521r1 = @as(c_int, 25);
pub const TLS_ALERT_WARNING = @as(c_int, 0x01);
pub const TLS_ALERT_CRITICAL = @as(c_int, 0x02);
pub inline fn TLS_CIPHERS_SIZE(n: anytype, mitigated: anytype) @TypeOf(n * @as(c_int, 2)) {
    _ = &n;
    _ = &mitigated;
    return n * @as(c_int, 2);
}
pub const SRTP_AES128_CM_HMAC_SHA1_80 = @as(c_int, 0x0001);
pub const SRTP_AES128_CM_HMAC_SHA1_32 = @as(c_int, 0x0002);
pub const SRTP_NULL_HMAC_SHA1_80 = @as(c_int, 0x0005);
pub const SRTP_NULL_HMAC_SHA1_32 = @as(c_int, 0x0006);
pub const SRTP_AEAD_AES_128_GCM = @as(c_int, 0x0007);
pub const SRTP_AEAD_AES_256_GCM = @as(c_int, 0x0008);
pub const SRTP_NULL = @as(c_int, 0);
pub const SRTP_AES_CM = @as(c_int, 1);
pub const SRTP_AUTH_NULL = @as(c_int, 0);
pub const SRTP_AUTH_HMAC_SHA1 = @as(c_int, 1);
pub const SSL_SERVER_RSA_CERT = @as(c_int, 1);
pub const SSL_SERVER_RSA_KEY = @as(c_int, 2);
pub const SSL_FILETYPE_PEM = @as(c_int, 1);
pub const SSL_VERIFY_NONE = @as(c_int, 0);
pub const SSL_VERIFY_PEER = @as(c_int, 1);
pub const SSL_VERIFY_FAIL_IF_NO_PEER_CERT = @as(c_int, 2);
pub const SSL_VERIFY_CLIENT_ONCE = @as(c_int, 3);
pub const TLS_DH_DEFAULT_P = "87A8E61DB4B6663CFFBBD19C651959998CEEF608660DD0F25D2CEED4435E3B00E00DF8F1D61957D4FAF7DF4561B2AA3016C3D91134096FAA3BF4296D830E9A7C209E0C6497517ABD5A8A9D306BCF67ED91F9E6725B4758C022E0B1EF4275BF7B6C5BFC11D45F9088B941F54EB1E59BB8BC39A0BF12307F5C4FDB70C581B23F76B63ACAE1CAA6B7902D52526735488A0EF13C6D9A51BFA4AB3AD8347796524D8EF6A167B5A41825D967E144E5140564251CCACB83E6B486F6B3CA3F7971506026C0B857F689962856DED4010ABD0BE621C3A3960A54E710C375F26375D7014103A4B54330C198AF126116D2276E11715F693877FAD7EF09CADB094AE91E1A1597";
pub const TLS_DH_DEFAULT_G = "3FB32C9B73134D0B2E77506660EDBD484CA7B18F21EF205407F4793A1A0BA12510DBC15077BE463FFF4FED4AAC0BB555BE3A6C1B0C6B47B1BC3773BF7E8C6F62901228F8C28CBB18A55AE31341000A650196F931C77A57F2DDF463E5E9EC144B777DE62AAAB8A8628AC376D282D6ED3864E67982428EBC831D14348F6F2F9193B5045AF2767164E1DFC967C1FB3F2E55A4BD1BFFE83B9C80D052B985D182EA0ADB2A3B7313D3FE14C8484B1E052588B9B7D2BBD2DF016199ECD06E1557CD0915B3353BBB64E0EC377FD028370DF92B52C7891428CDC67EB6184B523D1DB246C32F63078490F00EF8D647D148D47954515E2327CFEF98C582664B4C0F6CC41659";
pub const TLS_DHE_KEY_SIZE = @as(c_int, 2048);
pub inline fn TLS_MALLOC(size: anytype) @TypeOf(malloc(size)) {
    _ = &size;
    return malloc(size);
}
pub inline fn TLS_REALLOC(ptr: anytype, size: anytype) @TypeOf(realloc(ptr, size)) {
    _ = &ptr;
    _ = &size;
    return realloc(ptr, size);
}
pub const TLS_FREE = @compileError("unable to translate C expr: unexpected token 'if'");
// tlse_amalgamated.c:151:13
pub const TLS_ERROR = @compileError("unable to translate C expr: unexpected token 'if'");
// tlse_amalgamated.c:154:9
pub const DEBUG_PRINT = @compileError("unable to translate C expr: expected ')' instead got '...'");
// tlse_amalgamated.c:163:9
pub const DEBUG_DUMP_HEX = @compileError("unable to translate C expr: unexpected token '{'");
// tlse_amalgamated.c:164:9
pub const DEBUG_INDEX = @compileError("unable to translate C expr: unexpected token '{'");
// tlse_amalgamated.c:165:9
pub const DEBUG_DUMP = @compileError("unable to translate C expr: unexpected token '{'");
// tlse_amalgamated.c:166:9
pub const DEBUG_DUMP_HEX_LABEL = @compileError("unable to translate C expr: unexpected token '{'");
// tlse_amalgamated.c:167:9
pub inline fn htonll(x: anytype) @TypeOf(if (@as(c_int, 1) == htonl(@as(c_int, 1))) x else (@import("std").zig.c_translation.cast(u64, htonl(x & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFFFFFF, .hex))) << @as(c_int, 32)) | htonl(x >> @as(c_int, 32))) {
    _ = &x;
    return if (@as(c_int, 1) == htonl(@as(c_int, 1))) x else (@import("std").zig.c_translation.cast(u64, htonl(x & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFFFFFF, .hex))) << @as(c_int, 32)) | htonl(x >> @as(c_int, 32));
}
pub inline fn ntohll(x: anytype) @TypeOf(if (@as(c_int, 1) == ntohl(@as(c_int, 1))) x else (@import("std").zig.c_translation.cast(u64, ntohl(x & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFFFFFF, .hex))) << @as(c_int, 32)) | ntohl(x >> @as(c_int, 32))) {
    _ = &x;
    return if (@as(c_int, 1) == ntohl(@as(c_int, 1))) x else (@import("std").zig.c_translation.cast(u64, ntohl(x & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFFFFFF, .hex))) << @as(c_int, 32)) | ntohl(x >> @as(c_int, 32));
}
pub const TLS_CHANGE_CIPHER = @as(c_int, 0x14);
pub const TLS_ALERT = @as(c_int, 0x15);
pub const TLS_HANDSHAKE = @as(c_int, 0x16);
pub const TLS_APPLICATION_DATA = @as(c_int, 0x17);
pub const TLS_SERIALIZED_OBJECT = @as(c_int, 0xFE);
pub const TLS_CLIENT_HELLO_MINSIZE = @as(c_int, 41);
pub const TLS_CLIENT_RANDOM_SIZE = @as(c_int, 32);
pub const TLS_SERVER_RANDOM_SIZE = @as(c_int, 32);
pub const TLS_MAX_SESSION_ID = @as(c_int, 32);
pub const TLS_SHA256_MAC_SIZE = @as(c_int, 32);
pub const TLS_SHA1_MAC_SIZE = @as(c_int, 20);
pub const TLS_SHA384_MAC_SIZE = @as(c_int, 48);
pub const TLS_MAX_MAC_SIZE = TLS_SHA384_MAC_SIZE;
pub const TLS_MAX_KEY_EXPANSION_SIZE = @as(c_int, 192);
pub const TLS_MAX_HASH_LEN = @as(c_int, 64);
pub const TLS_AES_IV_LENGTH = @as(c_int, 16);
pub const TLS_AES_BLOCK_SIZE = @as(c_int, 16);
pub const TLS_AES_GCM_IV_LENGTH = @as(c_int, 4);
pub const TLS_13_AES_GCM_IV_LENGTH = @as(c_int, 12);
pub const TLS_GCM_TAG_LEN = @as(c_int, 16);
pub const TLS_MAX_TAG_LEN = @as(c_int, 16);
pub const TLS_MIN_FINISHED_OPAQUE_LEN = @as(c_int, 12);
pub const TLS_BLOB_INCREMENT = @as(c_int, 0xFFF);
pub const TLS_ASN1_MAXLEVEL = @as(c_int, 0xFF);
pub const DTLS_COOKIE_SIZE = @as(c_int, 32);
pub const DTLS_MAX_FRAGMENT_SIZE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000, .hex);
pub const TLS_MAX_SHA_SIZE = @as(c_int, 48);
pub const TLS_V11_HASH_SIZE = @as(c_int, 36);
pub const TLS_MAX_HASH_SIZE = TLS_MAX_SHA_SIZE;
pub const TLS_MAX_RSA_KEY = @as(c_int, 2048);
pub const TLS_MAXTLS_APP_SIZE = @as(c_int, 0x4000);
pub const TLS_MAX_ERROR_SLEEP_uS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal);
pub const TLS_MAX_ERROR_IDLE_S = @as(c_int, 5);
pub const TLS_V13_MAX_KEY_SIZE = @as(c_int, 32);
pub const TLS_V13_MAX_IV_SIZE = @as(c_int, 12);
pub const VERSION_SUPPORTED = @compileError("unable to translate macro: undefined identifier `context`");
// tlse_amalgamated.c:227:9
pub const CHECK_SIZE = @compileError("unable to translate C expr: unexpected token 'if'");
// tlse_amalgamated.c:228:9
pub const TLS_IMPORT_CHECK_SIZE = @compileError("unable to translate macro: undefined identifier `context`");
// tlse_amalgamated.c:229:9
pub const CHECK_HANDSHAKE_STATE = @compileError("unable to translate macro: undefined identifier `type`");
// tlse_amalgamated.c:230:9
pub const TLS_24_BIT = @compileError("unable to translate macro: undefined identifier `u_val`");
// tlse_amalgamated.c:231:9
pub inline fn TLS_TOMCRYPT_PRIVATE_DP(key: anytype) @TypeOf(key.*.dp) {
    _ = &key;
    return key.*.dp;
}
pub const TLS_TOMCRYPT_PRIVATE_SET_INDEX = @compileError("unable to translate C expr: unexpected token '='");
// tlse_amalgamated.c:238:13
pub const TLS_CHACHA20_IV_LENGTH = @as(c_int, 12);
pub const CHACHA_MINKEYLEN = @as(c_int, 16);
pub const CHACHA_NONCELEN = @as(c_int, 8);
pub const CHACHA_NONCELEN_96 = @as(c_int, 12);
pub const CHACHA_CTRLEN = @as(c_int, 8);
pub const CHACHA_CTRLEN_96 = @as(c_int, 4);
pub const CHACHA_STATELEN = CHACHA_NONCELEN + CHACHA_CTRLEN;
pub const CHACHA_BLOCKLEN = @as(c_int, 64);
pub const POLY1305_MAX_AAD = @as(c_int, 32);
pub const POLY1305_KEYLEN = @as(c_int, 32);
pub const POLY1305_TAGLEN = @as(c_int, 16);
pub const uint8_t = u8;
pub const poly1305_block_size = @as(c_int, 16);
pub const poly1305_context = poly1305_state_internal_t;
pub const U8C = @import("std").zig.c_translation.Macros.U_SUFFIX;
pub const U32C = @import("std").zig.c_translation.Macros.U_SUFFIX;
pub inline fn U8V(v: anytype) @TypeOf(@import("std").zig.c_translation.cast(djb_u8, v) & U8C(@as(c_int, 0xFF))) {
    _ = &v;
    return @import("std").zig.c_translation.cast(djb_u8, v) & U8C(@as(c_int, 0xFF));
}
pub inline fn U32V(v: anytype) @TypeOf(@import("std").zig.c_translation.cast(djb_u32, v) & U32C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFFFFFF, .hex))) {
    _ = &v;
    return @import("std").zig.c_translation.cast(djb_u32, v) & U32C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFFFFFF, .hex));
}
pub inline fn ROTL32(v: anytype, n: anytype) @TypeOf(U32V(v << n) | (v >> (@as(c_int, 32) - n))) {
    _ = &v;
    _ = &n;
    return U32V(v << n) | (v >> (@as(c_int, 32) - n));
}
pub inline fn _private_tls_U8TO32_LITTLE(p: anytype) @TypeOf(((@import("std").zig.c_translation.cast(djb_u32, p[@as(usize, @intCast(@as(c_int, 0)))]) | (@import("std").zig.c_translation.cast(djb_u32, p[@as(usize, @intCast(@as(c_int, 1)))]) << @as(c_int, 8))) | (@import("std").zig.c_translation.cast(djb_u32, p[@as(usize, @intCast(@as(c_int, 2)))]) << @as(c_int, 16))) | (@import("std").zig.c_translation.cast(djb_u32, p[@as(usize, @intCast(@as(c_int, 3)))]) << @as(c_int, 24))) {
    _ = &p;
    return ((@import("std").zig.c_translation.cast(djb_u32, p[@as(usize, @intCast(@as(c_int, 0)))]) | (@import("std").zig.c_translation.cast(djb_u32, p[@as(usize, @intCast(@as(c_int, 1)))]) << @as(c_int, 8))) | (@import("std").zig.c_translation.cast(djb_u32, p[@as(usize, @intCast(@as(c_int, 2)))]) << @as(c_int, 16))) | (@import("std").zig.c_translation.cast(djb_u32, p[@as(usize, @intCast(@as(c_int, 3)))]) << @as(c_int, 24));
}
pub const _private_tls_U32TO8_LITTLE = @compileError("unable to translate C expr: unexpected token 'do'");
// tlse_amalgamated.c:313:9
pub inline fn ROTATE(v: anytype, c: anytype) @TypeOf(ROTL32(v, c)) {
    _ = &v;
    _ = &c;
    return ROTL32(v, c);
}
pub inline fn XOR(v: anytype, w: anytype) @TypeOf(v ^ w) {
    _ = &v;
    _ = &w;
    return v ^ w;
}
pub inline fn PLUS(v: anytype, w: anytype) @TypeOf(U32V(v + w)) {
    _ = &v;
    _ = &w;
    return U32V(v + w);
}
pub inline fn PLUSONE(v: anytype) @TypeOf(PLUS(v, @as(c_int, 1))) {
    _ = &v;
    return PLUS(v, @as(c_int, 1));
}
pub const QUARTERROUND = @compileError("unable to translate C expr: unexpected token '='");
// tlse_amalgamated.c:326:9
pub const TLS_HASH_ALGO_NUMBER = (sha512 - sha256) + @as(c_int, 1);
pub const TLS_SIGN_ALGO_NUMBER = @as(c_int, 3);
pub const SRTP_MASTER_KEY_KEY_LEN = @as(c_int, 16);
pub const SRTP_MASTER_KEY_SALT_LEN = @as(c_int, 14);
pub const TLS_EC_secp256r1_OID = TLS_EC_prime256v1_OID;
pub const timeval = struct_timeval;
pub const timespec = struct_timespec;
pub const __pthread_internal_list = struct___pthread_internal_list;
pub const __pthread_internal_slist = struct___pthread_internal_slist;
pub const __pthread_mutex_s = struct___pthread_mutex_s;
pub const __pthread_rwlock_arch_t = struct___pthread_rwlock_arch_t;
pub const __pthread_cond_s = struct___pthread_cond_s;
pub const random_data = struct_random_data;
pub const drand48_data = struct_drand48_data;
pub const _G_fpos_t = struct__G_fpos_t;
pub const _G_fpos64_t = struct__G_fpos64_t;
pub const _IO_marker = struct__IO_marker;
pub const _IO_codecvt = struct__IO_codecvt;
pub const _IO_wide_data = struct__IO_wide_data;
pub const _IO_FILE = struct__IO_FILE;
pub const _IO_cookie_io_functions_t = struct__IO_cookie_io_functions_t;
pub const __locale_struct = struct___locale_struct;
pub const tm = struct_tm;
pub const itimerspec = struct_itimerspec;
pub const sigval = union_sigval;
pub const sigevent = struct_sigevent;
pub const iovec = struct_iovec;
pub const __socket_type = enum___socket_type;
pub const sockaddr = struct_sockaddr;
pub const sockaddr_storage = struct_sockaddr_storage;
pub const msghdr = struct_msghdr;
pub const cmsghdr = struct_cmsghdr;
pub const linger = struct_linger;
pub const osockaddr = struct_osockaddr;
pub const in_addr = struct_in_addr;
pub const ip_opts = struct_ip_opts;
pub const in_pktinfo = struct_in_pktinfo;
pub const in6_addr = struct_in6_addr;
pub const sockaddr_in = struct_sockaddr_in;
pub const sockaddr_in6 = struct_sockaddr_in6;
pub const ip_mreq = struct_ip_mreq;
pub const ip_mreqn = struct_ip_mreqn;
pub const ip_mreq_source = struct_ip_mreq_source;
pub const ipv6_mreq = struct_ipv6_mreq;
pub const group_req = struct_group_req;
pub const group_source_req = struct_group_source_req;
pub const ip_msfilter = struct_ip_msfilter;
pub const group_filter = struct_group_filter;
pub const _fpx_sw_bytes = struct__fpx_sw_bytes;
pub const _fpreg = struct__fpreg;
pub const _fpxreg = struct__fpxreg;
pub const _xmmreg = struct__xmmreg;
pub const _fpstate = struct__fpstate;
pub const sigcontext = struct_sigcontext;
pub const _xsave_hdr = struct__xsave_hdr;
pub const _ymmh_state = struct__ymmh_state;
pub const _xstate = struct__xstate;
pub const _libc_fpxreg = struct__libc_fpxreg;
pub const _libc_xmmreg = struct__libc_xmmreg;
pub const _libc_fpstate = struct__libc_fpstate;
pub const blowfish_key = struct_blowfish_key;
pub const rc5_key = struct_rc5_key;
pub const rc6_key = struct_rc6_key;
pub const saferp_key = struct_saferp_key;
pub const rijndael_key = struct_rijndael_key;
pub const kseed_key = struct_kseed_key;
pub const kasumi_key = struct_kasumi_key;
pub const xtea_key = struct_xtea_key;
pub const twofish_key = struct_twofish_key;
pub const safer_key = struct_safer_key;
pub const rc2_key = struct_rc2_key;
pub const des_key = struct_des_key;
pub const des3_key = struct_des3_key;
pub const cast5_key = struct_cast5_key;
pub const noekeon_key = struct_noekeon_key;
pub const skipjack_key = struct_skipjack_key;
pub const khazad_key = struct_khazad_key;
pub const anubis_key = struct_anubis_key;
pub const Symmetric_key = union_Symmetric_key;
pub const ltc_cipher_descriptor = struct_ltc_cipher_descriptor;
pub const sha512_state = struct_sha512_state;
pub const sha256_state = struct_sha256_state;
pub const sha1_state = struct_sha1_state;
pub const md5_state = struct_md5_state;
pub const md4_state = struct_md4_state;
pub const tiger_state = struct_tiger_state;
pub const md2_state = struct_md2_state;
pub const rmd128_state = struct_rmd128_state;
pub const rmd160_state = struct_rmd160_state;
pub const rmd256_state = struct_rmd256_state;
pub const rmd320_state = struct_rmd320_state;
pub const whirlpool_state = struct_whirlpool_state;
pub const chc_state = struct_chc_state;
pub const Hash_state = union_Hash_state;
pub const ltc_hash_descriptor = struct_ltc_hash_descriptor;
pub const Hmac_state = struct_Hmac_state;
pub const yarrow_prng = struct_yarrow_prng;
pub const rc4_prng = struct_rc4_prng;
pub const fortuna_prng = struct_fortuna_prng;
pub const sober128_prng = struct_sober128_prng;
pub const Prng_state = union_Prng_state;
pub const ltc_prng_descriptor = struct_ltc_prng_descriptor;
pub const ltc_pka_id = enum_ltc_pka_id;
pub const public_key_type = enum_public_key_type;
pub const Rsa_key = struct_Rsa_key;
pub const ltc_asn1_list_ = struct_ltc_asn1_list_;
pub const edge = struct_edge;
pub const ltc_pkcs_1_v1_5_blocks = enum_ltc_pkcs_1_v1_5_blocks;
pub const ltc_pkcs_1_paddings = enum_ltc_pkcs_1_paddings;
pub const TLSCertificate = struct_TLSCertificate;
pub const ECCCurveParameters = struct_ECCCurveParameters;
pub const TLSHandshakeList = struct_TLSHandshakeList;
pub const DTLSFragment = struct_DTLSFragment;
pub const DTLSData = struct_DTLSData;
pub const TLSContext = struct_TLSContext;
pub const TLSPacket = struct_TLSPacket;
pub const TLSRTCPeerBuffer = struct_TLSRTCPeerBuffer;
pub const TLSRTCPeerConnection = struct_TLSRTCPeerConnection;
pub const _private_OID_chain = struct__private_OID_chain;
